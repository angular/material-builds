{"version":3,"file":"_option-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/core/option/optgroup.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/core/option/option.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Component,\n  ViewEncapsulation,\n  ChangeDetectionStrategy,\n  Input,\n  InjectionToken,\n  booleanAttribute,\n  inject,\n} from '@angular/core';\nimport {_IdGenerator} from '@angular/cdk/a11y';\nimport {MatOptionParentComponent, MAT_OPTION_PARENT_COMPONENT} from './option-parent';\n\n// Notes on the accessibility pattern used for `mat-optgroup`.\n// The option group has two different \"modes\": regular and inert. The regular mode uses the\n// recommended a11y pattern which has `role=\"group\"` on the group element with `aria-labelledby`\n// pointing to the label. This works for `mat-select`, but it seems to hit a bug for autocomplete\n// under VoiceOver where the group doesn't get read out at all. The bug appears to be that if\n// there's __any__ a11y-related attribute on the group (e.g. `role` or `aria-labelledby`),\n// VoiceOver on Safari won't read it out.\n// We've introduced the `inert` mode as a workaround. Under this mode, all a11y attributes are\n// removed from the group, and we get the screen reader to read out the group label by mirroring it\n// inside an invisible element in the option. This is sub-optimal, because the screen reader will\n// repeat the group label on each navigation, whereas the default pattern only reads the group when\n// the user enters a new group. The following alternate approaches were considered:\n// 1. Reading out the group label using the `LiveAnnouncer` solves the problem, but we can't control\n//    when the text will be read out so sometimes it comes in too late or never if the user\n//    navigates quickly.\n// 2. `<mat-option aria-describedby=\"groupLabel\"` - This works on Safari, but VoiceOver in Chrome\n//    won't read out the description at all.\n// 3. `<mat-option aria-labelledby=\"optionLabel groupLabel\"` - This works on Chrome, but Safari\n//     doesn't read out the text at all. Furthermore, on\n\n/**\n * Injection token that can be used to reference instances of `MatOptgroup`. It serves as\n * alternative token to the actual `MatOptgroup` class which could cause unnecessary\n * retention of the class and its component metadata.\n */\nexport const MAT_OPTGROUP = new InjectionToken<MatOptgroup>('MatOptgroup');\n\n/**\n * Component that is used to group instances of `mat-option`.\n */\n@Component({\n  selector: 'mat-optgroup',\n  exportAs: 'matOptgroup',\n  templateUrl: 'optgroup.html',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  styleUrl: 'optgroup.css',\n  host: {\n    'class': 'mat-mdc-optgroup',\n    '[attr.role]': '_inert ? null : \"group\"',\n    '[attr.aria-disabled]': '_inert ? null : disabled.toString()',\n    '[attr.aria-labelledby]': '_inert ? null : _labelId',\n  },\n  providers: [{provide: MAT_OPTGROUP, useExisting: MatOptgroup}],\n})\nexport class MatOptgroup {\n  /** Label for the option group. */\n  @Input() label: string;\n\n  /** whether the option group is disabled. */\n  @Input({transform: booleanAttribute}) disabled: boolean = false;\n\n  /** Unique id for the underlying label. */\n  _labelId: string = inject(_IdGenerator).getId('mat-optgroup-label-');\n\n  /** Whether the group is in inert a11y mode. */\n  _inert: boolean;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const parent = inject<MatOptionParentComponent>(MAT_OPTION_PARENT_COMPONENT, {optional: true});\n    this._inert = parent?.inertGroups ?? false;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {_IdGenerator, FocusableOption, FocusOrigin} from '@angular/cdk/a11y';\nimport {ENTER, hasModifierKey, SPACE} from '@angular/cdk/keycodes';\nimport {\n  Component,\n  ViewEncapsulation,\n  ChangeDetectionStrategy,\n  ElementRef,\n  ChangeDetectorRef,\n  AfterViewChecked,\n  OnDestroy,\n  Input,\n  Output,\n  EventEmitter,\n  QueryList,\n  ViewChild,\n  booleanAttribute,\n  inject,\n  isSignal,\n  Signal,\n  signal,\n} from '@angular/core';\nimport {Subject} from 'rxjs';\nimport {MAT_OPTGROUP, MatOptgroup} from './optgroup';\nimport {MatOptionParentComponent, MAT_OPTION_PARENT_COMPONENT} from './option-parent';\nimport {MatRipple} from '../ripple/ripple';\nimport {MatPseudoCheckbox} from '../selection/pseudo-checkbox/pseudo-checkbox';\nimport {_StructuralStylesLoader} from '../focus-indicators/structural-styles';\nimport {_CdkPrivateStyleLoader, _VisuallyHiddenLoader} from '@angular/cdk/private';\n\n/** Event object emitted by MatOption when selected or deselected. */\nexport class MatOptionSelectionChange<T = any> {\n  constructor(\n    /** Reference to the option that emitted the event. */\n    public source: MatOption<T>,\n    /** Whether the change in the option's value was a result of a user action. */\n    public isUserInput = false,\n  ) {}\n}\n\n/**\n * Single option inside of a `<mat-select>` element.\n */\n@Component({\n  selector: 'mat-option',\n  exportAs: 'matOption',\n  host: {\n    'role': 'option',\n    '[class.mdc-list-item--selected]': 'selected',\n    '[class.mat-mdc-option-multiple]': 'multiple',\n    '[class.mat-mdc-option-active]': 'active',\n    '[class.mdc-list-item--disabled]': 'disabled',\n    '[id]': 'id',\n    // Set aria-selected to false for non-selected items and true for selected items. Conform to\n    // [WAI ARIA Listbox authoring practices guide](\n    //  https://www.w3.org/WAI/ARIA/apg/patterns/listbox/), \"If any options are selected, each\n    // selected option has either aria-selected or aria-checked  set to true. All options that are\n    // selectable but not selected have either aria-selected or aria-checked set to false.\" Align\n    // aria-selected implementation of Chips and List components.\n    //\n    // Set `aria-selected=\"false\"` on not-selected listbox options to fix VoiceOver announcing\n    // every option as \"selected\" (#21491).\n    '[attr.aria-selected]': 'selected',\n    '[attr.aria-disabled]': 'disabled.toString()',\n    '(click)': '_selectViaInteraction()',\n    '(keydown)': '_handleKeydown($event)',\n    'class': 'mat-mdc-option mdc-list-item',\n  },\n  styleUrl: 'option.css',\n  templateUrl: 'option.html',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [MatPseudoCheckbox, MatRipple],\n})\nexport class MatOption<T = any> implements FocusableOption, AfterViewChecked, OnDestroy {\n  private _element = inject<ElementRef<HTMLElement>>(ElementRef);\n  _changeDetectorRef = inject(ChangeDetectorRef);\n  private _parent = inject<MatOptionParentComponent>(MAT_OPTION_PARENT_COMPONENT, {optional: true});\n  group = inject<MatOptgroup>(MAT_OPTGROUP, {optional: true});\n\n  private _signalDisableRipple = false;\n  private _selected = false;\n  private _active = false;\n  private _mostRecentViewValue = '';\n\n  /** Whether the wrapping component is in multiple selection mode. */\n  get multiple() {\n    return this._parent && this._parent.multiple;\n  }\n\n  /** Whether or not the option is currently selected. */\n  get selected(): boolean {\n    return this._selected;\n  }\n\n  /** The form value of the option. */\n  @Input() value: T;\n\n  /** The unique ID of the option. */\n  @Input() id: string = inject(_IdGenerator).getId('mat-option-');\n\n  /** Whether the option is disabled. */\n  @Input({transform: booleanAttribute})\n  get disabled(): boolean {\n    return (this.group && this.group.disabled) || this._disabled();\n  }\n  set disabled(value: boolean) {\n    this._disabled.set(value);\n  }\n  private _disabled = signal(false);\n\n  /** Whether ripples for the option are disabled. */\n  get disableRipple(): boolean {\n    return this._signalDisableRipple\n      ? (this._parent!.disableRipple as Signal<boolean>)()\n      : !!this._parent?.disableRipple;\n  }\n\n  /** Whether to display checkmark for single-selection. */\n  get hideSingleSelectionIndicator(): boolean {\n    return !!(this._parent && this._parent.hideSingleSelectionIndicator);\n  }\n\n  /** Event emitted when the option is selected or deselected. */\n  // tslint:disable-next-line:no-output-on-prefix\n  @Output() readonly onSelectionChange = new EventEmitter<MatOptionSelectionChange<T>>();\n\n  /** Element containing the option's text. */\n  @ViewChild('text', {static: true}) _text: ElementRef<HTMLElement> | undefined;\n\n  /** Emits when the state of the option changes and any parents have to be notified. */\n  readonly _stateChanges = new Subject<void>();\n\n  constructor(...args: unknown[]);\n  constructor() {\n    const styleLoader = inject(_CdkPrivateStyleLoader);\n    styleLoader.load(_StructuralStylesLoader);\n    styleLoader.load(_VisuallyHiddenLoader);\n    this._signalDisableRipple = !!this._parent && isSignal(this._parent.disableRipple);\n  }\n\n  /**\n   * Whether or not the option is currently active and ready to be selected.\n   * An active option displays styles as if it is focused, but the\n   * focus is actually retained somewhere else. This comes in handy\n   * for components like autocomplete where focus must remain on the input.\n   */\n  get active(): boolean {\n    return this._active;\n  }\n\n  /**\n   * The displayed value of the option. It is necessary to show the selected option in the\n   * select's trigger.\n   */\n  get viewValue(): string {\n    // TODO(kara): Add input property alternative for node envs.\n    return (this._text?.nativeElement.textContent || '').trim();\n  }\n\n  /** Selects the option. */\n  select(emitEvent = true): void {\n    if (!this._selected) {\n      this._selected = true;\n      this._changeDetectorRef.markForCheck();\n\n      if (emitEvent) {\n        this._emitSelectionChangeEvent();\n      }\n    }\n  }\n\n  /** Deselects the option. */\n  deselect(emitEvent = true): void {\n    if (this._selected) {\n      this._selected = false;\n      this._changeDetectorRef.markForCheck();\n\n      if (emitEvent) {\n        this._emitSelectionChangeEvent();\n      }\n    }\n  }\n\n  /** Sets focus onto this option. */\n  focus(_origin?: FocusOrigin, options?: FocusOptions): void {\n    // Note that we aren't using `_origin`, but we need to keep it because some internal consumers\n    // use `MatOption` in a `FocusKeyManager` and we need it to match `FocusableOption`.\n    const element = this._getHostElement();\n\n    if (typeof element.focus === 'function') {\n      element.focus(options);\n    }\n  }\n\n  /**\n   * This method sets display styles on the option to make it appear\n   * active. This is used by the ActiveDescendantKeyManager so key\n   * events will display the proper options as active on arrow key events.\n   */\n  setActiveStyles(): void {\n    if (!this._active) {\n      this._active = true;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n\n  /**\n   * This method removes display styles on the option that made it appear\n   * active. This is used by the ActiveDescendantKeyManager so key\n   * events will display the proper options as active on arrow key events.\n   */\n  setInactiveStyles(): void {\n    if (this._active) {\n      this._active = false;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n\n  /** Gets the label to be used when determining whether the option should be focused. */\n  getLabel(): string {\n    return this.viewValue;\n  }\n\n  /** Ensures the option is selected when activated from the keyboard. */\n  _handleKeydown(event: KeyboardEvent): void {\n    if ((event.keyCode === ENTER || event.keyCode === SPACE) && !hasModifierKey(event)) {\n      this._selectViaInteraction();\n\n      // Prevent the page from scrolling down and form submits.\n      event.preventDefault();\n    }\n  }\n\n  /**\n   * `Selects the option while indicating the selection came from the user. Used to\n   * determine if the select's view -> model callback should be invoked.`\n   */\n  _selectViaInteraction(): void {\n    if (!this.disabled) {\n      this._selected = this.multiple ? !this._selected : true;\n      this._changeDetectorRef.markForCheck();\n      this._emitSelectionChangeEvent(true);\n    }\n  }\n\n  /** Returns the correct tabindex for the option depending on disabled state. */\n  // This method is only used by `MatLegacyOption`. Keeping it here to avoid breaking the types.\n  // That's because `MatLegacyOption` use `MatOption` type in a few places such as\n  // `MatOptionSelectionChange`. It is safe to delete this when `MatLegacyOption` is deleted.\n  _getTabIndex(): string {\n    return this.disabled ? '-1' : '0';\n  }\n\n  /** Gets the host DOM element. */\n  _getHostElement(): HTMLElement {\n    return this._element.nativeElement;\n  }\n\n  ngAfterViewChecked() {\n    // Since parent components could be using the option's label to display the selected values\n    // (e.g. `mat-select`) and they don't have a way of knowing if the option's label has changed\n    // we have to check for changes in the DOM ourselves and dispatch an event. These checks are\n    // relatively cheap, however we still limit them only to selected options in order to avoid\n    // hitting the DOM too often.\n    if (this._selected) {\n      const viewValue = this.viewValue;\n\n      if (viewValue !== this._mostRecentViewValue) {\n        if (this._mostRecentViewValue) {\n          this._stateChanges.next();\n        }\n\n        this._mostRecentViewValue = viewValue;\n      }\n    }\n  }\n\n  ngOnDestroy() {\n    this._stateChanges.complete();\n  }\n\n  /** Emits the selection change event. */\n  private _emitSelectionChangeEvent(isUserInput = false): void {\n    this.onSelectionChange.emit(new MatOptionSelectionChange<T>(this, isUserInput));\n  }\n}\n\n/**\n * Counts the amount of option group labels that precede the specified option.\n * @param optionIndex Index of the option at which to start counting.\n * @param options Flat list of all of the options.\n * @param optionGroups Flat list of all of the option groups.\n * @docs-private\n */\nexport function _countGroupLabelsBeforeOption(\n  optionIndex: number,\n  options: QueryList<MatOption>,\n  optionGroups: QueryList<MatOptgroup>,\n): number {\n  if (optionGroups.length) {\n    let optionsArray = options.toArray();\n    let groups = optionGroups.toArray();\n    let groupCounter = 0;\n\n    for (let i = 0; i < optionIndex + 1; i++) {\n      if (optionsArray[i].group && optionsArray[i].group === groups[groupCounter]) {\n        groupCounter++;\n      }\n    }\n\n    return groupCounter;\n  }\n\n  return 0;\n}\n\n/**\n * Determines the position to which to scroll a panel in order for an option to be into view.\n * @param optionOffset Offset of the option from the top of the panel.\n * @param optionHeight Height of the options.\n * @param currentScrollPosition Current scroll position of the panel.\n * @param panelHeight Height of the panel.\n * @docs-private\n */\nexport function _getOptionScrollPosition(\n  optionOffset: number,\n  optionHeight: number,\n  currentScrollPosition: number,\n  panelHeight: number,\n): number {\n  if (optionOffset < currentScrollPosition) {\n    return optionOffset;\n  }\n\n  if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {\n    return Math.max(0, optionOffset - panelHeight + optionHeight);\n  }\n\n  return currentScrollPosition;\n}\n"],"names":["MatOptionSelectionChange","constructor","source","isUserInput","MatOption","inject","ElementRef","_changeDetectorRef","ChangeDetectorRef","_parent","MAT_OPTION_PARENT_COMPONENT","optional","_selected","multiple","disabled","group","_disabled","value","signal","ngDevMode","debugName","disableRipple","hideSingleSelectionIndicator","styleLoader","_CdkPrivateStyleLoader","load","_StructuralStylesLoader","_signalDisableRipple","isSignal","viewValue","markForCheck","emitEvent","_emitSelectionChangeEvent","deselect","options","element","_getHostElement","focus","setActiveStyles","_active","setInactiveStyles","_selectViaInteraction","event","preventDefault","ngAfterViewChecked","complete","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","imports","MatPseudoCheckbox","MatRipple","template","styles","ctorParameters","propDecorators","transform","booleanAttribute","_text","args","static"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsEU,OAAA;;;;;ACeH,MAAsCA,wBAAgB,CAAA;QAE/B;aACX;aACFC,oBAKN,GAAA,KAAA,EAAA;IAIG,IAAAC,CAAAA,MAAA,GAAAA,MAAA;IAEZ,IAAAC,CAAAA,WAAA,GAAAA,WAAA;;;MAFYC,SAAA,CAAA;UAEZ,GAAAC,MAAA,CAAAC,UAAA,CAAA;EAEoCC,kBAAA,GAAAF,MAAA,CAAAG,iBAAA,CAAA;EAC3BC,OAAA,GAAAJ,MAAA,CAAAK,2BAAA,EAAA;IAAAC,QAAA,EAAA;AAAA,GAAA,CAAA;;;;;EAMTC,SAAA,GAAA,KAAA;;;AA4CG,EAAA,IAAAC,QAAAA,GAAA;IACH,OAAU,IAAA,CAAAJ,OAAA,IAAA,IAAA,CAAAA,OAAA,CAAAI,QAAA;AAEV;;;AAMA;AAEE,EAAA,KAAA;;AAMEC,EAAAA,IAAAA,QAAAA,GAAA;AACA,IAAA,OAAA,IAAA,CAAAC,KAAA,IAAAA,IAAAA,CAAAA,KAAA,CAAAD,QAAA,SAAAE,SAAA,EAAA;;cAIAF,CAAAG,KAAA,EAAA;;AAIwB;EAE1BD,SAAA,GAAAE,MAAA,CAAA,KAAA,EAAA,IAAAC,SAAoB,GAAA,CAAA;IAAAC,SAAA,EAAA;AAAA,GAAA,CAAA,GAAA,EAAA,CAAA,CAAA;mBAIdC,GAAA;2CAEJ,CAAAZ,OAAA,CAAAY,aAAA,EACF,GAAA,CAAA,CAAA,IAAA,CAAAZ,OAAA,EAAAY,aAAA;;;kBAMoF,CAAAZ,OAAA,IAAAA,IAAAA,CAAAA,OAAA,CAAAa,4BAAA,CAAA;;;;;;AAcpF,IAAA,MAAAC,WAAA,GAAAlB,MAAA,CAAAmB,sBAAmB,CAAA;IACZD,WAAA,CAAAE,IAAc,CAAAC,uBAAA,CAAA;;IAGvB,IAAA,CAAAC,oBAAA,GAAAlB,CAAAA,CAAAA,IAAAA,CAAAA,OAAA,IAAAmB,QAAA,CAAA,IAAA,CAAAnB,OAAA,CAAAY,aAAA,CAAA;;;;;eAsBIQ,GAAA;;;;;AAUD,MAAA,IAAA,CAAAjB,SAAA,GAAA,IAAA;MACH,IAAAL,CAAAA,kBAAA,CAAAuB,YAAA,EAAA;AACE,MAAA,IAAIC,SAAK,EAAC;AACR,QAAA,IAAA,CAAAC,yBAAA,EAAA;AAEA;;;AAK0FC,EAAAA,QAAAA,CAAAF,SAAA,GAAA,IAAA,EAAA;QAEH,IAAA,CAAAnB,SAAA,EAAA;AAC/E,MAAA,IAAA,CAAAA,SAAA,GAAA,KAAA;;AAEZ,MAAA,IAAAmB,SAAA,EAAA;;AAIE;;;AAK6F,EAAA,KAAA,CAAA,OAAA,EAAAG,OAAA,EAAA;AAI7FC,IAAAA,MAAAA,OAAA,QAAAC,eAAA,EAAA;IACE,IAAA,OAAAD,OAAA,CAAAE,KAAA,KAAA,UAAA,EAAA;MAEAF,OAAA,CAAAE,KAAA,CAAAH,OAAA,CAAA;AAEI;;iBAURI,GAAA;;AAIE,MAAA,IAAA,CAAAC,OAAA,GAAA,IAAA;;;;mBA5OAC,GAAA;AACA,IAAA,IAAA,IAAA,CAAAD,OAAA,EAAA;AAEA,MAAA,IAAA,CAAAA,OAAA,GAAA,KAAA;;;;;;;;;AAYA,MAAA,IAAA,CAAAE,qBAAA,EAAA;AAEAC,MAAAA,KAAA,CAAAC,cAAA,EAAA;AACA;;;;;;;;;;AAoOD,IAAA,OAAA,KAAA7B,QAAA,GAAA,IAAA,GAAA,GAAA;AACH;EAOIsB,eAAA,GAAA;;AAGA;AACEQ,EAAAA,kBAAAA,GAAA;AASN,IAAA,IAAA,IAAA,CAAAhC,SAAA,EAAA;;;;;;;AASG;;;AASD,EAAA,WAAA,GAAA;AAEI,IAAA,IAAA,CAAA,aAAA,CAAAiC,QAAA,EAAA;;AAKNb,EAAAA,yBAAAA,CAAA7B,WAAA,GAAA,KAAA,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QA5OI,MAAA,EAAA,IAAA;AAcF,QAAA,sBAAA,EAAA,UAAA;AACA,QAAA,sBAAA,EAAA,qBAAA;AACE,QAAA,SAAA,EAAA,yBAAA;AACF,QAAA,WAAA,EAAA,wBAAA;QAEA,OAA+D,EAAA;;mBAC/D,EAAA2C,iBAAA,CAAAC,IAAA;MAAAC,eAAA,EAAAC,uBAAA,CAAAC,MAAA;MAAAC,OAA+C,EAAA,CAAAC,iBAAA,EAAAC,SAAA,CAAA;MAAAC,QAAA,EAAA,w9CAAA;MAAAC,MAAA,EAAA,CAAA,4zHAAA;AAAA,KAAA;;AAC5B,EAAA,cAAA,EAAAC,MAAA,EAAA;EAAAC,cAAA,EAAA;AAAAxC,IAAAA,KAAA,EAAmE,CAAA;;;;;;AAM7E,IAAA,QAAA,EAAA,CAAA;AAGT,MAAA,IAAA,EAAA,KAAA;AACE,MAAA,IAAA,EAAA,CAAA;AAAAyC,QAAAA,SAAA,EAAAC;AAGyB,OAAA;;;;;IAkCCC,KAAA,EAAA,CAAA;qBAAA;AAIxBC,MAAAA,IAAA,EAAA,CAAA,MAAA,EAAA;QAAAC,MAAA,EAAA;AAAA,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}