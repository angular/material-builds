{"version":3,"file":"chips.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/chips/tokens.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/chips/chip-action.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/chips/chip-icons.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/chips/chip.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/chips/chip-option.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/chips/chip-edit-input.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/chips/chip-row.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/chips/chip-set.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/chips/chip-listbox.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/chips/chip-grid.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/chips/chip-input.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/chips/chips-module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ENTER, ModifierKey} from '@angular/cdk/keycodes';\nimport {InjectionToken} from '@angular/core';\n\n/** Key that can be used as a separator between chips. */\nexport interface SeparatorKey {\n  keyCode: number;\n  modifiers: readonly ModifierKey[];\n}\n\n/** Default options, for the chips module, that can be overridden. */\nexport interface MatChipsDefaultOptions {\n  /** The list of key codes that will trigger a chipEnd event. */\n  separatorKeyCodes: readonly (number | SeparatorKey)[] | ReadonlySet<number | SeparatorKey>;\n\n  /** Whether icon indicators should be hidden for single-selection. */\n  hideSingleSelectionIndicator?: boolean;\n\n  /** Whether the chip input should be interactive while disabled by default. */\n  inputDisabledInteractive?: boolean;\n}\n\n/** Injection token to be used to override the default options for the chips module. */\nexport const MAT_CHIPS_DEFAULT_OPTIONS = new InjectionToken<MatChipsDefaultOptions>(\n  'mat-chips-default-options',\n  {\n    providedIn: 'root',\n    factory: () => ({\n      separatorKeyCodes: [ENTER],\n    }),\n  },\n);\n\n/**\n * Injection token that can be used to reference instances of `MatChipAvatar`. It serves as\n * alternative token to the actual `MatChipAvatar` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const MAT_CHIP_AVATAR = new InjectionToken('MatChipAvatar');\n\n/**\n * Injection token that can be used to reference instances of `MatChipTrailingIcon`. It serves as\n * alternative token to the actual `MatChipTrailingIcon` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const MAT_CHIP_TRAILING_ICON = new InjectionToken('MatChipTrailingIcon');\n\n/**\n * Injection token that can be used to reference instances of `MatChipEdit`. It serves as\n * alternative token to the actual `MatChipEdit` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const MAT_CHIP_EDIT = new InjectionToken('MatChipEdit');\n\n/**\n * Injection token that can be used to reference instances of `MatChipRemove`. It serves as\n * alternative token to the actual `MatChipRemove` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const MAT_CHIP_REMOVE = new InjectionToken('MatChipRemove');\n\n/**\n * Injection token used to avoid a circular dependency between the `MatChip` and `MatChipAction`.\n */\nexport const MAT_CHIP = new InjectionToken('MatChip');\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Directive,\n  ElementRef,\n  Input,\n  booleanAttribute,\n  numberAttribute,\n  inject,\n} from '@angular/core';\nimport {ENTER, SPACE} from '@angular/cdk/keycodes';\nimport {MAT_CHIP} from './tokens';\nimport {_CdkPrivateStyleLoader} from '@angular/cdk/private';\nimport {_StructuralStylesLoader} from '../core';\n\n/**\n * A non-interactive section of a chip.\n * @docs-private\n */\n@Directive({\n  selector: '[matChipContent]',\n  host: {\n    'class':\n      'mat-mdc-chip-action mdc-evolution-chip__action mdc-evolution-chip__action--presentational',\n    '[class.mdc-evolution-chip__action--primary]': '_isPrimary',\n    '[class.mdc-evolution-chip__action--secondary]': '!_isPrimary',\n    '[class.mdc-evolution-chip__action--trailing]': '!_isPrimary && !_isLeading',\n    '[attr.disabled]': '_getDisabledAttribute()',\n    '[attr.aria-disabled]': 'disabled',\n  },\n})\nexport class MatChipContent {\n  _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  protected _parentChip = inject<{\n    _handlePrimaryActionInteraction(): void;\n    remove(): void;\n    disabled: boolean;\n    _edit(): void;\n    _isEditing?: boolean;\n  }>(MAT_CHIP);\n\n  /** Whether this is the primary action in the chip. */\n  _isPrimary = true;\n\n  /** Whether this is the leading action in the chip. */\n  _isLeading = false; // TODO(adolgachev): consolidate usage to secondary css class\n\n  /** Whether the action is disabled. */\n  @Input({transform: booleanAttribute})\n  get disabled(): boolean {\n    return this._disabled || this._parentChip?.disabled || false;\n  }\n  set disabled(value: boolean) {\n    this._disabled = value;\n  }\n  private _disabled = false;\n\n  /** Tab index of the action. */\n  @Input({\n    transform: (value: unknown) => (value == null ? -1 : numberAttribute(value)),\n  })\n  tabIndex: number = -1;\n\n  /**\n   * Private API to allow focusing this chip when it is disabled.\n   */\n  @Input()\n  _allowFocusWhenDisabled = false;\n\n  /**\n   * Determine the value of the disabled attribute for this chip action.\n   */\n  protected _getDisabledAttribute(): string | null {\n    // When this chip action is disabled and focusing disabled chips is not permitted, return empty\n    // string to indicate that disabled attribute should be included.\n    return this.disabled && !this._allowFocusWhenDisabled ? '' : null;\n  }\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    inject(_CdkPrivateStyleLoader).load(_StructuralStylesLoader);\n    if (this._elementRef.nativeElement.nodeName === 'BUTTON') {\n      this._elementRef.nativeElement.setAttribute('type', 'button');\n    }\n  }\n\n  focus() {\n    this._elementRef.nativeElement.focus();\n  }\n}\n\n/**\n * Interactive section of a chip.\n * @docs-private\n */\n@Directive({\n  selector: '[matChipAction]',\n  host: {\n    '[attr.tabindex]': '_getTabindex()',\n    '[class.mdc-evolution-chip__action--presentational]': 'false',\n    '(click)': '_handleClick($event)',\n    '(keydown)': '_handleKeydown($event)',\n  },\n})\nexport class MatChipAction extends MatChipContent {\n  /**\n   * Determine the value of the tabindex attribute for this chip action.\n   */\n  protected _getTabindex(): string | null {\n    return this.disabled && !this._allowFocusWhenDisabled ? null : this.tabIndex.toString();\n  }\n\n  _handleClick(event: MouseEvent) {\n    if (!this.disabled && this._isPrimary) {\n      event.preventDefault();\n      this._parentChip._handlePrimaryActionInteraction();\n    }\n  }\n\n  _handleKeydown(event: KeyboardEvent) {\n    if (\n      (event.keyCode === ENTER || event.keyCode === SPACE) &&\n      !this.disabled &&\n      this._isPrimary &&\n      !this._parentChip._isEditing\n    ) {\n      event.preventDefault();\n      this._parentChip._handlePrimaryActionInteraction();\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ENTER, SPACE} from '@angular/cdk/keycodes';\nimport {Directive} from '@angular/core';\nimport {MatChipAction, MatChipContent} from './chip-action';\nimport {MAT_CHIP_AVATAR, MAT_CHIP_EDIT, MAT_CHIP_REMOVE, MAT_CHIP_TRAILING_ICON} from './tokens';\n\n/** Avatar image within a chip. */\n@Directive({\n  selector: 'mat-chip-avatar, [matChipAvatar]',\n  host: {\n    'class': 'mat-mdc-chip-avatar mdc-evolution-chip__icon mdc-evolution-chip__icon--primary',\n    'role': 'img',\n  },\n  providers: [{provide: MAT_CHIP_AVATAR, useExisting: MatChipAvatar}],\n})\nexport class MatChipAvatar {}\n\n/** Non-interactive trailing icon in a chip. */\n@Directive({\n  selector: 'mat-chip-trailing-icon, [matChipTrailingIcon]',\n  host: {\n    'class':\n      'mat-mdc-chip-trailing-icon mdc-evolution-chip__icon mdc-evolution-chip__icon--trailing',\n    'aria-hidden': 'true',\n  },\n  providers: [{provide: MAT_CHIP_TRAILING_ICON, useExisting: MatChipTrailingIcon}],\n})\nexport class MatChipTrailingIcon extends MatChipContent {\n  override _isPrimary = false;\n}\n\n/**\n * Directive to edit the parent chip when the leading action icon is clicked or\n * when the ENTER key is pressed on it.\n *\n * Recommended for use with the Material Design \"edit\" icon\n * available at https://material.io/icons/#ic_edit.\n *\n * Example:\n *\n * ```\n * <mat-chip>\n *   <button matChipEdit aria-label=\"Edit\">\n *     <mat-icon>edit</mat-icon>\n *   </button>\n * </mat-chip>\n * ```\n */\n\n@Directive({\n  selector: '[matChipEdit]',\n  host: {\n    'class':\n      'mat-mdc-chip-edit mat-mdc-chip-avatar mat-focus-indicator ' +\n      'mdc-evolution-chip__icon mdc-evolution-chip__icon--primary',\n    'role': 'button',\n    '[attr.aria-hidden]': 'null',\n  },\n  providers: [{provide: MAT_CHIP_EDIT, useExisting: MatChipEdit}],\n})\nexport class MatChipEdit extends MatChipAction {\n  override _isPrimary = false;\n  override _isLeading = true;\n\n  override _handleClick(event: MouseEvent): void {\n    if (!this.disabled) {\n      event.stopPropagation();\n      event.preventDefault();\n      this._parentChip._edit();\n    }\n  }\n\n  override _handleKeydown(event: KeyboardEvent) {\n    if ((event.keyCode === ENTER || event.keyCode === SPACE) && !this.disabled) {\n      event.stopPropagation();\n      event.preventDefault();\n      this._parentChip._edit();\n    }\n  }\n}\n\n/**\n * Directive to remove the parent chip when the trailing icon is clicked or\n * when the ENTER key is pressed on it.\n *\n * Recommended for use with the Material Design \"cancel\" icon\n * available at https://material.io/icons/#ic_cancel.\n *\n * Example:\n *\n * ```\n * <mat-chip>\n *   <mat-icon matChipRemove>cancel</mat-icon>\n * </mat-chip>\n * ```\n */\n\n@Directive({\n  selector: '[matChipRemove]',\n  host: {\n    'class':\n      'mat-mdc-chip-remove mat-mdc-chip-trailing-icon mat-focus-indicator ' +\n      'mdc-evolution-chip__icon mdc-evolution-chip__icon--trailing',\n    'role': 'button',\n    '[attr.aria-hidden]': 'null',\n  },\n  providers: [{provide: MAT_CHIP_REMOVE, useExisting: MatChipRemove}],\n})\nexport class MatChipRemove extends MatChipAction {\n  override _isPrimary = false;\n\n  override _handleClick(event: MouseEvent): void {\n    if (!this.disabled) {\n      event.stopPropagation();\n      event.preventDefault();\n      this._parentChip.remove();\n    }\n  }\n\n  override _handleKeydown(event: KeyboardEvent) {\n    if ((event.keyCode === ENTER || event.keyCode === SPACE) && !this.disabled) {\n      event.stopPropagation();\n      event.preventDefault();\n      this._parentChip.remove();\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {FocusMonitor, _IdGenerator} from '@angular/cdk/a11y';\nimport {BACKSPACE, DELETE} from '@angular/cdk/keycodes';\nimport {_CdkPrivateStyleLoader, _VisuallyHiddenLoader} from '@angular/cdk/private';\n\nimport {\n  AfterContentInit,\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChild,\n  ContentChildren,\n  DoCheck,\n  ElementRef,\n  EventEmitter,\n  HOST_TAG_NAME,\n  Injector,\n  Input,\n  NgZone,\n  OnDestroy,\n  OnInit,\n  Output,\n  QueryList,\n  ViewChild,\n  ViewEncapsulation,\n  booleanAttribute,\n  inject,\n  DOCUMENT,\n} from '@angular/core';\nimport {\n  MAT_RIPPLE_GLOBAL_OPTIONS,\n  MatRippleLoader,\n  RippleGlobalOptions,\n  _StructuralStylesLoader,\n  _animationsDisabled,\n} from '../core';\nimport {Subject, Subscription, merge} from 'rxjs';\nimport {MatChipAction, MatChipContent} from './chip-action';\nimport {MatChipAvatar, MatChipEdit, MatChipRemove, MatChipTrailingIcon} from './chip-icons';\nimport {\n  MAT_CHIP,\n  MAT_CHIP_AVATAR,\n  MAT_CHIP_EDIT,\n  MAT_CHIP_REMOVE,\n  MAT_CHIP_TRAILING_ICON,\n} from './tokens';\n\n/** Represents an event fired on an individual `mat-chip`. */\nexport interface MatChipEvent {\n  /** The chip the event was fired on. */\n  chip: MatChip;\n}\n\n/**\n * Material design styled Chip base component. Used inside the MatChipSet component.\n *\n * Extended by MatChipOption and MatChipRow for different interaction patterns.\n */\n@Component({\n  selector: 'mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]',\n  exportAs: 'matChip',\n  templateUrl: 'chip.html',\n  styleUrl: 'chip.css',\n  host: {\n    'class': 'mat-mdc-chip',\n    '[class]': '\"mat-\" + (color || \"primary\")',\n    '[class.mdc-evolution-chip]': '!_isBasicChip',\n    '[class.mdc-evolution-chip--disabled]': 'disabled',\n    '[class.mdc-evolution-chip--with-trailing-action]': '_hasTrailingIcon()',\n    '[class.mdc-evolution-chip--with-primary-graphic]': 'leadingIcon',\n    '[class.mdc-evolution-chip--with-primary-icon]': 'leadingIcon',\n    '[class.mdc-evolution-chip--with-avatar]': 'leadingIcon',\n    '[class.mat-mdc-chip-with-avatar]': 'leadingIcon',\n    '[class.mat-mdc-chip-highlighted]': 'highlighted',\n    '[class.mat-mdc-chip-disabled]': 'disabled',\n    '[class.mat-mdc-basic-chip]': '_isBasicChip',\n    '[class.mat-mdc-standard-chip]': '!_isBasicChip',\n    '[class.mat-mdc-chip-with-trailing-icon]': '_hasTrailingIcon()',\n    '[class._mat-animation-noopable]': '_animationsDisabled',\n    '[id]': 'id',\n    '[attr.role]': 'role',\n    '[attr.aria-label]': 'ariaLabel',\n    '(keydown)': '_handleKeydown($event)',\n  },\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  providers: [{provide: MAT_CHIP, useExisting: MatChip}],\n  imports: [MatChipContent],\n})\nexport class MatChip implements OnInit, AfterViewInit, AfterContentInit, DoCheck, OnDestroy {\n  _changeDetectorRef = inject(ChangeDetectorRef);\n  _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  private readonly _tagName = inject(HOST_TAG_NAME);\n  protected _ngZone = inject(NgZone);\n  private _focusMonitor = inject(FocusMonitor);\n  private _globalRippleOptions = inject<RippleGlobalOptions>(MAT_RIPPLE_GLOBAL_OPTIONS, {\n    optional: true,\n  });\n\n  protected _document = inject(DOCUMENT);\n\n  /** Emits when the chip is focused. */\n  readonly _onFocus = new Subject<MatChipEvent>();\n\n  /** Emits when the chip is blurred. */\n  readonly _onBlur = new Subject<MatChipEvent>();\n\n  /** Whether this chip is a basic (unstyled) chip. */\n  _isBasicChip: boolean;\n\n  /** Role for the root of the chip. */\n  @Input() role: string | null = null;\n\n  /** Whether the chip has focus. */\n  private _hasFocusInternal = false;\n\n  /** Whether moving focus into the chip is pending. */\n  private _pendingFocus: boolean;\n\n  /** Subscription to changes in the chip's actions. */\n  private _actionChanges: Subscription | undefined;\n\n  /** Whether animations for the chip are enabled. */\n  _animationsDisabled = _animationsDisabled();\n\n  /** All avatars present in the chip. */\n  @ContentChildren(MAT_CHIP_AVATAR, {descendants: true})\n  protected _allLeadingIcons: QueryList<MatChipAvatar>;\n\n  /** All trailing icons present in the chip. */\n  @ContentChildren(MAT_CHIP_TRAILING_ICON, {descendants: true})\n  protected _allTrailingIcons: QueryList<MatChipTrailingIcon>;\n\n  /** All edit icons present in the chip. */\n  @ContentChildren(MAT_CHIP_EDIT, {descendants: true})\n  protected _allEditIcons: QueryList<MatChipEdit>;\n\n  /** All remove icons present in the chip. */\n  @ContentChildren(MAT_CHIP_REMOVE, {descendants: true})\n  protected _allRemoveIcons: QueryList<MatChipRemove>;\n\n  _hasFocus() {\n    return this._hasFocusInternal;\n  }\n\n  /** A unique id for the chip. If none is supplied, it will be auto-generated. */\n  @Input() id: string = inject(_IdGenerator).getId('mat-mdc-chip-');\n\n  // TODO(#26104): Consider deprecating and using `_computeAriaAccessibleName` instead.\n  // `ariaLabel` may be unnecessary, and `_computeAriaAccessibleName` only supports\n  // datepicker's use case.\n  /** ARIA label for the content of the chip. */\n  @Input('aria-label') ariaLabel: string | null = null;\n\n  // TODO(#26104): Consider deprecating and using `_computeAriaAccessibleName` instead.\n  // `ariaDescription` may be unnecessary, and `_computeAriaAccessibleName` only supports\n  // datepicker's use case.\n  /** ARIA description for the content of the chip. */\n  @Input('aria-description') ariaDescription: string | null = null;\n\n  /** Whether the chip list is disabled. */\n  _chipListDisabled: boolean = false;\n\n  /** Whether the chip was focused when it was removed. */\n  _hadFocusOnRemove = false;\n\n  private _textElement!: HTMLElement;\n\n  /**\n   * The value of the chip. Defaults to the content inside\n   * the `mat-mdc-chip-action-label` element.\n   */\n  @Input()\n  get value(): any {\n    return this._value !== undefined ? this._value : this._textElement.textContent!.trim();\n  }\n  set value(value: any) {\n    this._value = value;\n  }\n  protected _value: any;\n\n  // TODO: should be typed as `ThemePalette` but internal apps pass in arbitrary strings.\n  /**\n   * Theme color of the chip. This API is supported in M2 themes only, it has no\n   * effect in M3 themes. For color customization in M3, see https://material.angular.dev/components/chips/styling.\n   *\n   * For information on applying color variants in M3, see\n   * https://material.angular.dev/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n   */\n  @Input() color?: string | null;\n\n  /**\n   * Determines whether or not the chip displays the remove styling and emits (removed) events.\n   */\n  @Input({transform: booleanAttribute})\n  removable: boolean = true;\n\n  /**\n   * Colors the chip for emphasis as if it were selected.\n   */\n  @Input({transform: booleanAttribute})\n  highlighted: boolean = false;\n\n  /** Whether the ripple effect is disabled or not. */\n  @Input({transform: booleanAttribute})\n  disableRipple: boolean = false;\n\n  /** Whether the chip is disabled. */\n  @Input({transform: booleanAttribute})\n  get disabled(): boolean {\n    return this._disabled || this._chipListDisabled;\n  }\n  set disabled(value: boolean) {\n    this._disabled = value;\n  }\n  private _disabled = false;\n\n  /** Emitted when a chip is to be removed. */\n  @Output() readonly removed: EventEmitter<MatChipEvent> = new EventEmitter<MatChipEvent>();\n\n  /** Emitted when the chip is destroyed. */\n  @Output() readonly destroyed: EventEmitter<MatChipEvent> = new EventEmitter<MatChipEvent>();\n\n  /** The unstyled chip selector for this component. */\n  protected basicChipAttrName = 'mat-basic-chip';\n\n  /** The chip's leading icon. */\n  @ContentChild(MAT_CHIP_AVATAR) leadingIcon: MatChipAvatar;\n\n  /** The chip's leading edit icon. */\n  @ContentChild(MAT_CHIP_EDIT) editIcon: MatChipEdit;\n\n  /** The chip's trailing icon. */\n  @ContentChild(MAT_CHIP_TRAILING_ICON) trailingIcon: MatChipTrailingIcon;\n\n  /** The chip's trailing remove icon. */\n  @ContentChild(MAT_CHIP_REMOVE) removeIcon: MatChipRemove;\n\n  /** Action receiving the primary set of user interactions. */\n  @ViewChild(MatChipAction) primaryAction: MatChipAction;\n\n  /**\n   * Handles the lazy creation of the MatChip ripple.\n   * Used to improve initial load time of large applications.\n   */\n  private _rippleLoader: MatRippleLoader = inject(MatRippleLoader);\n\n  protected _injector = inject(Injector);\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const styleLoader = inject(_CdkPrivateStyleLoader);\n    styleLoader.load(_StructuralStylesLoader);\n    styleLoader.load(_VisuallyHiddenLoader);\n    this._monitorFocus();\n\n    this._rippleLoader?.configureRipple(this._elementRef.nativeElement, {\n      className: 'mat-mdc-chip-ripple',\n      disabled: this._isRippleDisabled(),\n    });\n  }\n\n  ngOnInit() {\n    // This check needs to happen in `ngOnInit` so the overridden value of\n    // `basicChipAttrName` coming from base classes can be picked up.\n    this._isBasicChip =\n      this._elementRef.nativeElement.hasAttribute(this.basicChipAttrName) ||\n      this._tagName.toLowerCase() === this.basicChipAttrName;\n  }\n\n  ngAfterViewInit() {\n    this._textElement = this._elementRef.nativeElement.querySelector('.mat-mdc-chip-action-label')!;\n\n    if (this._pendingFocus) {\n      this._pendingFocus = false;\n      this.focus();\n    }\n  }\n\n  ngAfterContentInit(): void {\n    // Since the styling depends on the presence of some\n    // actions, we have to mark for check on changes.\n    this._actionChanges = merge(\n      this._allLeadingIcons.changes,\n      this._allTrailingIcons.changes,\n      this._allEditIcons.changes,\n      this._allRemoveIcons.changes,\n    ).subscribe(() => this._changeDetectorRef.markForCheck());\n  }\n\n  ngDoCheck(): void {\n    this._rippleLoader.setDisabled(this._elementRef.nativeElement, this._isRippleDisabled());\n  }\n\n  ngOnDestroy() {\n    this._focusMonitor.stopMonitoring(this._elementRef);\n    this._rippleLoader?.destroyRipple(this._elementRef.nativeElement);\n    this._actionChanges?.unsubscribe();\n    this.destroyed.emit({chip: this});\n    this.destroyed.complete();\n  }\n\n  /**\n   * Allows for programmatic removal of the chip.\n   *\n   * Informs any listeners of the removal request. Does not remove the chip from the DOM.\n   */\n  remove(): void {\n    if (this.removable) {\n      this._hadFocusOnRemove = this._hasFocus();\n      this.removed.emit({chip: this});\n    }\n  }\n\n  /** Whether or not the ripple should be disabled. */\n  _isRippleDisabled(): boolean {\n    return (\n      this.disabled ||\n      this.disableRipple ||\n      this._animationsDisabled ||\n      this._isBasicChip ||\n      !this._hasInteractiveActions() ||\n      !!this._globalRippleOptions?.disabled\n    );\n  }\n\n  /** Returns whether the chip has a trailing icon. */\n  _hasTrailingIcon() {\n    return !!(this.trailingIcon || this.removeIcon);\n  }\n\n  /** Handles keyboard events on the chip. */\n  _handleKeydown(event: KeyboardEvent) {\n    // Ignore backspace events where the user is holding down the key\n    // so that we don't accidentally remove too many chips.\n    if ((event.keyCode === BACKSPACE && !event.repeat) || event.keyCode === DELETE) {\n      event.preventDefault();\n      this.remove();\n    }\n  }\n\n  /** Allows for programmatic focusing of the chip. */\n  focus(): void {\n    if (!this.disabled) {\n      // If `focus` is called before `ngAfterViewInit`, we won't have access to the primary action.\n      // This can happen if the consumer tries to focus a chip immediately after it is added.\n      // Queue the method to be called again on init.\n      if (this.primaryAction) {\n        this.primaryAction.focus();\n      } else {\n        this._pendingFocus = true;\n      }\n    }\n  }\n\n  /** Gets the action that contains a specific target node. */\n  _getSourceAction(target: Node): MatChipAction | undefined {\n    return this._getActions().find(action => {\n      const element = action._elementRef.nativeElement;\n      return element === target || element.contains(target);\n    });\n  }\n\n  /** Gets all of the actions within the chip. */\n  _getActions(): MatChipAction[] {\n    const result: MatChipAction[] = [];\n\n    if (this.editIcon) {\n      result.push(this.editIcon);\n    }\n\n    if (this.primaryAction) {\n      result.push(this.primaryAction);\n    }\n\n    if (this.removeIcon) {\n      result.push(this.removeIcon);\n    }\n\n    return result;\n  }\n\n  /** Handles interactions with the primary action of the chip. */\n  _handlePrimaryActionInteraction() {\n    // Empty here, but is overwritten in child classes.\n  }\n\n  /** Returns whether the chip has any interactive actions. */\n  _hasInteractiveActions(): boolean {\n    return this._getActions().length > 0;\n  }\n\n  /** Handles interactions with the edit action of the chip. */\n  _edit(event: Event) {\n    // Empty here, but is overwritten in child classes.\n  }\n\n  /** Starts the focus monitoring process on the chip. */\n  private _monitorFocus() {\n    this._focusMonitor.monitor(this._elementRef, true).subscribe(origin => {\n      const hasFocus = origin !== null;\n\n      if (hasFocus !== this._hasFocusInternal) {\n        this._hasFocusInternal = hasFocus;\n\n        if (hasFocus) {\n          this._onFocus.next({chip: this});\n        } else {\n          // When animations are enabled, Angular may end up removing the chip from the DOM a little\n          // earlier than usual, causing it to be blurred and throwing off the logic in the chip list\n          // that moves focus to the next item. To work around the issue, we defer marking the chip\n          // as not focused until after the next render.\n          this._changeDetectorRef.markForCheck();\n          setTimeout(() => this._ngZone.run(() => this._onBlur.next({chip: this})));\n        }\n      }\n    });\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  EventEmitter,\n  Input,\n  Output,\n  ViewEncapsulation,\n  OnInit,\n  inject,\n  booleanAttribute,\n} from '@angular/core';\nimport {MatChip} from './chip';\nimport {MAT_CHIP, MAT_CHIPS_DEFAULT_OPTIONS} from './tokens';\nimport {MatChipAction} from './chip-action';\n\n/** Event object emitted by MatChipOption when selected or deselected. */\nexport class MatChipSelectionChange {\n  constructor(\n    /** Reference to the chip that emitted the event. */\n    public source: MatChipOption,\n    /** Whether the chip that emitted the event is selected. */\n    public selected: boolean,\n    /** Whether the selection change was a result of a user interaction. */\n    public isUserInput = false,\n  ) {}\n}\n\n/**\n * An extension of the MatChip component that supports chip selection. Used with MatChipListbox.\n *\n * Unlike other chips, the user can focus on disabled chip options inside a MatChipListbox. The\n * user cannot click disabled chips.\n */\n@Component({\n  selector: 'mat-basic-chip-option, [mat-basic-chip-option], mat-chip-option, [mat-chip-option]',\n  templateUrl: 'chip-option.html',\n  styleUrl: 'chip.css',\n  host: {\n    'class': 'mat-mdc-chip mat-mdc-chip-option',\n    '[class.mdc-evolution-chip]': '!_isBasicChip',\n    '[class.mdc-evolution-chip--filter]': '!_isBasicChip',\n    '[class.mdc-evolution-chip--selectable]': '!_isBasicChip',\n    '[class.mat-mdc-chip-selected]': 'selected',\n    '[class.mat-mdc-chip-multiple]': '_chipListMultiple',\n    '[class.mat-mdc-chip-disabled]': 'disabled',\n    '[class.mat-mdc-chip-with-avatar]': 'leadingIcon',\n    '[class.mdc-evolution-chip--disabled]': 'disabled',\n    '[class.mdc-evolution-chip--selected]': 'selected',\n    // This class enables the transition on the checkmark. Usually MDC adds it when selection\n    // starts and removes it once the animation is finished. We don't need to go through all\n    // the trouble, because we only care about the selection animation. MDC needs to do it,\n    // because they also have an exit animation that we don't care about.\n    '[class.mdc-evolution-chip--selecting]': '!_animationsDisabled',\n    '[class.mdc-evolution-chip--with-trailing-action]': '_hasTrailingIcon()',\n    '[class.mdc-evolution-chip--with-primary-icon]': 'leadingIcon',\n    '[class.mdc-evolution-chip--with-primary-graphic]': '_hasLeadingGraphic()',\n    '[class.mdc-evolution-chip--with-avatar]': 'leadingIcon',\n    '[class.mat-mdc-chip-highlighted]': 'highlighted',\n    '[class.mat-mdc-chip-with-trailing-icon]': '_hasTrailingIcon()',\n    '[attr.tabindex]': 'null',\n    '[attr.aria-label]': 'null',\n    '[attr.aria-description]': 'null',\n    '[attr.role]': 'role',\n    '[id]': 'id',\n  },\n  providers: [\n    {provide: MatChip, useExisting: MatChipOption},\n    {provide: MAT_CHIP, useExisting: MatChipOption},\n  ],\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [MatChipAction],\n})\nexport class MatChipOption extends MatChip implements OnInit {\n  /** Default chip options. */\n  private _defaultOptions = inject(MAT_CHIPS_DEFAULT_OPTIONS, {optional: true});\n\n  /** Whether the chip list is selectable. */\n  chipListSelectable: boolean = true;\n\n  /** Whether the chip list is in multi-selection mode. */\n  _chipListMultiple: boolean = false;\n\n  /** Whether the chip list hides single-selection indicator. */\n  _chipListHideSingleSelectionIndicator: boolean =\n    this._defaultOptions?.hideSingleSelectionIndicator ?? false;\n\n  /**\n   * Whether or not the chip is selectable.\n   *\n   * When a chip is not selectable, changes to its selected state are always\n   * ignored. By default an option chip is selectable, and it becomes\n   * non-selectable if its parent chip list is not selectable.\n   */\n  @Input({transform: booleanAttribute})\n  get selectable(): boolean {\n    return this._selectable && this.chipListSelectable;\n  }\n  set selectable(value: boolean) {\n    this._selectable = value;\n    this._changeDetectorRef.markForCheck();\n  }\n  protected _selectable: boolean = true;\n\n  /** Whether the chip is selected. */\n  @Input({transform: booleanAttribute})\n  get selected(): boolean {\n    return this._selected;\n  }\n  set selected(value: boolean) {\n    this._setSelectedState(value, false, true);\n  }\n  private _selected = false;\n\n  /**\n   * The ARIA selected applied to the chip. Conforms to WAI ARIA best practices for listbox\n   * interaction patterns.\n   *\n   * From [WAI ARIA Listbox authoring practices guide](\n   * https://www.w3.org/WAI/ARIA/apg/patterns/listbox/):\n   *  \"If any options are selected, each selected option has either aria-selected or aria-checked\n   *  set to true. All options that are selectable but not selected have either aria-selected or\n   *  aria-checked set to false.\"\n   *\n   * Set `aria-selected=\"false\"` on not-selected listbox options that are selectable to fix\n   * VoiceOver reading every option as \"selected\" (#25736).\n   */\n  get ariaSelected(): string | null {\n    return this.selectable ? this.selected.toString() : null;\n  }\n\n  /** The unstyled chip selector for this component. */\n  protected override basicChipAttrName = 'mat-basic-chip-option';\n\n  /** Emitted when the chip is selected or deselected. */\n  @Output() readonly selectionChange: EventEmitter<MatChipSelectionChange> =\n    new EventEmitter<MatChipSelectionChange>();\n\n  override ngOnInit() {\n    super.ngOnInit();\n    this.role = 'presentation';\n  }\n\n  /** Selects the chip. */\n  select(): void {\n    this._setSelectedState(true, false, true);\n  }\n\n  /** Deselects the chip. */\n  deselect(): void {\n    this._setSelectedState(false, false, true);\n  }\n\n  /** Selects this chip and emits userInputSelection event */\n  selectViaInteraction(): void {\n    this._setSelectedState(true, true, true);\n  }\n\n  /** Toggles the current selected state of this chip. */\n  toggleSelected(isUserInput: boolean = false): boolean {\n    this._setSelectedState(!this.selected, isUserInput, true);\n    return this.selected;\n  }\n\n  override _handlePrimaryActionInteraction() {\n    if (!this.disabled) {\n      // Interacting with the primary action implies that the chip already has focus, however\n      // there's a bug in Safari where focus ends up lingering on the previous chip (see #27544).\n      // We work around it by explicitly focusing the primary action of the current chip.\n      this.focus();\n\n      if (this.selectable) {\n        this.toggleSelected(true);\n      }\n    }\n  }\n\n  _hasLeadingGraphic() {\n    if (this.leadingIcon) {\n      return true;\n    }\n\n    // The checkmark graphic communicates selected state for both single-select and multi-select.\n    // Include checkmark in single-select to fix a11y issue where selected state is communicated\n    // visually only using color (#25886).\n    return !this._chipListHideSingleSelectionIndicator || this._chipListMultiple;\n  }\n\n  _setSelectedState(isSelected: boolean, isUserInput: boolean, emitEvent: boolean) {\n    if (isSelected !== this.selected) {\n      this._selected = isSelected;\n\n      if (emitEvent) {\n        this.selectionChange.emit({\n          source: this,\n          isUserInput,\n          selected: this.selected,\n        });\n      }\n\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive, ElementRef, inject, DOCUMENT} from '@angular/core';\n\n/**\n * A directive that makes a span editable and exposes functions to modify and retrieve the\n * element's contents.\n */\n@Directive({\n  selector: 'span[matChipEditInput]',\n  host: {\n    'class': 'mat-chip-edit-input',\n    'role': 'textbox',\n    'tabindex': '-1',\n    'contenteditable': 'true',\n  },\n})\nexport class MatChipEditInput {\n  private readonly _elementRef = inject(ElementRef);\n  private readonly _document = inject(DOCUMENT);\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  initialize(initialValue: string) {\n    this.getNativeElement().focus();\n    this.setValue(initialValue);\n  }\n\n  getNativeElement(): HTMLElement {\n    return this._elementRef.nativeElement;\n  }\n\n  setValue(value: string) {\n    this.getNativeElement().textContent = value;\n    this._moveCursorToEndOfInput();\n  }\n\n  getValue(): string {\n    return this.getNativeElement().textContent || '';\n  }\n\n  private _moveCursorToEndOfInput() {\n    const range = this._document.createRange();\n    range.selectNodeContents(this.getNativeElement());\n    range.collapse(false);\n    const sel = window.getSelection()!;\n    sel.removeAllRanges();\n    sel.addRange(range);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ENTER} from '@angular/cdk/keycodes';\nimport {\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  Component,\n  ContentChild,\n  EventEmitter,\n  Input,\n  Output,\n  ViewChild,\n  ViewEncapsulation,\n  afterNextRender,\n} from '@angular/core';\nimport {takeUntil} from 'rxjs/operators';\nimport {MatChip, MatChipEvent} from './chip';\nimport {MatChipAction} from './chip-action';\nimport {MatChipEditInput} from './chip-edit-input';\nimport {MAT_CHIP} from './tokens';\n\n/** Represents an event fired on an individual `mat-chip` when it is edited. */\nexport interface MatChipEditedEvent extends MatChipEvent {\n  /** The final edit value. */\n  value: string;\n}\n\n/**\n * An extension of the MatChip component used with MatChipGrid and\n * the matChipInputFor directive.\n */\n@Component({\n  selector: 'mat-chip-row, [mat-chip-row], mat-basic-chip-row, [mat-basic-chip-row]',\n  templateUrl: 'chip-row.html',\n  styleUrl: 'chip.css',\n  host: {\n    'class': 'mat-mdc-chip mat-mdc-chip-row mdc-evolution-chip',\n    '[class.mat-mdc-chip-with-avatar]': 'leadingIcon',\n    '[class.mat-mdc-chip-disabled]': 'disabled',\n    '[class.mat-mdc-chip-editing]': '_isEditing',\n    '[class.mat-mdc-chip-editable]': 'editable',\n    '[class.mdc-evolution-chip--disabled]': 'disabled',\n    '[class.mdc-evolution-chip--with-leading-action]': '_hasLeadingActionIcon()',\n    '[class.mdc-evolution-chip--with-trailing-action]': '_hasTrailingIcon()',\n    '[class.mdc-evolution-chip--with-primary-graphic]': 'leadingIcon',\n    '[class.mdc-evolution-chip--with-primary-icon]': 'leadingIcon',\n    '[class.mdc-evolution-chip--with-avatar]': 'leadingIcon',\n    '[class.mat-mdc-chip-highlighted]': 'highlighted',\n    '[class.mat-mdc-chip-with-trailing-icon]': '_hasTrailingIcon()',\n    '[id]': 'id',\n    // Has to have a negative tabindex in order to capture\n    // focus and redirect it to the primary action.\n    '[attr.tabindex]': 'disabled ? null : -1',\n    '[attr.aria-label]': 'null',\n    '[attr.aria-description]': 'null',\n    '[attr.role]': 'role',\n    '(focus)': '_handleFocus()',\n    '(click)': 'this._hasInteractiveActions() ? _handleClick($event) : null',\n    '(dblclick)': '_handleDoubleclick($event)',\n  },\n  providers: [\n    {provide: MatChip, useExisting: MatChipRow},\n    {provide: MAT_CHIP, useExisting: MatChipRow},\n  ],\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [MatChipAction, MatChipEditInput],\n})\nexport class MatChipRow extends MatChip implements AfterViewInit {\n  protected override basicChipAttrName = 'mat-basic-chip-row';\n\n  /**\n   * The editing action has to be triggered in a timeout. While we're waiting on it, a blur\n   * event might occur which will interrupt the editing. This flag is used to avoid interruptions\n   * while the editing action is being initialized.\n   */\n  private _editStartPending = false;\n\n  @Input() editable: boolean = false;\n\n  /** Emitted when the chip is edited. */\n  @Output() readonly edited: EventEmitter<MatChipEditedEvent> =\n    new EventEmitter<MatChipEditedEvent>();\n\n  /** The default chip edit input that is used if none is projected into this chip row. */\n  @ViewChild(MatChipEditInput) defaultEditInput?: MatChipEditInput;\n\n  /** The projected chip edit input. */\n  @ContentChild(MatChipEditInput) contentEditInput?: MatChipEditInput;\n\n  /**\n   * Set on a mousedown when the chip is already focused via mouse or keyboard.\n   *\n   * This allows us to ensure chip is already focused when deciding whether to enter the\n   * edit mode on a subsequent click. Otherwise, the chip appears focused when handling the\n   * first click event.\n   */\n  private _alreadyFocused = false;\n\n  _isEditing = false;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    super();\n\n    this.role = 'row';\n    this._onBlur.pipe(takeUntil(this.destroyed)).subscribe(() => {\n      if (this._isEditing && !this._editStartPending) {\n        this._onEditFinish();\n      }\n      this._alreadyFocused = false;\n    });\n  }\n\n  override ngAfterViewInit() {\n    super.ngAfterViewInit();\n\n    // Sets _alreadyFocused (ahead of click) when chip already has focus.\n    this._ngZone.runOutsideAngular(() => {\n      this._elementRef.nativeElement.addEventListener(\n        'mousedown',\n        () => (this._alreadyFocused = this._hasFocus()),\n      );\n    });\n  }\n\n  protected _hasLeadingActionIcon() {\n    // The leading action (edit) icon is hidden while editing.\n    return !this._isEditing && !!this.editIcon;\n  }\n\n  override _hasTrailingIcon() {\n    // The trailing icon is hidden while editing.\n    return !this._isEditing && super._hasTrailingIcon();\n  }\n\n  /** Sends focus to the first gridcell when the user clicks anywhere inside the chip. */\n  _handleFocus() {\n    if (!this._isEditing && !this.disabled) {\n      this.focus();\n    }\n  }\n\n  override _handleKeydown(event: KeyboardEvent): void {\n    if (event.keyCode === ENTER && !this.disabled) {\n      if (this._isEditing) {\n        event.preventDefault();\n        this._onEditFinish();\n      } else if (this.editable) {\n        this._startEditing(event);\n      }\n    } else if (this._isEditing) {\n      // Stop the event from reaching the chip set in order to avoid navigating.\n      event.stopPropagation();\n    } else {\n      super._handleKeydown(event);\n    }\n  }\n\n  _handleClick(event: MouseEvent) {\n    if (!this.disabled && this.editable && !this._isEditing && this._alreadyFocused) {\n      // Ensure click event not picked up unintentionally by other listeners, as\n      // once editing starts, the source element is detached from DOM.\n      event.preventDefault();\n      event.stopPropagation();\n      this._startEditing(event);\n    }\n  }\n\n  _handleDoubleclick(event: MouseEvent) {\n    if (!this.disabled && this.editable) {\n      this._startEditing(event);\n    }\n  }\n\n  override _edit(): void {\n    // markForCheck necessary for edit input to be rendered\n    this._changeDetectorRef.markForCheck();\n    this._startEditing();\n  }\n\n  private _startEditing(event?: Event) {\n    if (\n      !this.primaryAction ||\n      (this.removeIcon &&\n        !!event &&\n        this._getSourceAction(event.target as Node) === this.removeIcon)\n    ) {\n      return;\n    }\n\n    // The value depends on the DOM so we need to extract it before we flip the flag.\n    const value = this.value;\n\n    this._isEditing = this._editStartPending = true;\n\n    // Defer initializing the input until after it has been added to the DOM.\n    afterNextRender(\n      () => {\n        this._getEditInput().initialize(value);\n\n        // Necessary when using edit icon to prevent edit from aborting\n        setTimeout(() => this._ngZone.run(() => (this._editStartPending = false)));\n      },\n      {injector: this._injector},\n    );\n  }\n\n  private _onEditFinish() {\n    this._isEditing = this._editStartPending = false;\n    this.edited.emit({chip: this, value: this._getEditInput().getValue()});\n\n    // If the edit input is still focused or focus was returned to the body after it was destroyed,\n    // return focus to the chip contents.\n    if (\n      this._document.activeElement === this._getEditInput().getNativeElement() ||\n      this._document.activeElement === this._document.body\n    ) {\n      this.primaryAction.focus();\n    }\n  }\n\n  override _isRippleDisabled(): boolean {\n    return super._isRippleDisabled() || this._isEditing;\n  }\n\n  /**\n   * Gets the projected chip edit input, or the default input if none is projected in. One of these\n   * two values is guaranteed to be defined.\n   */\n  private _getEditInput(): MatChipEditInput {\n    return this.contentEditInput || this.defaultEditInput!;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {FocusKeyManager} from '@angular/cdk/a11y';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  ElementRef,\n  Input,\n  OnDestroy,\n  QueryList,\n  ViewEncapsulation,\n  booleanAttribute,\n  numberAttribute,\n  inject,\n} from '@angular/core';\nimport {Observable, Subject, merge} from 'rxjs';\nimport {startWith, switchMap, takeUntil} from 'rxjs/operators';\nimport {MatChip, MatChipEvent} from './chip';\nimport {MatChipAction, MatChipContent} from './chip-action';\n\n/**\n * Basic container component for the MatChip component.\n *\n * Extended by MatChipListbox and MatChipGrid for different interaction patterns.\n */\n@Component({\n  selector: 'mat-chip-set',\n  template: `\n    <div class=\"mdc-evolution-chip-set__chips\" role=\"presentation\">\n      <ng-content></ng-content>\n    </div>\n  `,\n  styleUrl: 'chip-set.css',\n  host: {\n    'class': 'mat-mdc-chip-set mdc-evolution-chip-set',\n    '(keydown)': '_handleKeydown($event)',\n    '[attr.role]': 'role',\n  },\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatChipSet implements AfterViewInit, OnDestroy {\n  protected _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  protected _changeDetectorRef = inject(ChangeDetectorRef);\n  private _dir = inject(Directionality, {optional: true});\n\n  /** Index of the last destroyed chip that had focus. */\n  private _lastDestroyedFocusedChipIndex: number | null = null;\n\n  /** Used to manage focus within the chip list. */\n  protected _keyManager: FocusKeyManager<MatChipAction>;\n\n  /** Subject that emits when the component has been destroyed. */\n  protected _destroyed = new Subject<void>();\n\n  /** Role to use if it hasn't been overwritten by the user. */\n  protected _defaultRole = 'presentation';\n\n  /** Combined stream of all of the child chips' focus events. */\n  get chipFocusChanges(): Observable<MatChipEvent> {\n    return this._getChipStream(chip => chip._onFocus);\n  }\n\n  /** Combined stream of all of the child chips' destroy events. */\n  get chipDestroyedChanges(): Observable<MatChipEvent> {\n    return this._getChipStream(chip => chip.destroyed);\n  }\n\n  /** Combined stream of all of the child chips' remove events. */\n  get chipRemovedChanges(): Observable<MatChipEvent> {\n    return this._getChipStream(chip => chip.removed);\n  }\n\n  /** Whether the chip set is disabled. */\n  @Input({transform: booleanAttribute})\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(value: boolean) {\n    this._disabled = value;\n    this._syncChipsState();\n  }\n  protected _disabled: boolean = false;\n\n  /** Whether the chip list contains chips or not. */\n  get empty(): boolean {\n    return !this._chips || this._chips.length === 0;\n  }\n\n  /** The ARIA role applied to the chip set. */\n  @Input()\n  get role(): string | null {\n    if (this._explicitRole) {\n      return this._explicitRole;\n    }\n\n    return this.empty ? null : this._defaultRole;\n  }\n\n  /** Tabindex of the chip set. */\n  @Input({\n    transform: (value: unknown) => (value == null ? 0 : numberAttribute(value)),\n  })\n  tabIndex: number = 0;\n\n  set role(value: string | null) {\n    this._explicitRole = value;\n  }\n  private _explicitRole: string | null = null;\n\n  /** Whether any of the chips inside of this chip-set has focus. */\n  get focused(): boolean {\n    return this._hasFocusedChip();\n  }\n\n  /** The chips that are part of this chip set. */\n  @ContentChildren(MatChip, {\n    // We need to use `descendants: true`, because Ivy will no longer match\n    // indirect descendants if it's left as false.\n    descendants: true,\n  })\n  _chips: QueryList<MatChip>;\n\n  /** Flat list of all the actions contained within the chips. */\n  _chipActions = new QueryList<MatChipAction>();\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  ngAfterViewInit() {\n    this._setUpFocusManagement();\n    this._trackChipSetChanges();\n    this._trackDestroyedFocusedChip();\n  }\n\n  ngOnDestroy() {\n    this._keyManager?.destroy();\n    this._chipActions.destroy();\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n\n  /** Checks whether any of the chips is focused. */\n  protected _hasFocusedChip() {\n    return this._chips && this._chips.some(chip => chip._hasFocus());\n  }\n\n  /** Syncs the chip-set's state with the individual chips. */\n  protected _syncChipsState() {\n    this._chips?.forEach(chip => {\n      chip._chipListDisabled = this._disabled;\n      chip._changeDetectorRef.markForCheck();\n    });\n  }\n\n  /** Dummy method for subclasses to override. Base chip set cannot be focused. */\n  focus() {}\n\n  /** Handles keyboard events on the chip set. */\n  _handleKeydown(event: KeyboardEvent) {\n    if (this._originatesFromChip(event)) {\n      this._keyManager.onKeydown(event);\n    }\n  }\n\n  /**\n   * Utility to ensure all indexes are valid.\n   *\n   * @param index The index to be checked.\n   * @returns True if the index is valid for our list of chips.\n   */\n  protected _isValidIndex(index: number): boolean {\n    return index >= 0 && index < this._chips.length;\n  }\n\n  /**\n   * Removes the `tabindex` from the chip set and resets it back afterwards, allowing the\n   * user to tab out of it. This prevents the set from capturing focus and redirecting\n   * it back to the first chip, creating a focus trap, if it user tries to tab away.\n   */\n  protected _allowFocusEscape() {\n    const previous = this._elementRef.nativeElement.tabIndex;\n\n    if (previous !== -1) {\n      // Set the tabindex directly on the element, instead of going through\n      // the data binding, because we aren't guaranteed that change detection\n      // will run quickly enough to allow focus to escape.\n      this._elementRef.nativeElement.tabIndex = -1;\n\n      // Note that this needs to be a `setTimeout`, because a `Promise.resolve`\n      // doesn't allow enough time for the focus to escape.\n      setTimeout(() => (this._elementRef.nativeElement.tabIndex = previous));\n    }\n  }\n\n  /**\n   * Gets a stream of events from all the chips within the set.\n   * The stream will automatically incorporate any newly-added chips.\n   */\n  protected _getChipStream<T, C extends MatChip = MatChip>(\n    mappingFunction: (chip: C) => Observable<T>,\n  ): Observable<T> {\n    return this._chips.changes.pipe(\n      startWith(null),\n      switchMap(() => merge(...(this._chips as QueryList<C>).map(mappingFunction))),\n    );\n  }\n\n  /** Checks whether an event comes from inside a chip element. */\n  protected _originatesFromChip(event: Event): boolean {\n    let currentElement = event.target as HTMLElement | null;\n\n    while (currentElement && currentElement !== this._elementRef.nativeElement) {\n      if (currentElement.classList.contains('mat-mdc-chip')) {\n        return true;\n      }\n      currentElement = currentElement.parentElement;\n    }\n    return false;\n  }\n\n  /** Sets up the chip set's focus management logic. */\n  private _setUpFocusManagement() {\n    // Create a flat `QueryList` containing the actions of all of the chips.\n    // This allows us to navigate both within the chip and move to the next/previous\n    // one using the existing `ListKeyManager`.\n    this._chips.changes.pipe(startWith(this._chips)).subscribe((chips: QueryList<MatChip>) => {\n      const actions: MatChipAction[] = [];\n      chips.forEach(chip => chip._getActions().forEach(action => actions.push(action)));\n      this._chipActions.reset(actions);\n      this._chipActions.notifyOnChanges();\n    });\n\n    this._keyManager = new FocusKeyManager(this._chipActions)\n      .withVerticalOrientation()\n      .withHorizontalOrientation(this._dir ? this._dir.value : 'ltr')\n      .withHomeAndEnd()\n      .skipPredicate(action => this._skipPredicate(action));\n\n    // Keep the manager active index in sync so that navigation picks\n    // up from the current chip if the user clicks into the list directly.\n    this.chipFocusChanges.pipe(takeUntil(this._destroyed)).subscribe(({chip}) => {\n      const action = chip._getSourceAction(document.activeElement as Element);\n\n      if (action) {\n        this._keyManager.updateActiveItem(action);\n      }\n    });\n\n    this._dir?.change\n      .pipe(takeUntil(this._destroyed))\n      .subscribe(direction => this._keyManager.withHorizontalOrientation(direction));\n  }\n\n  /**\n   * Determines if key manager should avoid putting a given chip action in the tab index. Skip\n   * non-interactive and disabled actions since the user can't do anything with them.\n   */\n  protected _skipPredicate(action: MatChipContent): boolean {\n    // `mat-chip-set` does not permit focusing disabled chips.\n    return action.disabled;\n  }\n\n  /** Listens to changes in the chip set and syncs up the state of the individual chips. */\n  private _trackChipSetChanges() {\n    this._chips.changes.pipe(startWith(null), takeUntil(this._destroyed)).subscribe(() => {\n      if (this.disabled) {\n        // Since this happens after the content has been\n        // checked, we need to defer it to the next tick.\n        Promise.resolve().then(() => this._syncChipsState());\n      }\n\n      this._redirectDestroyedChipFocus();\n    });\n  }\n\n  /** Starts tracking the destroyed chips in order to capture the focused one. */\n  private _trackDestroyedFocusedChip() {\n    this.chipDestroyedChanges.pipe(takeUntil(this._destroyed)).subscribe((event: MatChipEvent) => {\n      // If the focused chip is destroyed, save its index so that we can move focus to the next\n      // chip. We only save the index here, rather than move the focus immediately, because we want\n      // to wait until the chip is removed from the chip list before focusing the next one. This\n      // allows us to keep focus on the same index if the chip gets swapped out.\n      const chipArray = this._chips.toArray();\n      const chipIndex = chipArray.indexOf(event.chip);\n      const hasFocus = event.chip._hasFocus();\n      const wasLastFocused =\n        event.chip._hadFocusOnRemove &&\n        this._keyManager.activeItem &&\n        event.chip._getActions().includes(this._keyManager.activeItem);\n\n      // Note that depending on the timing, the chip might've already lost focus by the\n      // time we check this. We need the `wasLastFocused` as a fallback to detect such cases.\n      // In `wasLastFocused` we also need to ensure that the chip actually had focus when it was\n      // deleted so that we don't steal away the user's focus after they've moved on from the chip.\n      const shouldMoveFocus = hasFocus || wasLastFocused;\n\n      if (this._isValidIndex(chipIndex) && shouldMoveFocus) {\n        this._lastDestroyedFocusedChipIndex = chipIndex;\n      }\n    });\n  }\n\n  /**\n   * Finds the next appropriate chip to move focus to,\n   * if the currently-focused chip is destroyed.\n   */\n  private _redirectDestroyedChipFocus() {\n    if (this._lastDestroyedFocusedChipIndex == null) {\n      return;\n    }\n\n    if (this._chips.length) {\n      const newIndex = Math.min(this._lastDestroyedFocusedChipIndex, this._chips.length - 1);\n      const chipToFocus = this._chips.toArray()[newIndex];\n\n      if (chipToFocus.disabled) {\n        // If we're down to one disabled chip, move focus back to the set.\n        if (this._chips.length === 1) {\n          this.focus();\n        } else {\n          this._keyManager.setPreviousItemActive();\n        }\n      } else {\n        chipToFocus.focus();\n      }\n    } else {\n      this.focus();\n    }\n\n    this._lastDestroyedFocusedChipIndex = null;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  AfterContentInit,\n  booleanAttribute,\n  ChangeDetectionStrategy,\n  Component,\n  ContentChildren,\n  EventEmitter,\n  forwardRef,\n  inject,\n  Input,\n  OnDestroy,\n  Output,\n  QueryList,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '@angular/forms';\nimport {Observable} from 'rxjs';\nimport {startWith, takeUntil} from 'rxjs/operators';\nimport {TAB} from '@angular/cdk/keycodes';\nimport {MatChip, MatChipEvent} from './chip';\nimport {MatChipOption, MatChipSelectionChange} from './chip-option';\nimport {MatChipSet} from './chip-set';\nimport {MatChipAction} from './chip-action';\nimport {MAT_CHIPS_DEFAULT_OPTIONS} from './tokens';\n\n/** Change event object that is emitted when the chip listbox value has changed. */\nexport class MatChipListboxChange {\n  constructor(\n    /** Chip listbox that emitted the event. */\n    public source: MatChipListbox,\n    /** Value of the chip listbox when the event was emitted. */\n    public value: any,\n  ) {}\n}\n\n/**\n * Provider Expression that allows mat-chip-listbox to register as a ControlValueAccessor.\n * This allows it to support [(ngModel)].\n * @docs-private\n */\nexport const MAT_CHIP_LISTBOX_CONTROL_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatChipListbox),\n  multi: true,\n};\n\n/**\n * An extension of the MatChipSet component that supports chip selection.\n * Used with MatChipOption chips.\n */\n@Component({\n  selector: 'mat-chip-listbox',\n  template: `\n    <div class=\"mdc-evolution-chip-set__chips\" role=\"presentation\">\n      <ng-content></ng-content>\n    </div>\n  `,\n  styleUrl: 'chip-set.css',\n  host: {\n    'class': 'mdc-evolution-chip-set mat-mdc-chip-listbox',\n    '[attr.role]': 'role',\n    '[tabIndex]': '(disabled || empty) ? -1 : tabIndex',\n    '[attr.aria-required]': 'role ? required : null',\n    '[attr.aria-disabled]': 'disabled.toString()',\n    '[attr.aria-multiselectable]': 'multiple',\n    '[attr.aria-orientation]': 'ariaOrientation',\n    '[class.mat-mdc-chip-list-disabled]': 'disabled',\n    '[class.mat-mdc-chip-list-required]': 'required',\n    '(focus)': 'focus()',\n    '(blur)': '_blur()',\n    '(keydown)': '_keydown($event)',\n  },\n  providers: [MAT_CHIP_LISTBOX_CONTROL_VALUE_ACCESSOR],\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatChipListbox\n  extends MatChipSet\n  implements AfterContentInit, OnDestroy, ControlValueAccessor\n{\n  /**\n   * Function when touched. Set as part of ControlValueAccessor implementation.\n   * @docs-private\n   */\n  _onTouched = () => {};\n\n  /**\n   * Function when changed. Set as part of ControlValueAccessor implementation.\n   * @docs-private\n   */\n  _onChange: (value: any) => void = () => {};\n\n  // TODO: MDC uses `grid` here\n  protected override _defaultRole = 'listbox';\n\n  /** Default chip options. */\n  private _defaultOptions = inject(MAT_CHIPS_DEFAULT_OPTIONS, {optional: true});\n\n  /** Whether the user should be allowed to select multiple chips. */\n  @Input({transform: booleanAttribute})\n  get multiple(): boolean {\n    return this._multiple;\n  }\n  set multiple(value: boolean) {\n    this._multiple = value;\n    this._syncListboxProperties();\n  }\n  private _multiple: boolean = false;\n\n  /** The array of selected chips inside the chip listbox. */\n  get selected(): MatChipOption[] | MatChipOption {\n    const selectedChips = this._chips.toArray().filter(chip => chip.selected);\n    return this.multiple ? selectedChips : selectedChips[0];\n  }\n\n  /** Orientation of the chip list. */\n  @Input('aria-orientation') ariaOrientation: 'horizontal' | 'vertical' = 'horizontal';\n\n  /**\n   * Whether or not this chip listbox is selectable.\n   *\n   * When a chip listbox is not selectable, the selected states for all\n   * the chips inside the chip listbox are always ignored.\n   */\n  @Input({transform: booleanAttribute})\n  get selectable(): boolean {\n    return this._selectable;\n  }\n  set selectable(value: boolean) {\n    this._selectable = value;\n    this._syncListboxProperties();\n  }\n  protected _selectable: boolean = true;\n\n  /**\n   * A function to compare the option values with the selected values. The first argument\n   * is a value from an option. The second is a value from the selection. A boolean\n   * should be returned.\n   */\n  @Input() compareWith: (o1: any, o2: any) => boolean = (o1: any, o2: any) => o1 === o2;\n\n  /** Whether this chip listbox is required. */\n  @Input({transform: booleanAttribute})\n  required: boolean = false;\n\n  /** Whether checkmark indicator for single-selection options is hidden. */\n  @Input({transform: booleanAttribute})\n  get hideSingleSelectionIndicator(): boolean {\n    return this._hideSingleSelectionIndicator;\n  }\n  set hideSingleSelectionIndicator(value: boolean) {\n    this._hideSingleSelectionIndicator = value;\n    this._syncListboxProperties();\n  }\n  private _hideSingleSelectionIndicator: boolean =\n    this._defaultOptions?.hideSingleSelectionIndicator ?? false;\n\n  /** Combined stream of all of the child chips' selection change events. */\n  get chipSelectionChanges(): Observable<MatChipSelectionChange> {\n    return this._getChipStream<MatChipSelectionChange, MatChipOption>(chip => chip.selectionChange);\n  }\n\n  /** Combined stream of all of the child chips' blur events. */\n  get chipBlurChanges(): Observable<MatChipEvent> {\n    return this._getChipStream(chip => chip._onBlur);\n  }\n\n  /** The value of the listbox, which is the combined value of the selected chips. */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(value: any) {\n    if (this._chips && this._chips.length) {\n      this._setSelectionByValue(value, false);\n    }\n    this._value = value;\n  }\n  protected _value: any;\n\n  /** Event emitted when the selected chip listbox value has been changed by the user. */\n  @Output() readonly change: EventEmitter<MatChipListboxChange> =\n    new EventEmitter<MatChipListboxChange>();\n\n  @ContentChildren(MatChipOption, {\n    // We need to use `descendants: true`, because Ivy will no longer match\n    // indirect descendants if it's left as false.\n    descendants: true,\n  })\n  // We need an initializer here to avoid a TS error. The value will be set in `ngAfterViewInit`.\n  override _chips: QueryList<MatChipOption> = undefined!;\n\n  ngAfterContentInit() {\n    this._chips.changes.pipe(startWith(null), takeUntil(this._destroyed)).subscribe(() => {\n      if (this.value !== undefined) {\n        Promise.resolve().then(() => {\n          this._setSelectionByValue(this.value, false);\n        });\n      }\n      // Update listbox selectable/multiple properties on chips\n      this._syncListboxProperties();\n    });\n\n    this.chipBlurChanges.pipe(takeUntil(this._destroyed)).subscribe(() => this._blur());\n    this.chipSelectionChanges.pipe(takeUntil(this._destroyed)).subscribe(event => {\n      if (!this.multiple) {\n        this._chips.forEach(chip => {\n          if (chip !== event.source) {\n            chip._setSelectedState(false, false, false);\n          }\n        });\n      }\n\n      if (event.isUserInput) {\n        this._propagateChanges();\n      }\n    });\n  }\n\n  /**\n   * Focuses the first selected chip in this chip listbox, or the first non-disabled chip when there\n   * are no selected chips.\n   */\n  override focus(): void {\n    if (this.disabled) {\n      return;\n    }\n\n    const firstSelectedChip = this._getFirstSelectedChip();\n\n    if (firstSelectedChip && !firstSelectedChip.disabled) {\n      firstSelectedChip.focus();\n    } else if (this._chips.length > 0) {\n      this._keyManager.setFirstItemActive();\n    } else {\n      this._elementRef.nativeElement.focus();\n    }\n  }\n\n  /**\n   * Implemented as part of ControlValueAccessor.\n   * @docs-private\n   */\n  writeValue(value: any): void {\n    if (value != null) {\n      this.value = value;\n    } else {\n      this.value = undefined;\n    }\n  }\n\n  /**\n   * Implemented as part of ControlValueAccessor.\n   * @docs-private\n   */\n  registerOnChange(fn: (value: any) => void): void {\n    this._onChange = fn;\n  }\n\n  /**\n   * Implemented as part of ControlValueAccessor.\n   * @docs-private\n   */\n  registerOnTouched(fn: () => void): void {\n    this._onTouched = fn;\n  }\n\n  /**\n   * Implemented as part of ControlValueAccessor.\n   * @docs-private\n   */\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  /** Selects all chips with value. */\n  _setSelectionByValue(value: any, isUserInput: boolean = true) {\n    this._clearSelection();\n\n    if (Array.isArray(value)) {\n      value.forEach(currentValue => this._selectValue(currentValue, isUserInput));\n    } else {\n      this._selectValue(value, isUserInput);\n    }\n  }\n\n  /** When blurred, marks the field as touched when focus moved outside the chip listbox. */\n  _blur() {\n    if (!this.disabled) {\n      // Wait to see if focus moves to an individual chip.\n      setTimeout(() => {\n        if (!this.focused) {\n          this._markAsTouched();\n        }\n      });\n    }\n  }\n\n  _keydown(event: KeyboardEvent) {\n    if (event.keyCode === TAB) {\n      super._allowFocusEscape();\n    }\n  }\n\n  /** Marks the field as touched */\n  private _markAsTouched() {\n    this._onTouched();\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /** Emits change event to set the model value. */\n  private _propagateChanges(): void {\n    let valueToEmit: any = null;\n\n    if (Array.isArray(this.selected)) {\n      valueToEmit = this.selected.map(chip => chip.value);\n    } else {\n      valueToEmit = this.selected ? this.selected.value : undefined;\n    }\n    this._value = valueToEmit;\n    this.change.emit(new MatChipListboxChange(this, valueToEmit));\n    this._onChange(valueToEmit);\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /**\n   * Deselects every chip in the listbox.\n   * @param skip Chip that should not be deselected.\n   */\n  private _clearSelection(skip?: MatChip): void {\n    this._chips.forEach(chip => {\n      if (chip !== skip) {\n        chip.deselect();\n      }\n    });\n  }\n\n  /**\n   * Finds and selects the chip based on its value.\n   * @returns Chip that has the corresponding value.\n   */\n  private _selectValue(value: any, isUserInput: boolean): MatChip | undefined {\n    const correspondingChip = this._chips.find(chip => {\n      return chip.value != null && this.compareWith(chip.value, value);\n    });\n\n    if (correspondingChip) {\n      isUserInput ? correspondingChip.selectViaInteraction() : correspondingChip.select();\n    }\n\n    return correspondingChip;\n  }\n\n  /** Syncs the chip-listbox selection state with the individual chips. */\n  private _syncListboxProperties() {\n    if (this._chips) {\n      // Defer setting the value in order to avoid the \"Expression\n      // has changed after it was checked\" errors from Angular.\n      Promise.resolve().then(() => {\n        this._chips.forEach(chip => {\n          chip._chipListMultiple = this.multiple;\n          chip.chipListSelectable = this._selectable;\n          chip._chipListHideSingleSelectionIndicator = this.hideSingleSelectionIndicator;\n          chip._changeDetectorRef.markForCheck();\n        });\n      });\n    }\n  }\n\n  /** Returns the first selected chip in this listbox, or undefined if no chips are selected. */\n  private _getFirstSelectedChip(): MatChipOption | undefined {\n    if (Array.isArray(this.selected)) {\n      return this.selected.length ? this.selected[0] : undefined;\n    } else {\n      return this.selected;\n    }\n  }\n\n  /**\n   * Determines if key manager should avoid putting a given chip action in the tab index. Skip\n   * non-interactive actions since the user can't do anything with them.\n   */\n  protected override _skipPredicate(action: MatChipAction): boolean {\n    // Override the skip predicate in the base class to avoid skipping disabled chips. Allow\n    // disabled chip options to receive focus to align with WAI ARIA recommendation. Normally WAI\n    // ARIA's instructions are to exclude disabled items from the tab order, but it makes a few\n    // exceptions for compound widgets.\n    //\n    // From [Developing a Keyboard Interface](\n    // https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/):\n    //   \"For the following composite widget elements, keep them focusable when disabled: Options in a\n    //   Listbox...\"\n    return false;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {_IdGenerator} from '@angular/cdk/a11y';\nimport {DOWN_ARROW, hasModifierKey, TAB, UP_ARROW} from '@angular/cdk/keycodes';\nimport {\n  AfterContentInit,\n  AfterViewInit,\n  booleanAttribute,\n  ChangeDetectionStrategy,\n  Component,\n  ContentChildren,\n  DoCheck,\n  EventEmitter,\n  Input,\n  OnDestroy,\n  Output,\n  QueryList,\n  ViewEncapsulation,\n  inject,\n} from '@angular/core';\nimport {\n  ControlValueAccessor,\n  FormGroupDirective,\n  NgControl,\n  NgForm,\n  Validators,\n} from '@angular/forms';\nimport {_ErrorStateTracker, ErrorStateMatcher} from '../core';\nimport {MatFormFieldControl} from '../form-field';\nimport {merge, Observable, Subject} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\nimport {MatChipEvent} from './chip';\nimport {MatChipRow} from './chip-row';\nimport {MatChipSet} from './chip-set';\nimport {MatChipTextControl} from './chip-text-control';\n\n/** Change event object that is emitted when the chip grid value has changed. */\nexport class MatChipGridChange {\n  constructor(\n    /** Chip grid that emitted the event. */\n    public source: MatChipGrid,\n    /** Value of the chip grid when the event was emitted. */\n    public value: any,\n  ) {}\n}\n\n/**\n * An extension of the MatChipSet component used with MatChipRow chips and\n * the matChipInputFor directive.\n */\n@Component({\n  selector: 'mat-chip-grid',\n  template: `\n    <div class=\"mdc-evolution-chip-set__chips\" role=\"presentation\">\n      <ng-content></ng-content>\n    </div>\n  `,\n  styleUrl: 'chip-set.css',\n  host: {\n    'class': 'mat-mdc-chip-set mat-mdc-chip-grid mdc-evolution-chip-set',\n    '[attr.role]': 'role',\n    '[attr.tabindex]': '(disabled || (_chips && _chips.length === 0)) ? -1 : tabIndex',\n    '[attr.aria-disabled]': 'disabled.toString()',\n    '[attr.aria-invalid]': 'errorState',\n    '[class.mat-mdc-chip-list-disabled]': 'disabled',\n    '[class.mat-mdc-chip-list-invalid]': 'errorState',\n    '[class.mat-mdc-chip-list-required]': 'required',\n    '(focus)': 'focus()',\n    '(blur)': '_blur()',\n  },\n  providers: [{provide: MatFormFieldControl, useExisting: MatChipGrid}],\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatChipGrid\n  extends MatChipSet\n  implements\n    AfterContentInit,\n    AfterViewInit,\n    ControlValueAccessor,\n    DoCheck,\n    MatFormFieldControl<any>,\n    OnDestroy\n{\n  ngControl = inject(NgControl, {optional: true, self: true})!;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  readonly controlType: string = 'mat-chip-grid';\n\n  /** The chip input to add more chips */\n  protected _chipInput?: MatChipTextControl;\n\n  protected override _defaultRole = 'grid';\n  private _errorStateTracker: _ErrorStateTracker;\n  private _uid = inject(_IdGenerator).getId('mat-chip-grid-');\n\n  /**\n   * List of element ids to propagate to the chipInput's aria-describedby attribute.\n   */\n  private _ariaDescribedbyIds: string[] = [];\n\n  /**\n   * Function when touched. Set as part of ControlValueAccessor implementation.\n   * @docs-private\n   */\n  _onTouched = () => {};\n\n  /**\n   * Function when changed. Set as part of ControlValueAccessor implementation.\n   * @docs-private\n   */\n  _onChange: (value: any) => void = () => {};\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input({transform: booleanAttribute})\n  override get disabled(): boolean {\n    return this.ngControl ? !!this.ngControl.disabled : this._disabled;\n  }\n  override set disabled(value: boolean) {\n    this._disabled = value;\n    this._syncChipsState();\n    this.stateChanges.next();\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get id(): string {\n    return this._chipInput ? this._chipInput.id : this._uid;\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  override get empty(): boolean {\n    return (\n      (!this._chipInput || this._chipInput.empty) && (!this._chips || this._chips.length === 0)\n    );\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get placeholder(): string {\n    return this._chipInput ? this._chipInput.placeholder : this._placeholder;\n  }\n  set placeholder(value: string) {\n    this._placeholder = value;\n    this.stateChanges.next();\n  }\n  protected _placeholder: string;\n\n  /** Whether any chips or the matChipInput inside of this chip-grid has focus. */\n  override get focused(): boolean {\n    return this._chipInput?.focused || this._hasFocusedChip();\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input({transform: booleanAttribute})\n  get required(): boolean {\n    return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;\n  }\n  set required(value: boolean) {\n    this._required = value;\n    this.stateChanges.next();\n  }\n  protected _required: boolean | undefined;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get shouldLabelFloat(): boolean {\n    return !this.empty || this.focused;\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(value: any) {\n    this._value = value;\n  }\n  protected _value: any[] = [];\n\n  /** An object used to control when error messages are shown. */\n  @Input()\n  get errorStateMatcher() {\n    return this._errorStateTracker.matcher;\n  }\n  set errorStateMatcher(value: ErrorStateMatcher) {\n    this._errorStateTracker.matcher = value;\n  }\n\n  /** Combined stream of all of the child chips' blur events. */\n  get chipBlurChanges(): Observable<MatChipEvent> {\n    return this._getChipStream(chip => chip._onBlur);\n  }\n\n  /** Emits when the chip grid value has been changed by the user. */\n  @Output() readonly change: EventEmitter<MatChipGridChange> =\n    new EventEmitter<MatChipGridChange>();\n\n  /**\n   * Emits whenever the raw value of the chip-grid changes. This is here primarily\n   * to facilitate the two-way binding for the `value` input.\n   * @docs-private\n   */\n  @Output() readonly valueChange: EventEmitter<any> = new EventEmitter<any>();\n\n  @ContentChildren(MatChipRow, {\n    // We need to use `descendants: true`, because Ivy will no longer match\n    // indirect descendants if it's left as false.\n    descendants: true,\n  })\n  // We need an initializer here to avoid a TS error. The value will be set in `ngAfterViewInit`.\n  override _chips: QueryList<MatChipRow> = undefined!;\n\n  /**\n   * Emits whenever the component state changes and should cause the parent\n   * form-field to update. Implemented as part of `MatFormFieldControl`.\n   * @docs-private\n   */\n  readonly stateChanges = new Subject<void>();\n\n  /** Whether the chip grid is in an error state. */\n  get errorState() {\n    return this._errorStateTracker.errorState;\n  }\n  set errorState(value: boolean) {\n    this._errorStateTracker.errorState = value;\n  }\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    super();\n\n    const parentForm = inject(NgForm, {optional: true});\n    const parentFormGroup = inject(FormGroupDirective, {optional: true});\n    const defaultErrorStateMatcher = inject(ErrorStateMatcher);\n\n    if (this.ngControl) {\n      this.ngControl.valueAccessor = this;\n    }\n\n    this._errorStateTracker = new _ErrorStateTracker(\n      defaultErrorStateMatcher,\n      this.ngControl,\n      parentFormGroup,\n      parentForm,\n      this.stateChanges,\n    );\n  }\n\n  ngAfterContentInit() {\n    this.chipBlurChanges.pipe(takeUntil(this._destroyed)).subscribe(() => {\n      this._blur();\n      this.stateChanges.next();\n    });\n\n    merge(this.chipFocusChanges, this._chips.changes)\n      .pipe(takeUntil(this._destroyed))\n      .subscribe(() => this.stateChanges.next());\n  }\n\n  ngDoCheck() {\n    if (this.ngControl) {\n      // We need to re-evaluate this on every change detection cycle, because there are some\n      // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n      // that whatever logic is in here has to be super lean or we risk destroying the performance.\n      this.updateErrorState();\n    }\n  }\n\n  override ngOnDestroy() {\n    super.ngOnDestroy();\n    this.stateChanges.complete();\n  }\n\n  /** Associates an HTML input element with this chip grid. */\n  registerInput(inputElement: MatChipTextControl): void {\n    this._chipInput = inputElement;\n    this._chipInput.setDescribedByIds(this._ariaDescribedbyIds);\n\n    // If ids were already attached to host element, can now remove in favor of chipInput\n    this._elementRef.nativeElement.removeAttribute('aria-describedby');\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  onContainerClick(event: MouseEvent) {\n    if (!this.disabled && !this._originatesFromChip(event)) {\n      this.focus();\n    }\n  }\n\n  /**\n   * Focuses the first chip in this chip grid, or the associated input when there\n   * are no eligible chips.\n   */\n  override focus(): void {\n    if (this.disabled || this._chipInput?.focused) {\n      return;\n    }\n\n    if (!this._chips.length || this._chips.first.disabled) {\n      if (!this._chipInput) {\n        return;\n      }\n\n      // Delay until the next tick, because this can cause a \"changed after checked\"\n      // error if the input does something on focus (e.g. opens an autocomplete).\n      Promise.resolve().then(() => this._chipInput!.focus());\n    } else {\n      const activeItem = this._keyManager.activeItem;\n\n      if (activeItem) {\n        activeItem.focus();\n      } else {\n        this._keyManager.setFirstItemActive();\n      }\n    }\n\n    this.stateChanges.next();\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get describedByIds(): string[] {\n    if (this._chipInput) {\n      return this._chipInput.describedByIds || [];\n    }\n    const existing = this._elementRef.nativeElement.getAttribute('aria-describedby');\n    return existing ? existing.split(' ') : [];\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  setDescribedByIds(ids: string[]) {\n    // We must keep this up to date to handle the case where ids are set\n    // before the chip input is registered.\n    this._ariaDescribedbyIds = ids;\n\n    if (this._chipInput) {\n      this._chipInput.setDescribedByIds(ids);\n    } else if (ids.length) {\n      this._elementRef.nativeElement.setAttribute('aria-describedby', ids.join(' '));\n    } else {\n      this._elementRef.nativeElement.removeAttribute('aria-describedby');\n    }\n  }\n\n  /**\n   * Implemented as part of ControlValueAccessor.\n   * @docs-private\n   */\n  writeValue(value: any): void {\n    // The user is responsible for creating the child chips, so we just store the value.\n    this._value = value;\n  }\n\n  /**\n   * Implemented as part of ControlValueAccessor.\n   * @docs-private\n   */\n  registerOnChange(fn: (value: any) => void): void {\n    this._onChange = fn;\n  }\n\n  /**\n   * Implemented as part of ControlValueAccessor.\n   * @docs-private\n   */\n  registerOnTouched(fn: () => void): void {\n    this._onTouched = fn;\n  }\n\n  /**\n   * Implemented as part of ControlValueAccessor.\n   * @docs-private\n   */\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n    this.stateChanges.next();\n  }\n\n  /** Refreshes the error state of the chip grid. */\n  updateErrorState() {\n    this._errorStateTracker.updateErrorState();\n  }\n\n  /** When blurred, mark the field as touched when focus moved outside the chip grid. */\n  _blur() {\n    if (!this.disabled) {\n      // Check whether the focus moved to chip input.\n      // If the focus is not moved to chip input, mark the field as touched. If the focus moved\n      // to chip input, do nothing.\n      // Timeout is needed to wait for the focus() event trigger on chip input.\n      setTimeout(() => {\n        if (!this.focused) {\n          this._propagateChanges();\n          this._markAsTouched();\n        }\n      });\n    }\n  }\n\n  /**\n   * Removes the `tabindex` from the chip grid and resets it back afterwards, allowing the\n   * user to tab out of it. This prevents the grid from capturing focus and redirecting\n   * it back to the first chip, creating a focus trap, if it user tries to tab away.\n   */\n  protected override _allowFocusEscape() {\n    if (!this._chipInput?.focused) {\n      super._allowFocusEscape();\n    }\n  }\n\n  /** Handles custom keyboard events. */\n  override _handleKeydown(event: KeyboardEvent) {\n    const keyCode = event.keyCode;\n    const activeItem = this._keyManager.activeItem;\n\n    if (keyCode === TAB) {\n      if (\n        this._chipInput?.focused &&\n        hasModifierKey(event, 'shiftKey') &&\n        this._chips.length &&\n        !this._chips.last.disabled\n      ) {\n        event.preventDefault();\n\n        if (activeItem) {\n          this._keyManager.setActiveItem(activeItem);\n        } else {\n          this._focusLastChip();\n        }\n      } else {\n        // Use the super method here since it doesn't check for the input\n        // focused state. This allows focus to escape if there's only one\n        // disabled chip left in the list.\n        super._allowFocusEscape();\n      }\n    } else if (!this._chipInput?.focused) {\n      // The up and down arrows are supposed to navigate between the individual rows in the grid.\n      // We do this by filtering the actions down to the ones that have the same `_isPrimary`\n      // flag as the active action and moving focus between them ourseles instead of delegating\n      // to the key manager. For more information, see #29359 and:\n      // https://www.w3.org/WAI/ARIA/apg/patterns/grid/examples/layout-grids/#ex2_label\n      if ((keyCode === UP_ARROW || keyCode === DOWN_ARROW) && activeItem) {\n        const eligibleActions = this._chipActions.filter(\n          action => action._isPrimary === activeItem._isPrimary && !this._skipPredicate(action),\n        );\n        const currentIndex = eligibleActions.indexOf(activeItem);\n        const delta = event.keyCode === UP_ARROW ? -1 : 1;\n\n        event.preventDefault();\n        if (currentIndex > -1 && this._isValidIndex(currentIndex + delta)) {\n          this._keyManager.setActiveItem(eligibleActions[currentIndex + delta]);\n        }\n      } else {\n        super._handleKeydown(event);\n      }\n    }\n\n    this.stateChanges.next();\n  }\n\n  _focusLastChip() {\n    if (this._chips.length) {\n      this._chips.last.focus();\n    }\n  }\n\n  /** Emits change event to set the model value. */\n  private _propagateChanges(): void {\n    const valueToEmit = this._chips.length ? this._chips.toArray().map(chip => chip.value) : [];\n    this._value = valueToEmit;\n    this.change.emit(new MatChipGridChange(this, valueToEmit));\n    this.valueChange.emit(valueToEmit);\n    this._onChange(valueToEmit);\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /** Mark the field as touched */\n  private _markAsTouched() {\n    this._onTouched();\n    this._changeDetectorRef.markForCheck();\n    this.stateChanges.next();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {BACKSPACE, hasModifierKey, ModifierKey} from '@angular/cdk/keycodes';\nimport {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Input,\n  OnChanges,\n  OnDestroy,\n  Output,\n  booleanAttribute,\n  inject,\n} from '@angular/core';\nimport {_IdGenerator} from '@angular/cdk/a11y';\nimport {MatFormField, MAT_FORM_FIELD} from '../form-field';\nimport {MatChipsDefaultOptions, MAT_CHIPS_DEFAULT_OPTIONS, SeparatorKey} from './tokens';\nimport {MatChipGrid} from './chip-grid';\nimport {MatChipTextControl} from './chip-text-control';\n\n/** Represents an input event on a `matChipInput`. */\nexport interface MatChipInputEvent {\n  /**\n   * The native `<input>` element that the event is being fired for.\n   * @deprecated Use `MatChipInputEvent#chipInput.inputElement` instead.\n   * @breaking-change 13.0.0 This property will be removed.\n   */\n  input: HTMLInputElement;\n\n  /** The value of the input. */\n  value: string;\n\n  /** Reference to the chip input that emitted the event. */\n  chipInput: MatChipInput;\n}\n\n/**\n * Directive that adds chip-specific behaviors to an input element inside `<mat-form-field>`.\n * May be placed inside or outside of a `<mat-chip-grid>`.\n */\n@Directive({\n  selector: 'input[matChipInputFor]',\n  exportAs: 'matChipInput, matChipInputFor',\n  host: {\n    // TODO: eventually we should remove `mat-input-element` from here since it comes from the\n    // non-MDC version of the input. It's currently being kept for backwards compatibility, because\n    // the MDC chips were landed initially with it.\n    'class': 'mat-mdc-chip-input mat-mdc-input-element mdc-text-field__input mat-input-element',\n    '(keydown)': '_keydown($event)',\n    '(blur)': '_blur()',\n    '(focus)': '_focus()',\n    '(input)': '_onInput()',\n    '[id]': 'id',\n    '[attr.disabled]': 'disabled && !disabledInteractive ? \"\" : null',\n    '[attr.placeholder]': 'placeholder || null',\n    '[attr.aria-invalid]': '_chipGrid && _chipGrid.ngControl ? _chipGrid.ngControl.invalid : null',\n    '[attr.aria-required]': '_chipGrid && _chipGrid.required || null',\n    '[attr.aria-disabled]': 'disabled && disabledInteractive ? \"true\" : null',\n    '[attr.readonly]': '_getReadonlyAttribute()',\n    '[attr.required]': '_chipGrid && _chipGrid.required || null',\n  },\n})\nexport class MatChipInput implements MatChipTextControl, OnChanges, OnDestroy {\n  protected _elementRef = inject<ElementRef<HTMLInputElement>>(ElementRef);\n\n  /** Whether the control is focused. */\n  focused: boolean = false;\n\n  /** Register input for chip list */\n  @Input('matChipInputFor')\n  get chipGrid(): MatChipGrid {\n    return this._chipGrid;\n  }\n  set chipGrid(value: MatChipGrid) {\n    if (value) {\n      this._chipGrid = value;\n      this._chipGrid.registerInput(this);\n    }\n  }\n  protected _chipGrid: MatChipGrid;\n\n  /**\n   * Whether or not the chipEnd event will be emitted when the input is blurred.\n   */\n  @Input({alias: 'matChipInputAddOnBlur', transform: booleanAttribute})\n  addOnBlur: boolean = false;\n\n  /**\n   * The list of key codes that will trigger a chipEnd event.\n   *\n   * Defaults to `[ENTER]`.\n   */\n  @Input('matChipInputSeparatorKeyCodes')\n  separatorKeyCodes: readonly (number | SeparatorKey)[] | ReadonlySet<number | SeparatorKey>;\n\n  /** Emitted when a chip is to be added. */\n  @Output('matChipInputTokenEnd')\n  readonly chipEnd: EventEmitter<MatChipInputEvent> = new EventEmitter<MatChipInputEvent>();\n\n  /** The input's placeholder text. */\n  @Input() placeholder: string = '';\n\n  /** Unique id for the input. */\n  @Input() id: string = inject(_IdGenerator).getId('mat-mdc-chip-list-input-');\n\n  /** Whether the input is disabled. */\n  @Input({transform: booleanAttribute})\n  get disabled(): boolean {\n    return this._disabled || (this._chipGrid && this._chipGrid.disabled);\n  }\n  set disabled(value: boolean) {\n    this._disabled = value;\n  }\n  private _disabled: boolean = false;\n\n  /** Whether the input is readonly. */\n  @Input({transform: booleanAttribute})\n  readonly: boolean = false;\n\n  /** Whether the input should remain interactive when it is disabled. */\n  @Input({alias: 'matChipInputDisabledInteractive', transform: booleanAttribute})\n  disabledInteractive: boolean;\n\n  /** Whether the input is empty. */\n  get empty(): boolean {\n    return !this.inputElement.value;\n  }\n\n  /** The native input element to which this directive is attached. */\n  readonly inputElement!: HTMLInputElement;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const defaultOptions = inject<MatChipsDefaultOptions>(MAT_CHIPS_DEFAULT_OPTIONS);\n    const formField = inject<MatFormField>(MAT_FORM_FIELD, {optional: true});\n\n    this.inputElement = this._elementRef.nativeElement as HTMLInputElement;\n    this.separatorKeyCodes = defaultOptions.separatorKeyCodes;\n    this.disabledInteractive = defaultOptions.inputDisabledInteractive ?? false;\n\n    if (formField) {\n      this.inputElement.classList.add('mat-mdc-form-field-input-control');\n    }\n  }\n\n  ngOnChanges() {\n    this._chipGrid.stateChanges.next();\n  }\n\n  ngOnDestroy(): void {\n    this.chipEnd.complete();\n  }\n\n  /** Utility method to make host definition/tests more clear. */\n  _keydown(event: KeyboardEvent) {\n    if (this.empty && event.keyCode === BACKSPACE) {\n      // Ignore events where the user is holding down backspace\n      // so that we don't accidentally remove too many chips.\n      if (!event.repeat) {\n        this._chipGrid._focusLastChip();\n      }\n      event.preventDefault();\n    } else {\n      this._emitChipEnd(event);\n    }\n  }\n\n  /** Checks to see if the blur should emit the (chipEnd) event. */\n  _blur() {\n    if (this.addOnBlur) {\n      this._emitChipEnd();\n    }\n    this.focused = false;\n    // Blur the chip list if it is not focused\n    if (!this._chipGrid.focused) {\n      this._chipGrid._blur();\n    }\n    this._chipGrid.stateChanges.next();\n  }\n\n  _focus() {\n    this.focused = true;\n    this._chipGrid.stateChanges.next();\n  }\n\n  /** Checks to see if the (chipEnd) event needs to be emitted. */\n  _emitChipEnd(event?: KeyboardEvent) {\n    if (!event || (this._isSeparatorKey(event) && !event.repeat)) {\n      this.chipEnd.emit({\n        input: this.inputElement,\n        value: this.inputElement.value,\n        chipInput: this,\n      });\n\n      event?.preventDefault();\n    }\n  }\n\n  _onInput() {\n    // Let chip list know whenever the value changes.\n    this._chipGrid.stateChanges.next();\n  }\n\n  /** Focuses the input. */\n  focus(): void {\n    this.inputElement.focus();\n  }\n\n  /** Clears the input */\n  clear(): void {\n    this.inputElement.value = '';\n  }\n\n  /**\n   * Implemented as part of MatChipTextControl.\n   * @docs-private\n   */\n  get describedByIds(): string[] {\n    const element = this._elementRef.nativeElement;\n    const existingDescribedBy = element.getAttribute('aria-describedby');\n\n    return existingDescribedBy?.split(' ') || [];\n  }\n\n  setDescribedByIds(ids: string[]): void {\n    const element = this._elementRef.nativeElement;\n\n    // Set the value directly in the DOM since this binding\n    // is prone to \"changed after checked\" errors.\n    if (ids.length) {\n      element.setAttribute('aria-describedby', ids.join(' '));\n    } else {\n      element.removeAttribute('aria-describedby');\n    }\n  }\n\n  /** Checks whether a keycode is one of the configured separators. */\n  private _isSeparatorKey(event: KeyboardEvent): boolean {\n    if (!this.separatorKeyCodes) {\n      return false;\n    }\n\n    for (const key of this.separatorKeyCodes) {\n      let keyCode: number;\n      let modifiers: readonly ModifierKey[] | null;\n\n      if (typeof key === 'number') {\n        keyCode = key;\n        modifiers = null;\n      } else {\n        keyCode = key.keyCode;\n        modifiers = key.modifiers;\n      }\n\n      const modifiersMatch = !modifiers?.length\n        ? !hasModifierKey(event)\n        : hasModifierKey(event, ...modifiers);\n\n      if (keyCode === event.keyCode && modifiersMatch) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /** Gets the value to set on the `readonly` attribute. */\n  protected _getReadonlyAttribute(): string | null {\n    return this.readonly || (this.disabled && this.disabledInteractive) ? 'true' : null;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ENTER} from '@angular/cdk/keycodes';\nimport {NgModule} from '@angular/core';\nimport {ErrorStateMatcher, MatRippleModule} from '../core';\nimport {MatChip} from './chip';\nimport {MAT_CHIPS_DEFAULT_OPTIONS, MatChipsDefaultOptions} from './tokens';\nimport {MatChipEditInput} from './chip-edit-input';\nimport {MatChipGrid} from './chip-grid';\nimport {MatChipAvatar, MatChipEdit, MatChipRemove, MatChipTrailingIcon} from './chip-icons';\nimport {MatChipInput} from './chip-input';\nimport {MatChipListbox} from './chip-listbox';\nimport {MatChipRow} from './chip-row';\nimport {MatChipOption} from './chip-option';\nimport {MatChipSet} from './chip-set';\nimport {MatChipAction} from './chip-action';\nimport {BidiModule} from '@angular/cdk/bidi';\n\nconst CHIP_DECLARATIONS = [\n  MatChip,\n  MatChipAvatar,\n  MatChipEdit,\n  MatChipEditInput,\n  MatChipGrid,\n  MatChipInput,\n  MatChipListbox,\n  MatChipOption,\n  MatChipRemove,\n  MatChipRow,\n  MatChipSet,\n  MatChipTrailingIcon,\n];\n\n@NgModule({\n  imports: [MatRippleModule, MatChipAction, CHIP_DECLARATIONS],\n  exports: [BidiModule, CHIP_DECLARATIONS],\n  providers: [\n    ErrorStateMatcher,\n    {\n      provide: MAT_CHIPS_DEFAULT_OPTIONS,\n      useValue: {\n        separatorKeyCodes: [ENTER],\n      } as MatChipsDefaultOptions,\n    },\n  ],\n})\nexport class MatChipsModule {}\n"],"names":["MAT_CHIP_AVATAR","InjectionToken","MatChipContent","inject","ElementRef","disabled","_disabled","_parentChip","_allowFocusWhenDisabled","_getDisabledAttribute","_elementRef","nativeElement","nodeName","setAttribute","focus","i0","ngDeclareFactory","minVersion","version","ngImport","type","deps","target","FactoryTarget","Directive","ngDeclareDirective","isStandalone","selector","inputs","booleanAttribute","tabIndex","value","numberAttribute","host","properties","classAttribute","ctorParameters","propDecorators","_handleClick","event","_isPrimary","_handlePrimaryActionInteraction","MatChipAvatar","decorators","args","providers","provide","useExisting","MatChipTrailingIcon","preventDefault","_edit","_handleKeydown","fac","MatChipEdit","dir","attributes","MAT_CHIP_EDIT","usesInheritance","remove","MatChipRemove","MAT_CHIP_REMOVE","MatChip","optional","DOCUMENT","_onFocus","Subject","_onBlur","_actionChanges","_allTrailingIcons","_allEditIcons","_hasFocus","_hasFocusInternal","id","_IdGenerator","_chipListDisabled","_textElement","_value","undefined","textContent","trim","EventEmitter","destroyed","leadingIcon","editIcon","trailingIcon","removeIcon","_rippleLoader","MatRippleLoader","constructor","_monitorFocus","configureRipple","ngOnInit","_isBasicChip","hasAttribute","basicChipAttrName","_pendingFocus","ngAfterContentInit","merge","_allLeadingIcons","changes","_allRemoveIcons","subscribe","_changeDetectorRef","markForCheck","ngDoCheck","setDisabled","_isRippleDisabled","ngOnDestroy","_focusMonitor","stopMonitoring","destroyRipple","BACKSPACE","repeat","keyCode","DELETE","descendants","ContentChildren","Input","removable","transform","ContentChild","ViewChild","MatChipSelectionChange","source","selected","isUserInput","_chipListHideSingleSelectionIndicator","_defaultOptions","hideSingleSelectionIndicator","_selectable","_selected","role","select","_setSelectedState","deselect","toggleSelected","selectable","MatChipEditInput","getNativeElement","setValue","_moveCursorToEndOfInput","range","_document","createRange","selectNodeContents","collapse","sel","window","getSelection","removeAllRanges","MatChipRow","_editStartPending","editable","contentEditInput","_alreadyFocused","_onEditFinish","ngAfterViewInit","addEventListener","_hasLeadingActionIcon","_hasTrailingIcon","ENTER","_isEditing","_startEditing","stopPropagation","_handleDoubleclick","MAT_CHIP","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","imports","MatChipAction","template","styles","MatChipSet","ChangeDetectorRef","_keyManager","_destroyed","chipFocusChanges","_getChipStream","chip","chipRemovedChanges","_chips","length","_explicitRole","empty","_defaultRole","_trackDestroyedFocusedChip","destroy","_chipActions","complete","_hasFocusedChip","some","_syncChipsState","_originatesFromChip","_isValidIndex","index","_allowFocusEscape","setTimeout","previous","pipe","startWith","switchMap","map","mappingFunction","currentElement","contains","parentElement","_setUpFocusManagement","chips","action","actions","push","reset","_dir","_skipPredicate","takeUntil","withHorizontalOrientation","direction","Promise","resolve","then","_redirectDestroyedChipFocus","MatChipListboxChange","MAT_CHIP_LISTBOX_CONTROL_VALUE_ACCESSOR","NG_VALUE_ACCESSOR","multiple","_multiple","_syncListboxProperties","selectedChips","toArray","filter","ariaOrientation","selectionChange","_setSelectionByValue","_blur","forEach","_propagateChanges","firstSelectedChip","setFirstItemActive","writeValue","registerOnChange","fn","registerOnTouched","_onTouched","setDisabledState","isDisabled","Array","isArray","currentValue","_selectValue","focused","_markAsTouched","TAB","valueToEmit","change","emit","_onChange","_clearSelection","skip","encapsulation","MatChipOption","MatChipGridChange","MatChipGrid","ngControl","NgControl","self","_ariaDescribedbyIds","stateChanges","next","_chipInput","_uid","placeholder","_placeholder","required","_required","control","hasValidator","Validators","errorStateMatcher","_errorStateTracker","matcher","chipBlurChanges","errorState","NgForm","parentFormGroup","FormGroupDirective","defaultErrorStateMatcher","ErrorStateMatcher","_ErrorStateTracker","parentForm","registerInput","inputElement","setDescribedByIds","removeAttribute","onContainerClick","ids","join","updateErrorState","Output","chipGrid","_chipGrid","getId","defaultOptions","MAT_CHIPS_DEFAULT_OPTIONS","separatorKeyCodes","disabledInteractive","inputDisabledInteractive","formField","classList","add","ngOnChanges","chipEnd","_keydown","addOnBlur","_emitChipEnd","_focus","_isSeparatorKey","chipInput","readonly","alias","MatChipsModule","NgModule","ngDeclareNgModule","MatRippleModule","exports","BidiModule","ngDeclareInjector","CHIP_DECLARATIONS"],"mappings":"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"}