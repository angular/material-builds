{"version":3,"file":"slider.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/slider/slider-interface.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/slider/slider-thumb.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/slider/slider.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/slider/slider-input.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/slider/slider-module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken, ChangeDetectorRef, WritableSignal} from '@angular/core';\nimport {MatRipple, RippleGlobalOptions} from '../core';\n\n/**\n * Thumb types: range slider has two thumbs (START, END) whereas single point\n * slider only has one thumb (END).\n */\nexport enum _MatThumb {\n  START = 1,\n  END = 2,\n}\n\n/** Tick mark enum, for discrete sliders. */\nexport enum _MatTickMark {\n  ACTIVE = 0,\n  INACTIVE = 1,\n}\n\n/**\n * Injection token that can be used for a `MatSlider` to provide itself as a\n * parent to the `MatSliderThumb` and `MatSliderRangeThumb`.\n * Used primarily to avoid circular imports.\n * @docs-private\n */\nexport const MAT_SLIDER = new InjectionToken<{}>('_MatSlider');\n\n/**\n * Injection token that can be used to query for a `MatSliderThumb`.\n * Used primarily to avoid circular imports.\n * @docs-private\n */\nexport const MAT_SLIDER_THUMB = new InjectionToken<{}>('_MatSliderThumb');\n\n/**\n * Injection token that can be used to query for a `MatSliderRangeThumb`.\n * Used primarily to avoid circular imports.\n * @docs-private\n */\nexport const MAT_SLIDER_RANGE_THUMB = new InjectionToken<{}>('_MatSliderRangeThumb');\n\n/**\n * Injection token that can be used to query for a `MatSliderVisualThumb`.\n * Used primarily to avoid circular imports.\n * @docs-private\n */\nexport const MAT_SLIDER_VISUAL_THUMB = new InjectionToken<{}>('_MatSliderVisualThumb');\n\n/** Represents a drag event emitted by the MatSlider component. */\nexport interface MatSliderDragEvent {\n  /** The MatSliderThumb that was interacted with. */\n  source: _MatSliderThumb;\n\n  /** The MatSlider that was interacted with. */\n  parent: _MatSlider;\n\n  /** The current value of the slider. */\n  value: number;\n}\n\n/**\n * A simple change event emitted by the MatSlider component.\n * @deprecated Use event bindings directly on the MatSliderThumbs for `change` and `input` events. See https://v17.material.angular.dev/guide/mdc-migration for information about migrating.\n * @breaking-change 17.0.0\n */\nexport class MatSliderChange {\n  /** The MatSliderThumb that was interacted with. */\n  source: _MatSliderThumb;\n\n  /** The MatSlider that was interacted with. */\n  parent: _MatSlider;\n\n  /** The new value of the source slider. */\n  value: number;\n}\n\nexport interface _MatSlider {\n  /** Whether the given pointer event occurred within the bounds of the slider pointer's DOM Rect. */\n  _isCursorOnSliderThumb(event: PointerEvent, rect: DOMRect): boolean;\n\n  /** Gets the slider thumb input of the given thumb position. */\n  _getInput(thumbPosition: _MatThumb): _MatSliderThumb | _MatSliderRangeThumb | undefined;\n\n  /** Gets the slider thumb HTML input element of the given thumb position. */\n  _getThumb(thumbPosition: _MatThumb): _MatSliderVisualThumb;\n\n  /** The minimum value that the slider can have. */\n  min: number;\n\n  /** The maximum value that the slider can have. */\n  max: number;\n\n  /** The amount that slider values can increment or decrement by. */\n  step: number;\n\n  /** Whether the slider is disabled. */\n  disabled: boolean;\n\n  /** Whether the slider is a range slider. */\n  _isRange: boolean;\n\n  /** Whether the slider is rtl. */\n  _isRtl: boolean;\n\n  /** The stored width of the host element's bounding client rect. */\n  _cachedWidth: number;\n\n  /** The stored width of the host element's bounding client rect. */\n  _cachedLeft: number;\n\n  /**\n   * The padding of the native slider input. This is added in order to make the region where the\n   * thumb ripple extends past the end of the slider track clickable.\n   */\n  _inputPadding: number;\n\n  /** The radius of the visual slider's ripple. */\n  _rippleRadius: number;\n\n  /** The global configuration for `matRipple` instances. */\n  readonly _globalRippleOptions: RippleGlobalOptions | null;\n\n  /** Whether animations have been disabled. */\n  _noopAnimations: boolean;\n\n  /** Whether or not the slider should use animations. */\n  _hasAnimation: boolean;\n\n  /** Triggers UI updates that are needed after a slider input value has changed. */\n  _onValueChange: (source: _MatSliderThumb) => void;\n\n  /** Triggers UI updates that are needed after the slider thumb position has changed. */\n  _onTranslateXChange: (source: _MatSliderThumb) => void;\n\n  /** Updates the stored slider dimensions using the current bounding client rect. */\n  _updateDimensions: () => void;\n\n  /** Updates the scale on the active portion of the track. */\n  _updateTrackUI: (source: _MatSliderThumb) => void;\n\n  /** Used to set the transition duration for thumb and track animations. */\n  _setTransition: (withAnimation: boolean) => void;\n\n  _cdr: ChangeDetectorRef;\n}\n\nexport interface _MatSliderThumb {\n  /** The minimum value that the slider can have. */\n  min: number;\n\n  /** The maximum value that the slider can have. */\n  max: number;\n\n  /** The amount that slider values can increment or decrement by. */\n  step: number;\n\n  /** The current value of this slider input. */\n  value: number;\n\n  /** The current translateX in px of the slider visual thumb. */\n  translateX: number;\n\n  /** Indicates whether this thumb is the start or end thumb. */\n  thumbPosition: _MatThumb;\n\n  /** Similar to percentage but calcualted using translateX relative to the total track width. */\n  fillPercentage: number;\n\n  /** Whether the slider is disabled. */\n  disabled: boolean;\n\n  /** The host native HTML input element. */\n  _hostElement: HTMLInputElement;\n\n  /** Whether the input is currently focused (either by tab or after clicking). */\n  _isFocused: boolean;\n\n  /** The aria-valuetext string representation of the input's value. */\n  _valuetext: WritableSignal<string>;\n\n  /**\n   * Indicates whether UI updates should be skipped.\n   *\n   * This flag is used to avoid flickering\n   * when correcting values on pointer up/down.\n   */\n  _skipUIUpdate: boolean;\n\n  /** Handles the initialization of properties for the slider input. */\n  initProps: () => void;\n\n  /** Handles UI initialization controlled by this slider input. */\n  initUI: () => void;\n\n  /** Calculates the visual thumb's translateX based on the slider input's current value. */\n  _calcTranslateXByValue: () => number;\n\n  /** Updates the visual thumb based on the slider input's current value. */\n  _updateThumbUIByValue: () => void;\n\n  /**\n   * Sets the slider input to disproportionate dimensions to allow for touch\n   * events to be captured on touch devices.\n   */\n  _updateWidthInactive: () => void;\n\n  /**\n   * Used to set the slider width to the correct\n   * dimensions while the user is dragging.\n   */\n  _updateWidthActive: () => void;\n}\n\nexport interface _MatSliderRangeThumb extends _MatSliderThumb {\n  /** Whether this slider corresponds to the input on the left hand side. */\n  _isLeftThumb: boolean;\n\n  /**\n   * Gets the sibling MatSliderRangeThumb.\n   * Returns undefined if it is too early in Angular's life cycle.\n   */\n  getSibling: () => _MatSliderRangeThumb | undefined;\n\n  /** Used to cache whether this slider input corresponds to the visual left thumb. */\n  _setIsLeftThumb: () => void;\n\n  /** Updates the input styles to control whether it is pinned to the start or end of the mat-slider. */\n  _updateStaticStyles: () => void;\n\n  /** Updates the min and max properties of this slider input according to it's sibling. */\n  _updateMinMax: () => void;\n}\n\nexport interface _MatSliderVisualThumb {\n  /** The MatRipple for this slider thumb. */\n  _ripple: MatRipple;\n\n  /** Whether the slider thumb is currently being pressed. */\n  _isActive: boolean;\n\n  /** The host native HTML input element. */\n  _hostElement: HTMLElement;\n\n  /** Shows the value indicator ui. */\n  _showValueIndicator: () => void;\n\n  /** Hides the value indicator ui. */\n  _hideValueIndicator: () => void;\n\n  /** Whether the slider visual thumb is currently showing any ripple. */\n  _isShowingAnyRipple: () => boolean;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ElementRef,\n  Input,\n  NgZone,\n  OnDestroy,\n  Renderer2,\n  ViewChild,\n  ViewEncapsulation,\n  inject,\n} from '@angular/core';\nimport {MatRipple, RippleAnimationConfig, RippleRef, RippleState} from '../core';\nimport {\n  _MatThumb,\n  _MatSlider,\n  _MatSliderThumb,\n  _MatSliderVisualThumb,\n  MAT_SLIDER,\n  MAT_SLIDER_VISUAL_THUMB,\n} from './slider-interface';\nimport {Platform} from '@angular/cdk/platform';\n\n/**\n * The visual slider thumb.\n *\n * Handles the slider thumb ripple states (hover, focus, and active),\n * and displaying the value tooltip on discrete sliders.\n * @docs-private\n */\n@Component({\n  selector: 'mat-slider-visual-thumb',\n  templateUrl: './slider-thumb.html',\n  styleUrl: 'slider-thumb.css',\n  host: {\n    'class': 'mdc-slider__thumb mat-mdc-slider-visual-thumb',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  providers: [{provide: MAT_SLIDER_VISUAL_THUMB, useExisting: MatSliderVisualThumb}],\n  imports: [MatRipple],\n})\nexport class MatSliderVisualThumb implements _MatSliderVisualThumb, AfterViewInit, OnDestroy {\n  readonly _cdr = inject(ChangeDetectorRef);\n  private readonly _ngZone = inject(NgZone);\n  private _slider = inject<_MatSlider>(MAT_SLIDER);\n  private _renderer = inject(Renderer2);\n  private _listenerCleanups: (() => void)[] | undefined;\n\n  /** Whether the slider displays a numeric value label upon pressing the thumb. */\n  @Input() discrete: boolean;\n\n  /** Indicates which slider thumb this input corresponds to. */\n  @Input() thumbPosition: _MatThumb;\n\n  /** The display value of the slider thumb. */\n  @Input() valueIndicatorText: string;\n\n  /** The MatRipple for this slider thumb. */\n  @ViewChild(MatRipple) readonly _ripple: MatRipple;\n\n  /** The slider thumb knob. */\n  @ViewChild('knob') _knob: ElementRef<HTMLElement>;\n\n  /** The slider thumb value indicator container. */\n  @ViewChild('valueIndicatorContainer')\n  _valueIndicatorContainer: ElementRef<HTMLElement>;\n\n  /** The slider input corresponding to this slider thumb. */\n  private _sliderInput: _MatSliderThumb;\n\n  /** The native html element of the slider input corresponding to this thumb. */\n  private _sliderInputEl: HTMLInputElement | undefined;\n\n  /** The RippleRef for the slider thumbs hover state. */\n  private _hoverRippleRef: RippleRef | undefined;\n\n  /** The RippleRef for the slider thumbs focus state. */\n  private _focusRippleRef: RippleRef | undefined;\n\n  /** The RippleRef for the slider thumbs active state. */\n  private _activeRippleRef: RippleRef | undefined;\n\n  /** Whether the slider thumb is currently being hovered. */\n  private _isHovered: boolean = false;\n\n  /** Whether the slider thumb is currently being pressed. */\n  _isActive = false;\n\n  /** Whether the value indicator tooltip is visible. */\n  _isValueIndicatorVisible: boolean = false;\n\n  /** The host native HTML input element. */\n  _hostElement = inject<ElementRef<HTMLElement>>(ElementRef).nativeElement;\n\n  private _platform = inject(Platform);\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  ngAfterViewInit() {\n    const sliderInput = this._slider._getInput(this.thumbPosition);\n\n    // No-op if the slider isn't configured properly. `MatSlider` will\n    // throw an error instructing the user how to set up the slider.\n    if (!sliderInput) {\n      return;\n    }\n\n    this._ripple.radius = 24;\n    this._sliderInput = sliderInput;\n    this._sliderInputEl = this._sliderInput._hostElement;\n\n    // These listeners don't update any data bindings so we bind them outside\n    // of the NgZone to prevent Angular from needlessly running change detection.\n    this._ngZone.runOutsideAngular(() => {\n      const input = this._sliderInputEl!;\n      const renderer = this._renderer;\n      this._listenerCleanups = [\n        renderer.listen(input, 'pointermove', this._onPointerMove),\n        renderer.listen(input, 'pointerdown', this._onDragStart),\n        renderer.listen(input, 'pointerup', this._onDragEnd),\n        renderer.listen(input, 'pointerleave', this._onMouseLeave),\n        renderer.listen(input, 'focus', this._onFocus),\n        renderer.listen(input, 'blur', this._onBlur),\n      ];\n    });\n  }\n\n  ngOnDestroy() {\n    this._listenerCleanups?.forEach(cleanup => cleanup());\n  }\n\n  private _onPointerMove = (event: PointerEvent): void => {\n    if (this._sliderInput._isFocused) {\n      return;\n    }\n\n    const rect = this._hostElement.getBoundingClientRect();\n    const isHovered = this._slider._isCursorOnSliderThumb(event, rect);\n    this._isHovered = isHovered;\n\n    if (isHovered) {\n      this._showHoverRipple();\n    } else {\n      this._hideRipple(this._hoverRippleRef);\n    }\n  };\n\n  private _onMouseLeave = (): void => {\n    this._isHovered = false;\n    this._hideRipple(this._hoverRippleRef);\n  };\n\n  private _onFocus = (): void => {\n    // We don't want to show the hover ripple on top of the focus ripple.\n    // Happen when the users cursor is over a thumb and then the user tabs to it.\n    this._hideRipple(this._hoverRippleRef);\n    this._showFocusRipple();\n    this._hostElement.classList.add('mdc-slider__thumb--focused');\n  };\n\n  private _onBlur = (): void => {\n    // Happens when the user tabs away while still dragging a thumb.\n    if (!this._isActive) {\n      this._hideRipple(this._focusRippleRef);\n    }\n    // Happens when the user tabs away from a thumb but their cursor is still over it.\n    if (this._isHovered) {\n      this._showHoverRipple();\n    }\n    this._hostElement.classList.remove('mdc-slider__thumb--focused');\n  };\n\n  private _onDragStart = (event: PointerEvent): void => {\n    if (event.button !== 0) {\n      return;\n    }\n    this._isActive = true;\n    this._showActiveRipple();\n  };\n\n  private _onDragEnd = (): void => {\n    this._isActive = false;\n    this._hideRipple(this._activeRippleRef);\n    // Happens when the user starts dragging a thumb, tabs away, and then stops dragging.\n    if (!this._sliderInput._isFocused) {\n      this._hideRipple(this._focusRippleRef);\n    }\n\n    // On Safari we need to immediately re-show the hover ripple because\n    // sliders do not retain focus from pointer events on that platform.\n    if (this._platform.SAFARI) {\n      this._showHoverRipple();\n    }\n  };\n\n  /** Handles displaying the hover ripple. */\n  private _showHoverRipple(): void {\n    if (!this._isShowingRipple(this._hoverRippleRef)) {\n      this._hoverRippleRef = this._showRipple({enterDuration: 0, exitDuration: 0});\n      this._hoverRippleRef?.element.classList.add('mat-mdc-slider-hover-ripple');\n    }\n  }\n\n  /** Handles displaying the focus ripple. */\n  private _showFocusRipple(): void {\n    // Show the focus ripple event if noop animations are enabled.\n    if (!this._isShowingRipple(this._focusRippleRef)) {\n      this._focusRippleRef = this._showRipple({enterDuration: 0, exitDuration: 0}, true);\n      this._focusRippleRef?.element.classList.add('mat-mdc-slider-focus-ripple');\n    }\n  }\n\n  /** Handles displaying the active ripple. */\n  private _showActiveRipple(): void {\n    if (!this._isShowingRipple(this._activeRippleRef)) {\n      this._activeRippleRef = this._showRipple({enterDuration: 225, exitDuration: 400});\n      this._activeRippleRef?.element.classList.add('mat-mdc-slider-active-ripple');\n    }\n  }\n\n  /** Whether the given rippleRef is currently fading in or visible. */\n  private _isShowingRipple(rippleRef?: RippleRef): boolean {\n    return rippleRef?.state === RippleState.FADING_IN || rippleRef?.state === RippleState.VISIBLE;\n  }\n\n  /** Manually launches the slider thumb ripple using the specified ripple animation config. */\n  private _showRipple(\n    animation: RippleAnimationConfig,\n    ignoreGlobalRippleConfig?: boolean,\n  ): RippleRef | undefined {\n    if (this._slider.disabled) {\n      return;\n    }\n    this._showValueIndicator();\n    if (this._slider._isRange) {\n      const sibling = this._slider._getThumb(\n        this.thumbPosition === _MatThumb.START ? _MatThumb.END : _MatThumb.START,\n      );\n      sibling._showValueIndicator();\n    }\n    if (this._slider._globalRippleOptions?.disabled && !ignoreGlobalRippleConfig) {\n      return;\n    }\n    return this._ripple.launch({\n      animation: this._slider._noopAnimations ? {enterDuration: 0, exitDuration: 0} : animation,\n      centered: true,\n      persistent: true,\n    });\n  }\n\n  /**\n   * Fades out the given ripple.\n   * Also hides the value indicator if no ripple is showing.\n   */\n  private _hideRipple(rippleRef?: RippleRef): void {\n    rippleRef?.fadeOut();\n\n    if (this._isShowingAnyRipple()) {\n      return;\n    }\n\n    if (!this._slider._isRange) {\n      this._hideValueIndicator();\n    }\n\n    const sibling = this._getSibling();\n    if (!sibling._isShowingAnyRipple()) {\n      this._hideValueIndicator();\n      sibling._hideValueIndicator();\n    }\n  }\n\n  /** Shows the value indicator ui. */\n  _showValueIndicator(): void {\n    this._hostElement.classList.add('mdc-slider__thumb--with-indicator');\n  }\n\n  /** Hides the value indicator ui. */\n  _hideValueIndicator(): void {\n    this._hostElement.classList.remove('mdc-slider__thumb--with-indicator');\n  }\n\n  _getSibling(): _MatSliderVisualThumb {\n    return this._slider._getThumb(\n      this.thumbPosition === _MatThumb.START ? _MatThumb.END : _MatThumb.START,\n    );\n  }\n\n  /** Gets the value indicator container's native HTML element. */\n  _getValueIndicatorContainer(): HTMLElement | undefined {\n    return this._valueIndicatorContainer?.nativeElement;\n  }\n\n  /** Gets the native HTML element of the slider thumb knob. */\n  _getKnob(): HTMLElement {\n    return this._knob.nativeElement;\n  }\n\n  _isShowingAnyRipple(): boolean {\n    return (\n      this._isShowingRipple(this._hoverRippleRef) ||\n      this._isShowingRipple(this._focusRippleRef) ||\n      this._isShowingRipple(this._activeRippleRef)\n    );\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directionality} from '@angular/cdk/bidi';\nimport {Platform} from '@angular/cdk/platform';\nimport {\n  AfterViewInit,\n  booleanAttribute,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChild,\n  ContentChildren,\n  ElementRef,\n  inject,\n  Input,\n  NgZone,\n  numberAttribute,\n  OnDestroy,\n  QueryList,\n  ViewChild,\n  ViewChildren,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {\n  _animationsDisabled,\n  _StructuralStylesLoader,\n  MAT_RIPPLE_GLOBAL_OPTIONS,\n  RippleGlobalOptions,\n  ThemePalette,\n} from '../core';\nimport {Subscription} from 'rxjs';\nimport {\n  _MatThumb,\n  _MatTickMark,\n  _MatSlider,\n  _MatSliderRangeThumb,\n  _MatSliderThumb,\n  _MatSliderVisualThumb,\n  MAT_SLIDER_RANGE_THUMB,\n  MAT_SLIDER_THUMB,\n  MAT_SLIDER,\n  MAT_SLIDER_VISUAL_THUMB,\n} from './slider-interface';\nimport {MatSliderVisualThumb} from './slider-thumb';\nimport {_CdkPrivateStyleLoader} from '@angular/cdk/private';\n\n// TODO(wagnermaciel): maybe handle the following edge case:\n// 1. start dragging discrete slider\n// 2. tab to disable checkbox\n// 3. without ending drag, disable the slider\n\n/**\n * Allows users to select from a range of values by moving the slider thumb. It is similar in\n * behavior to the native `<input type=\"range\">` element.\n */\n@Component({\n  selector: 'mat-slider',\n  templateUrl: 'slider.html',\n  styleUrl: 'slider.css',\n  host: {\n    'class': 'mat-mdc-slider mdc-slider',\n    '[class]': '\"mat-\" + (color || \"primary\")',\n    '[class.mdc-slider--range]': '_isRange',\n    '[class.mdc-slider--disabled]': 'disabled',\n    '[class.mdc-slider--discrete]': 'discrete',\n    '[class.mdc-slider--tick-marks]': 'showTickMarks',\n    '[class._mat-animation-noopable]': '_noopAnimations',\n  },\n  exportAs: 'matSlider',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  providers: [{provide: MAT_SLIDER, useExisting: MatSlider}],\n  imports: [MatSliderVisualThumb],\n})\nexport class MatSlider implements AfterViewInit, OnDestroy, _MatSlider {\n  readonly _ngZone = inject(NgZone);\n  readonly _cdr = inject(ChangeDetectorRef);\n  readonly _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  readonly _dir = inject(Directionality, {optional: true});\n  readonly _globalRippleOptions = inject<RippleGlobalOptions>(MAT_RIPPLE_GLOBAL_OPTIONS, {\n    optional: true,\n  });\n\n  /** The active portion of the slider track. */\n  @ViewChild('trackActive') _trackActive: ElementRef<HTMLElement>;\n\n  /** The slider thumb(s). */\n  @ViewChildren(MAT_SLIDER_VISUAL_THUMB) _thumbs: QueryList<_MatSliderVisualThumb>;\n\n  /** The sliders hidden range input(s). */\n  @ContentChild(MAT_SLIDER_THUMB) _input: _MatSliderThumb;\n\n  /** The sliders hidden range input(s). */\n  @ContentChildren(MAT_SLIDER_RANGE_THUMB, {descendants: false})\n  _inputs: QueryList<_MatSliderRangeThumb>;\n\n  /** Whether the slider is disabled. */\n  @Input({transform: booleanAttribute})\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(v: boolean) {\n    this._disabled = v;\n    const endInput = this._getInput(_MatThumb.END);\n    const startInput = this._getInput(_MatThumb.START);\n\n    if (endInput) {\n      endInput.disabled = this._disabled;\n    }\n    if (startInput) {\n      startInput.disabled = this._disabled;\n    }\n  }\n  private _disabled: boolean = false;\n\n  /** Whether the slider displays a numeric value label upon pressing the thumb. */\n  @Input({transform: booleanAttribute})\n  get discrete(): boolean {\n    return this._discrete;\n  }\n  set discrete(v: boolean) {\n    this._discrete = v;\n    this._updateValueIndicatorUIs();\n  }\n  private _discrete: boolean = false;\n\n  /** Whether the slider displays tick marks along the slider track. */\n  @Input({transform: booleanAttribute})\n  get showTickMarks(): boolean {\n    return this._showTickMarks;\n  }\n  set showTickMarks(value: boolean) {\n    this._showTickMarks = value;\n\n    if (this._hasViewInitialized) {\n      this._updateTickMarkUI();\n      this._updateTickMarkTrackUI();\n    }\n  }\n  private _showTickMarks: boolean = false;\n\n  /** The minimum value that the slider can have. */\n  @Input({transform: numberAttribute})\n  get min(): number {\n    return this._min;\n  }\n  set min(v: number) {\n    const min = v === undefined || v === null || isNaN(v) ? this._min : v;\n    if (this._min !== min) {\n      this._updateMin(min);\n    }\n  }\n  private _min: number = 0;\n\n  /**\n   * Theme color of the slider. This API is supported in M2 themes only, it\n   * has no effect in M3 themes. For color customization in M3, see https://material.angular.dev/components/slider/styling.\n   *\n   * For information on applying color variants in M3, see\n   * https://material.angular.dev/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n   */\n  @Input()\n  color: ThemePalette;\n\n  /** Whether ripples are disabled in the slider. */\n  @Input({transform: booleanAttribute})\n  disableRipple: boolean = false;\n\n  private _updateMin(min: number): void {\n    const prevMin = this._min;\n    this._min = min;\n    this._isRange ? this._updateMinRange({old: prevMin, new: min}) : this._updateMinNonRange(min);\n    this._onMinMaxOrStepChange();\n  }\n\n  private _updateMinRange(min: {old: number; new: number}): void {\n    const endInput = this._getInput(_MatThumb.END) as _MatSliderRangeThumb;\n    const startInput = this._getInput(_MatThumb.START) as _MatSliderRangeThumb;\n\n    const oldEndValue = endInput.value;\n    const oldStartValue = startInput.value;\n\n    startInput.min = min.new;\n    endInput.min = Math.max(min.new, startInput.value);\n    startInput.max = Math.min(endInput.max, endInput.value);\n\n    startInput._updateWidthInactive();\n    endInput._updateWidthInactive();\n\n    min.new < min.old\n      ? this._onTranslateXChangeBySideEffect(endInput, startInput)\n      : this._onTranslateXChangeBySideEffect(startInput, endInput);\n\n    if (oldEndValue !== endInput.value) {\n      this._onValueChange(endInput);\n    }\n\n    if (oldStartValue !== startInput.value) {\n      this._onValueChange(startInput);\n    }\n  }\n\n  private _updateMinNonRange(min: number): void {\n    const input = this._getInput(_MatThumb.END);\n    if (input) {\n      const oldValue = input.value;\n\n      input.min = min;\n      input._updateThumbUIByValue();\n      this._updateTrackUI(input);\n\n      if (oldValue !== input.value) {\n        this._onValueChange(input);\n      }\n    }\n  }\n\n  /** The maximum value that the slider can have. */\n  @Input({transform: numberAttribute})\n  get max(): number {\n    return this._max;\n  }\n  set max(v: number) {\n    const max = v === undefined || v === null || isNaN(v) ? this._max : v;\n    if (this._max !== max) {\n      this._updateMax(max);\n    }\n  }\n  private _max: number = 100;\n\n  private _updateMax(max: number): void {\n    const prevMax = this._max;\n    this._max = max;\n    this._isRange ? this._updateMaxRange({old: prevMax, new: max}) : this._updateMaxNonRange(max);\n    this._onMinMaxOrStepChange();\n  }\n\n  private _updateMaxRange(max: {old: number; new: number}): void {\n    const endInput = this._getInput(_MatThumb.END) as _MatSliderRangeThumb;\n    const startInput = this._getInput(_MatThumb.START) as _MatSliderRangeThumb;\n\n    const oldEndValue = endInput.value;\n    const oldStartValue = startInput.value;\n\n    endInput.max = max.new;\n    startInput.max = Math.min(max.new, endInput.value);\n    endInput.min = startInput.value;\n\n    endInput._updateWidthInactive();\n    startInput._updateWidthInactive();\n\n    max.new > max.old\n      ? this._onTranslateXChangeBySideEffect(startInput, endInput)\n      : this._onTranslateXChangeBySideEffect(endInput, startInput);\n\n    if (oldEndValue !== endInput.value) {\n      this._onValueChange(endInput);\n    }\n\n    if (oldStartValue !== startInput.value) {\n      this._onValueChange(startInput);\n    }\n  }\n\n  private _updateMaxNonRange(max: number): void {\n    const input = this._getInput(_MatThumb.END);\n    if (input) {\n      const oldValue = input.value;\n\n      input.max = max;\n      input._updateThumbUIByValue();\n      this._updateTrackUI(input);\n\n      if (oldValue !== input.value) {\n        this._onValueChange(input);\n      }\n    }\n  }\n\n  /** The values at which the thumb will snap. */\n  @Input({transform: numberAttribute})\n  get step(): number {\n    return this._step;\n  }\n  set step(v: number) {\n    const step = isNaN(v) ? this._step : v;\n    if (this._step !== step) {\n      this._updateStep(step);\n    }\n  }\n  private _step: number = 1;\n\n  private _updateStep(step: number): void {\n    this._step = step;\n    this._isRange ? this._updateStepRange() : this._updateStepNonRange();\n    this._onMinMaxOrStepChange();\n  }\n\n  private _updateStepRange(): void {\n    const endInput = this._getInput(_MatThumb.END) as _MatSliderRangeThumb;\n    const startInput = this._getInput(_MatThumb.START) as _MatSliderRangeThumb;\n\n    const oldEndValue = endInput.value;\n    const oldStartValue = startInput.value;\n\n    const prevStartValue = startInput.value;\n\n    endInput.min = this._min;\n    startInput.max = this._max;\n\n    endInput.step = this._step;\n    startInput.step = this._step;\n\n    if (this._platform.SAFARI) {\n      endInput.value = endInput.value;\n      startInput.value = startInput.value;\n    }\n\n    endInput.min = Math.max(this._min, startInput.value);\n    startInput.max = Math.min(this._max, endInput.value);\n\n    startInput._updateWidthInactive();\n    endInput._updateWidthInactive();\n\n    endInput.value < prevStartValue\n      ? this._onTranslateXChangeBySideEffect(startInput, endInput)\n      : this._onTranslateXChangeBySideEffect(endInput, startInput);\n\n    if (oldEndValue !== endInput.value) {\n      this._onValueChange(endInput);\n    }\n\n    if (oldStartValue !== startInput.value) {\n      this._onValueChange(startInput);\n    }\n  }\n\n  private _updateStepNonRange(): void {\n    const input = this._getInput(_MatThumb.END);\n    if (input) {\n      const oldValue = input.value;\n\n      input.step = this._step;\n      if (this._platform.SAFARI) {\n        input.value = input.value;\n      }\n\n      input._updateThumbUIByValue();\n\n      if (oldValue !== input.value) {\n        this._onValueChange(input);\n      }\n    }\n  }\n\n  /**\n   * Function that will be used to format the value before it is displayed\n   * in the thumb label. Can be used to format very large number in order\n   * for them to fit into the slider thumb.\n   */\n  @Input() displayWith: (value: number) => string = (value: number) => `${value}`;\n\n  /** Used to keep track of & render the active & inactive tick marks on the slider track. */\n  _tickMarks: _MatTickMark[];\n\n  /** Whether animations have been disabled. */\n  _noopAnimations = _animationsDisabled();\n\n  /** Subscription to changes to the directionality (LTR / RTL) context for the application. */\n  private _dirChangeSubscription: Subscription;\n\n  /** Observer used to monitor size changes in the slider. */\n  private _resizeObserver: ResizeObserver | null;\n\n  // Stored dimensions to avoid calling getBoundingClientRect redundantly.\n\n  _cachedWidth: number;\n  _cachedLeft: number;\n\n  _rippleRadius: number = 24;\n\n  // The value indicator tooltip text for the visual slider thumb(s).\n\n  /** @docs-private */\n  protected startValueIndicatorText: string = '';\n\n  /** @docs-private */\n  protected endValueIndicatorText: string = '';\n\n  // Used to control the translateX of the visual slider thumb(s).\n\n  _endThumbTransform: string;\n  _startThumbTransform: string;\n\n  _isRange: boolean = false;\n\n  /** Whether the slider is rtl. */\n  _isRtl: boolean = false;\n\n  private _hasViewInitialized: boolean = false;\n\n  /**\n   * The width of the tick mark track.\n   * The tick mark track width is different from full track width\n   */\n  _tickMarkTrackWidth: number = 0;\n\n  _hasAnimation: boolean = false;\n\n  private _resizeTimer: null | ReturnType<typeof setTimeout> = null;\n\n  private _platform = inject(Platform);\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    inject(_CdkPrivateStyleLoader).load(_StructuralStylesLoader);\n\n    if (this._dir) {\n      this._dirChangeSubscription = this._dir.change.subscribe(() => this._onDirChange());\n      this._isRtl = this._dir.value === 'rtl';\n    }\n  }\n\n  /** The radius of the native slider's knob. AFAIK there is no way to avoid hardcoding this. */\n  _knobRadius: number = 8;\n\n  _inputPadding: number;\n\n  ngAfterViewInit(): void {\n    if (this._platform.isBrowser) {\n      this._updateDimensions();\n    }\n\n    const eInput = this._getInput(_MatThumb.END);\n    const sInput = this._getInput(_MatThumb.START);\n    this._isRange = !!eInput && !!sInput;\n    this._cdr.detectChanges();\n\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      _validateInputs(\n        this._isRange,\n        this._getInput(_MatThumb.END),\n        this._getInput(_MatThumb.START),\n      );\n    }\n\n    const thumb = this._getThumb(_MatThumb.END);\n    this._rippleRadius = thumb._ripple.radius;\n    this._inputPadding = this._rippleRadius - this._knobRadius;\n\n    this._isRange\n      ? this._initUIRange(eInput as _MatSliderRangeThumb, sInput as _MatSliderRangeThumb)\n      : this._initUINonRange(eInput!);\n\n    this._updateTrackUI(eInput!);\n    this._updateTickMarkUI();\n    this._updateTickMarkTrackUI();\n\n    this._observeHostResize();\n    this._cdr.detectChanges();\n  }\n\n  private _initUINonRange(eInput: _MatSliderThumb): void {\n    eInput.initProps();\n    eInput.initUI();\n\n    this._updateValueIndicatorUI(eInput);\n\n    this._hasViewInitialized = true;\n    eInput._updateThumbUIByValue();\n  }\n\n  private _initUIRange(eInput: _MatSliderRangeThumb, sInput: _MatSliderRangeThumb): void {\n    eInput.initProps();\n    eInput.initUI();\n\n    sInput.initProps();\n    sInput.initUI();\n\n    eInput._updateMinMax();\n    sInput._updateMinMax();\n\n    eInput._updateStaticStyles();\n    sInput._updateStaticStyles();\n\n    this._updateValueIndicatorUIs();\n\n    this._hasViewInitialized = true;\n\n    eInput._updateThumbUIByValue();\n    sInput._updateThumbUIByValue();\n  }\n\n  ngOnDestroy(): void {\n    this._dirChangeSubscription.unsubscribe();\n    this._resizeObserver?.disconnect();\n    this._resizeObserver = null;\n  }\n\n  /** Handles updating the slider ui after a dir change. */\n  private _onDirChange(): void {\n    this._isRtl = this._dir?.value === 'rtl';\n    this._isRange ? this._onDirChangeRange() : this._onDirChangeNonRange();\n    this._updateTickMarkUI();\n  }\n\n  private _onDirChangeRange(): void {\n    const endInput = this._getInput(_MatThumb.END) as _MatSliderRangeThumb;\n    const startInput = this._getInput(_MatThumb.START) as _MatSliderRangeThumb;\n\n    endInput._setIsLeftThumb();\n    startInput._setIsLeftThumb();\n\n    endInput.translateX = endInput._calcTranslateXByValue();\n    startInput.translateX = startInput._calcTranslateXByValue();\n\n    endInput._updateStaticStyles();\n    startInput._updateStaticStyles();\n\n    endInput._updateWidthInactive();\n    startInput._updateWidthInactive();\n\n    endInput._updateThumbUIByValue();\n    startInput._updateThumbUIByValue();\n  }\n\n  private _onDirChangeNonRange(): void {\n    const input = this._getInput(_MatThumb.END)!;\n    input._updateThumbUIByValue();\n  }\n\n  /** Starts observing and updating the slider if the host changes its size. */\n  private _observeHostResize() {\n    if (typeof ResizeObserver === 'undefined' || !ResizeObserver) {\n      return;\n    }\n\n    this._ngZone.runOutsideAngular(() => {\n      this._resizeObserver = new ResizeObserver(() => {\n        if (this._isActive()) {\n          return;\n        }\n        if (this._resizeTimer) {\n          clearTimeout(this._resizeTimer);\n        }\n        this._onResize();\n      });\n      this._resizeObserver.observe(this._elementRef.nativeElement);\n    });\n  }\n\n  /** Whether any of the thumbs are currently active. */\n  private _isActive(): boolean {\n    return this._getThumb(_MatThumb.START)._isActive || this._getThumb(_MatThumb.END)._isActive;\n  }\n\n  private _getValue(thumbPosition: _MatThumb = _MatThumb.END): number {\n    const input = this._getInput(thumbPosition);\n    if (!input) {\n      return this.min;\n    }\n    return input.value;\n  }\n\n  private _skipUpdate(): boolean {\n    return !!(\n      this._getInput(_MatThumb.START)?._skipUIUpdate || this._getInput(_MatThumb.END)?._skipUIUpdate\n    );\n  }\n\n  /** Stores the slider dimensions. */\n  _updateDimensions(): void {\n    this._cachedWidth = this._elementRef.nativeElement.offsetWidth;\n    this._cachedLeft = this._elementRef.nativeElement.getBoundingClientRect().left;\n  }\n\n  /** Sets the styles for the active portion of the track. */\n  _setTrackActiveStyles(styles: {\n    left: string;\n    right: string;\n    transform: string;\n    transformOrigin: string;\n  }): void {\n    const trackStyle = this._trackActive.nativeElement.style;\n\n    trackStyle.left = styles.left;\n    trackStyle.right = styles.right;\n    trackStyle.transformOrigin = styles.transformOrigin;\n    trackStyle.transform = styles.transform;\n  }\n\n  /** Returns the translateX positioning for a tick mark based on it's index. */\n  _calcTickMarkTransform(index: number): string {\n    // TODO(wagnermaciel): See if we can avoid doing this and just using flex to position these.\n    const offset = index * (this._tickMarkTrackWidth / (this._tickMarks.length - 1));\n    const translateX = this._isRtl ? this._cachedWidth - 6 - offset : offset;\n    return `translateX(${translateX}px`;\n  }\n\n  // Handlers for updating the slider ui.\n\n  _onTranslateXChange(source: _MatSliderThumb): void {\n    if (!this._hasViewInitialized) {\n      return;\n    }\n\n    this._updateThumbUI(source);\n    this._updateTrackUI(source);\n    this._updateOverlappingThumbUI(source as _MatSliderRangeThumb);\n  }\n\n  _onTranslateXChangeBySideEffect(\n    input1: _MatSliderRangeThumb,\n    input2: _MatSliderRangeThumb,\n  ): void {\n    if (!this._hasViewInitialized) {\n      return;\n    }\n\n    input1._updateThumbUIByValue();\n    input2._updateThumbUIByValue();\n  }\n\n  _onValueChange(source: _MatSliderThumb): void {\n    if (!this._hasViewInitialized) {\n      return;\n    }\n\n    this._updateValueIndicatorUI(source);\n    this._updateTickMarkUI();\n    this._cdr.detectChanges();\n  }\n\n  _onMinMaxOrStepChange(): void {\n    if (!this._hasViewInitialized) {\n      return;\n    }\n\n    this._updateTickMarkUI();\n    this._updateTickMarkTrackUI();\n    this._cdr.markForCheck();\n  }\n\n  _onResize(): void {\n    if (!this._hasViewInitialized) {\n      return;\n    }\n\n    this._updateDimensions();\n    if (this._isRange) {\n      const eInput = this._getInput(_MatThumb.END) as _MatSliderRangeThumb;\n      const sInput = this._getInput(_MatThumb.START) as _MatSliderRangeThumb;\n\n      eInput._updateThumbUIByValue();\n      sInput._updateThumbUIByValue();\n\n      eInput._updateStaticStyles();\n      sInput._updateStaticStyles();\n\n      eInput._updateMinMax();\n      sInput._updateMinMax();\n\n      eInput._updateWidthInactive();\n      sInput._updateWidthInactive();\n    } else {\n      const eInput = this._getInput(_MatThumb.END);\n      if (eInput) {\n        eInput._updateThumbUIByValue();\n      }\n    }\n\n    this._updateTickMarkUI();\n    this._updateTickMarkTrackUI();\n    this._cdr.detectChanges();\n  }\n\n  /** Whether or not the slider thumbs overlap. */\n  private _thumbsOverlap: boolean = false;\n\n  /** Returns true if the slider knobs are overlapping one another. */\n  private _areThumbsOverlapping(): boolean {\n    const startInput = this._getInput(_MatThumb.START);\n    const endInput = this._getInput(_MatThumb.END);\n    if (!startInput || !endInput) {\n      return false;\n    }\n    return endInput.translateX - startInput.translateX < 20;\n  }\n\n  /**\n   * Updates the class names of overlapping slider thumbs so\n   * that the current active thumb is styled to be on \"top\".\n   */\n  private _updateOverlappingThumbClassNames(source: _MatSliderRangeThumb): void {\n    const sibling = source.getSibling()!;\n    const sourceThumb = this._getThumb(source.thumbPosition);\n    const siblingThumb = this._getThumb(sibling.thumbPosition);\n    siblingThumb._hostElement.classList.remove('mdc-slider__thumb--top');\n    sourceThumb._hostElement.classList.toggle('mdc-slider__thumb--top', this._thumbsOverlap);\n  }\n\n  /** Updates the UI of slider thumbs when they begin or stop overlapping. */\n  private _updateOverlappingThumbUI(source: _MatSliderRangeThumb): void {\n    if (!this._isRange || this._skipUpdate()) {\n      return;\n    }\n    if (this._thumbsOverlap !== this._areThumbsOverlapping()) {\n      this._thumbsOverlap = !this._thumbsOverlap;\n      this._updateOverlappingThumbClassNames(source);\n    }\n  }\n\n  // _MatThumb styles update conditions\n  //\n  // 1. TranslateX, resize, or dir change\n  //    - Reason: The thumb styles need to be updated according to the new translateX.\n  // 2. Min, max, or step\n  //    - Reason: The value may have silently changed.\n\n  /** Updates the translateX of the given thumb. */\n  _updateThumbUI(source: _MatSliderThumb) {\n    if (this._skipUpdate()) {\n      return;\n    }\n    const thumb = this._getThumb(\n      source.thumbPosition === _MatThumb.END ? _MatThumb.END : _MatThumb.START,\n    )!;\n    thumb._hostElement.style.transform = `translateX(${source.translateX}px)`;\n  }\n\n  // Value indicator text update conditions\n  //\n  // 1. Value\n  //    - Reason: The value displayed needs to be updated.\n  // 2. Min, max, or step\n  //    - Reason: The value may have silently changed.\n\n  /** Updates the value indicator tooltip ui for the given thumb. */\n  _updateValueIndicatorUI(source: _MatSliderThumb): void {\n    if (this._skipUpdate()) {\n      return;\n    }\n\n    const valuetext = this.displayWith(source.value);\n\n    this._hasViewInitialized\n      ? source._valuetext.set(valuetext)\n      : source._hostElement.setAttribute('aria-valuetext', valuetext);\n\n    if (this.discrete) {\n      source.thumbPosition === _MatThumb.START\n        ? (this.startValueIndicatorText = valuetext)\n        : (this.endValueIndicatorText = valuetext);\n\n      const visualThumb = this._getThumb(source.thumbPosition);\n      valuetext.length < 3\n        ? visualThumb._hostElement.classList.add('mdc-slider__thumb--short-value')\n        : visualThumb._hostElement.classList.remove('mdc-slider__thumb--short-value');\n    }\n  }\n\n  /** Updates all value indicator UIs in the slider. */\n  private _updateValueIndicatorUIs(): void {\n    const eInput = this._getInput(_MatThumb.END);\n    const sInput = this._getInput(_MatThumb.START);\n\n    if (eInput) {\n      this._updateValueIndicatorUI(eInput);\n    }\n    if (sInput) {\n      this._updateValueIndicatorUI(sInput);\n    }\n  }\n\n  // Update Tick Mark Track Width\n  //\n  // 1. Min, max, or step\n  //    - Reason: The maximum reachable value may have changed.\n  //    - Side note: The maximum reachable value is different from the maximum value set by the\n  //      user. For example, a slider with [min: 5, max: 100, step: 10] would have a maximum\n  //      reachable value of 95.\n  // 2. Resize\n  //    - Reason: The position for the maximum reachable value needs to be recalculated.\n\n  /** Updates the width of the tick mark track. */\n  private _updateTickMarkTrackUI(): void {\n    if (!this.showTickMarks || this._skipUpdate()) {\n      return;\n    }\n\n    const step = this._step && this._step > 0 ? this._step : 1;\n    const maxValue = Math.floor(this.max / step) * step;\n    const percentage = (maxValue - this.min) / (this.max - this.min);\n    this._tickMarkTrackWidth = (this._cachedWidth - 6) * percentage;\n  }\n\n  // Track active update conditions\n  //\n  // 1. TranslateX\n  //    - Reason: The track active should line up with the new thumb position.\n  // 2. Min or max\n  //    - Reason #1: The 'active' percentage needs to be recalculated.\n  //    - Reason #2: The value may have silently changed.\n  // 3. Step\n  //    - Reason: The value may have silently changed causing the thumb(s) to shift.\n  // 4. Dir change\n  //    - Reason: The track active will need to be updated according to the new thumb position(s).\n  // 5. Resize\n  //    - Reason: The total width the 'active' tracks translateX is based on has changed.\n\n  /** Updates the scale on the active portion of the track. */\n  _updateTrackUI(source: _MatSliderThumb): void {\n    if (this._skipUpdate()) {\n      return;\n    }\n\n    this._isRange\n      ? this._updateTrackUIRange(source as _MatSliderRangeThumb)\n      : this._updateTrackUINonRange(source as _MatSliderThumb);\n  }\n\n  private _updateTrackUIRange(source: _MatSliderRangeThumb): void {\n    const sibling = source.getSibling();\n    if (!sibling || !this._cachedWidth) {\n      return;\n    }\n\n    const activePercentage = Math.abs(sibling.translateX - source.translateX) / this._cachedWidth;\n\n    if (source._isLeftThumb && this._cachedWidth) {\n      this._setTrackActiveStyles({\n        left: 'auto',\n        right: `${this._cachedWidth - sibling.translateX}px`,\n        transformOrigin: 'right',\n        transform: `scaleX(${activePercentage})`,\n      });\n    } else {\n      this._setTrackActiveStyles({\n        left: `${sibling.translateX}px`,\n        right: 'auto',\n        transformOrigin: 'left',\n        transform: `scaleX(${activePercentage})`,\n      });\n    }\n  }\n\n  private _updateTrackUINonRange(source: _MatSliderThumb): void {\n    this._isRtl\n      ? this._setTrackActiveStyles({\n          left: 'auto',\n          right: '0px',\n          transformOrigin: 'right',\n          transform: `scaleX(${1 - source.fillPercentage})`,\n        })\n      : this._setTrackActiveStyles({\n          left: '0px',\n          right: 'auto',\n          transformOrigin: 'left',\n          transform: `scaleX(${source.fillPercentage})`,\n        });\n  }\n\n  // Tick mark update conditions\n  //\n  // 1. Value\n  //    - Reason: a tick mark which was once active might now be inactive or vice versa.\n  // 2. Min, max, or step\n  //    - Reason #1: the number of tick marks may have changed.\n  //    - Reason #2: The value may have silently changed.\n\n  /** Updates the dots along the slider track. */\n  _updateTickMarkUI(): void {\n    if (\n      !this.showTickMarks ||\n      this.step === undefined ||\n      this.min === undefined ||\n      this.max === undefined\n    ) {\n      return;\n    }\n    const step = this.step > 0 ? this.step : 1;\n    this._isRange ? this._updateTickMarkUIRange(step) : this._updateTickMarkUINonRange(step);\n  }\n\n  private _updateTickMarkUINonRange(step: number): void {\n    const value = this._getValue();\n    let numActive = Math.max(Math.round((value - this.min) / step), 0) + 1;\n    let numInactive = Math.max(Math.round((this.max - value) / step), 0) - 1;\n    this._isRtl ? numActive++ : numInactive++;\n\n    this._tickMarks = Array(numActive)\n      .fill(_MatTickMark.ACTIVE)\n      .concat(Array(numInactive).fill(_MatTickMark.INACTIVE));\n  }\n\n  private _updateTickMarkUIRange(step: number): void {\n    const endValue = this._getValue();\n    const startValue = this._getValue(_MatThumb.START);\n\n    const numInactiveBeforeStartThumb = Math.max(Math.round((startValue - this.min) / step), 0);\n    const numActive = Math.max(Math.round((endValue - startValue) / step) + 1, 0);\n    const numInactiveAfterEndThumb = Math.max(Math.round((this.max - endValue) / step), 0);\n    this._tickMarks = Array(numInactiveBeforeStartThumb)\n      .fill(_MatTickMark.INACTIVE)\n      .concat(\n        Array(numActive).fill(_MatTickMark.ACTIVE),\n        Array(numInactiveAfterEndThumb).fill(_MatTickMark.INACTIVE),\n      );\n  }\n\n  /** Gets the slider thumb input of the given thumb position. */\n  _getInput(thumbPosition: _MatThumb): _MatSliderThumb | _MatSliderRangeThumb | undefined {\n    if (thumbPosition === _MatThumb.END && this._input) {\n      return this._input;\n    }\n    if (this._inputs?.length) {\n      return thumbPosition === _MatThumb.START ? this._inputs.first : this._inputs.last;\n    }\n    return;\n  }\n\n  /** Gets the slider thumb HTML input element of the given thumb position. */\n  _getThumb(thumbPosition: _MatThumb): _MatSliderVisualThumb {\n    return thumbPosition === _MatThumb.END ? this._thumbs?.last! : this._thumbs?.first!;\n  }\n\n  _setTransition(withAnimation: boolean): void {\n    this._hasAnimation = !this._platform.IOS && withAnimation && !this._noopAnimations;\n    this._elementRef.nativeElement.classList.toggle(\n      'mat-mdc-slider-with-animation',\n      this._hasAnimation,\n    );\n  }\n\n  /** Whether the given pointer event occurred within the bounds of the slider pointer's DOM Rect. */\n  _isCursorOnSliderThumb(event: PointerEvent, rect: DOMRect) {\n    const radius = rect.width / 2;\n    const centerX = rect.x + radius;\n    const centerY = rect.y + radius;\n    const dx = event.clientX - centerX;\n    const dy = event.clientY - centerY;\n    return Math.pow(dx, 2) + Math.pow(dy, 2) < Math.pow(radius, 2);\n  }\n}\n\n/** Ensures that there is not an invalid configuration for the slider thumb inputs. */\nfunction _validateInputs(\n  isRange: boolean,\n  endInputElement: _MatSliderThumb | _MatSliderRangeThumb | undefined,\n  startInputElement: _MatSliderThumb | undefined,\n): void {\n  const startValid =\n    !isRange || startInputElement?._hostElement.hasAttribute('matSliderStartThumb');\n  const endValid = endInputElement?._hostElement.hasAttribute(\n    isRange ? 'matSliderEndThumb' : 'matSliderThumb',\n  );\n\n  if (!startValid || !endValid) {\n    _throwInvalidInputConfigurationError();\n  }\n}\n\nfunction _throwInvalidInputConfigurationError(): void {\n  throw Error(`Invalid slider thumb input configuration!\n\n   Valid configurations are as follows:\n\n     <mat-slider>\n       <input matSliderThumb>\n     </mat-slider>\n\n     or\n\n     <mat-slider>\n       <input matSliderStartThumb>\n       <input matSliderEndThumb>\n     </mat-slider>\n   `);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  booleanAttribute,\n  ChangeDetectorRef,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  forwardRef,\n  inject,\n  Input,\n  NgZone,\n  numberAttribute,\n  OnDestroy,\n  Output,\n  Renderer2,\n  signal,\n} from '@angular/core';\nimport {ControlValueAccessor, FormControl, NG_VALUE_ACCESSOR} from '@angular/forms';\nimport {Subject} from 'rxjs';\nimport {\n  _MatThumb,\n  MatSliderDragEvent,\n  _MatSlider,\n  _MatSliderRangeThumb,\n  _MatSliderThumb,\n  MAT_SLIDER_RANGE_THUMB,\n  MAT_SLIDER_THUMB,\n  MAT_SLIDER,\n} from './slider-interface';\nimport {Platform} from '@angular/cdk/platform';\n\n/**\n * Provider that allows the slider thumb to register as a ControlValueAccessor.\n * @docs-private\n */\nexport const MAT_SLIDER_THUMB_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatSliderThumb),\n  multi: true,\n};\n\n/**\n * Provider that allows the range slider thumb to register as a ControlValueAccessor.\n * @docs-private\n */\nexport const MAT_SLIDER_RANGE_THUMB_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatSliderRangeThumb),\n  multi: true,\n};\n\n/**\n * Directive that adds slider-specific behaviors to an input element inside `<mat-slider>`.\n * Up to two may be placed inside of a `<mat-slider>`.\n *\n * If one is used, the selector `matSliderThumb` must be used, and the outcome will be a normal\n * slider. If two are used, the selectors `matSliderStartThumb` and `matSliderEndThumb` must be\n * used, and the outcome will be a range slider with two slider thumbs.\n */\n@Directive({\n  selector: 'input[matSliderThumb]',\n  exportAs: 'matSliderThumb',\n  host: {\n    'class': 'mdc-slider__input',\n    'type': 'range',\n    '[attr.aria-valuetext]': '_valuetext()',\n    '(change)': '_onChange()',\n    '(input)': '_onInput()',\n    // TODO(wagnermaciel): Consider using a global event listener instead.\n    // Reason: I have found a semi-consistent way to mouse up without triggering this event.\n    '(blur)': '_onBlur()',\n    '(focus)': '_onFocus()',\n  },\n  providers: [\n    MAT_SLIDER_THUMB_VALUE_ACCESSOR,\n    {provide: MAT_SLIDER_THUMB, useExisting: MatSliderThumb},\n  ],\n})\nexport class MatSliderThumb implements _MatSliderThumb, OnDestroy, ControlValueAccessor {\n  readonly _ngZone = inject(NgZone);\n  readonly _elementRef = inject<ElementRef<HTMLInputElement>>(ElementRef);\n  readonly _cdr = inject(ChangeDetectorRef);\n  protected _slider = inject<_MatSlider>(MAT_SLIDER);\n  private _platform = inject(Platform);\n  private _listenerCleanups: (() => void)[];\n\n  @Input({transform: numberAttribute})\n  get value(): number {\n    return numberAttribute(this._hostElement.value, 0);\n  }\n  set value(value: number) {\n    if (value === null) {\n      value = this._getDefaultValue();\n    }\n    value = isNaN(value) ? 0 : value;\n    const stringValue = value + '';\n    if (!this._hasSetInitialValue) {\n      this._initialValue = stringValue;\n      return;\n    }\n    if (this._isActive) {\n      return;\n    }\n    this._setValue(stringValue);\n  }\n\n  /**\n   * Handles programmatic value setting. This has been split out to\n   * allow the range thumb to override it and add additional necessary logic.\n   */\n  protected _setValue(value: string) {\n    this._hostElement.value = value;\n    this._updateThumbUIByValue();\n    this._slider._onValueChange(this);\n    this._cdr.detectChanges();\n    this._slider._cdr.markForCheck();\n  }\n\n  /** Event emitted when the `value` is changed. */\n  @Output() readonly valueChange: EventEmitter<number> = new EventEmitter<number>();\n\n  /** Event emitted when the slider thumb starts being dragged. */\n  @Output() readonly dragStart: EventEmitter<MatSliderDragEvent> =\n    new EventEmitter<MatSliderDragEvent>();\n\n  /** Event emitted when the slider thumb stops being dragged. */\n  @Output() readonly dragEnd: EventEmitter<MatSliderDragEvent> =\n    new EventEmitter<MatSliderDragEvent>();\n\n  /**\n   * The current translateX in px of the slider visual thumb.\n   * @docs-private\n   */\n  get translateX(): number {\n    if (this._slider.min >= this._slider.max) {\n      this._translateX = this._tickMarkOffset;\n      return this._translateX;\n    }\n    if (this._translateX === undefined) {\n      this._translateX = this._calcTranslateXByValue();\n    }\n    return this._translateX;\n  }\n  set translateX(v: number) {\n    this._translateX = v;\n  }\n  private _translateX: number | undefined;\n\n  /**\n   * Indicates whether this thumb is the start or end thumb.\n   * @docs-private\n   */\n  thumbPosition: _MatThumb = _MatThumb.END;\n\n  /** @docs-private */\n  get min(): number {\n    return numberAttribute(this._hostElement.min, 0);\n  }\n  set min(v: number) {\n    this._hostElement.min = v + '';\n    this._cdr.detectChanges();\n  }\n\n  /** @docs-private */\n  get max(): number {\n    return numberAttribute(this._hostElement.max, 0);\n  }\n  set max(v: number) {\n    this._hostElement.max = v + '';\n    this._cdr.detectChanges();\n  }\n\n  get step(): number {\n    return numberAttribute(this._hostElement.step, 0);\n  }\n  set step(v: number) {\n    this._hostElement.step = v + '';\n    this._cdr.detectChanges();\n  }\n\n  /** @docs-private */\n  get disabled(): boolean {\n    return booleanAttribute(this._hostElement.disabled);\n  }\n  set disabled(v: boolean) {\n    this._hostElement.disabled = v;\n    this._cdr.detectChanges();\n\n    if (this._slider.disabled !== this.disabled) {\n      this._slider.disabled = this.disabled;\n    }\n  }\n\n  /** The percentage of the slider that coincides with the value. */\n  get percentage(): number {\n    if (this._slider.min >= this._slider.max) {\n      return this._slider._isRtl ? 1 : 0;\n    }\n    return (this.value - this._slider.min) / (this._slider.max - this._slider.min);\n  }\n\n  /** @docs-private */\n  get fillPercentage(): number {\n    if (!this._slider._cachedWidth) {\n      return this._slider._isRtl ? 1 : 0;\n    }\n    if (this._translateX === 0) {\n      return 0;\n    }\n    return this.translateX / this._slider._cachedWidth;\n  }\n\n  /** The host native HTML input element. */\n  _hostElement = this._elementRef.nativeElement;\n\n  /** The aria-valuetext string representation of the input's value. */\n  _valuetext = signal('');\n\n  /** The radius of a native html slider's knob. */\n  _knobRadius: number = 8;\n\n  /** The distance in px from the start of the slider track to the first tick mark. */\n  _tickMarkOffset = 3;\n\n  /** Whether user's cursor is currently in a mouse down state on the input. */\n  _isActive: boolean = false;\n\n  /** Whether the input is currently focused (either by tab or after clicking). */\n  _isFocused: boolean = false;\n\n  /** Used to relay updates to _isFocused to the slider visual thumbs. */\n  private _setIsFocused(v: boolean): void {\n    this._isFocused = v;\n  }\n\n  /**\n   * Whether the initial value has been set.\n   * This exists because the initial value cannot be immediately set because the min and max\n   * must first be relayed from the parent MatSlider component, which can only happen later\n   * in the component lifecycle.\n   */\n  private _hasSetInitialValue: boolean = false;\n\n  /** The stored initial value. */\n  _initialValue: string | undefined;\n\n  /** Defined when a user is using a form control to manage slider value & validation. */\n  private _formControl: FormControl | undefined;\n\n  /** Emits when the component is destroyed. */\n  protected readonly _destroyed = new Subject<void>();\n\n  /**\n   * Indicates whether UI updates should be skipped.\n   *\n   * This flag is used to avoid flickering\n   * when correcting values on pointer up/down.\n   */\n  _skipUIUpdate: boolean = false;\n\n  /** Callback called when the slider input value changes. */\n  protected _onChangeFn: ((value: any) => void) | undefined;\n\n  /** Callback called when the slider input has been touched. */\n  private _onTouchedFn: () => void = () => {};\n\n  /**\n   * Whether the NgModel has been initialized.\n   *\n   * This flag is used to ignore ghost null calls to\n   * writeValue which can break slider initialization.\n   *\n   * See https://github.com/angular/angular/issues/14988.\n   */\n  protected _isControlInitialized = false;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const renderer = inject(Renderer2);\n\n    this._ngZone.runOutsideAngular(() => {\n      this._listenerCleanups = [\n        renderer.listen(this._hostElement, 'pointerdown', this._onPointerDown.bind(this)),\n        renderer.listen(this._hostElement, 'pointermove', this._onPointerMove.bind(this)),\n        renderer.listen(this._hostElement, 'pointerup', this._onPointerUp.bind(this)),\n      ];\n    });\n  }\n\n  ngOnDestroy(): void {\n    this._listenerCleanups.forEach(cleanup => cleanup());\n    this._destroyed.next();\n    this._destroyed.complete();\n    this.dragStart.complete();\n    this.dragEnd.complete();\n  }\n\n  /** @docs-private */\n  initProps(): void {\n    this._updateWidthInactive();\n\n    // If this or the parent slider is disabled, just make everything disabled.\n    if (this.disabled !== this._slider.disabled) {\n      // The MatSlider setter for disabled will relay this and disable both inputs.\n      this._slider.disabled = true;\n    }\n\n    this.step = this._slider.step;\n    this.min = this._slider.min;\n    this.max = this._slider.max;\n    this._initValue();\n  }\n\n  /** @docs-private */\n  initUI(): void {\n    this._updateThumbUIByValue();\n  }\n\n  _initValue(): void {\n    this._hasSetInitialValue = true;\n    if (this._initialValue === undefined) {\n      this.value = this._getDefaultValue();\n    } else {\n      this._hostElement.value = this._initialValue;\n      this._updateThumbUIByValue();\n      this._slider._onValueChange(this);\n      this._cdr.detectChanges();\n    }\n  }\n\n  _getDefaultValue(): number {\n    return this.min;\n  }\n\n  _onBlur(): void {\n    this._setIsFocused(false);\n    this._onTouchedFn();\n  }\n\n  _onFocus(): void {\n    this._slider._setTransition(false);\n    this._slider._updateTrackUI(this);\n    this._setIsFocused(true);\n  }\n\n  _onChange(): void {\n    this.valueChange.emit(this.value);\n    // only used to handle the edge case where user\n    // mousedown on the slider then uses arrow keys.\n    if (this._isActive) {\n      this._updateThumbUIByValue({withAnimation: true});\n    }\n  }\n\n  _onInput(): void {\n    this._onChangeFn?.(this.value);\n    // handles arrowing and updating the value when\n    // a step is defined.\n    if (this._slider.step || !this._isActive) {\n      this._updateThumbUIByValue({withAnimation: true});\n    }\n    this._slider._onValueChange(this);\n  }\n\n  _onNgControlValueChange(): void {\n    // only used to handle when the value change\n    // originates outside of the slider.\n    if (!this._isActive || !this._isFocused) {\n      this._slider._onValueChange(this);\n      this._updateThumbUIByValue();\n    }\n    this._slider.disabled = this._formControl!.disabled;\n  }\n\n  _onPointerDown(event: PointerEvent): void {\n    if (this.disabled || event.button !== 0) {\n      return;\n    }\n\n    // On IOS, dragging only works if the pointer down happens on the\n    // slider thumb and the slider does not receive focus from pointer events.\n    if (this._platform.IOS) {\n      const isCursorOnSliderThumb = this._slider._isCursorOnSliderThumb(\n        event,\n        this._slider._getThumb(this.thumbPosition)._hostElement.getBoundingClientRect(),\n      );\n\n      this._isActive = isCursorOnSliderThumb;\n      this._updateWidthActive();\n      this._slider._updateDimensions();\n      return;\n    }\n\n    this._isActive = true;\n    this._setIsFocused(true);\n    this._updateWidthActive();\n    this._slider._updateDimensions();\n\n    // Does nothing if a step is defined because we\n    // want the value to snap to the values on input.\n    if (!this._slider.step) {\n      this._updateThumbUIByPointerEvent(event, {withAnimation: true});\n    }\n\n    if (!this.disabled) {\n      this._handleValueCorrection(event);\n      this.dragStart.emit({source: this, parent: this._slider, value: this.value});\n    }\n  }\n\n  /**\n   * Corrects the value of the slider on pointer up/down.\n   *\n   * Called on pointer down and up because the value is set based\n   * on the inactive width instead of the active width.\n   */\n  private _handleValueCorrection(event: PointerEvent): void {\n    // Don't update the UI with the current value! The value on pointerdown\n    // and pointerup is calculated in the split second before the input(s)\n    // resize. See _updateWidthInactive() and _updateWidthActive() for more\n    // details.\n    this._skipUIUpdate = true;\n\n    // Note that this function gets triggered before the actual value of the\n    // slider is updated. This means if we were to set the value here, it\n    // would immediately be overwritten. Using setTimeout ensures the setting\n    // of the value happens after the value has been updated by the\n    // pointerdown event.\n    setTimeout(() => {\n      this._skipUIUpdate = false;\n      this._fixValue(event);\n    }, 0);\n  }\n\n  /** Corrects the value of the slider based on the pointer event's position. */\n  _fixValue(event: PointerEvent): void {\n    const xPos = event.clientX - this._slider._cachedLeft;\n    const width = this._slider._cachedWidth;\n    const step = this._slider.step === 0 ? 1 : this._slider.step;\n    const numSteps = Math.floor((this._slider.max - this._slider.min) / step);\n    const percentage = this._slider._isRtl ? 1 - xPos / width : xPos / width;\n\n    // To ensure the percentage is rounded to the necessary number of decimals.\n    const fixedPercentage = Math.round(percentage * numSteps) / numSteps;\n\n    const impreciseValue =\n      fixedPercentage * (this._slider.max - this._slider.min) + this._slider.min;\n    const value = Math.round(impreciseValue / step) * step;\n    const prevValue = this.value;\n\n    if (value === prevValue) {\n      // Because we prevented UI updates, if it turns out that the race\n      // condition didn't happen and the value is already correct, we\n      // have to apply the ui updates now.\n      this._slider._onValueChange(this);\n      this._slider.step > 0\n        ? this._updateThumbUIByValue()\n        : this._updateThumbUIByPointerEvent(event, {withAnimation: this._slider._hasAnimation});\n      return;\n    }\n\n    this.value = value;\n    this.valueChange.emit(this.value);\n    this._onChangeFn?.(this.value);\n    this._slider._onValueChange(this);\n    this._slider.step > 0\n      ? this._updateThumbUIByValue()\n      : this._updateThumbUIByPointerEvent(event, {withAnimation: this._slider._hasAnimation});\n  }\n\n  _onPointerMove(event: PointerEvent): void {\n    // Again, does nothing if a step is defined because\n    // we want the value to snap to the values on input.\n    if (!this._slider.step && this._isActive) {\n      this._updateThumbUIByPointerEvent(event);\n    }\n  }\n\n  _onPointerUp(): void {\n    if (this._isActive) {\n      this._isActive = false;\n      if (this._platform.SAFARI) {\n        this._setIsFocused(false);\n      }\n      this.dragEnd.emit({source: this, parent: this._slider, value: this.value});\n\n      // This setTimeout is to prevent the pointerup from triggering a value\n      // change on the input based on the inactive width. It's not clear why\n      // but for some reason on IOS this race condition is even more common so\n      // the timeout needs to be increased.\n      setTimeout(() => this._updateWidthInactive(), this._platform.IOS ? 10 : 0);\n    }\n  }\n\n  _clamp(v: number): number {\n    const min = this._tickMarkOffset;\n    const max = this._slider._cachedWidth - this._tickMarkOffset;\n    return Math.max(Math.min(v, max), min);\n  }\n\n  _calcTranslateXByValue(): number {\n    if (this._slider._isRtl) {\n      return (\n        (1 - this.percentage) * (this._slider._cachedWidth - this._tickMarkOffset * 2) +\n        this._tickMarkOffset\n      );\n    }\n    return (\n      this.percentage * (this._slider._cachedWidth - this._tickMarkOffset * 2) +\n      this._tickMarkOffset\n    );\n  }\n\n  _calcTranslateXByPointerEvent(event: PointerEvent): number {\n    return event.clientX - this._slider._cachedLeft;\n  }\n\n  /**\n   * Used to set the slider width to the correct\n   * dimensions while the user is dragging.\n   */\n  _updateWidthActive(): void {}\n\n  /**\n   * Sets the slider input to disproportionate dimensions to allow for touch\n   * events to be captured on touch devices.\n   */\n  _updateWidthInactive(): void {\n    this._hostElement.style.padding = `0 ${this._slider._inputPadding}px`;\n    this._hostElement.style.width = `calc(100% + ${\n      this._slider._inputPadding - this._tickMarkOffset * 2\n    }px)`;\n    this._hostElement.style.left = `-${this._slider._rippleRadius - this._tickMarkOffset}px`;\n  }\n\n  _updateThumbUIByValue(options?: {withAnimation: boolean}): void {\n    this.translateX = this._clamp(this._calcTranslateXByValue());\n    this._updateThumbUI(options);\n  }\n\n  _updateThumbUIByPointerEvent(event: PointerEvent, options?: {withAnimation: boolean}): void {\n    this.translateX = this._clamp(this._calcTranslateXByPointerEvent(event));\n    this._updateThumbUI(options);\n  }\n\n  _updateThumbUI(options?: {withAnimation: boolean}) {\n    this._slider._setTransition(!!options?.withAnimation);\n    this._slider._onTranslateXChange(this);\n  }\n\n  /**\n   * Sets the input's value.\n   * @param value The new value of the input\n   * @docs-private\n   */\n  writeValue(value: any): void {\n    if (this._isControlInitialized || value !== null) {\n      this.value = value;\n    }\n  }\n\n  /**\n   * Registers a callback to be invoked when the input's value changes from user input.\n   * @param fn The callback to register\n   * @docs-private\n   */\n  registerOnChange(fn: any): void {\n    this._onChangeFn = fn;\n    this._isControlInitialized = true;\n  }\n\n  /**\n   * Registers a callback to be invoked when the input is blurred by the user.\n   * @param fn The callback to register\n   * @docs-private\n   */\n  registerOnTouched(fn: any): void {\n    this._onTouchedFn = fn;\n  }\n\n  /**\n   * Sets the disabled state of the slider.\n   * @param isDisabled The new disabled state\n   * @docs-private\n   */\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  focus(): void {\n    this._hostElement.focus();\n  }\n\n  blur(): void {\n    this._hostElement.blur();\n  }\n}\n\n@Directive({\n  selector: 'input[matSliderStartThumb], input[matSliderEndThumb]',\n  exportAs: 'matSliderRangeThumb',\n  providers: [\n    MAT_SLIDER_RANGE_THUMB_VALUE_ACCESSOR,\n    {provide: MAT_SLIDER_RANGE_THUMB, useExisting: MatSliderRangeThumb},\n  ],\n})\nexport class MatSliderRangeThumb extends MatSliderThumb implements _MatSliderRangeThumb {\n  override readonly _cdr = inject(ChangeDetectorRef);\n\n  /** @docs-private */\n  getSibling(): _MatSliderRangeThumb | undefined {\n    if (!this._sibling) {\n      this._sibling = this._slider._getInput(this._isEndThumb ? _MatThumb.START : _MatThumb.END) as\n        | MatSliderRangeThumb\n        | undefined;\n    }\n    return this._sibling;\n  }\n  private _sibling: MatSliderRangeThumb | undefined;\n\n  /**\n   * Returns the minimum translateX position allowed for this slider input's visual thumb.\n   * @docs-private\n   */\n  getMinPos(): number {\n    const sibling = this.getSibling();\n    if (!this._isLeftThumb && sibling) {\n      return sibling.translateX;\n    }\n    return this._tickMarkOffset;\n  }\n\n  /**\n   * Returns the maximum translateX position allowed for this slider input's visual thumb.\n   * @docs-private\n   */\n  getMaxPos(): number {\n    const sibling = this.getSibling();\n    if (this._isLeftThumb && sibling) {\n      return sibling.translateX;\n    }\n    return this._slider._cachedWidth - this._tickMarkOffset;\n  }\n\n  _setIsLeftThumb(): void {\n    this._isLeftThumb =\n      (this._isEndThumb && this._slider._isRtl) || (!this._isEndThumb && !this._slider._isRtl);\n  }\n\n  /** Whether this slider corresponds to the input on the left hand side. */\n  _isLeftThumb: boolean;\n\n  /** Whether this slider corresponds to the input with greater value. */\n  _isEndThumb: boolean;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    super();\n\n    this._isEndThumb = this._hostElement.hasAttribute('matSliderEndThumb');\n    this._setIsLeftThumb();\n    this.thumbPosition = this._isEndThumb ? _MatThumb.END : _MatThumb.START;\n  }\n\n  override _getDefaultValue(): number {\n    return this._isEndThumb && this._slider._isRange ? this.max : this.min;\n  }\n\n  override _onInput(): void {\n    super._onInput();\n    this._updateSibling();\n    if (!this._isActive) {\n      this._updateWidthInactive();\n    }\n  }\n\n  override _onNgControlValueChange(): void {\n    super._onNgControlValueChange();\n    this.getSibling()?._updateMinMax();\n  }\n\n  override _onPointerDown(event: PointerEvent): void {\n    if (this.disabled || event.button !== 0) {\n      return;\n    }\n    if (this._sibling) {\n      this._sibling._updateWidthActive();\n      this._sibling._hostElement.classList.add('mat-mdc-slider-input-no-pointer-events');\n    }\n    super._onPointerDown(event);\n  }\n\n  override _onPointerUp(): void {\n    super._onPointerUp();\n    if (this._sibling) {\n      setTimeout(() => {\n        this._sibling!._updateWidthInactive();\n        this._sibling!._hostElement.classList.remove('mat-mdc-slider-input-no-pointer-events');\n      });\n    }\n  }\n\n  override _onPointerMove(event: PointerEvent): void {\n    super._onPointerMove(event);\n    if (!this._slider.step && this._isActive) {\n      this._updateSibling();\n    }\n  }\n\n  override _fixValue(event: PointerEvent): void {\n    super._fixValue(event);\n    this._sibling?._updateMinMax();\n  }\n\n  override _clamp(v: number): number {\n    return Math.max(Math.min(v, this.getMaxPos()), this.getMinPos());\n  }\n\n  _updateMinMax(): void {\n    const sibling = this.getSibling();\n    if (!sibling) {\n      return;\n    }\n    if (this._isEndThumb) {\n      this.min = Math.max(this._slider.min, sibling.value);\n      this.max = this._slider.max;\n    } else {\n      this.min = this._slider.min;\n      this.max = Math.min(this._slider.max, sibling.value);\n    }\n  }\n\n  override _updateWidthActive(): void {\n    const minWidth = this._slider._rippleRadius * 2 - this._slider._inputPadding * 2;\n    const maxWidth =\n      this._slider._cachedWidth + this._slider._inputPadding - minWidth - this._tickMarkOffset * 2;\n    const percentage =\n      this._slider.min < this._slider.max\n        ? (this.max - this.min) / (this._slider.max - this._slider.min)\n        : 1;\n    const width = maxWidth * percentage + minWidth;\n    this._hostElement.style.width = `${width}px`;\n    this._hostElement.style.padding = `0 ${this._slider._inputPadding}px`;\n  }\n\n  override _updateWidthInactive(): void {\n    const sibling = this.getSibling();\n    if (!sibling) {\n      return;\n    }\n    const maxWidth = this._slider._cachedWidth - this._tickMarkOffset * 2;\n    const midValue = this._isEndThumb\n      ? this.value - (this.value - sibling.value) / 2\n      : this.value + (sibling.value - this.value) / 2;\n\n    const _percentage = this._isEndThumb\n      ? (this.max - midValue) / (this._slider.max - this._slider.min)\n      : (midValue - this.min) / (this._slider.max - this._slider.min);\n\n    const percentage = this._slider.min < this._slider.max ? _percentage : 1;\n\n    // Extend the native input width by the radius of the ripple\n    let ripplePadding = this._slider._rippleRadius;\n\n    // If one of the inputs is maximally sized (the value of both thumbs is\n    // equal to the min or max), make that input take up all of the width and\n    // make the other unselectable.\n    if (percentage === 1) {\n      ripplePadding = 48;\n    } else if (percentage === 0) {\n      ripplePadding = 0;\n    }\n\n    const width = maxWidth * percentage + ripplePadding;\n    this._hostElement.style.width = `${width}px`;\n    this._hostElement.style.padding = '0px';\n\n    if (this._isLeftThumb) {\n      this._hostElement.style.left = `-${this._slider._rippleRadius - this._tickMarkOffset}px`;\n      this._hostElement.style.right = 'auto';\n    } else {\n      this._hostElement.style.left = 'auto';\n      this._hostElement.style.right = `-${this._slider._rippleRadius - this._tickMarkOffset}px`;\n    }\n  }\n\n  _updateStaticStyles(): void {\n    this._hostElement.classList.toggle('mat-slider__right-input', !this._isLeftThumb);\n  }\n\n  private _updateSibling(): void {\n    const sibling = this.getSibling();\n    if (!sibling) {\n      return;\n    }\n    sibling._updateMinMax();\n    if (this._isActive) {\n      sibling._updateWidthActive();\n    } else {\n      sibling._updateWidthInactive();\n    }\n  }\n\n  /**\n   * Sets the input's value.\n   * @param value The new value of the input\n   * @docs-private\n   */\n  override writeValue(value: any): void {\n    if (this._isControlInitialized || value !== null) {\n      this.value = value;\n      this._updateWidthInactive();\n      this._updateSibling();\n    }\n  }\n\n  override _setValue(value: string) {\n    super._setValue(value);\n    this._updateWidthInactive();\n    this._updateSibling();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {BidiModule} from '@angular/cdk/bidi';\nimport {NgModule} from '@angular/core';\nimport {MatRippleModule} from '../core';\nimport {MatSlider} from './slider';\nimport {MatSliderVisualThumb} from './slider-thumb';\nimport {MatSliderThumb, MatSliderRangeThumb} from './slider-input';\n\n@NgModule({\n  imports: [MatRippleModule, MatSlider, MatSliderThumb, MatSliderRangeThumb, MatSliderVisualThumb],\n  exports: [MatSlider, MatSliderThumb, MatSliderRangeThumb, BidiModule],\n})\nexport class MatSliderModule {}\n"],"names":["_MatThumb","_MatTickMark","MAT_SLIDER","InjectionToken","MAT_SLIDER_VISUAL_THUMB","MatSliderChange","MatSliderVisualThumb","thumbPosition","valueIndicatorText","_knob","_focusRippleRef","_isHovered","_hostElement","inject","ElementRef","nativeElement","_platform","Platform","ngAfterViewInit","sliderInput","_slider","_getInput","radius","_sliderInputEl","_sliderInput","runOutsideAngular","renderer","_renderer","_listenerCleanups","listen","input","_onPointerMove","_onDragStart","_onMouseLeave","_onFocus","_onBlur","forEach","cleanup","event","_isFocused","getBoundingClientRect","isHovered","_isCursorOnSliderThumb","rect","_showHoverRipple","_hideRipple","_hoverRippleRef","_showFocusRipple","classList","add","_isActive","button","_onDragEnd","_activeRippleRef","SAFARI","_isShowingRipple","_showRipple","enterDuration","exitDuration","element","rippleRef","state","RippleState","FADING_IN","VISIBLE","END","START","providers","provide","useExisting","imports","MatRipple","template","styles","ViewChild","type","MatSlider","disabled","_disabled","v","startInput","_discrete","_updateValueIndicatorUIs","_showTickMarks","showTickMarks","value","_hasViewInitialized","_updateTickMarkTrackUI","min","_min","_onMinMaxOrStepChange","_updateMinRange","endInput","oldEndValue","oldStartValue","new","max","Math","_updateWidthInactive","old","_onTranslateXChangeBySideEffect","_onValueChange","_updateMinNonRange","oldValue","_updateThumbUIByValue","_max","undefined","isNaN","_updateMax","_isRange","_updateMaxRange","prevMax","_updateMaxNonRange","_updateTrackUI","_step","step","_updateStep","_updateStepRange","prevStartValue","_updateStepNonRange","_tickMarks","_cachedLeft","startValueIndicatorText","_tickMarkTrackWidth","_resizeTimer","_dir","change","subscribe","_onDirChange","_isRtl","isBrowser","eInput","sInput","ngDevMode","thumb","_getThumb","_rippleRadius","_ripple","_knobRadius","_initUIRange","_initUINonRange","initUI","_updateValueIndicatorUI","initProps","_updateMinMax","ngOnDestroy","_dirChangeSubscription","unsubscribe","_resizeObserver","_onDirChangeRange","_onDirChangeNonRange","_updateTickMarkUI","_setIsLeftThumb","translateX","_calcTranslateXByValue","_updateStaticStyles","_observeHostResize","_onResize","observe","_elementRef","_getValue","_skipUpdate","_skipUIUpdate","_updateDimensions","_cachedWidth","offsetWidth","style","left","trackStyle","right","transformOrigin","_calcTickMarkTransform","index","length","offset","source","_updateOverlappingThumbUI","input2","input1","detectChanges","_areThumbsOverlapping","sibling","getSibling","displayWith","_valuetext","set","valuetext","setAttribute","discrete","endValueIndicatorText","visualThumb","changeDetection","ChangeDetectionStrategy","OnPush","encapsulation","ViewEncapsulation","None","ctorParameters","propDecorators","_trackActive","MAT_SLIDER_THUMB","ContentChildren","MAT_SLIDER_RANGE_THUMB","descendants","Input","transform","booleanAttribute","numberAttribute","args","_validateInputs","isRange","endInputElement","startInputElement","hasAttribute","endValid","NG_VALUE_ACCESSOR","multi","MAT_SLIDER_RANGE_THUMB_VALUE_ACCESSOR","forwardRef","MatSliderRangeThumb","_getDefaultValue","stringValue","_hasSetInitialValue","_initialValue","_setValue","EventEmitter","_translateX","_tickMarkOffset","_cdr","fillPercentage","signal","debugName","Subject","bind","_onPointerUp","next","complete","dragEnd","_initValue","_setTransition","_setIsFocused","withAnimation","_onInput","_onChangeFn","_onNgControlValueChange","_formControl","isCursorOnSliderThumb","_updateWidthActive","_updateThumbUIByPointerEvent","dragStart","emit","parent","_handleValueCorrection","setTimeout","width","numSteps","floor","percentage","xPos","prevValue","_hasAnimation","valueChange","IOS","_calcTranslateXByPointerEvent","clientX","padding","_inputPadding","_clamp","options","_updateThumbUI","writeValue","registerOnChange","fn","_isControlInitialized","_onTouchedFn","setDisabledState","isDisabled","blur","MAT_SLIDER_THUMB_VALUE_ACCESSOR","MatSliderThumb","host","Output","_sibling","_isEndThumb","getMinPos","_isLeftThumb","constructor","_onPointerDown","remove","selector","fac","i0","ngDeclareFactory","minVersion","version","ngImport","MatSliderModule","deps","target","FactoryTarget","NgModule","decorators"],"mappings":"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"}