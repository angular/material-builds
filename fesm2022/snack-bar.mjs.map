{"version":3,"file":"snack-bar.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/snack-bar/snack-bar-ref.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/snack-bar/snack-bar-config.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/snack-bar/snack-bar-content.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/snack-bar/simple-snack-bar.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/snack-bar/snack-bar-container.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/snack-bar/snack-bar.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/snack-bar/snack-bar-module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {OverlayRef} from '@angular/cdk/overlay';\nimport {Observable, Subject} from 'rxjs';\nimport {MatSnackBarContainer} from './snack-bar-container';\n\n/** Event that is emitted when a snack bar is dismissed. */\nexport interface MatSnackBarDismiss {\n  /** Whether the snack bar was dismissed using the action button. */\n  dismissedByAction: boolean;\n}\n\n/** Maximum amount of milliseconds that can be passed into setTimeout. */\nconst MAX_TIMEOUT = Math.pow(2, 31) - 1;\n\n/**\n * Reference to a snack bar dispatched from the snack bar service.\n */\nexport class MatSnackBarRef<T> {\n  /** The instance of the component making up the content of the snack bar. */\n  instance: T;\n\n  /**\n   * The instance of the component making up the content of the snack bar.\n   * @docs-private\n   */\n  containerInstance: MatSnackBarContainer;\n\n  /** Subject for notifying the user that the snack bar has been dismissed. */\n  private readonly _afterDismissed = new Subject<MatSnackBarDismiss>();\n\n  /** Subject for notifying the user that the snack bar has opened and appeared. */\n  private readonly _afterOpened = new Subject<void>();\n\n  /** Subject for notifying the user that the snack bar action was called. */\n  private readonly _onAction = new Subject<void>();\n\n  /**\n   * Timeout ID for the duration setTimeout call. Used to clear the timeout if the snackbar is\n   * dismissed before the duration passes.\n   */\n  private _durationTimeoutId: ReturnType<typeof setTimeout>;\n\n  /** Whether the snack bar was dismissed using the action button. */\n  private _dismissedByAction = false;\n\n  constructor(\n    containerInstance: MatSnackBarContainer,\n    private _overlayRef: OverlayRef,\n  ) {\n    this.containerInstance = containerInstance;\n    containerInstance._onExit.subscribe(() => this._finishDismiss());\n  }\n\n  /** Dismisses the snack bar. */\n  dismiss(): void {\n    if (!this._afterDismissed.closed) {\n      this.containerInstance.exit();\n    }\n    clearTimeout(this._durationTimeoutId);\n  }\n\n  /** Marks the snackbar action clicked. */\n  dismissWithAction(): void {\n    if (!this._onAction.closed) {\n      this._dismissedByAction = true;\n      this._onAction.next();\n      this._onAction.complete();\n      this.dismiss();\n    }\n    clearTimeout(this._durationTimeoutId);\n  }\n\n  /**\n   * Marks the snackbar action clicked.\n   * @deprecated Use `dismissWithAction` instead.\n   * @breaking-change 8.0.0\n   */\n  closeWithAction(): void {\n    this.dismissWithAction();\n  }\n\n  /** Dismisses the snack bar after some duration */\n  _dismissAfter(duration: number): void {\n    // Note that we need to cap the duration to the maximum value for setTimeout, because\n    // it'll revert to 1 if somebody passes in something greater (e.g. `Infinity`). See #17234.\n    this._durationTimeoutId = setTimeout(() => this.dismiss(), Math.min(duration, MAX_TIMEOUT));\n  }\n\n  /** Marks the snackbar as opened */\n  _open(): void {\n    if (!this._afterOpened.closed) {\n      this._afterOpened.next();\n      this._afterOpened.complete();\n    }\n  }\n\n  /** Cleans up the DOM after closing. */\n  private _finishDismiss(): void {\n    this._overlayRef.dispose();\n\n    if (!this._onAction.closed) {\n      this._onAction.complete();\n    }\n\n    this._afterDismissed.next({dismissedByAction: this._dismissedByAction});\n    this._afterDismissed.complete();\n    this._dismissedByAction = false;\n  }\n\n  /** Gets an observable that is notified when the snack bar is finished closing. */\n  afterDismissed(): Observable<MatSnackBarDismiss> {\n    return this._afterDismissed;\n  }\n\n  /** Gets an observable that is notified when the snack bar has opened and appeared. */\n  afterOpened(): Observable<void> {\n    return this.containerInstance._onEnter;\n  }\n\n  /** Gets an observable that is notified when the snack bar action is called. */\n  onAction(): Observable<void> {\n    return this._onAction;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ViewContainerRef, InjectionToken} from '@angular/core';\nimport {AriaLivePoliteness} from '@angular/cdk/a11y';\nimport {Direction} from '@angular/cdk/bidi';\n\n/** Injection token that can be used to access the data that was passed in to a snack bar. */\nexport const MAT_SNACK_BAR_DATA = new InjectionToken<any>('MatSnackBarData');\n\n/** Possible values for horizontalPosition on MatSnackBarConfig. */\nexport type MatSnackBarHorizontalPosition = 'start' | 'center' | 'end' | 'left' | 'right';\n\n/** Possible values for verticalPosition on MatSnackBarConfig. */\nexport type MatSnackBarVerticalPosition = 'top' | 'bottom';\n\n/**\n * Configuration used when opening a snack-bar.\n */\nexport class MatSnackBarConfig<D = any> {\n  /** The politeness level for the MatAriaLiveAnnouncer announcement. */\n  politeness?: AriaLivePoliteness = 'polite';\n\n  /**\n   * Message to be announced by the LiveAnnouncer. When opening a snackbar without a custom\n   * component or template, the announcement message will default to the specified message.\n   */\n  announcementMessage?: string = '';\n\n  /**\n   * The view container that serves as the parent for the snackbar for the purposes of dependency\n   * injection. Note: this does not affect where the snackbar is inserted in the DOM.\n   */\n  viewContainerRef?: ViewContainerRef;\n\n  /** The length of time in milliseconds to wait before automatically dismissing the snack bar. */\n  duration?: number = 0;\n\n  /** Extra CSS classes to be added to the snack bar container. */\n  panelClass?: string | string[];\n\n  /** Text layout direction for the snack bar. */\n  direction?: Direction;\n\n  /** Data being injected into the child component. */\n  data?: D | null = null;\n\n  /** The horizontal position to place the snack bar. */\n  horizontalPosition?: MatSnackBarHorizontalPosition = 'center';\n\n  /** The vertical position to place the snack bar. */\n  verticalPosition?: MatSnackBarVerticalPosition = 'bottom';\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive} from '@angular/core';\n\n/** Directive that should be applied to the text element to be rendered in the snack bar. */\n@Directive({\n  selector: `[matSnackBarLabel]`,\n  host: {\n    'class': 'mat-mdc-snack-bar-label mdc-snackbar__label',\n  },\n})\nexport class MatSnackBarLabel {}\n\n/** Directive that should be applied to the element containing the snack bar's action buttons. */\n@Directive({\n  selector: `[matSnackBarActions]`,\n  host: {\n    'class': 'mat-mdc-snack-bar-actions mdc-snackbar__actions',\n  },\n})\nexport class MatSnackBarActions {}\n\n/** Directive that should be applied to each of the snack bar's action buttons. */\n@Directive({\n  selector: `[matSnackBarAction]`,\n  host: {\n    'class': 'mat-mdc-snack-bar-action mdc-snackbar__action',\n  },\n})\nexport class MatSnackBarAction {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ChangeDetectionStrategy, Component, ViewEncapsulation, inject} from '@angular/core';\nimport {MatButton} from '../button';\nimport {MatSnackBarRef} from './snack-bar-ref';\nimport {MAT_SNACK_BAR_DATA} from './snack-bar-config';\nimport {MatSnackBarAction, MatSnackBarActions, MatSnackBarLabel} from './snack-bar-content';\n\n/**\n * Interface for a simple snack bar component that has a message and a single action.\n */\nexport interface TextOnlySnackBar {\n  data: {message: string; action: string};\n  snackBarRef: MatSnackBarRef<TextOnlySnackBar>;\n  action: () => void;\n  hasAction: boolean;\n}\n\n@Component({\n  selector: 'simple-snack-bar',\n  templateUrl: 'simple-snack-bar.html',\n  styleUrl: 'simple-snack-bar.css',\n  exportAs: 'matSnackBar',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [MatButton, MatSnackBarLabel, MatSnackBarActions, MatSnackBarAction],\n  host: {\n    'class': 'mat-mdc-simple-snack-bar',\n  },\n})\nexport class SimpleSnackBar implements TextOnlySnackBar {\n  snackBarRef = inject<MatSnackBarRef<SimpleSnackBar>>(MatSnackBarRef);\n  data = inject(MAT_SNACK_BAR_DATA);\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  /** Performs the action on the snack bar. */\n  action(): void {\n    this.snackBarRef.dismissWithAction();\n  }\n\n  /** If the action button should be shown. */\n  get hasAction(): boolean {\n    return !!this.data.action;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {_IdGenerator, AriaLivePoliteness} from '@angular/cdk/a11y';\nimport {Platform} from '@angular/cdk/platform';\nimport {\n  BasePortalOutlet,\n  CdkPortalOutlet,\n  ComponentPortal,\n  DomPortal,\n  TemplatePortal,\n} from '@angular/cdk/portal';\n\nimport {\n  afterNextRender,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ComponentRef,\n  ElementRef,\n  EmbeddedViewRef,\n  inject,\n  Injector,\n  NgZone,\n  OnDestroy,\n  ViewChild,\n  ViewEncapsulation,\n  DOCUMENT,\n} from '@angular/core';\nimport {Observable, of, Subject} from 'rxjs';\nimport {_animationsDisabled} from '../core';\nimport {MatSnackBarConfig} from './snack-bar-config';\n\nconst ENTER_ANIMATION = '_mat-snack-bar-enter';\nconst EXIT_ANIMATION = '_mat-snack-bar-exit';\n\n/**\n * Internal component that wraps user-provided snack bar content.\n * @docs-private\n */\n@Component({\n  selector: 'mat-snack-bar-container',\n  templateUrl: 'snack-bar-container.html',\n  styleUrl: 'snack-bar-container.css',\n  // In Ivy embedded views will be change detected from their declaration place, rather than\n  // where they were stamped out. This means that we can't have the snack bar container be OnPush,\n  // because it might cause snack bars that were opened from a template not to be out of date.\n  // tslint:disable-next-line:validate-decorators\n  changeDetection: ChangeDetectionStrategy.Default,\n  encapsulation: ViewEncapsulation.None,\n  imports: [CdkPortalOutlet],\n  host: {\n    'class': 'mdc-snackbar mat-mdc-snack-bar-container',\n    '[class.mat-snack-bar-container-enter]': '_animationState === \"visible\"',\n    '[class.mat-snack-bar-container-exit]': '_animationState === \"hidden\"',\n    '[class.mat-snack-bar-container-animations-enabled]': '!_animationsDisabled',\n    '(animationend)': 'onAnimationEnd($event.animationName)',\n    '(animationcancel)': 'onAnimationEnd($event.animationName)',\n  },\n})\nexport class MatSnackBarContainer extends BasePortalOutlet implements OnDestroy {\n  private _ngZone = inject(NgZone);\n  readonly _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  private _changeDetectorRef = inject(ChangeDetectorRef);\n  private _platform = inject(Platform);\n  protected _animationsDisabled = _animationsDisabled();\n  snackBarConfig = inject(MatSnackBarConfig);\n\n  private _document = inject(DOCUMENT);\n  private _trackedModals = new Set<Element>();\n  private _enterFallback: ReturnType<typeof setTimeout> | undefined;\n  private _exitFallback: ReturnType<typeof setTimeout> | undefined;\n  private _injector = inject(Injector);\n\n  /** The number of milliseconds to wait before announcing the snack bar's content. */\n  private readonly _announceDelay: number = 150;\n\n  /** The timeout for announcing the snack bar's content. */\n  private _announceTimeoutId: ReturnType<typeof setTimeout>;\n\n  /** Whether the component has been destroyed. */\n  private _destroyed = false;\n\n  /** The portal outlet inside of this container into which the snack bar content will be loaded. */\n  @ViewChild(CdkPortalOutlet, {static: true}) _portalOutlet: CdkPortalOutlet;\n\n  /** Subject for notifying that the snack bar has announced to screen readers. */\n  readonly _onAnnounce: Subject<void> = new Subject();\n\n  /** Subject for notifying that the snack bar has exited from view. */\n  readonly _onExit: Subject<void> = new Subject();\n\n  /** Subject for notifying that the snack bar has finished entering the view. */\n  readonly _onEnter: Subject<void> = new Subject();\n\n  /** The state of the snack bar animations. */\n  _animationState = 'void';\n\n  /** aria-live value for the live region. */\n  _live: AriaLivePoliteness;\n\n  /**\n   * Element that will have the `mdc-snackbar__label` class applied if the attached component\n   * or template does not have it. This ensures that the appropriate structure, typography, and\n   * color is applied to the attached view.\n   */\n  @ViewChild('label', {static: true}) _label: ElementRef;\n\n  /**\n   * Role of the live region. This is only for Firefox as there is a known issue where Firefox +\n   * JAWS does not read out aria-live message.\n   */\n  _role?: 'status' | 'alert';\n\n  /** Unique ID of the aria-live element. */\n  readonly _liveElementId = inject(_IdGenerator).getId('mat-snack-bar-container-live-');\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    super();\n    const config = this.snackBarConfig;\n\n    // Use aria-live rather than a live role like 'alert' or 'status'\n    // because NVDA and JAWS have show inconsistent behavior with live roles.\n    if (config.politeness === 'assertive' && !config.announcementMessage) {\n      this._live = 'assertive';\n    } else if (config.politeness === 'off') {\n      this._live = 'off';\n    } else {\n      this._live = 'polite';\n    }\n\n    // Only set role for Firefox. Set role based on aria-live because setting role=\"alert\" implies\n    // aria-live=\"assertive\" which may cause issues if aria-live is set to \"polite\" above.\n    if (this._platform.FIREFOX) {\n      if (this._live === 'polite') {\n        this._role = 'status';\n      }\n      if (this._live === 'assertive') {\n        this._role = 'alert';\n      }\n    }\n  }\n\n  /** Attach a component portal as content to this snack bar container. */\n  attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\n    this._assertNotAttached();\n    const result = this._portalOutlet.attachComponentPortal(portal);\n    this._afterPortalAttached();\n    return result;\n  }\n\n  /** Attach a template portal as content to this snack bar container. */\n  attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C> {\n    this._assertNotAttached();\n    const result = this._portalOutlet.attachTemplatePortal(portal);\n    this._afterPortalAttached();\n    return result;\n  }\n\n  /**\n   * Attaches a DOM portal to the snack bar container.\n   * @deprecated To be turned into a method.\n   * @breaking-change 10.0.0\n   */\n  override attachDomPortal = (portal: DomPortal) => {\n    this._assertNotAttached();\n    const result = this._portalOutlet.attachDomPortal(portal);\n    this._afterPortalAttached();\n    return result;\n  };\n\n  /** Handle end of animations, updating the state of the snackbar. */\n  onAnimationEnd(animationName: string) {\n    if (animationName === EXIT_ANIMATION) {\n      this._completeExit();\n    } else if (animationName === ENTER_ANIMATION) {\n      clearTimeout(this._enterFallback);\n      this._ngZone.run(() => {\n        this._onEnter.next();\n        this._onEnter.complete();\n      });\n    }\n  }\n\n  /** Begin animation of snack bar entrance into view. */\n  enter(): void {\n    if (!this._destroyed) {\n      this._animationState = 'visible';\n      // _animationState lives in host bindings and `detectChanges` does not refresh host bindings\n      // so we have to call `markForCheck` to ensure the host view is refreshed eventually.\n      this._changeDetectorRef.markForCheck();\n      this._changeDetectorRef.detectChanges();\n      this._screenReaderAnnounce();\n\n      if (this._animationsDisabled) {\n        afterNextRender(\n          () => {\n            this._ngZone.run(() => queueMicrotask(() => this.onAnimationEnd(ENTER_ANIMATION)));\n          },\n          {injector: this._injector},\n        );\n      } else {\n        clearTimeout(this._enterFallback);\n        this._enterFallback = setTimeout(() => {\n          // The snack bar will stay invisible if it fails to animate. Add a fallback class so it\n          // becomes visible. This can happen in some apps that do `* {animation: none !important}`.\n          this._elementRef.nativeElement.classList.add('mat-snack-bar-fallback-visible');\n          this.onAnimationEnd(ENTER_ANIMATION);\n        }, 200);\n      }\n    }\n  }\n\n  /** Begin animation of the snack bar exiting from view. */\n  exit(): Observable<void> {\n    if (this._destroyed) {\n      return of(undefined);\n    }\n\n    // It's common for snack bars to be opened by random outside calls like HTTP requests or\n    // errors. Run inside the NgZone to ensure that it functions correctly.\n    this._ngZone.run(() => {\n      // Note: this one transitions to `hidden`, rather than `void`, in order to handle the case\n      // where multiple snack bars are opened in quick succession (e.g. two consecutive calls to\n      // `MatSnackBar.open`).\n      this._animationState = 'hidden';\n      this._changeDetectorRef.markForCheck();\n\n      // Mark this element with an 'exit' attribute to indicate that the snackbar has\n      // been dismissed and will soon be removed from the DOM. This is used by the snackbar\n      // test harness.\n      this._elementRef.nativeElement.setAttribute('mat-exit', '');\n\n      // If the snack bar hasn't been announced by the time it exits it wouldn't have been open\n      // long enough to visually read it either, so clear the timeout for announcing.\n      clearTimeout(this._announceTimeoutId);\n\n      if (this._animationsDisabled) {\n        afterNextRender(\n          () => {\n            this._ngZone.run(() => queueMicrotask(() => this.onAnimationEnd(EXIT_ANIMATION)));\n          },\n          {injector: this._injector},\n        );\n      } else {\n        clearTimeout(this._exitFallback);\n        this._exitFallback = setTimeout(() => this.onAnimationEnd(EXIT_ANIMATION), 200);\n      }\n    });\n\n    return this._onExit;\n  }\n\n  /** Makes sure the exit callbacks have been invoked when the element is destroyed. */\n  ngOnDestroy() {\n    this._destroyed = true;\n    this._clearFromModals();\n    this._completeExit();\n  }\n\n  private _completeExit() {\n    clearTimeout(this._exitFallback);\n    queueMicrotask(() => {\n      this._onExit.next();\n      this._onExit.complete();\n    });\n  }\n\n  /**\n   * Called after the portal contents have been attached. Can be\n   * used to modify the DOM once it's guaranteed to be in place.\n   */\n  private _afterPortalAttached() {\n    const element: HTMLElement = this._elementRef.nativeElement;\n    const panelClasses = this.snackBarConfig.panelClass;\n\n    if (panelClasses) {\n      if (Array.isArray(panelClasses)) {\n        // Note that we can't use a spread here, because IE doesn't support multiple arguments.\n        panelClasses.forEach(cssClass => element.classList.add(cssClass));\n      } else {\n        element.classList.add(panelClasses);\n      }\n    }\n\n    this._exposeToModals();\n\n    // Check to see if the attached component or template uses the MDC template structure,\n    // specifically the MDC label. If not, the container should apply the MDC label class to this\n    // component's label container, which will apply MDC's label styles to the attached view.\n    const label = this._label.nativeElement;\n    const labelClass = 'mdc-snackbar__label';\n    label.classList.toggle(labelClass, !label.querySelector(`.${labelClass}`));\n  }\n\n  /**\n   * Some browsers won't expose the accessibility node of the live element if there is an\n   * `aria-modal` and the live element is outside of it. This method works around the issue by\n   * pointing the `aria-owns` of all modals to the live element.\n   */\n  private _exposeToModals() {\n    // TODO(http://github.com/angular/components/issues/26853): consider de-duplicating this with the\n    // `LiveAnnouncer` and any other usages.\n    //\n    // Note that the selector here is limited to CDK overlays at the moment in order to reduce the\n    // section of the DOM we need to look through. This should cover all the cases we support, but\n    // the selector can be expanded if it turns out to be too narrow.\n    const id = this._liveElementId;\n    const modals = this._document.querySelectorAll(\n      'body > .cdk-overlay-container [aria-modal=\"true\"]',\n    );\n\n    for (let i = 0; i < modals.length; i++) {\n      const modal = modals[i];\n      const ariaOwns = modal.getAttribute('aria-owns');\n      this._trackedModals.add(modal);\n\n      if (!ariaOwns) {\n        modal.setAttribute('aria-owns', id);\n      } else if (ariaOwns.indexOf(id) === -1) {\n        modal.setAttribute('aria-owns', ariaOwns + ' ' + id);\n      }\n    }\n  }\n\n  /** Clears the references to the live element from any modals it was added to. */\n  private _clearFromModals() {\n    this._trackedModals.forEach(modal => {\n      const ariaOwns = modal.getAttribute('aria-owns');\n\n      if (ariaOwns) {\n        const newValue = ariaOwns.replace(this._liveElementId, '').trim();\n\n        if (newValue.length > 0) {\n          modal.setAttribute('aria-owns', newValue);\n        } else {\n          modal.removeAttribute('aria-owns');\n        }\n      }\n    });\n    this._trackedModals.clear();\n  }\n\n  /** Asserts that no content is already attached to the container. */\n  private _assertNotAttached() {\n    if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('Attempting to attach snack bar content after content is already attached');\n    }\n  }\n\n  /**\n   * Starts a timeout to move the snack bar content to the live region so screen readers will\n   * announce it.\n   */\n  private _screenReaderAnnounce() {\n    if (this._announceTimeoutId) {\n      return;\n    }\n\n    this._ngZone.runOutsideAngular(() => {\n      this._announceTimeoutId = setTimeout(() => {\n        if (this._destroyed) {\n          return;\n        }\n\n        const element = this._elementRef.nativeElement;\n        const inertElement = element.querySelector('[aria-hidden]');\n        const liveElement = element.querySelector('[aria-live]');\n\n        if (inertElement && liveElement) {\n          // If an element in the snack bar content is focused before being moved\n          // track it and restore focus after moving to the live region.\n          let focusedElement: HTMLElement | null = null;\n          if (\n            this._platform.isBrowser &&\n            document.activeElement instanceof HTMLElement &&\n            inertElement.contains(document.activeElement)\n          ) {\n            focusedElement = document.activeElement;\n          }\n\n          inertElement.removeAttribute('aria-hidden');\n          liveElement.appendChild(inertElement);\n          focusedElement?.focus();\n\n          this._onAnnounce.next();\n          this._onAnnounce.complete();\n        }\n      }, this._announceDelay);\n    });\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {LiveAnnouncer} from '@angular/cdk/a11y';\nimport {BreakpointObserver, Breakpoints} from '@angular/cdk/layout';\nimport {\n  ComponentType,\n  createGlobalPositionStrategy,\n  createOverlayRef,\n  OverlayConfig,\n  OverlayRef,\n} from '@angular/cdk/overlay';\nimport {\n  ComponentRef,\n  EmbeddedViewRef,\n  Injectable,\n  InjectionToken,\n  Injector,\n  OnDestroy,\n  TemplateRef,\n  inject,\n} from '@angular/core';\nimport {SimpleSnackBar, TextOnlySnackBar} from './simple-snack-bar';\nimport {MatSnackBarContainer} from './snack-bar-container';\nimport {MAT_SNACK_BAR_DATA, MatSnackBarConfig} from './snack-bar-config';\nimport {MatSnackBarRef} from './snack-bar-ref';\nimport {ComponentPortal, TemplatePortal} from '@angular/cdk/portal';\nimport {takeUntil} from 'rxjs/operators';\nimport {_animationsDisabled} from '../core';\n\n/** Injection token that can be used to specify default snack bar. */\nexport const MAT_SNACK_BAR_DEFAULT_OPTIONS = new InjectionToken<MatSnackBarConfig>(\n  'mat-snack-bar-default-options',\n  {\n    providedIn: 'root',\n    factory: () => new MatSnackBarConfig(),\n  },\n);\n\n/**\n * Service to dispatch Material Design snack bar messages.\n */\n@Injectable({providedIn: 'root'})\nexport class MatSnackBar implements OnDestroy {\n  private _live = inject(LiveAnnouncer);\n  private _injector = inject(Injector);\n  private _breakpointObserver = inject(BreakpointObserver);\n  private _parentSnackBar = inject(MatSnackBar, {optional: true, skipSelf: true});\n  private _defaultConfig = inject<MatSnackBarConfig>(MAT_SNACK_BAR_DEFAULT_OPTIONS);\n  private _animationsDisabled = _animationsDisabled();\n\n  /**\n   * Reference to the current snack bar in the view *at this level* (in the Angular injector tree).\n   * If there is a parent snack-bar service, all operations should delegate to that parent\n   * via `_openedSnackBarRef`.\n   */\n  private _snackBarRefAtThisLevel: MatSnackBarRef<any> | null = null;\n\n  /** The component that should be rendered as the snack bar's simple component. */\n  simpleSnackBarComponent = SimpleSnackBar;\n\n  /** The container component that attaches the provided template or component. */\n  snackBarContainerComponent = MatSnackBarContainer;\n\n  /** The CSS class to apply for handset mode. */\n  handsetCssClass = 'mat-mdc-snack-bar-handset';\n\n  /** Reference to the currently opened snackbar at *any* level. */\n  get _openedSnackBarRef(): MatSnackBarRef<any> | null {\n    const parent = this._parentSnackBar;\n    return parent ? parent._openedSnackBarRef : this._snackBarRefAtThisLevel;\n  }\n\n  set _openedSnackBarRef(value: MatSnackBarRef<any> | null) {\n    if (this._parentSnackBar) {\n      this._parentSnackBar._openedSnackBarRef = value;\n    } else {\n      this._snackBarRefAtThisLevel = value;\n    }\n  }\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  /**\n   * Creates and dispatches a snack bar with a custom component for the content, removing any\n   * currently opened snack bars.\n   *\n   * @param component Component to be instantiated.\n   * @param config Extra configuration for the snack bar.\n   */\n  openFromComponent<T, D = any>(\n    component: ComponentType<T>,\n    config?: MatSnackBarConfig<D>,\n  ): MatSnackBarRef<T> {\n    return this._attach(component, config) as MatSnackBarRef<T>;\n  }\n\n  /**\n   * Creates and dispatches a snack bar with a custom template for the content, removing any\n   * currently opened snack bars.\n   *\n   * @param template Template to be instantiated.\n   * @param config Extra configuration for the snack bar.\n   */\n  openFromTemplate(\n    template: TemplateRef<any>,\n    config?: MatSnackBarConfig,\n  ): MatSnackBarRef<EmbeddedViewRef<any>> {\n    return this._attach(template, config);\n  }\n\n  /**\n   * Opens a snackbar with a message and an optional action.\n   * @param message The message to show in the snackbar.\n   * @param action The label for the snackbar action.\n   * @param config Additional configuration options for the snackbar.\n   */\n  open(\n    message: string,\n    action: string = '',\n    config?: MatSnackBarConfig,\n  ): MatSnackBarRef<TextOnlySnackBar> {\n    const _config = {...this._defaultConfig, ...config};\n\n    // Since the user doesn't have access to the component, we can\n    // override the data to pass in our own message and action.\n    _config.data = {message, action};\n\n    // Since the snack bar has `role=\"alert\"`, we don't\n    // want to announce the same message twice.\n    if (_config.announcementMessage === message) {\n      _config.announcementMessage = undefined;\n    }\n\n    return this.openFromComponent(this.simpleSnackBarComponent, _config);\n  }\n\n  /**\n   * Dismisses the currently-visible snack bar.\n   */\n  dismiss(): void {\n    if (this._openedSnackBarRef) {\n      this._openedSnackBarRef.dismiss();\n    }\n  }\n\n  ngOnDestroy() {\n    // Only dismiss the snack bar at the current level on destroy.\n    if (this._snackBarRefAtThisLevel) {\n      this._snackBarRefAtThisLevel.dismiss();\n    }\n  }\n\n  /**\n   * Attaches the snack bar container component to the overlay.\n   */\n  private _attachSnackBarContainer(\n    overlayRef: OverlayRef,\n    config: MatSnackBarConfig,\n  ): MatSnackBarContainer {\n    const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\n    const injector = Injector.create({\n      parent: userInjector || this._injector,\n      providers: [{provide: MatSnackBarConfig, useValue: config}],\n    });\n\n    const containerPortal = new ComponentPortal(\n      this.snackBarContainerComponent,\n      config.viewContainerRef,\n      injector,\n    );\n    const containerRef: ComponentRef<MatSnackBarContainer> = overlayRef.attach(containerPortal);\n    containerRef.instance.snackBarConfig = config;\n    return containerRef.instance;\n  }\n\n  /**\n   * Places a new component or a template as the content of the snack bar container.\n   */\n  private _attach<T>(\n    content: ComponentType<T> | TemplateRef<T>,\n    userConfig?: MatSnackBarConfig,\n  ): MatSnackBarRef<T | EmbeddedViewRef<any>> {\n    const config = {...new MatSnackBarConfig(), ...this._defaultConfig, ...userConfig};\n    const overlayRef = this._createOverlay(config);\n    const container = this._attachSnackBarContainer(overlayRef, config);\n    const snackBarRef = new MatSnackBarRef<T | EmbeddedViewRef<any>>(container, overlayRef);\n\n    if (content instanceof TemplateRef) {\n      const portal = new TemplatePortal(content, null!, {\n        $implicit: config.data,\n        snackBarRef,\n      } as any);\n\n      snackBarRef.instance = container.attachTemplatePortal(portal);\n    } else {\n      const injector = this._createInjector(config, snackBarRef);\n      const portal = new ComponentPortal(content, undefined, injector);\n      const contentRef = container.attachComponentPortal<T>(portal);\n\n      // We can't pass this via the injector, because the injector is created earlier.\n      snackBarRef.instance = contentRef.instance;\n    }\n\n    // Subscribe to the breakpoint observer and attach the mat-snack-bar-handset class as\n    // appropriate. This class is applied to the overlay element because the overlay must expand to\n    // fill the width of the screen for full width snackbars.\n    this._breakpointObserver\n      .observe(Breakpoints.HandsetPortrait)\n      .pipe(takeUntil(overlayRef.detachments()))\n      .subscribe(state => {\n        overlayRef.overlayElement.classList.toggle(this.handsetCssClass, state.matches);\n      });\n\n    if (config.announcementMessage) {\n      // Wait until the snack bar contents have been announced then deliver this message.\n      container._onAnnounce.subscribe(() => {\n        this._live.announce(config.announcementMessage!, config.politeness);\n      });\n    }\n\n    this._animateSnackBar(snackBarRef, config);\n    this._openedSnackBarRef = snackBarRef;\n    return this._openedSnackBarRef;\n  }\n\n  /** Animates the old snack bar out and the new one in. */\n  private _animateSnackBar(snackBarRef: MatSnackBarRef<any>, config: MatSnackBarConfig) {\n    // When the snackbar is dismissed, clear the reference to it.\n    snackBarRef.afterDismissed().subscribe(() => {\n      // Clear the snackbar ref if it hasn't already been replaced by a newer snackbar.\n      if (this._openedSnackBarRef == snackBarRef) {\n        this._openedSnackBarRef = null;\n      }\n\n      if (config.announcementMessage) {\n        this._live.clear();\n      }\n    });\n\n    // If a dismiss timeout is provided, set up dismiss based on after the snackbar is opened.\n    if (config.duration && config.duration > 0) {\n      snackBarRef.afterOpened().subscribe(() => snackBarRef._dismissAfter(config.duration!));\n    }\n\n    if (this._openedSnackBarRef) {\n      // If a snack bar is already in view, dismiss it and enter the\n      // new snack bar after exit animation is complete.\n      this._openedSnackBarRef.afterDismissed().subscribe(() => {\n        snackBarRef.containerInstance.enter();\n      });\n      this._openedSnackBarRef.dismiss();\n    } else {\n      // If no snack bar is in view, enter the new snack bar.\n      snackBarRef.containerInstance.enter();\n    }\n  }\n\n  /**\n   * Creates a new overlay and places it in the correct location.\n   * @param config The user-specified snack bar config.\n   */\n  private _createOverlay(config: MatSnackBarConfig): OverlayRef {\n    const overlayConfig = new OverlayConfig();\n    overlayConfig.direction = config.direction;\n\n    const positionStrategy = createGlobalPositionStrategy(this._injector);\n    // Set horizontal position.\n    const isRtl = config.direction === 'rtl';\n    const isLeft =\n      config.horizontalPosition === 'left' ||\n      (config.horizontalPosition === 'start' && !isRtl) ||\n      (config.horizontalPosition === 'end' && isRtl);\n    const isRight = !isLeft && config.horizontalPosition !== 'center';\n    if (isLeft) {\n      positionStrategy.left('0');\n    } else if (isRight) {\n      positionStrategy.right('0');\n    } else {\n      positionStrategy.centerHorizontally();\n    }\n    // Set horizontal position.\n    if (config.verticalPosition === 'top') {\n      positionStrategy.top('0');\n    } else {\n      positionStrategy.bottom('0');\n    }\n\n    overlayConfig.positionStrategy = positionStrategy;\n    overlayConfig.disableAnimations = this._animationsDisabled;\n    return createOverlayRef(this._injector, overlayConfig);\n  }\n\n  /**\n   * Creates an injector to be used inside of a snack bar component.\n   * @param config Config that was used to create the snack bar.\n   * @param snackBarRef Reference to the snack bar.\n   */\n  private _createInjector<T>(config: MatSnackBarConfig, snackBarRef: MatSnackBarRef<T>): Injector {\n    const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\n\n    return Injector.create({\n      parent: userInjector || this._injector,\n      providers: [\n        {provide: MatSnackBarRef, useValue: snackBarRef},\n        {provide: MAT_SNACK_BAR_DATA, useValue: config.data},\n      ],\n    });\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {OverlayModule} from '@angular/cdk/overlay';\nimport {PortalModule} from '@angular/cdk/portal';\nimport {NgModule} from '@angular/core';\nimport {BidiModule} from '@angular/cdk/bidi';\nimport {MatButtonModule} from '../button';\n\nimport {SimpleSnackBar} from './simple-snack-bar';\nimport {MatSnackBarContainer} from './snack-bar-container';\nimport {MatSnackBarAction, MatSnackBarActions, MatSnackBarLabel} from './snack-bar-content';\nimport {MatSnackBar} from './snack-bar';\n\nconst DIRECTIVES = [MatSnackBarContainer, MatSnackBarLabel, MatSnackBarActions, MatSnackBarAction];\n\n@NgModule({\n  imports: [OverlayModule, PortalModule, MatButtonModule, SimpleSnackBar, ...DIRECTIVES],\n  exports: [BidiModule, ...DIRECTIVES],\n  providers: [MatSnackBar],\n})\nexport class MatSnackBarModule {}\n"],"names":["MatSnackBarRef","_overlayRef","containerInstance","Subject","_durationTimeoutId","_dismissedByAction","constructor","dismiss","exit","clearTimeout","dismissWithAction","_onAction","next","complete","setTimeout","Math","min","duration","MAX_TIMEOUT","_afterOpened","closed","MatSnackBarConfig","politeness","announcementMessage","minVersion","version","ngImport","i0","type","MatSnackBarLabel","decorators","args","selector","ɵɵngDeclareFactory","MatSnackBarActions","deps","target","ɵɵFactoryTarget","Directive","isStandalone","host","classAttribute","MatSnackBarAction","SimpleSnackBar","snackBarRef","inject","data","MAT_SNACK_BAR_DATA","action","ENTER_ANIMATION","EXIT_ANIMATION","NgZone","_elementRef","ElementRef","snackBarConfig","_document","DOCUMENT","_trackedModals","Set","_enterFallback","_injector","Injector","_announceTimeoutId","_live","_liveElementId","_IdGenerator","getId","config","FIREFOX","_assertNotAttached","_portalOutlet","attachComponentPortal","portal","_afterPortalAttached","result","attachTemplatePortal","onAnimationEnd","animationName","_onEnter","_destroyed","_animationState","_animationsDisabled","afterNextRender","_ngZone","run","queueMicrotask","injector","nativeElement","classList","add","_changeDetectorRef","markForCheck","_exitFallback","_clearFromModals","_completeExit","_onExit","element","panelClasses","forEach","cssClass","_label","label","toggle","labelClass","querySelector","id","modals","querySelectorAll","ariaOwns","modal","getAttribute","setAttribute","styles","ctorParameters","propDecorators","static","factory","MatSnackBar","LiveAnnouncer","_breakpointObserver","BreakpointObserver","_snackBarRefAtThisLevel","_openedSnackBarRef","value","message","undefined","openFromComponent","simpleSnackBarComponent","_config","_attachSnackBarContainer","overlayRef","viewContainerRef","create","parent","userInjector","containerPortal","ComponentPortal","snackBarContainerComponent","containerRef","attach","instance","_defaultConfig","userConfig","container","$implicit","_createInjector","content","contentRef","pipe","takeUntil","detachments","_onAnnounce","subscribe","announce","_animateSnackBar","afterDismissed","afterOpened","_dismissAfter","DIRECTIVES","MatSnackBarContainer","ɵfac","MatSnackBarModule","NgModule"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAwBA,MAAAA,cAAA,CAAA;EAEEC,WAAQ;UAcmE;EA2CxEC,iBAAA;iBAlCgE,OAAAC,OAAA,EAAA;;AAQjE,EAAA,SAAA,GAAA,IAAAA,OAAA,EAAA;EAQAC,kBAAkB;AAIHC,EAAAA,kBAAA,GAAA,KAAA;EAEbC,WAAAJ,CAAAA,iBAAA,EAAAD,WAAA,EAAA;;;;AAIF;EAIFM,OAAA,GAAA;oCAIG,EAAA;MAAA,IAAAL,CAAAA,iBAAA,CAAAM,IAAA,EAAA;;IAGHC,YAAA,CAAA,IAAA,CAAAL,kBAAA,CAAA;;mBAK6FM,GAAA;QAC3F,CAAI,IAAC;MACP,IAAA,CAAAL,kBAAA,GAAA,IAAA;MAEmC,IAAAM,CAAAA,SAAA,CAAAC,IAAA,EAAA;MACnC,IAAAD,CAAAA,SAAK,CAAAE,QAAA,EAAA;AACH,MAAA,IAAA,CAAAN,OAAA,EAAA;AAEE;iBACF,KAAAH,kBAAA,CAAA;;oBASA;AAEA,IAAA,IAAA,CAAAM,iBAAA,EAAA;AAEA;;2BAMF,GAAAI,UAAA,CAAA,MAAA,IAAA,CAAAP,OAAA,EAAA,EAAAQ,IAAA,CAAAC,GAAA,CAAAC,QAAA,EAAAC,WAAA,CAAA,CAAA;;;QAO+E,CAAA,IAAA,CAAAC,YAAA,CAAAC,MAAA,EAAA;MAC/E,IAAAD,CAAAA,YAAA,CAAAP,IAAA,EAAA;;AAEA;AACD;;;;;;;;;;;;;;;;;;;;;;;;AC1GD,MAAAS,iBAAA,CAAA;EAOKC,UAAA,GAAA,QAAA;EAgBHC,mBAAS,GAAA,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2BCpCD,CAAA;AAAAC,EAAAA,UAAA,EAAA,QAAA;EAAAC,OAAA,EAAA,eAAA;AAAAC,EAAAA,QAAA,EAAAC,EAAA;AAAAC,EAAAA,IAAA,EAAAC,gBAAA;EAAAC,UAAA,EAAA,CAAA;;IACRC,IAAA,EAAA,CAAA;AAcWC,MAAAA,QAAA,EAAkB,CAAA,kBAAA,CAAA;;;;;;;AAZ3B,MAAA,kBAAA,CAAA;AACD,EAAA,OAAA,IAAA,GAAA,EAAA,CAAAC,kBAAA,CAAA;IAAAT,UAAA,EAAA,QAAA;IAAAC,OAAA,EAAA,eAAA;AAAAC,IAAAA,QAAA,EAAAC,EAAA;AAAAC,IAAAA,IAAA,EAAAM,kBAAA;IAAAC,IAAA,EAAA,EAAA;AAAAC,IAAAA,MAAA,EAAAT,EAAA,CAAAU,eAAA,CAAAC;AAAA,GAAA,CAAA;AACF,EAAA,OAAA,IAAA,GAAA,EAAA,CAAA,oBAAA,CAAA;IAAAd,UAAA,EAAA,QAAA;AAAAC,IAAAA,OAAA,EAAA,eAAA;AAAAG,IAAAA,IAAA,EAAAM,kBAAA;IAAAK,YAAA,EAAA,IAAA;IAAAP,QAAA,EAAA,sBAAA;IAAAQ,IAAA,EAAA;MAAAC,cAAA,EAAA;AAAA,KAAA;AAAAf,IAAAA,QAAA,EAAAC;AAAA,GAAA,CAAA;;AAGgG,EAAA,CAAA,wBAAA,CAAA;EAAAH,UAAA,EAAA,QAAA;EAAAC,OAAA,EAAA,eAAA;AAAAC,EAAAA,QAAA,EAAAC,EAAA;AAAAC,EAAAA,IAAA,EAAAM,kBAAA;EAAAJ,UAAA,EAAA,CAAA;;;AAI7FE,MAAAA,QAAA,EAAO,CAAA,oBAAA,CAAA;;;;;;;;;;;;;;;;AAHA,EAAA,OAAA,IAAA,GAAA,EAAA,CAAA,oBAAA,CAAA;IAAAR,UAAA,EAAA,QAAA;AAAAC,IAAAA,OAAA,EAAA,eAAA;AAAAG,IAAAA,IAAA,EAAAc,iBAAA;IAAAH,YAAA,EAAA,IAAA;IAAAP,QAAA,EAAA,qBAAA;IAAAQ,IAAA,EAAA;MAAAC,cAAA,EAAA;AAAA,KAAA;AAAAf,IAAAA,QAAA,EAAAC;AAAA,GAAA,CAAA;;AAET,EAAA,CAAA,wBAAA,CAAA;EAAAH,UAAA,EAAA,QAAA;EAAAC,OAAA,EAAA,eAAA;AAAAC,EAAAA,QAAA,EAAAC,EAAA;AAAAC,EAAAA,IAAA,EAAAc,iBAAA;EAAAZ,UAAA,EAAA,CAAA;;IAGDC,IAAA,EAAA,CAAA;;;;;;;;;ACWD,MAAAY,cAAA,CAAA;EAEEC,WAAI,GAAAC,MAAA,CAAA7C,cAAU,CAAA;AAGd8C,EAAAA,IAAA,GAAAD,MAAA,CAAAE,kBAAe,CAAA;aAE6BzC,GAAA;AAE1C0C,EAAAA,MAAAA,GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNJ,MAAAC,eAAM,GAAiB,sBAAA;AAEvB,MAAAC;;SAwDiF,GAAAL,MAAA,CAAAM,MAAA,CAAA;EACtEC,WAAA,GAAAP,MAAqC,CAAAQ,UAAA,CAAA;;;;EAQ9CC,cAAA,GAAAT,MAAA,CAAAxB,iBAAA,CAAA;EA0BSkC,SAAA,GAAAV,MAAA,CAAAW,QAAA,CAAA;EACLC,cAAK,GAAQ,IAAAC,GAAK,EAAA;EACpBC,cAAA;;AACEC,EAAAA,SAAK,GAAKf,MAAG,CAAAgB,QAAQ,CAAA;gBAGuE,GAAA,GAAA;EAG5FC,kBAAmB;eAEnB,KAAA;;;;;;EAoBFC,KAAA;;;AAmBAC,EAAAA,cAAA,GAAAnB,MAAA,CAAAoB,YAAA,EAAAC,KAAA,CAAA,+BAAA,CAAA;EACE5D,WAAA,GAAA;;;6CAMJ,CAAA6D,MAAA,CAAA5C,mBAAA,EAAA;AAEuD,MAAA,IAAA,CAAAwC,KAAA,GAAA,WAAA;eAKnDI,MAAA,CAAA7C,UAAA,KAAA,KAAA,EAAA;MACA,IAAA,CAAAyC,KAAI,GAAC,KAAA;KAIL,MAAA;mBACiB,QAAA;;sBAMjB,CAAAK,OAAA,EAAA;;;AACE;AACA,MAAA,IAAA,IAAA,CAAAL,KAAA,KAAA,WAAA,EAAA;;;AAIE;;;AAIR,IAAA,IAAA,CAAAM,kBAAA,EAAA;AAE0D,IAAA,MAAA,MAAA,GAAA,IAAA,CAAAC,aAAA,CAAAC,qBAAA,CAAAC,MAAA,CAAA;AACtD,IAAA,IAAA,CAAAC,oBAAA,EAAA;AACF,IAAA,OAAAC,MAAA;AACE;uBAIqEF,MAAA,EAAA;IACvE,IAAA,CAAAH,oBAAsB;gBACsE,GAAA,IAAA,CAAAC,aAAA,CAAAK,oBAAA,CAAAH,MAAA,CAAA;6BACA,EAAA;iBACnE;AACvB;oBAS+EA,MAAA,IAAA;AAC/E,IAAA,IAAA,CAAAH,kBAAA,EAAA;;;;;AAUEO,EAAAA,cAAAA,CAAAC,aAAgC,EAAA;IAChC,IAAAA,aAAA,KAAA3B,cAAkB,EAAA;wBACpB,EAAA;eAGK2B,aAAA,KAAA5B,eAAA,EAAA;AACTxC,MAAAA,YAAA,MAAAkD,cAAA,CAAA;;QAIE,IAAK,CAAAmB,QAAA,CAAAlE,IAAiB,EAAA;QACtB,IAAAkE,CAAAA,QAAqB,CAAAjE,QAAA,EAAA;;AAEvB;;AAGE,EAAA,KAAA,GAAA;AACA,IAAA,IAAA,CAAA,IAAA,CAAAkE,UAAc,EAAA;AACZ,MAAA,IAAA,CAAAC,eAAK,GAAc,SAAA;;;;MAQpB,IAAA,IAAA,CAAAC,mBAAA,EAAA;AACyBC,QAAAA,eAAA,CAAA,MAAA;UAC1B,IAAAC,CAAAA,OAAA,CAAAC,GAAA,CAAA,MAAAC,cAAA,CAAAT,MAAAA,IAAAA,CAAAA,cAAA,CAAA3B,eAAA,CAAA,CAAA,CAAA;AACA,SAAA,EAAA;AAAAqC,UAAAA,QAAA,EAAA1B,IAAAA,CAAAA;AAAA,SAAA,CAAA;OAGE,MAAA;wCACyF,CAAA;YAEzF,CAAAD,cAAA,GAAA7C,UAAA,CAAA,MAAA;AAKE,UAAA,IAAA,CAAAsC,WAAgB,CAAAmC,aAEkE,CAAAC,SAAA,CAAAC,GAAA,CAAA,gCAAA,CAAA;;SACO,EAAA,GAAA,CAAA;;;;;AAO/F,IAAA,IAAA,IAAA,CAAA,UAAA,EAAA;;;;;MAYE,IAAAC,CAAAA,kBAAA,CAAAC,YAAA,EAAA;;AAWIlF,MAAAA,YAAA,MAAAqD;;;sBAGF,CAAAsB,GAAA,CAAA,MAAAC,cAAA,CAAAT,MAAAA,IAAAA,CAAAA,cAAA,CAAA1B,cAAA,CAAA,CAAA,CAAA;SACF,EAAA;AAAAoC,UAAAA,QAAA,EAAA1B,IAAAA,CAAAA;AAAA,SAAA,CAAA;OAIsB,MAAA;AACtBnD,QAAAA,YAAmB,CAAA,IAAA,CAAAmF,aAAA,CAAe;YAG5B,CAAAA,aAAA,GAAA9E,UAAU,CAAA8D,MAAAA,IAAAA,CAAAA,cAAA,CAAA1B,cAAA,CAAA,EAAA,GAAA,CAAA;;;;;;AASd,IAAA,IAAA,CAAA,UAAA,GAAA,IAAA;AACF,IAAA,IAAA,CAAA2C,gBAAA,EAAA;AACF,IAAA,IAAA,CAAAC,aAAA,EAAA;;AAIEA,EAAAA,aAAAA,GAAA;;kBAGF,CAAA,MAAA;AAEA,MAAA,IAAA,CAAAC,OAAA,CAAAnF,IAAA,EAAA;;;AAGG;AAOwB6D,EAAAA,oBAAAA,GAAA;AACrB,IAAA,MAAAuB,OAAA,GAAA,IAAA,CAAA5C,WAAA,CAAAmC,aAAA;;AAIA,IAAA,IAAAU,YAAA,EAAA;;QAIAA,YAAA,CAAAC,OAAA,CAAAC,QAAA,IAAAH,OAAA,CAAAR,SAAA,CAAAC,GAAA,CAAAU,QAAA,CAAA,CAAA;;yBAGM,CAAAV,GAAA,CAAAQ,YAAyC,CAAA;;;AAM3C,IAAA,IAAA,CAAA,eAAA,EAAA;eAIF,GAAA,IAAA,CAAAG,MAAA,CAAAb,aAAA;;IAGAc,KAAA,CAAAb,SAAA,CAAAc,MAAA,CAAAC,UAAA,EAAA,CAAAF,KAAA,CAAAG,aAAA,CAAA,CAAA,CAAA,EAAAD,UAAA,CAAA,CAAA,CAAA,CAAA;;;IA1UN,MAAAE,EAAA,GAAA,IAAA,CAAAzC,cAAA;AACD,IAAA,MAAA0C,MAAA,GAAA,IAAA,CAAAnD,SAAA,CAAAoD,gBAAA,CAAA,mDAAA,CAAA;;;AA0BU,MAAA,MAAAC,QAAA,GAAAC,KAAA,CAAAC,YAAA,CAAA,WAAA,CAAA;;;AAsBAD,QAAAA,KAAA,CAAAE,YAAA,CAAgB,WAAA,EAAAN,EAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gBASJ,irBAAA;MAAAO,MAAA,EAAA,CAAA,83FAAA;AAAA,KAAA;;AAIvB,EAAA,cAAA,EAAAC,MAAA,EAAA;EAAAC,cAAA,EAAA;IAAA5C,aAAA,EAAA,CAAA;AACE,MAAA,IAAA,EAAA,SAAA;AACA,MAAA,IAAA,EAAA,CAAA,eAAA,EAAA;QAAA6C,MAAA,EAAA;AAAA,OAAA;;;;;;AAIW,OAAA;;;;;;;ECtEVC,OAAA,EAAAA,MAAA,IAAA/F,iBAAA;;AAOuB,MAAAgG,WAAA,CAAA;EAK1BtD,KAAA,GAAAlB,MAAiE,CAAAyE,aAAA,CAAA;EACjE1D,SAAsB,GAAAf,MAAA,CAAAgB,QAAA,CAAA;EAEpB0D,mBAAA,GAAA1E,MAAA,CAAA2E,kBAAA,CAAA;;;;;;AAKEvC,EAAAA,mBAAA,GAAAA,mBAAA,EAAA;AASJwC,EAAAA,uBAAA,GAAA,IAAA;;;AAOiB,EAAA,eAAA,GAAA,2BAAA;AAOjB,EAAA,IAAAC,kBAAA,GAAA;;;;AAMG,EAAA,IAAAA,mBAAAC,KAAA,EAAA;4BACa,EAAA;;;;;AAYb;AACCrH,EAAAA,WAAAA,GACa;;;;;;;;;;;;;;;;AAiEf,IAAA,+BAGwB,KAAAsH,OAAA,EAAA;iCAGH,GAAAC,SAAc;;AAGzB,IAAA,OAAA,IAAA,CAAAC,iBAAA,CAAA,IAAA,CAAAC,uBAAA,EAACC,OAAA,CAAA;;;;UAUX,CAAAN,kBAAA,CAAAnH,OAAA,EAAA;;;;;WAQGkH,uBAAkB,CAAAlH,OAAA,EAAA;;;0BAQlB0H,CAAAC,UAAA,EAAC/D,MAAA,EAAA;sBACJ,GAAAA,MAAA,IAAAA,MAAA,CAAAgE,gBAAA,IAAAhE,MAAA,CAAAgE,gBAAA,CAAA7C,QAAA;AAEA,IAAA,MAAAA,QAAA,GAAAzB,QAAA,CAAAuE,MAAA,CAAA;MACAC,MAAA,EAAAC,YAAA,IAAA,IAAA,CAAA1E,SAAA;;;;;;IAKsB,MAAA2E,eAAA,GAAAC,IAAAA,eAAA,CAAAC,IAAAA,CAAAA,0BAAA,EAAAtE,MAAA,CAAAgE,gBAAA,EAAA7C,QAAA,CAAA;AACuC,IAAA,MAAAoD,YAAA,GAC7DR,UAA0B,CAAAS,OACyDJ,eAAA,CAAA;AAE/EG,IAAAA,YAAA,CAAAE,QAAK,CAAAtF,cAAA,GAAqBa,MAAA;uBAC5B,CAAAyE,QAAA;;6BAa8D,EAAA;gBACZ,GAAA;AAAA,MAAA,GAAA,IAAAvH,iBAAA,EAAA;AAAA,MAAA,GAAA,KAAAwH,cAAA;MAAA,GAAAC;AAAA,KAAA;;AAEhD,IAAA,MAAAC,SAAA,GAAAd,IAAAA,CAAAA,wBAAA,CAAAC,UAAA,EAAA/D,MAAA,CAAA;AAEF,IAAA,MAAAvB,WAAA,GAAA5C,IAAAA,cAAA,CAAA+I,SAAA,EAAAb,UAAA,CAAA;;;QAGAc,iBACF,CAAAlG,IAAA;AAGFF,QAAAA;;;KAKE,MAAA;MACA,MAAA0C,QAAA,GAAa,IAAU,CAAA2D,eAAS,CAAA9E,mBAAU,CAAA;YAE1CK,MAAA,GAAM,IAAAgE,eAAgB,CAAAU,OAAA,EAAArB,SAAA,EAAAvC,QAAA,CAAA;AACtB6D,MAAAA,MAAAA,UAA2B,GAAAJ,SAAA,CAAAxE,qBAAA,CAAAC,MAAA,CAAA;iBAIxB,CAAAoE,QAAyB,GAAAO,UAAA,CAAAP,QAAA;;AAI1B,IAAA,IAAA,CAAArB,mBAAA,qCAEA6B,CAAAA,IAAA,CAAAC,SAAA,CAAAnB,UAAiB,CAAAoB,WAAU,IAAA;;;;eAM3B,CAAAC,WAAA,CAAAC,SAAA,CAAyB,MAAA;YAC3B,CAAAzF,KAAA,CAAA0F,QAAA,CAAAtF,MAAA,CAAA5C,mBAAA,EAAA4C,MAAA,CAAA7C,UAAA,CAAA;;;QAEA,CAAAoI,gBAAA,CAAA9G,WAAA,EAAAuB,MAAA,CAAA;IAGA,IAAA,CAAAuD,kBAAA,GAAA9E,WAA+B;;;;AAQ9BA,IAAAA,WAAA,CAAA+G,cAAA,EAAAH,CAAAA,SAAA,CAAA,MAAA;AAED,MAAA,IAAA,IAAkB,CAAA9B,kBAAS,IAAA9E,WAAA,EAAA;;AAIzB;MACE,IAAAuB,MAAU,CAAA5C,mBAAsC,EAAA;;AAEjD;;;MAxQMqB,WAAA,CAAAgH,WAAA,EAAA,CAAAJ,SAAA,CAAA,MAAA5G,WAAA,CAAAiH,aAAA,CAAA1F,MAAA,CAAAlD,QAAA,CAAA,CAAA;;+BADF,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBX,MAAA6I,aAA8B,CAAAC,oBAAA,EAAAlI,gBAAA,EAAAK,kBAAA,EAAAQ,iBAAA,CAAA;;AAAjB,EAAA,OAAAsH,IAAA,GAAArI,EAAA,CAAAM,kBAAA,CAAA;IAAAT,UAAA,EAAA,QAAA;IAAAC,OAAA,EAAA,eAAA;AAAAC,IAAAA,QAAA,EAAAC,EAAA;AAAAC,IAAAA,IAAA,EAAAqI,iBAAA;IAAA9H,IAAA,EAAA,EAAA;AAAAC,IAAAA,MAAA,EAAAT,EAAA,CAAAU,eAAA,CAAA6H;AAAA,GAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;AAJXtI,IAAAA,IAAA,EAAAsI,QAAA;;;;;;;;;;;"}