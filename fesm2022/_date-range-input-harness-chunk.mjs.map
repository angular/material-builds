{"version":3,"file":"_date-range-input-harness-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/datepicker/testing/datepicker-input-harness-base.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/datepicker/testing/calendar-cell-harness.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/datepicker/testing/calendar-harness.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/datepicker/testing/datepicker-trigger-harness-base.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/datepicker/testing/datepicker-input-harness.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/datepicker/testing/date-range-input-harness.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ComponentHarnessConstructor, HarnessPredicate} from '@angular/cdk/testing';\nimport {MatFormFieldControlHarnessBase} from '@angular/material/form-field/testing/control';\nimport {DatepickerInputHarnessFilters} from './datepicker-harness-filters';\n\n/** Sets up the filter predicates for a datepicker input harness. */\nexport function getInputPredicate<T extends MatDatepickerInputHarnessBase>(\n  type: ComponentHarnessConstructor<T>,\n  options: DatepickerInputHarnessFilters,\n): HarnessPredicate<T> {\n  return new HarnessPredicate(type, options)\n    .addOption('value', options.value, (harness, value) => {\n      return HarnessPredicate.stringMatches(harness.getValue(), value);\n    })\n    .addOption('placeholder', options.placeholder, (harness, placeholder) => {\n      return HarnessPredicate.stringMatches(harness.getPlaceholder(), placeholder);\n    })\n    .addOption('label', options.label, (harness, label) => {\n      return HarnessPredicate.stringMatches(harness.getLabel(), label);\n    });\n}\n\n/** Base class for datepicker input harnesses. */\nexport abstract class MatDatepickerInputHarnessBase extends MatFormFieldControlHarnessBase {\n  /** Whether the input is disabled. */\n  async isDisabled(): Promise<boolean> {\n    return (await this.host()).getProperty<boolean>('disabled');\n  }\n\n  /** Whether the input is required. */\n  async isRequired(): Promise<boolean> {\n    return (await this.host()).getProperty<boolean>('required');\n  }\n\n  /** Gets the value of the input. */\n  async getValue(): Promise<string> {\n    // The \"value\" property of the native input is always defined.\n    return await (await this.host()).getProperty<string>('value');\n  }\n\n  /**\n   * Sets the value of the input. The value will be set by simulating\n   * keypresses that correspond to the given value.\n   */\n  async setValue(newValue: string): Promise<void> {\n    const inputEl = await this.host();\n    await inputEl.clear();\n\n    // We don't want to send keys for the value if the value is an empty\n    // string in order to clear the value. Sending keys with an empty string\n    // still results in unnecessary focus events.\n    if (newValue) {\n      await inputEl.sendKeys(newValue);\n    }\n\n    await inputEl.dispatchEvent('change');\n  }\n\n  /** Gets the placeholder of the input. */\n  async getPlaceholder(): Promise<string> {\n    return await (await this.host()).getProperty<string>('placeholder');\n  }\n\n  /**\n   * Focuses the input and returns a promise that indicates when the\n   * action is complete.\n   */\n  async focus(): Promise<void> {\n    return (await this.host()).focus();\n  }\n\n  /**\n   * Blurs the input and returns a promise that indicates when the\n   * action is complete.\n   */\n  async blur(): Promise<void> {\n    return (await this.host()).blur();\n  }\n\n  /** Whether the input is focused. */\n  async isFocused(): Promise<boolean> {\n    return (await this.host()).isFocused();\n  }\n\n  /** Gets the formatted minimum date for the input's value. */\n  async getMin(): Promise<string | null> {\n    return (await this.host()).getAttribute('min');\n  }\n\n  /** Gets the formatted maximum date for the input's value. */\n  async getMax(): Promise<string | null> {\n    return (await this.host()).getAttribute('max');\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {HarnessPredicate, ComponentHarness} from '@angular/cdk/testing';\nimport {CalendarCellHarnessFilters} from './datepicker-harness-filters';\n\n/** Harness for interacting with a standard Material calendar cell in tests. */\nexport class MatCalendarCellHarness extends ComponentHarness {\n  static hostSelector = '.mat-calendar-body-cell';\n\n  /** Reference to the inner content element inside the cell. */\n  private _content = this.locatorFor('.mat-calendar-body-cell-content');\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a `MatCalendarCellHarness`\n   * that meets certain criteria.\n   * @param options Options for filtering which cell instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with(options: CalendarCellHarnessFilters = {}): HarnessPredicate<MatCalendarCellHarness> {\n    return new HarnessPredicate(MatCalendarCellHarness, options)\n      .addOption('text', options.text, (harness, text) => {\n        return HarnessPredicate.stringMatches(harness.getText(), text);\n      })\n      .addOption('selected', options.selected, async (harness, selected) => {\n        return (await harness.isSelected()) === selected;\n      })\n      .addOption('active', options.active, async (harness, active) => {\n        return (await harness.isActive()) === active;\n      })\n      .addOption('disabled', options.disabled, async (harness, disabled) => {\n        return (await harness.isDisabled()) === disabled;\n      })\n      .addOption('today', options.today, async (harness, today) => {\n        return (await harness.isToday()) === today;\n      })\n      .addOption('inRange', options.inRange, async (harness, inRange) => {\n        return (await harness.isInRange()) === inRange;\n      })\n      .addOption(\n        'inComparisonRange',\n        options.inComparisonRange,\n        async (harness, inComparisonRange) => {\n          return (await harness.isInComparisonRange()) === inComparisonRange;\n        },\n      )\n      .addOption('inPreviewRange', options.inPreviewRange, async (harness, inPreviewRange) => {\n        return (await harness.isInPreviewRange()) === inPreviewRange;\n      });\n  }\n\n  /** Gets the text of the calendar cell. */\n  async getText(): Promise<string> {\n    return (await this._content()).text();\n  }\n\n  /** Gets the aria-label of the calendar cell. */\n  async getAriaLabel(): Promise<string> {\n    // We're guaranteed for the `aria-label` to be defined\n    // since this is a private element that we control.\n    return (await this.host()).getAttribute('aria-label') as Promise<string>;\n  }\n\n  /** Whether the cell is selected. */\n  async isSelected(): Promise<boolean> {\n    const host = await this.host();\n    return (await host.getAttribute('aria-pressed')) === 'true';\n  }\n\n  /** Whether the cell is disabled. */\n  async isDisabled(): Promise<boolean> {\n    return this._hasState('disabled');\n  }\n\n  /** Whether the cell is currently activated using keyboard navigation. */\n  async isActive(): Promise<boolean> {\n    return this._hasState('active');\n  }\n\n  /** Whether the cell represents today's date. */\n  async isToday(): Promise<boolean> {\n    return (await this._content()).hasClass('mat-calendar-body-today');\n  }\n\n  /** Selects the calendar cell. Won't do anything if the cell is disabled. */\n  async select(): Promise<void> {\n    return (await this.host()).click();\n  }\n\n  /** Hovers over the calendar cell. */\n  async hover(): Promise<void> {\n    return (await this.host()).hover();\n  }\n\n  /** Moves the mouse away from the calendar cell. */\n  async mouseAway(): Promise<void> {\n    return (await this.host()).mouseAway();\n  }\n\n  /** Focuses the calendar cell. */\n  async focus(): Promise<void> {\n    return (await this.host()).focus();\n  }\n\n  /** Removes focus from the calendar cell. */\n  async blur(): Promise<void> {\n    return (await this.host()).blur();\n  }\n\n  /** Whether the cell is the start of the main range. */\n  async isRangeStart(): Promise<boolean> {\n    return this._hasState('range-start');\n  }\n\n  /** Whether the cell is the end of the main range. */\n  async isRangeEnd(): Promise<boolean> {\n    return this._hasState('range-end');\n  }\n\n  /** Whether the cell is part of the main range. */\n  async isInRange(): Promise<boolean> {\n    return this._hasState('in-range');\n  }\n\n  /** Whether the cell is the start of the comparison range. */\n  async isComparisonRangeStart(): Promise<boolean> {\n    return this._hasState('comparison-start');\n  }\n\n  /** Whether the cell is the end of the comparison range. */\n  async isComparisonRangeEnd(): Promise<boolean> {\n    return this._hasState('comparison-end');\n  }\n\n  /** Whether the cell is inside of the comparison range. */\n  async isInComparisonRange(): Promise<boolean> {\n    return this._hasState('in-comparison-range');\n  }\n\n  /** Whether the cell is the start of the preview range. */\n  async isPreviewRangeStart(): Promise<boolean> {\n    return this._hasState('preview-start');\n  }\n\n  /** Whether the cell is the end of the preview range. */\n  async isPreviewRangeEnd(): Promise<boolean> {\n    return this._hasState('preview-end');\n  }\n\n  /** Whether the cell is inside of the preview range. */\n  async isInPreviewRange(): Promise<boolean> {\n    return this._hasState('in-preview');\n  }\n\n  /** Returns whether the cell has a particular CSS class-based state. */\n  private async _hasState(name: string): Promise<boolean> {\n    return (await this.host()).hasClass(`mat-calendar-body-${name}`);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {HarnessPredicate, ComponentHarness} from '@angular/cdk/testing';\nimport {CalendarHarnessFilters, CalendarCellHarnessFilters} from './datepicker-harness-filters';\nimport {MatCalendarCellHarness} from './calendar-cell-harness';\n\n/** Possible views of a `MatCalendarHarness`. */\nexport enum CalendarView {\n  MONTH,\n  YEAR,\n  MULTI_YEAR,\n}\n\n/** Harness for interacting with a standard Material calendar in tests. */\nexport class MatCalendarHarness extends ComponentHarness {\n  static hostSelector = '.mat-calendar';\n\n  /** Queries for the calendar's period toggle button. */\n  private _periodButton = this.locatorFor('.mat-calendar-period-button');\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a `MatCalendarHarness`\n   * that meets certain criteria.\n   * @param options Options for filtering which calendar instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with(options: CalendarHarnessFilters = {}): HarnessPredicate<MatCalendarHarness> {\n    return new HarnessPredicate(MatCalendarHarness, options);\n  }\n\n  /**\n   * Gets a list of cells inside the calendar.\n   * @param filter Optionally filters which cells are included.\n   */\n  async getCells(filter: CalendarCellHarnessFilters = {}): Promise<MatCalendarCellHarness[]> {\n    return this.locatorForAll(MatCalendarCellHarness.with(filter))();\n  }\n\n  /** Gets the current view that is being shown inside the calendar. */\n  async getCurrentView(): Promise<CalendarView> {\n    if (await this.locatorForOptional('mat-multi-year-view')()) {\n      return CalendarView.MULTI_YEAR;\n    }\n\n    if (await this.locatorForOptional('mat-year-view')()) {\n      return CalendarView.YEAR;\n    }\n\n    return CalendarView.MONTH;\n  }\n\n  /** Gets the label of the current calendar view. */\n  async getCurrentViewLabel(): Promise<string> {\n    return (await this._periodButton()).text();\n  }\n\n  /** Changes the calendar view by clicking on the view toggle button. */\n  async changeView(): Promise<void> {\n    return (await this._periodButton()).click();\n  }\n\n  /** Goes to the next page of the current view (e.g. next month when inside the month view). */\n  async next(): Promise<void> {\n    return (await this.locatorFor('.mat-calendar-next-button')()).click();\n  }\n\n  /**\n   * Goes to the previous page of the current view\n   * (e.g. previous month when inside the month view).\n   */\n  async previous(): Promise<void> {\n    return (await this.locatorFor('.mat-calendar-previous-button')()).click();\n  }\n\n  /**\n   * Selects a cell in the current calendar view.\n   * @param filter An optional filter to apply to the cells. The first cell matching the filter\n   *     will be selected.\n   */\n  async selectCell(filter: CalendarCellHarnessFilters = {}): Promise<void> {\n    const cells = await this.getCells(filter);\n    if (!cells.length) {\n      throw Error(`Cannot find calendar cell matching filter ${JSON.stringify(filter)}`);\n    }\n    await cells[0].select();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ComponentHarness, LocatorFactory, parallel, TestElement} from '@angular/cdk/testing';\nimport {CalendarHarnessFilters} from './datepicker-harness-filters';\nimport {MatCalendarHarness} from './calendar-harness';\n\n/** Interface for a test harness that can open and close a calendar. */\nexport interface DatepickerTrigger {\n  isCalendarOpen(): Promise<boolean>;\n  openCalendar(): Promise<void>;\n  closeCalendar(): Promise<void>;\n  hasCalendar(): Promise<boolean>;\n  getCalendar(filter?: CalendarHarnessFilters): Promise<MatCalendarHarness>;\n}\n\n/** Base class for harnesses that can trigger a calendar. */\nexport abstract class DatepickerTriggerHarnessBase\n  extends ComponentHarness\n  implements DatepickerTrigger\n{\n  /** Whether the trigger is disabled. */\n  abstract isDisabled(): Promise<boolean>;\n\n  /** Whether the calendar associated with the trigger is open. */\n  abstract isCalendarOpen(): Promise<boolean>;\n\n  /** Opens the calendar associated with the trigger. */\n  protected abstract _openCalendar(): Promise<void>;\n\n  /** Opens the calendar if the trigger is enabled and it has a calendar. */\n  async openCalendar(): Promise<void> {\n    const [isDisabled, hasCalendar] = await parallel(() => [this.isDisabled(), this.hasCalendar()]);\n\n    if (!isDisabled && hasCalendar) {\n      return this._openCalendar();\n    }\n  }\n\n  /** Closes the calendar if it is open. */\n  async closeCalendar(): Promise<void> {\n    if (await this.isCalendarOpen()) {\n      await closeCalendar(getCalendarId(this.host()), this.documentRootLocatorFactory());\n      // This is necessary so that we wait for the closing animation to finish in touch UI mode.\n      await this.forceStabilize();\n    }\n  }\n\n  /** Gets whether there is a calendar associated with the trigger. */\n  async hasCalendar(): Promise<boolean> {\n    return (await getCalendarId(this.host())) != null;\n  }\n\n  /**\n   * Gets the `MatCalendarHarness` that is associated with the trigger.\n   * @param filter Optionally filters which calendar is included.\n   */\n  async getCalendar(filter: CalendarHarnessFilters = {}): Promise<MatCalendarHarness> {\n    return getCalendar(filter, this.host(), this.documentRootLocatorFactory());\n  }\n}\n\n/** Gets the ID of the calendar that a particular test element can trigger. */\nexport async function getCalendarId(host: Promise<TestElement>): Promise<string | null> {\n  return (await host).getAttribute('data-mat-calendar');\n}\n\n/** Closes the calendar with a specific ID. */\nexport async function closeCalendar(\n  calendarId: Promise<string | null>,\n  documentLocator: LocatorFactory,\n) {\n  // We close the calendar by clicking on the backdrop, even though all datepicker variants\n  // have the ability to close by pressing escape. The backdrop is preferrable, because the\n  // escape key has multiple functions inside a range picker (either cancel the current range\n  // or close the calendar). Since we don't have access to set the ID on the backdrop in all\n  // cases, we set a unique class instead which is the same as the calendar's ID and suffixed\n  // with `-backdrop`.\n  const backdropSelector = `.${await calendarId}-backdrop`;\n  return (await documentLocator.locatorFor(backdropSelector)()).click();\n}\n\n/** Gets the test harness for a calendar associated with a particular host. */\nexport async function getCalendar(\n  filter: CalendarHarnessFilters,\n  host: Promise<TestElement>,\n  documentLocator: LocatorFactory,\n): Promise<MatCalendarHarness> {\n  const calendarId = await getCalendarId(host);\n\n  if (!calendarId) {\n    throw Error(`Element is not associated with a calendar`);\n  }\n\n  return documentLocator.locatorFor(\n    MatCalendarHarness.with({\n      ...filter,\n      selector: `#${calendarId}`,\n    }),\n  )();\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {HarnessPredicate, parallel, TestKey} from '@angular/cdk/testing';\nimport {DatepickerInputHarnessFilters, CalendarHarnessFilters} from './datepicker-harness-filters';\nimport {MatDatepickerInputHarnessBase, getInputPredicate} from './datepicker-input-harness-base';\nimport {MatCalendarHarness} from './calendar-harness';\nimport {\n  DatepickerTrigger,\n  closeCalendar,\n  getCalendarId,\n  getCalendar,\n} from './datepicker-trigger-harness-base';\n\n/** Harness for interacting with a standard Material datepicker inputs in tests. */\nexport class MatDatepickerInputHarness\n  extends MatDatepickerInputHarnessBase\n  implements DatepickerTrigger\n{\n  static hostSelector = '.mat-datepicker-input';\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a `MatDatepickerInputHarness`\n   * that meets certain criteria.\n   * @param options Options for filtering which input instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with(\n    options: DatepickerInputHarnessFilters = {},\n  ): HarnessPredicate<MatDatepickerInputHarness> {\n    return getInputPredicate(MatDatepickerInputHarness, options);\n  }\n\n  /** Gets whether the calendar associated with the input is open. */\n  async isCalendarOpen(): Promise<boolean> {\n    // `aria-owns` is set only if there's an open datepicker so we can use it as an indicator.\n    const host = await this.host();\n    return (await host.getAttribute('aria-owns')) != null;\n  }\n\n  /** Opens the calendar associated with the input. */\n  async openCalendar(): Promise<void> {\n    const [isDisabled, hasCalendar] = await parallel(() => [this.isDisabled(), this.hasCalendar()]);\n\n    if (!isDisabled && hasCalendar) {\n      // Alt + down arrow is the combination for opening the calendar with the keyboard.\n      const host = await this.host();\n      return host.sendKeys({alt: true}, TestKey.DOWN_ARROW);\n    }\n  }\n\n  /** Closes the calendar associated with the input. */\n  async closeCalendar(): Promise<void> {\n    if (await this.isCalendarOpen()) {\n      await closeCalendar(getCalendarId(this.host()), this.documentRootLocatorFactory());\n      // This is necessary so that we wait for the closing animation to finish in touch UI mode.\n      await this.forceStabilize();\n    }\n  }\n\n  /** Whether a calendar is associated with the input. */\n  async hasCalendar(): Promise<boolean> {\n    return (await getCalendarId(this.host())) != null;\n  }\n\n  /**\n   * Gets the `MatCalendarHarness` that is associated with the trigger.\n   * @param filter Optionally filters which calendar is included.\n   */\n  async getCalendar(filter: CalendarHarnessFilters = {}): Promise<MatCalendarHarness> {\n    return getCalendar(filter, this.host(), this.documentRootLocatorFactory());\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {HarnessPredicate, parallel, TestKey} from '@angular/cdk/testing';\nimport {MatDatepickerInputHarnessBase, getInputPredicate} from './datepicker-input-harness-base';\nimport {DatepickerTriggerHarnessBase} from './datepicker-trigger-harness-base';\nimport {\n  DatepickerInputHarnessFilters,\n  DateRangeInputHarnessFilters,\n} from './datepicker-harness-filters';\n\n/** Harness for interacting with a standard Material date range start input in tests. */\nexport class MatStartDateHarness extends MatDatepickerInputHarnessBase {\n  static hostSelector = '.mat-start-date';\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a `MatStartDateHarness`\n   * that meets certain criteria.\n   * @param options Options for filtering which input instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with(options: DatepickerInputHarnessFilters = {}): HarnessPredicate<MatStartDateHarness> {\n    return getInputPredicate(MatStartDateHarness, options);\n  }\n}\n\n/** Harness for interacting with a standard Material date range end input in tests. */\nexport class MatEndDateHarness extends MatDatepickerInputHarnessBase {\n  static hostSelector = '.mat-end-date';\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a `MatEndDateHarness`\n   * that meets certain criteria.\n   * @param options Options for filtering which input instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with(options: DatepickerInputHarnessFilters = {}): HarnessPredicate<MatEndDateHarness> {\n    return getInputPredicate(MatEndDateHarness, options);\n  }\n}\n\n/** Harness for interacting with a standard Material date range input in tests. */\nexport class MatDateRangeInputHarness extends DatepickerTriggerHarnessBase {\n  static hostSelector = '.mat-date-range-input';\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a `MatDateRangeInputHarness`\n   * that meets certain criteria.\n   * @param options Options for filtering which input instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with(\n    options: DateRangeInputHarnessFilters = {},\n  ): HarnessPredicate<MatDateRangeInputHarness> {\n    return new HarnessPredicate(MatDateRangeInputHarness, options)\n      .addOption('value', options.value, (harness, value) =>\n        HarnessPredicate.stringMatches(harness.getValue(), value),\n      )\n      .addOption('label', options.label, (harness, label) => {\n        return HarnessPredicate.stringMatches(harness.getLabel(), label);\n      });\n  }\n\n  /** Gets the combined value of the start and end inputs, including the separator. */\n  async getValue(): Promise<string> {\n    const [start, end, separator] = await parallel(() => [\n      this.getStartInput().then(input => input.getValue()),\n      this.getEndInput().then(input => input.getValue()),\n      this.getSeparator(),\n    ]);\n\n    return start + `${end ? ` ${separator} ${end}` : ''}`;\n  }\n\n  /** Gets the inner start date input inside the range input. */\n  async getStartInput(): Promise<MatStartDateHarness> {\n    // Don't pass in filters here since the start input is required and there can only be one.\n    return this.locatorFor(MatStartDateHarness)();\n  }\n\n  /** Gets the inner start date input inside the range input. */\n  async getEndInput(): Promise<MatEndDateHarness> {\n    // Don't pass in filters here since the end input is required and there can only be one.\n    return this.locatorFor(MatEndDateHarness)();\n  }\n\n  /**\n   * Gets the label for the range input, if it exists. This might be provided by a label element or\n   * by the `aria-label` attribute.\n   */\n  async getLabel(): Promise<string | null> {\n    // Directly copied from MatFormFieldControlHarnessBase. This class already has a parent so it\n    // cannot extend MatFormFieldControlHarnessBase for the functionality.\n    const documentRootLocator = this.documentRootLocatorFactory();\n    const labelId = await (await this.host()).getAttribute('aria-labelledby');\n    const labelText = await (await this.host()).getAttribute('aria-label');\n    const hostId = await (await this.host()).getAttribute('id');\n\n    if (labelId) {\n      // First, try to find the label by following [aria-labelledby]\n      const labelEl = await documentRootLocator.locatorForOptional(`[id=\"${labelId}\"]`)();\n      return labelEl ? labelEl.text() : null;\n    } else if (labelText) {\n      // If that doesn't work, return [aria-label] if it exists\n      return labelText;\n    } else if (hostId) {\n      // Finally, search the DOM for a label that points to the host element\n      const labelEl = await documentRootLocator.locatorForOptional(`[for=\"${hostId}\"]`)();\n      return labelEl ? labelEl.text() : null;\n    }\n    return null;\n  }\n\n  /** Gets the separator text between the values of the two inputs. */\n  async getSeparator(): Promise<string> {\n    return (await this.locatorFor('.mat-date-range-input-separator')()).text();\n  }\n\n  /** Gets whether the range input is disabled. */\n  async isDisabled(): Promise<boolean> {\n    // We consider the input as disabled if both of the sub-inputs are disabled.\n    const [startDisabled, endDisabled] = await parallel(() => [\n      this.getStartInput().then(input => input.isDisabled()),\n      this.getEndInput().then(input => input.isDisabled()),\n    ]);\n\n    return startDisabled && endDisabled;\n  }\n\n  /** Gets whether the range input is required. */\n  async isRequired(): Promise<boolean> {\n    return (await this.host()).hasClass('mat-date-range-input-required');\n  }\n\n  /** Opens the calendar associated with the input. */\n  async isCalendarOpen(): Promise<boolean> {\n    // `aria-owns` is set on both inputs only if there's an\n    // open range picker so we can use it as an indicator.\n    const startHost = await (await this.getStartInput()).host();\n    return (await startHost.getAttribute('aria-owns')) != null;\n  }\n\n  protected async _openCalendar(): Promise<void> {\n    // Alt + down arrow is the combination for opening the calendar with the keyboard.\n    const startHost = await (await this.getStartInput()).host();\n    return startHost.sendKeys({alt: true}, TestKey.DOWN_ARROW);\n  }\n}\n"],"names":["addOption","options","placeholder","harness","label","HarnessPredicate","stringMatches","getLabel","MatDatepickerInputHarnessBase","MatFormFieldControlHarnessBase","isDisabled","host","getProperty","getValue","setValue","newValue","inputEl","dispatchEvent","focus","blur","with","isSelected","selected","active","isActive","disabled","today","isToday","inRange","isInRange","inComparisonRange","isInComparisonRange","inPreviewRange","isInPreviewRange","getText","_content","text","getAriaLabel","getAttribute","select","hover","mouseAway","isRangeStart","_hasState","isRangeEnd","isComparisonRangeStart","CalendarView","MatCalendarHarness","hostSelector","getCells","filter","locatorForAll","MatCalendarCellHarness","MULTI_YEAR","locatorForOptional","MONTH","getCurrentViewLabel","_periodButton","click","next","previous","locatorFor","hasCalendar","_openCalendar","closeCalendar","isCalendarOpen","getCalendarId","documentRootLocatorFactory","forceStabilize","getCalendar","getInputPredicate","MatDatepickerInputHarness","parallel","start","end","separator","getStartInput","then","input","getEndInput","MatStartDateHarness","MatEndDateHarness","hostId","labelId","labelEl","labelText","documentRootLocator","startDisabled","endDisabled"],"mappings":"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"}