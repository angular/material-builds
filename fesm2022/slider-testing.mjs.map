{"version":3,"file":"slider-testing.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/slider/testing/slider-thumb-harness.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/slider/testing/slider-harness.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {coerceNumberProperty} from '@angular/cdk/coercion';\nimport {\n  ComponentHarness,\n  ComponentHarnessConstructor,\n  HarnessPredicate,\n  parallel,\n} from '@angular/cdk/testing';\nimport {SliderThumbHarnessFilters, ThumbPosition} from './slider-harness-filters';\n\n/** Harness for interacting with a thumb inside of a Material slider in tests. */\nexport class MatSliderThumbHarness extends ComponentHarness {\n  static hostSelector =\n    'input[matSliderThumb], input[matSliderStartThumb], input[matSliderEndThumb]';\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a slider thumb with specific attributes.\n   * @param options Options for filtering which thumb instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with<T extends MatSliderThumbHarness>(\n    this: ComponentHarnessConstructor<T>,\n    options: SliderThumbHarnessFilters = {},\n  ): HarnessPredicate<T> {\n    return new HarnessPredicate(this, options).addOption(\n      'position',\n      options.position,\n      async (harness, value) => {\n        return (await harness.getPosition()) === value;\n      },\n    );\n  }\n\n  /** Gets the position of the thumb inside the slider. */\n  async getPosition(): Promise<ThumbPosition> {\n    // Meant to mimic MDC's logic where `matSliderThumb` is treated as END.\n    const isStart = (await (await this.host()).getAttribute('matSliderStartThumb')) != null;\n    return isStart ? ThumbPosition.START : ThumbPosition.END;\n  }\n\n  /** Gets the value of the thumb. */\n  async getValue(): Promise<number> {\n    return await (await this.host()).getProperty<number>('valueAsNumber');\n  }\n\n  /** Sets the value of the thumb. */\n  async setValue(newValue: number): Promise<void> {\n    const input = await this.host();\n\n    // Since this is a range input, we can't simulate the user interacting with it so we set the\n    // value directly and dispatch a couple of fake events to ensure that everything fires.\n    await input.setInputValue(newValue + '');\n    await input.dispatchEvent('input');\n    await input.dispatchEvent('change');\n  }\n\n  /** Gets the current percentage value of the slider. */\n  async getPercentage(): Promise<number> {\n    const [value, min, max] = await parallel(() => [\n      this.getValue(),\n      this.getMinValue(),\n      this.getMaxValue(),\n    ]);\n\n    return (value - min) / (max - min);\n  }\n\n  /** Gets the maximum value of the thumb. */\n  async getMaxValue(): Promise<number> {\n    return coerceNumberProperty(await (await this.host()).getProperty<number>('max'));\n  }\n\n  /** Gets the minimum value of the thumb. */\n  async getMinValue(): Promise<number> {\n    return coerceNumberProperty(await (await this.host()).getProperty<number>('min'));\n  }\n\n  /** Gets the text representation of the slider's value. */\n  async getDisplayValue(): Promise<string> {\n    return (await (await this.host()).getAttribute('aria-valuetext')) || '';\n  }\n\n  /** Whether the thumb is disabled. */\n  async isDisabled(): Promise<boolean> {\n    return (await this.host()).getProperty<boolean>('disabled');\n  }\n\n  /** Gets the name of the thumb. */\n  async getName(): Promise<string> {\n    return await (await this.host()).getProperty<string>('name');\n  }\n\n  /** Gets the id of the thumb. */\n  async getId(): Promise<string> {\n    return await (await this.host()).getProperty<string>('id');\n  }\n\n  /**\n   * Focuses the thumb and returns a promise that indicates when the\n   * action is complete.\n   */\n  async focus(): Promise<void> {\n    return (await this.host()).focus();\n  }\n\n  /**\n   * Blurs the thumb and returns a promise that indicates when the\n   * action is complete.\n   */\n  async blur(): Promise<void> {\n    return (await this.host()).blur();\n  }\n\n  /** Whether the thumb is focused. */\n  async isFocused(): Promise<boolean> {\n    return (await this.host()).isFocused();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ComponentHarness,\n  ComponentHarnessConstructor,\n  HarnessPredicate,\n} from '@angular/cdk/testing';\nimport {coerceNumberProperty} from '@angular/cdk/coercion';\nimport {SliderHarnessFilters, ThumbPosition} from './slider-harness-filters';\nimport {MatSliderThumbHarness} from './slider-thumb-harness';\n\n/** Harness for interacting with a MDC mat-slider in tests. */\nexport class MatSliderHarness extends ComponentHarness {\n  static hostSelector = '.mat-mdc-slider';\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a slider with specific attributes.\n   * @param options Options for filtering which input instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with<T extends MatSliderHarness>(\n    this: ComponentHarnessConstructor<T>,\n    options: SliderHarnessFilters = {},\n  ): HarnessPredicate<T> {\n    return new HarnessPredicate(this, options)\n      .addOption('isRange', options.isRange, async (harness, value) => {\n        return (await harness.isRange()) === value;\n      })\n      .addOption('disabled', options.disabled, async (harness, disabled) => {\n        return (await harness.isDisabled()) === disabled;\n      });\n  }\n\n  /** Gets the start thumb of the slider (only applicable for range sliders). */\n  async getStartThumb(): Promise<MatSliderThumbHarness> {\n    if (!(await this.isRange())) {\n      throw Error(\n        '`getStartThumb` is only applicable for range sliders. ' +\n          'Did you mean to use `getEndThumb`?',\n      );\n    }\n    return this.locatorFor(MatSliderThumbHarness.with({position: ThumbPosition.START}))();\n  }\n\n  /** Gets the thumb (for single point sliders), or the end thumb (for range sliders). */\n  async getEndThumb(): Promise<MatSliderThumbHarness> {\n    return this.locatorFor(MatSliderThumbHarness.with({position: ThumbPosition.END}))();\n  }\n\n  /** Gets whether the slider is a range slider. */\n  async isRange(): Promise<boolean> {\n    return await (await this.host()).hasClass('mdc-slider--range');\n  }\n\n  /** Gets whether the slider is disabled. */\n  async isDisabled(): Promise<boolean> {\n    return await (await this.host()).hasClass('mdc-slider--disabled');\n  }\n\n  /** Gets the value step increments of the slider. */\n  async getStep(): Promise<number> {\n    // The same step value is forwarded to both thumbs.\n    const startHost = await (await this.getEndThumb()).host();\n    return coerceNumberProperty(await startHost.getProperty<string>('step'));\n  }\n\n  /** Gets the maximum value of the slider. */\n  async getMaxValue(): Promise<number> {\n    return (await this.getEndThumb()).getMaxValue();\n  }\n\n  /** Gets the minimum value of the slider. */\n  async getMinValue(): Promise<number> {\n    const startThumb = (await this.isRange())\n      ? await this.getStartThumb()\n      : await this.getEndThumb();\n    return startThumb.getMinValue();\n  }\n}\n"],"names":["with","options","HarnessPredicate","addOption","position","harness","value","getPosition","getAttribute","isStart","ThumbPosition","START","END","host","getProperty","setValue","newValue","input","setInputValue","dispatchEvent","getPercentage","min","max","parallel","getValue","getMinValue","getMaxValue","coerceNumberProperty","isDisabled","hostSelector","disabled","getStartThumb","isRange","Error","getEndThumb","locatorFor","MatSliderThumbHarness","hasClass","getStep"],"mappings":";;;;;;;;;;;aA0C2EA,CAAAC,OAAA,GAAA,EAAA,EAAA;AACvE,IAAA,OAAA,IAAAC,gBACA,CAAAD,IAAAA,EAAAA,OAAA,CAAAE,CAAAA,SAAA,CAAAF,UAAAA,EAAAA,OAAA,CAAAG,QAAA,EAAAC,OAAAA,OAAwD,EAAAC,KAAA,KAAA;;;;QAQvBC,WAAA,GAAA;iBAM3B,iBAAmB,WAAY,EAAEC,YACvC,CAAA,qBACM,CACR,KAAA,IAAA;AAEuDC,IAAAA,OAAAA,OAAA,GAAAC,aAAA,CAAAC,KAAA,GAAAD,aAAA,CAAAE,GAAA;;;AAMpD,IAAA,OAAA,MAAC,CAAA,MAAA,IAAA,CAAAC,IAAA,EAAA,EAAAC,WAAA,CAAA,eAAA,CAAA;;AAKJC,EAAAA,MAAAA,QAA2CA,CAAAC,QAAA,EAAA;IAC3C,MAAAC,KAAA,cAAAJ,IAAA,EAAA;AAKA,IAAA,MAAAI,KAAiB,CAAAC,aAAA,CAAAF,QAAA,GAAA,EAAA,CAAA;IACf,MAAAC,KAAA,CAAAE,aAAA,CAAA,OAAA,CAAA;8BAGwD,QAAA,CAAA;AAC1D;QAIAC,aAAA,GAAA;AACA,IAAA,MAAA,CAAAd,KAAA,EAAAe,GAAA,EAAAC,GAAA,CAAA,GAAA,MAAAC,QAAA,CACE,MAAA,CAAA,IAAA,CAAAC,QAAQ,EAAA,EACV,IAAA,CAAAC,WAAA,IAEA,IAAkC,CAAAC,WAAA,EAClC,CAAA,CAAA;;;mBAMEA,GAAA;WACFC,oBAAA,CAAA,MAAA,CAAA,MAAA,IAAA,CAAAd,IAAA,EAAA,EAAAC,WAAA,CAAA,KAAA,CAAA,CAAA;;AAKGW,EAAAA,MAAAA,WAAAA,GAAA;AACH,IAAA,OAAAE,oBAAA,CAAA,MAAA,CAAA,MAAA,IAAA,CAAAd,IAAA,EAAA,EAAAC,WAAA,CAAA,KAAA,CAAA,CAAA;;;;AAQA;AAEAc,EAAAA,MAAAA,UAAAA,GAAA;;;;;;;;;;;;;;;;;;;;;ACnGA,EAAA,OAAAC,YAAA,GAAA,iBAAA;aAgBa7B,CAAAC,OAAA,GAAc,EAAA,EAAA;AACvB,IAAA,OAAC,IAAAC,gBAAC,CAAAD,IAAAA,EAAAA,OAAA;;;AAQE,MAAA,OAAA,CAAA,MAAAI,OAAA,CAAAuB,UAAA,EAAA,MAAAE,QAAA;KAEN,CAAA;;AAOFC,EAAAA,MAAAA,aAAAA,GAAA;AAEiD,IAAA,IAAA,aAAAC,OAAA,EAAA,CAAA,EAAA;YACjDC,KAAa,CAAA,wDAAA,GACX,oCAAiC,CAAA;AACnC;;;;AAIE;AAGFC,EAAAA,MAAAA,WAAoDA,GAAA;AACpD,IAAA,OAAA,IAAa,CAAAC,UACX,CAAAC,qBAAA,CAAApC,IAAA,CAAA;MAAAI,QAAA,EAAAM,aAAmD,CAAAE;AAAA,KAAA,CAAA,CAAA,EAAA;;AAKrDoB,EAAAA,MAAAA,OAA4CA,GAAA;IAC5C,OAAAnB,MAAAA,CAAAA,MAAAA,IAAAA,CAAAA,IAAA,IAAAwB,QAAA,CAAA,mBAAA,CAAA;;AAKAT,EAAAA,MAAAA,UAAiBA,GAAA;;AAGb;AAEJU,EAAAA,MAAAA,OAAAA,GAAA;;;;;;;;;;;;;;;"}