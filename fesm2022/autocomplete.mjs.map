{"version":3,"file":"autocomplete.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/autocomplete/autocomplete.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/autocomplete/autocomplete.html","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/autocomplete/autocomplete-origin.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/autocomplete/autocomplete-trigger.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/autocomplete/autocomplete-module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  AfterContentInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  ElementRef,\n  EventEmitter,\n  InjectionToken,\n  Input,\n  OnDestroy,\n  Output,\n  QueryList,\n  TemplateRef,\n  ViewChild,\n  ViewEncapsulation,\n  booleanAttribute,\n  inject,\n} from '@angular/core';\nimport {\n  _animationsDisabled,\n  MAT_OPTGROUP,\n  MAT_OPTION_PARENT_COMPONENT,\n  MatOptgroup,\n  MatOption,\n  ThemePalette,\n} from '../core';\nimport {_IdGenerator, ActiveDescendantKeyManager} from '@angular/cdk/a11y';\nimport {Platform} from '@angular/cdk/platform';\nimport {Subscription} from 'rxjs';\n\n/** Event object that is emitted when an autocomplete option is selected. */\nexport class MatAutocompleteSelectedEvent {\n  constructor(\n    /** Reference to the autocomplete panel that emitted the event. */\n    public source: MatAutocomplete,\n    /** Option that was selected. */\n    public option: MatOption,\n  ) {}\n}\n\n/** Event object that is emitted when an autocomplete option is activated. */\nexport interface MatAutocompleteActivatedEvent {\n  /** Reference to the autocomplete panel that emitted the event. */\n  source: MatAutocomplete;\n\n  /** Option that was selected. */\n  option: MatOption | null;\n}\n\n/** Default `mat-autocomplete` options that can be overridden. */\nexport interface MatAutocompleteDefaultOptions {\n  /** Whether the first option should be highlighted when an autocomplete panel is opened. */\n  autoActiveFirstOption?: boolean;\n\n  /** Whether the active option should be selected as the user is navigating. */\n  autoSelectActiveOption?: boolean;\n\n  /**\n   * Whether the user is required to make a selection when\n   * they're interacting with the autocomplete.\n   */\n  requireSelection?: boolean;\n\n  /** Class to be applied to the autocomplete's backdrop. */\n  backdropClass?: string;\n\n  /** Whether the autocomplete has a backdrop. */\n  hasBackdrop?: boolean;\n\n  /** Class or list of classes to be applied to the autocomplete's overlay panel. */\n  overlayPanelClass?: string | string[];\n\n  /** Whether icon indicators should be hidden for single-selection. */\n  hideSingleSelectionIndicator?: boolean;\n}\n\n/** Injection token to be used to override the default options for `mat-autocomplete`. */\nexport const MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new InjectionToken<MatAutocompleteDefaultOptions>(\n  'mat-autocomplete-default-options',\n  {\n    providedIn: 'root',\n    factory: () => ({\n      autoActiveFirstOption: false,\n      autoSelectActiveOption: false,\n      hideSingleSelectionIndicator: false,\n      requireSelection: false,\n      hasBackdrop: false,\n    }),\n  },\n);\n\n/** Autocomplete component. */\n@Component({\n  selector: 'mat-autocomplete',\n  templateUrl: 'autocomplete.html',\n  styleUrl: 'autocomplete.css',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  exportAs: 'matAutocomplete',\n  host: {\n    'class': 'mat-mdc-autocomplete',\n  },\n  providers: [{provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatAutocomplete}],\n})\nexport class MatAutocomplete implements AfterContentInit, OnDestroy {\n  private _changeDetectorRef = inject(ChangeDetectorRef);\n  private _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  protected _defaults = inject<MatAutocompleteDefaultOptions>(MAT_AUTOCOMPLETE_DEFAULT_OPTIONS);\n  protected _animationsDisabled = _animationsDisabled();\n  private _activeOptionChanges = Subscription.EMPTY;\n\n  /** Manages active item in option list based on key events. */\n  _keyManager: ActiveDescendantKeyManager<MatOption>;\n\n  /** Whether the autocomplete panel should be visible, depending on option length. */\n  showPanel: boolean = false;\n\n  /** Whether the autocomplete panel is open. */\n  get isOpen(): boolean {\n    return this._isOpen && this.showPanel;\n  }\n  _isOpen: boolean = false;\n\n  /** Latest trigger that opened the autocomplete. */\n  _latestOpeningTrigger: unknown;\n\n  /** @docs-private Sets the theme color of the panel. */\n  _setColor(value: ThemePalette) {\n    this._color = value;\n    this._changeDetectorRef.markForCheck();\n  }\n  /** @docs-private theme color of the panel */\n  protected _color: ThemePalette;\n\n  // The @ViewChild query for TemplateRef here needs to be static because some code paths\n  // lead to the overlay being created before change detection has finished for this component.\n  // Notably, another component may trigger `focus` on the autocomplete-trigger.\n\n  /** @docs-private */\n  @ViewChild(TemplateRef, {static: true}) template: TemplateRef<any>;\n\n  /** Element for the panel containing the autocomplete options. */\n  @ViewChild('panel') panel: ElementRef;\n\n  /** Reference to all options within the autocomplete. */\n  @ContentChildren(MatOption, {descendants: true}) options: QueryList<MatOption>;\n\n  /** Reference to all option groups within the autocomplete. */\n  @ContentChildren(MAT_OPTGROUP, {descendants: true}) optionGroups: QueryList<MatOptgroup>;\n\n  /** Aria label of the autocomplete. */\n  @Input('aria-label') ariaLabel: string;\n\n  /** Input that can be used to specify the `aria-labelledby` attribute. */\n  @Input('aria-labelledby') ariaLabelledby: string;\n\n  /** Function that maps an option's control value to its display value in the trigger. */\n  @Input() displayWith: ((value: any) => string) | null = null;\n\n  /**\n   * Whether the first option should be highlighted when the autocomplete panel is opened.\n   * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\n   */\n  @Input({transform: booleanAttribute}) autoActiveFirstOption: boolean;\n\n  /** Whether the active option should be selected as the user is navigating. */\n  @Input({transform: booleanAttribute}) autoSelectActiveOption: boolean;\n\n  /**\n   * Whether the user is required to make a selection when they're interacting with the\n   * autocomplete. If the user moves away from the autocomplete without selecting an option from\n   * the list, the value will be reset. If the user opens the panel and closes it without\n   * interacting or selecting a value, the initial value will be kept.\n   */\n  @Input({transform: booleanAttribute}) requireSelection: boolean;\n\n  /**\n   * Specify the width of the autocomplete panel.  Can be any CSS sizing value, otherwise it will\n   * match the width of its host.\n   */\n  @Input() panelWidth: string | number;\n\n  /** Whether ripples are disabled within the autocomplete panel. */\n  @Input({transform: booleanAttribute}) disableRipple: boolean;\n\n  /** Event that is emitted whenever an option from the list is selected. */\n  @Output() readonly optionSelected: EventEmitter<MatAutocompleteSelectedEvent> =\n    new EventEmitter<MatAutocompleteSelectedEvent>();\n\n  /** Event that is emitted when the autocomplete panel is opened. */\n  @Output() readonly opened: EventEmitter<void> = new EventEmitter<void>();\n\n  /** Event that is emitted when the autocomplete panel is closed. */\n  @Output() readonly closed: EventEmitter<void> = new EventEmitter<void>();\n\n  /** Emits whenever an option is activated. */\n  @Output() readonly optionActivated: EventEmitter<MatAutocompleteActivatedEvent> =\n    new EventEmitter<MatAutocompleteActivatedEvent>();\n\n  /**\n   * Takes classes set on the host mat-autocomplete element and applies them to the panel\n   * inside the overlay container to allow for easy styling.\n   */\n  @Input('class')\n  set classList(value: string | string[]) {\n    this._classList = value;\n    this._elementRef.nativeElement.className = '';\n  }\n  _classList: string | string[];\n\n  /** Whether checkmark indicator for single-selection options is hidden. */\n  @Input({transform: booleanAttribute})\n  get hideSingleSelectionIndicator(): boolean {\n    return this._hideSingleSelectionIndicator;\n  }\n  set hideSingleSelectionIndicator(value: boolean) {\n    this._hideSingleSelectionIndicator = value;\n    this._syncParentProperties();\n  }\n  private _hideSingleSelectionIndicator: boolean;\n\n  /** Syncs the parent state with the individual options. */\n  _syncParentProperties(): void {\n    if (this.options) {\n      for (const option of this.options) {\n        option._changeDetectorRef.markForCheck();\n      }\n    }\n  }\n\n  /** Unique ID to be used by autocomplete trigger's \"aria-owns\" property. */\n  id: string = inject(_IdGenerator).getId('mat-autocomplete-');\n\n  /**\n   * Tells any descendant `mat-optgroup` to use the inert a11y pattern.\n   * @docs-private\n   */\n  readonly inertGroups: boolean;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const platform = inject(Platform);\n\n    // TODO(crisbeto): the problem that the `inertGroups` option resolves is only present on\n    // Safari using VoiceOver. We should occasionally check back to see whether the bug\n    // wasn't resolved in VoiceOver, and if it has, we can remove this and the `inertGroups`\n    // option altogether.\n    this.inertGroups = platform?.SAFARI || false;\n    this.autoActiveFirstOption = !!this._defaults.autoActiveFirstOption;\n    this.autoSelectActiveOption = !!this._defaults.autoSelectActiveOption;\n    this.requireSelection = !!this._defaults.requireSelection;\n    this._hideSingleSelectionIndicator = this._defaults.hideSingleSelectionIndicator ?? false;\n  }\n\n  ngAfterContentInit() {\n    this._keyManager = new ActiveDescendantKeyManager<MatOption>(this.options)\n      .withWrap()\n      .skipPredicate(this._skipPredicate);\n    this._activeOptionChanges = this._keyManager.change.subscribe(index => {\n      if (this.isOpen) {\n        this.optionActivated.emit({source: this, option: this.options.toArray()[index] || null});\n      }\n    });\n\n    // Set the initial visibility state.\n    this._setVisibility();\n  }\n\n  ngOnDestroy() {\n    this._keyManager?.destroy();\n    this._activeOptionChanges.unsubscribe();\n  }\n\n  /**\n   * Sets the panel scrollTop. This allows us to manually scroll to display options\n   * above or below the fold, as they are not actually being focused when active.\n   */\n  _setScrollTop(scrollTop: number): void {\n    if (this.panel) {\n      this.panel.nativeElement.scrollTop = scrollTop;\n    }\n  }\n\n  /** Returns the panel's scrollTop. */\n  _getScrollTop(): number {\n    return this.panel ? this.panel.nativeElement.scrollTop : 0;\n  }\n\n  /** Panel should hide itself when the option list is empty. */\n  _setVisibility() {\n    this.showPanel = !!this.options?.length;\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /** Emits the `select` event. */\n  _emitSelectEvent(option: MatOption): void {\n    const event = new MatAutocompleteSelectedEvent(this, option);\n    this.optionSelected.emit(event);\n  }\n\n  /** Gets the aria-labelledby for the autocomplete panel. */\n  _getPanelAriaLabelledby(labelId: string | null): string | null {\n    if (this.ariaLabel) {\n      return null;\n    }\n\n    const labelExpression = labelId ? labelId + ' ' : '';\n    return this.ariaLabelledby ? labelExpression + this.ariaLabelledby : labelId;\n  }\n\n  // `skipPredicate` determines if key manager should avoid putting a given option in the tab\n  // order. Allow disabled list items to receive focus via keyboard to align with WAI ARIA\n  // recommendation.\n  //\n  // Normally WAI ARIA's instructions are to exclude disabled items from the tab order, but it\n  // makes a few exceptions for compound widgets.\n  //\n  // From [Developing a Keyboard Interface](\n  // https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/):\n  //   \"For the following composite widget elements, keep them focusable when disabled: Options in a\n  //   Listbox...\"\n  //\n  // The user can focus disabled options using the keyboard, but the user cannot click disabled\n  // options.\n  protected _skipPredicate() {\n    return false;\n  }\n}\n","<ng-template let-formFieldId=\"id\">\n  <div\n    class=\"mat-mdc-autocomplete-panel mdc-menu-surface mdc-menu-surface--open\"\n    role=\"listbox\"\n    [id]=\"id\"\n    [class]=\"_classList\"\n    [class.mat-mdc-autocomplete-visible]=\"showPanel\"\n    [class.mat-mdc-autocomplete-hidden]=\"!showPanel\"\n    [class.mat-autocomplete-panel-animations-enabled]=\"!_animationsDisabled\"\n    [class.mat-primary]=\"_color === 'primary'\"\n    [class.mat-accent]=\"_color === 'accent'\"\n    [class.mat-warn]=\"_color === 'warn'\"\n    [attr.aria-label]=\"ariaLabel || null\"\n    [attr.aria-labelledby]=\"_getPanelAriaLabelledby(formFieldId)\"\n    #panel>\n    <ng-content></ng-content>\n  </div>\n</ng-template>\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive, ElementRef, inject} from '@angular/core';\n\n/**\n * Directive applied to an element to make it usable\n * as a connection point for an autocomplete panel.\n */\n@Directive({\n  selector: '[matAutocompleteOrigin]',\n  exportAs: 'matAutocompleteOrigin',\n})\nexport class MatAutocompleteOrigin {\n  elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n\n  constructor(...args: unknown[]);\n  constructor() {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {addAriaReferencedId, removeAriaReferencedId} from '@angular/cdk/a11y';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {DOWN_ARROW, ENTER, ESCAPE, TAB, UP_ARROW, hasModifierKey} from '@angular/cdk/keycodes';\nimport {BreakpointObserver, Breakpoints} from '@angular/cdk/layout';\nimport {\n  ConnectedPosition,\n  createFlexibleConnectedPositionStrategy,\n  createOverlayRef,\n  createRepositionScrollStrategy,\n  FlexibleConnectedPositionStrategy,\n  OverlayConfig,\n  OverlayRef,\n  PositionStrategy,\n  ScrollStrategy,\n} from '@angular/cdk/overlay';\nimport {_getEventTarget, _getFocusedElementPierceShadowDom} from '@angular/cdk/platform';\nimport {TemplatePortal} from '@angular/cdk/portal';\nimport {ViewportRuler} from '@angular/cdk/scrolling';\nimport {\n  AfterViewInit,\n  ChangeDetectorRef,\n  Directive,\n  ElementRef,\n  EnvironmentInjector,\n  InjectionToken,\n  Injector,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Renderer2,\n  SimpleChanges,\n  ViewContainerRef,\n  afterNextRender,\n  booleanAttribute,\n  forwardRef,\n  inject,\n} from '@angular/core';\nimport {coerceArray} from '@angular/cdk/coercion';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '@angular/forms';\nimport {\n  MatOption,\n  MatOptionSelectionChange,\n  _animationsDisabled,\n  _countGroupLabelsBeforeOption,\n  _getOptionScrollPosition,\n} from '../core';\nimport {MAT_FORM_FIELD, MatFormField} from '../form-field';\nimport {Observable, Subject, Subscription, defer, merge, of as observableOf} from 'rxjs';\nimport {delay, filter, map, startWith, switchMap, take, tap} from 'rxjs/operators';\nimport {\n  MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,\n  MatAutocomplete,\n  MatAutocompleteDefaultOptions,\n} from './autocomplete';\nimport {MatAutocompleteOrigin} from './autocomplete-origin';\n\n/**\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * @docs-private\n */\nexport const MAT_AUTOCOMPLETE_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatAutocompleteTrigger),\n  multi: true,\n};\n\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n * @docs-private\n */\nexport function getMatAutocompleteMissingPanelError(): Error {\n  return Error(\n    'Attempting to open an undefined instance of `mat-autocomplete`. ' +\n      'Make sure that the id passed to the `matAutocomplete` is correct and that ' +\n      \"you're attempting to open it after the ngAfterContentInit hook.\",\n  );\n}\n\n/** Injection token that determines the scroll handling while the autocomplete panel is open. */\nexport const MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new InjectionToken<() => ScrollStrategy>(\n  'mat-autocomplete-scroll-strategy',\n  {\n    providedIn: 'root',\n    factory: () => {\n      const injector = inject(Injector);\n      return () => createRepositionScrollStrategy(injector);\n    },\n  },\n);\n\n/** Base class with all of the `MatAutocompleteTrigger` functionality. */\n@Directive({\n  selector: `input[matAutocomplete], textarea[matAutocomplete]`,\n  host: {\n    'class': 'mat-mdc-autocomplete-trigger',\n    '[attr.autocomplete]': 'autocompleteAttribute',\n    '[attr.role]': 'autocompleteDisabled ? null : \"combobox\"',\n    '[attr.aria-autocomplete]': 'autocompleteDisabled ? null : \"list\"',\n    '[attr.aria-activedescendant]': '(panelOpen && activeOption) ? activeOption.id : null',\n    '[attr.aria-expanded]': 'autocompleteDisabled ? null : panelOpen.toString()',\n    '[attr.aria-controls]': '(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id',\n    '[attr.aria-haspopup]': 'autocompleteDisabled ? null : \"listbox\"',\n    // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\n    // a little earlier. This avoids issues where IE delays the focusing of the input.\n    '(focusin)': '_handleFocus()',\n    '(blur)': '_onTouched()',\n    '(input)': '_handleInput($event)',\n    '(keydown)': '_handleKeydown($event)',\n    '(click)': '_handleClick()',\n  },\n  exportAs: 'matAutocompleteTrigger',\n  providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR],\n})\nexport class MatAutocompleteTrigger\n  implements ControlValueAccessor, AfterViewInit, OnChanges, OnDestroy\n{\n  private _environmentInjector = inject(EnvironmentInjector);\n  private _element = inject<ElementRef<HTMLInputElement>>(ElementRef);\n  private _injector = inject(Injector);\n  private _viewContainerRef = inject(ViewContainerRef);\n  private _zone = inject(NgZone);\n  private _changeDetectorRef = inject(ChangeDetectorRef);\n  private _dir = inject(Directionality, {optional: true});\n  private _formField = inject<MatFormField | null>(MAT_FORM_FIELD, {optional: true, host: true});\n  private _viewportRuler = inject(ViewportRuler);\n  private _scrollStrategy = inject(MAT_AUTOCOMPLETE_SCROLL_STRATEGY);\n  private _renderer = inject(Renderer2);\n  private _animationsDisabled = _animationsDisabled();\n  private _defaults = inject<MatAutocompleteDefaultOptions | null>(\n    MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,\n    {optional: true},\n  );\n\n  private _overlayRef: OverlayRef | null;\n  private _portal: TemplatePortal;\n  private _componentDestroyed = false;\n  private _initialized = new Subject();\n  private _keydownSubscription: Subscription | null;\n  private _outsideClickSubscription: Subscription | null;\n  private _cleanupWindowBlur: (() => void) | undefined;\n\n  /** Old value of the native input. Used to work around issues with the `input` event on IE. */\n  private _previousValue: string | number | null;\n\n  /** Value of the input element when the panel was attached (even if there are no options). */\n  private _valueOnAttach: string | number | null;\n\n  /** Value on the previous keydown event. */\n  private _valueOnLastKeydown: string | null;\n\n  /** Strategy that is used to position the panel. */\n  private _positionStrategy: FlexibleConnectedPositionStrategy;\n\n  /** Whether or not the label state is being overridden. */\n  private _manuallyFloatingLabel = false;\n\n  /** The subscription for closing actions (some are bound to document). */\n  private _closingActionsSubscription: Subscription;\n\n  /** Subscription to viewport size changes. */\n  private _viewportSubscription = Subscription.EMPTY;\n\n  /** Implements BreakpointObserver to be used to detect handset landscape */\n  private _breakpointObserver = inject(BreakpointObserver);\n  private _handsetLandscapeSubscription = Subscription.EMPTY;\n\n  /**\n   * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n   * closed autocomplete from being reopened if the user switches to another browser tab and then\n   * comes back.\n   */\n  private _canOpenOnNextFocus = true;\n\n  /** Value inside the input before we auto-selected an option. */\n  private _valueBeforeAutoSelection: string | undefined;\n\n  /**\n   * Current option that we have auto-selected as the user is navigating,\n   * but which hasn't been propagated to the model value yet.\n   */\n  private _pendingAutoselectedOption: MatOption | null;\n\n  /** Stream of keyboard events that can close the panel. */\n  private readonly _closeKeyEventStream = new Subject<void>();\n\n  /** Classes to apply to the panel. Exposed as a public property for internal usage. */\n  readonly _overlayPanelClass = coerceArray(this._defaults?.overlayPanelClass || []);\n\n  /**\n   * Event handler for when the window is blurred. Needs to be an\n   * arrow function in order to preserve the context.\n   */\n  private _windowBlurHandler = () => {\n    // If the user blurred the window while the autocomplete is focused, it means that it'll be\n    // refocused when they come back. In this case we want to skip the first focus event, if the\n    // pane was closed, in order to avoid reopening it unintentionally.\n    this._canOpenOnNextFocus = this.panelOpen || !this._hasFocus();\n  };\n\n  /** `View -> model callback called when value changes` */\n  _onChange: (value: any) => void = () => {};\n\n  /** `View -> model callback called when autocomplete has been touched` */\n  _onTouched = () => {};\n\n  /** The autocomplete panel to be attached to this trigger. */\n  @Input('matAutocomplete') autocomplete: MatAutocomplete;\n\n  /**\n   * Position of the autocomplete panel relative to the trigger element. A position of `auto`\n   * will render the panel underneath the trigger if there is enough space for it to fit in\n   * the viewport, otherwise the panel will be shown above it. If the position is set to\n   * `above` or `below`, the panel will always be shown above or below the trigger. no matter\n   * whether it fits completely in the viewport.\n   */\n  @Input('matAutocompletePosition') position: 'auto' | 'above' | 'below' = 'auto';\n\n  /**\n   * Reference relative to which to position the autocomplete panel.\n   * Defaults to the autocomplete trigger element.\n   */\n  @Input('matAutocompleteConnectedTo') connectedTo: MatAutocompleteOrigin;\n\n  /**\n   * `autocomplete` attribute to be set on the input element.\n   * @docs-private\n   */\n  @Input('autocomplete') autocompleteAttribute: string = 'off';\n\n  /**\n   * Whether the autocomplete is disabled. When disabled, the element will\n   * act as a regular input and the user won't be able to open the panel.\n   */\n  @Input({alias: 'matAutocompleteDisabled', transform: booleanAttribute})\n  autocompleteDisabled: boolean;\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  /** Class to apply to the panel when it's above the input. */\n  private _aboveClass = 'mat-mdc-autocomplete-panel-above';\n\n  ngAfterViewInit() {\n    this._initialized.next();\n    this._initialized.complete();\n    this._cleanupWindowBlur = this._renderer.listen('window', 'blur', this._windowBlurHandler);\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    if (changes['position'] && this._positionStrategy) {\n      this._setStrategyPositions(this._positionStrategy);\n\n      if (this.panelOpen) {\n        this._overlayRef!.updatePosition();\n      }\n    }\n  }\n\n  ngOnDestroy() {\n    this._cleanupWindowBlur?.();\n    this._handsetLandscapeSubscription.unsubscribe();\n    this._viewportSubscription.unsubscribe();\n    this._componentDestroyed = true;\n    this._destroyPanel();\n    this._closeKeyEventStream.complete();\n    this._clearFromModal();\n  }\n\n  /** Whether or not the autocomplete panel is open. */\n  get panelOpen(): boolean {\n    return this._overlayAttached && this.autocomplete.showPanel;\n  }\n  private _overlayAttached: boolean = false;\n\n  /** Opens the autocomplete suggestion panel. */\n  openPanel(): void {\n    this._openPanelInternal();\n  }\n\n  /** Closes the autocomplete suggestion panel. */\n  closePanel(): void {\n    this._resetLabel();\n\n    if (!this._overlayAttached) {\n      return;\n    }\n\n    if (this.panelOpen) {\n      // Only emit if the panel was visible.\n      // `afterNextRender` always runs outside of the Angular zone, so all the subscriptions from\n      // `_subscribeToClosingActions()` are also outside of the Angular zone.\n      // We should manually run in Angular zone to update UI after panel closing.\n      this._zone.run(() => {\n        this.autocomplete.closed.emit();\n      });\n    }\n\n    // Only reset if this trigger is the latest one that opened the\n    // autocomplete since another may have taken it over.\n    if (this.autocomplete._latestOpeningTrigger === this) {\n      this.autocomplete._isOpen = false;\n      this.autocomplete._latestOpeningTrigger = null;\n    }\n\n    this._overlayAttached = false;\n    this._pendingAutoselectedOption = null;\n\n    if (this._overlayRef && this._overlayRef.hasAttached()) {\n      this._overlayRef.detach();\n      this._closingActionsSubscription.unsubscribe();\n    }\n\n    this._updatePanelState();\n\n    // Note that in some cases this can end up being called after the component is destroyed.\n    // Add a check to ensure that we don't try to run change detection on a destroyed view.\n    if (!this._componentDestroyed) {\n      // We need to trigger change detection manually, because\n      // `fromEvent` doesn't seem to do it at the proper time.\n      // This ensures that the label is reset when the\n      // user clicks outside.\n      this._changeDetectorRef.detectChanges();\n    }\n\n    // Remove aria-owns attribute when the autocomplete is no longer visible.\n    if (this._trackedModal) {\n      removeAriaReferencedId(this._trackedModal, 'aria-owns', this.autocomplete.id);\n    }\n  }\n\n  /**\n   * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n   * within the viewport.\n   */\n  updatePosition(): void {\n    if (this._overlayAttached) {\n      this._overlayRef!.updatePosition();\n    }\n  }\n\n  /**\n   * A stream of actions that should close the autocomplete panel, including\n   * when an option is selected, on blur, and when TAB is pressed.\n   */\n  get panelClosingActions(): Observable<MatOptionSelectionChange | null> {\n    return merge(\n      this.optionSelections,\n      this.autocomplete._keyManager.tabOut.pipe(filter(() => this._overlayAttached)),\n      this._closeKeyEventStream,\n      this._getOutsideClickStream(),\n      this._overlayRef\n        ? this._overlayRef.detachments().pipe(filter(() => this._overlayAttached))\n        : observableOf(),\n    ).pipe(\n      // Normalize the output so we return a consistent type.\n      map(event => (event instanceof MatOptionSelectionChange ? event : null)),\n    );\n  }\n\n  /** Stream of changes to the selection state of the autocomplete options. */\n  readonly optionSelections: Observable<MatOptionSelectionChange> = defer(() => {\n    const options = this.autocomplete ? this.autocomplete.options : null;\n\n    if (options) {\n      return options.changes.pipe(\n        startWith(options),\n        switchMap(() => merge(...options.map(option => option.onSelectionChange))),\n      );\n    }\n\n    // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n    // Return a stream that we'll replace with the real one once everything is in place.\n    return this._initialized.pipe(switchMap(() => this.optionSelections));\n  }) as Observable<MatOptionSelectionChange>;\n\n  /** The currently active option, coerced to MatOption type. */\n  get activeOption(): MatOption | null {\n    if (this.autocomplete && this.autocomplete._keyManager) {\n      return this.autocomplete._keyManager.activeItem;\n    }\n\n    return null;\n  }\n\n  /** Stream of clicks outside of the autocomplete panel. */\n  private _getOutsideClickStream(): Observable<any> {\n    return new Observable(observer => {\n      const listener = (event: MouseEvent | TouchEvent) => {\n        // If we're in the Shadow DOM, the event target will be the shadow root, so we have to\n        // fall back to check the first element in the path of the click event.\n        const clickTarget = _getEventTarget<HTMLElement>(event)!;\n        const formField = this._formField\n          ? this._formField.getConnectedOverlayOrigin().nativeElement\n          : null;\n        const customOrigin = this.connectedTo ? this.connectedTo.elementRef.nativeElement : null;\n\n        if (\n          this._overlayAttached &&\n          clickTarget !== this._element.nativeElement &&\n          // Normally focus moves inside `mousedown` so this condition will almost always be\n          // true. Its main purpose is to handle the case where the input is focused from an\n          // outside click which propagates up to the `body` listener within the same sequence\n          // and causes the panel to close immediately (see #3106).\n          !this._hasFocus() &&\n          (!formField || !formField.contains(clickTarget)) &&\n          (!customOrigin || !customOrigin.contains(clickTarget)) &&\n          !!this._overlayRef &&\n          !this._overlayRef.overlayElement.contains(clickTarget)\n        ) {\n          observer.next(event);\n        }\n      };\n\n      const cleanups = [\n        this._renderer.listen('document', 'click', listener),\n        this._renderer.listen('document', 'auxclick', listener),\n        this._renderer.listen('document', 'touchend', listener),\n      ];\n\n      return () => {\n        cleanups.forEach(current => current());\n      };\n    });\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  writeValue(value: any): void {\n    Promise.resolve(null).then(() => this._assignOptionValue(value));\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  registerOnChange(fn: (value: any) => {}): void {\n    this._onChange = fn;\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  registerOnTouched(fn: () => {}) {\n    this._onTouched = fn;\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  setDisabledState(isDisabled: boolean) {\n    this._element.nativeElement.disabled = isDisabled;\n  }\n\n  _handleKeydown(e: Event): void {\n    const event = e as KeyboardEvent;\n    const keyCode = event.keyCode;\n    const hasModifier = hasModifierKey(event);\n\n    // Prevent the default action on all escape key presses. This is here primarily to bring IE\n    // in line with other browsers. By default, pressing escape on IE will cause it to revert\n    // the input value to the one that it had on focus, however it won't dispatch any events\n    // which means that the model value will be out of sync with the view.\n    if (keyCode === ESCAPE && !hasModifier) {\n      event.preventDefault();\n    }\n\n    this._valueOnLastKeydown = this._element.nativeElement.value;\n\n    if (this.activeOption && keyCode === ENTER && this.panelOpen && !hasModifier) {\n      this.activeOption._selectViaInteraction();\n      this._resetActiveItem();\n      event.preventDefault();\n    } else if (this.autocomplete) {\n      const prevActiveItem = this.autocomplete._keyManager.activeItem;\n      const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\n\n      if (keyCode === TAB || (isArrowKey && !hasModifier && this.panelOpen)) {\n        this.autocomplete._keyManager.onKeydown(event);\n      } else if (isArrowKey && this._canOpen()) {\n        this._openPanelInternal(this._valueOnLastKeydown);\n      }\n\n      if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {\n        this._scrollToOption(this.autocomplete._keyManager.activeItemIndex || 0);\n\n        if (this.autocomplete.autoSelectActiveOption && this.activeOption) {\n          if (!this._pendingAutoselectedOption) {\n            this._valueBeforeAutoSelection = this._valueOnLastKeydown;\n          }\n\n          this._pendingAutoselectedOption = this.activeOption;\n          this._assignOptionValue(this.activeOption.value);\n        }\n      }\n    }\n  }\n\n  _handleInput(event: Event): void {\n    let target = event.target as HTMLInputElement;\n    let value: number | string | null = target.value;\n\n    // Based on `NumberValueAccessor` from forms.\n    if (target.type === 'number') {\n      value = value == '' ? null : parseFloat(value);\n    }\n\n    // If the input has a placeholder, IE will fire the `input` event on page load,\n    // focus and blur, in addition to when the user actually changed the value. To\n    // filter out all of the extra events, we save the value on focus and between\n    // `input` events, and we check whether it changed.\n    // See: https://connect.microsoft.com/IE/feedback/details/885747/\n    if (this._previousValue !== value) {\n      this._previousValue = value;\n      this._pendingAutoselectedOption = null;\n\n      // If selection is required we don't write to the CVA while the user is typing.\n      // At the end of the selection either the user will have picked something\n      // or we'll reset the value back to null.\n      if (!this.autocomplete || !this.autocomplete.requireSelection) {\n        this._onChange(value);\n      }\n\n      if (!value) {\n        this._clearPreviousSelectedOption(null, false);\n      } else if (this.panelOpen && !this.autocomplete.requireSelection) {\n        // Note that we don't reset this when `requireSelection` is enabled,\n        // because the option will be reset when the panel is closed.\n        const selectedOption = this.autocomplete.options?.find(option => option.selected);\n\n        if (selectedOption) {\n          const display = this._getDisplayValue(selectedOption.value);\n\n          if (value !== display) {\n            selectedOption.deselect(false);\n          }\n        }\n      }\n\n      if (this._canOpen() && this._hasFocus()) {\n        // When the `input` event fires, the input's value will have already changed. This means\n        // that if we take the `this._element.nativeElement.value` directly, it'll be one keystroke\n        // behind. This can be a problem when the user selects a value, changes a character while\n        // the input still has focus and then clicks away (see #28432). To work around it, we\n        // capture the value in `keydown` so we can use it here.\n        const valueOnAttach = this._valueOnLastKeydown ?? this._element.nativeElement.value;\n        this._valueOnLastKeydown = null;\n        this._openPanelInternal(valueOnAttach);\n      }\n    }\n  }\n\n  _handleFocus(): void {\n    if (!this._canOpenOnNextFocus) {\n      this._canOpenOnNextFocus = true;\n    } else if (this._canOpen()) {\n      this._previousValue = this._element.nativeElement.value;\n      this._attachOverlay(this._previousValue);\n      this._floatLabel(true);\n    }\n  }\n\n  _handleClick(): void {\n    if (this._canOpen() && !this.panelOpen) {\n      this._openPanelInternal();\n    }\n  }\n\n  /** Whether the input currently has focus. */\n  private _hasFocus(): boolean {\n    return _getFocusedElementPierceShadowDom() === this._element.nativeElement;\n  }\n\n  /**\n   * In \"auto\" mode, the label will animate down as soon as focus is lost.\n   * This causes the value to jump when selecting an option with the mouse.\n   * This method manually floats the label until the panel can be closed.\n   * @param shouldAnimate Whether the label should be animated when it is floated.\n   */\n  private _floatLabel(shouldAnimate = false): void {\n    if (this._formField && this._formField.floatLabel === 'auto') {\n      if (shouldAnimate) {\n        this._formField._animateAndLockLabel();\n      } else {\n        this._formField.floatLabel = 'always';\n      }\n\n      this._manuallyFloatingLabel = true;\n    }\n  }\n\n  /** If the label has been manually elevated, return it to its normal state. */\n  private _resetLabel(): void {\n    if (this._manuallyFloatingLabel) {\n      if (this._formField) {\n        this._formField.floatLabel = 'auto';\n      }\n      this._manuallyFloatingLabel = false;\n    }\n  }\n\n  /**\n   * This method listens to a stream of panel closing actions and resets the\n   * stream every time the option list changes.\n   */\n  private _subscribeToClosingActions(): Subscription {\n    const initialRender = new Observable(subscriber => {\n      afterNextRender(\n        () => {\n          subscriber.next();\n        },\n        {injector: this._environmentInjector},\n      );\n    });\n    const optionChanges =\n      this.autocomplete.options?.changes.pipe(\n        tap(() => this._positionStrategy.reapplyLastPosition()),\n        // Defer emitting to the stream until the next tick, because changing\n        // bindings in here will cause \"changed after checked\" errors.\n        delay(0),\n      ) ?? observableOf();\n\n    // When the options are initially rendered, and when the option list changes...\n    return (\n      merge(initialRender, optionChanges)\n        .pipe(\n          // create a new stream of panelClosingActions, replacing any previous streams\n          // that were created, and flatten it so our stream only emits closing events...\n          switchMap(() =>\n            this._zone.run(() => {\n              // `afterNextRender` always runs outside of the Angular zone, thus we have to re-enter\n              // the Angular zone. This will lead to change detection being called outside of the Angular\n              // zone and the `autocomplete.opened` will also emit outside of the Angular.\n              const wasOpen = this.panelOpen;\n              this._resetActiveItem();\n              this._updatePanelState();\n              this._changeDetectorRef.detectChanges();\n\n              if (this.panelOpen) {\n                this._overlayRef!.updatePosition();\n              }\n\n              if (wasOpen !== this.panelOpen) {\n                // If the `panelOpen` state changed, we need to make sure to emit the `opened` or\n                // `closed` event, because we may not have emitted it. This can happen\n                // - if the users opens the panel and there are no options, but the\n                //   options come in slightly later or as a result of the value changing,\n                // - if the panel is closed after the user entered a string that did not match any\n                //   of the available options,\n                // - if a valid string is entered after an invalid one.\n                if (this.panelOpen) {\n                  this._emitOpened();\n                } else {\n                  this.autocomplete.closed.emit();\n                }\n              }\n\n              return this.panelClosingActions;\n            }),\n          ),\n          // when the first closing event occurs...\n          take(1),\n        )\n        // set the value, close the panel, and complete.\n        .subscribe(event => this._setValueAndClose(event))\n    );\n  }\n\n  /**\n   * Emits the opened event once it's known that the panel will be shown and stores\n   * the state of the trigger right before the opening sequence was finished.\n   */\n  private _emitOpened() {\n    this.autocomplete.opened.emit();\n  }\n\n  /** Destroys the autocomplete suggestion panel. */\n  private _destroyPanel(): void {\n    if (this._overlayRef) {\n      this.closePanel();\n      this._overlayRef.dispose();\n      this._overlayRef = null;\n    }\n  }\n\n  /** Given a value, returns the string that should be shown within the input. */\n  private _getDisplayValue<T>(value: T): T | string {\n    const autocomplete = this.autocomplete;\n    return autocomplete && autocomplete.displayWith ? autocomplete.displayWith(value) : value;\n  }\n\n  private _assignOptionValue(value: any): void {\n    const toDisplay = this._getDisplayValue(value);\n\n    if (value == null) {\n      this._clearPreviousSelectedOption(null, false);\n    }\n\n    // Simply falling back to an empty string if the display value is falsy does not work properly.\n    // The display value can also be the number zero and shouldn't fall back to an empty string.\n    this._updateNativeInputValue(toDisplay != null ? toDisplay : '');\n  }\n\n  private _updateNativeInputValue(value: string): void {\n    // If it's used within a `MatFormField`, we should set it through the property so it can go\n    // through change detection.\n    if (this._formField) {\n      this._formField._control.value = value;\n    } else {\n      this._element.nativeElement.value = value;\n    }\n\n    this._previousValue = value;\n  }\n\n  /**\n   * This method closes the panel, and if a value is specified, also sets the associated\n   * control to that value. It will also mark the control as dirty if this interaction\n   * stemmed from the user.\n   */\n  private _setValueAndClose(event: MatOptionSelectionChange | null): void {\n    const panel = this.autocomplete;\n    const toSelect = event ? event.source : this._pendingAutoselectedOption;\n\n    if (toSelect) {\n      this._clearPreviousSelectedOption(toSelect);\n      this._assignOptionValue(toSelect.value);\n      // TODO(crisbeto): this should wait until the animation is done, otherwise the value\n      // gets reset while the panel is still animating which looks glitchy. It'll likely break\n      // some tests to change it at this point.\n      this._onChange(toSelect.value);\n      panel._emitSelectEvent(toSelect);\n      this._element.nativeElement.focus();\n    } else if (\n      panel.requireSelection &&\n      this._element.nativeElement.value !== this._valueOnAttach\n    ) {\n      this._clearPreviousSelectedOption(null);\n      this._assignOptionValue(null);\n      this._onChange(null);\n    }\n\n    this.closePanel();\n  }\n\n  /**\n   * Clear any previous selected option and emit a selection change event for this option\n   */\n  private _clearPreviousSelectedOption(skip: MatOption | null, emitEvent?: boolean) {\n    // Null checks are necessary here, because the autocomplete\n    // or its options may not have been assigned yet.\n    this.autocomplete?.options?.forEach(option => {\n      if (option !== skip && option.selected) {\n        option.deselect(emitEvent);\n      }\n    });\n  }\n\n  private _openPanelInternal(valueOnAttach = this._element.nativeElement.value) {\n    this._attachOverlay(valueOnAttach);\n    this._floatLabel();\n    // Add aria-owns attribute when the autocomplete becomes visible.\n    if (this._trackedModal) {\n      const panelId = this.autocomplete.id;\n      addAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n    }\n  }\n\n  private _attachOverlay(valueOnAttach: string): void {\n    if (!this.autocomplete) {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        throw getMatAutocompleteMissingPanelError();\n      } else {\n        // This shouldn't happen only in production mode, but some internal teams have\n        // observed it in their production logging. Return since the rest of the function\n        // assumes that the autocomplete is defined.\n        return;\n      }\n    }\n\n    let overlayRef = this._overlayRef;\n\n    if (!overlayRef) {\n      this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef, {\n        id: this._formField?.getLabelId(),\n      });\n      overlayRef = createOverlayRef(this._injector, this._getOverlayConfig());\n      this._overlayRef = overlayRef;\n      this._viewportSubscription = this._viewportRuler.change().subscribe(() => {\n        if (this.panelOpen && overlayRef) {\n          overlayRef.updateSize({width: this._getPanelWidth()});\n        }\n      });\n      // Subscribe to the breakpoint events stream to detect when screen is in\n      // handsetLandscape.\n      this._handsetLandscapeSubscription = this._breakpointObserver\n        .observe(Breakpoints.HandsetLandscape)\n        .subscribe(result => {\n          const isHandsetLandscape = result.matches;\n          // Check if result.matches Breakpoints.HandsetLandscape. Apply HandsetLandscape\n          // settings to prevent overlay cutoff in that breakpoint. Fixes b/284148377\n          if (isHandsetLandscape) {\n            this._positionStrategy\n              .withFlexibleDimensions(true)\n              .withGrowAfterOpen(true)\n              .withViewportMargin(8);\n          } else {\n            this._positionStrategy\n              .withFlexibleDimensions(false)\n              .withGrowAfterOpen(false)\n              .withViewportMargin(0);\n          }\n        });\n    } else {\n      // Update the trigger, panel width and direction, in case anything has changed.\n      this._positionStrategy.setOrigin(this._getConnectedElement());\n      overlayRef.updateSize({width: this._getPanelWidth()});\n    }\n\n    if (overlayRef && !overlayRef.hasAttached()) {\n      overlayRef.attach(this._portal);\n      this._valueOnAttach = valueOnAttach;\n      this._valueOnLastKeydown = null;\n      this._closingActionsSubscription = this._subscribeToClosingActions();\n    }\n\n    const wasOpen = this.panelOpen;\n\n    this.autocomplete._isOpen = this._overlayAttached = true;\n    this.autocomplete._latestOpeningTrigger = this;\n    this.autocomplete._setColor(this._formField?.color);\n    this._updatePanelState();\n    this._applyModalPanelOwnership();\n\n    // We need to do an extra `panelOpen` check in here, because the\n    // autocomplete won't be shown if there are no options.\n    if (this.panelOpen && wasOpen !== this.panelOpen) {\n      this._emitOpened();\n    }\n  }\n\n  /** Handles keyboard events coming from the overlay panel. */\n  private _handlePanelKeydown = (event: KeyboardEvent) => {\n    // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n    // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n    if (\n      (event.keyCode === ESCAPE && !hasModifierKey(event)) ||\n      (event.keyCode === UP_ARROW && hasModifierKey(event, 'altKey'))\n    ) {\n      // If the user had typed something in before we autoselected an option, and they decided\n      // to cancel the selection, restore the input value to the one they had typed in.\n      if (this._pendingAutoselectedOption) {\n        this._updateNativeInputValue(this._valueBeforeAutoSelection ?? '');\n        this._pendingAutoselectedOption = null;\n      }\n      this._closeKeyEventStream.next();\n      this._resetActiveItem();\n      // We need to stop propagation, otherwise the event will eventually\n      // reach the input itself and cause the overlay to be reopened.\n      event.stopPropagation();\n      event.preventDefault();\n    }\n  };\n\n  /** Updates the panel's visibility state and any trigger state tied to id. */\n  private _updatePanelState() {\n    this.autocomplete._setVisibility();\n\n    // Note that here we subscribe and unsubscribe based on the panel's visiblity state,\n    // because the act of subscribing will prevent events from reaching other overlays and\n    // we don't want to block the events if there are no options.\n    if (this.panelOpen) {\n      const overlayRef = this._overlayRef!;\n\n      if (!this._keydownSubscription) {\n        // Use the `keydownEvents` in order to take advantage of\n        // the overlay event targeting provided by the CDK overlay.\n        this._keydownSubscription = overlayRef.keydownEvents().subscribe(this._handlePanelKeydown);\n      }\n\n      if (!this._outsideClickSubscription) {\n        // Subscribe to the pointer events stream so that it doesn't get picked up by other overlays.\n        // TODO(crisbeto): we should switch `_getOutsideClickStream` eventually to use this stream,\n        // but the behvior isn't exactly the same and it ends up breaking some internal tests.\n        this._outsideClickSubscription = overlayRef.outsidePointerEvents().subscribe();\n      }\n    } else {\n      this._keydownSubscription?.unsubscribe();\n      this._outsideClickSubscription?.unsubscribe();\n      this._keydownSubscription = this._outsideClickSubscription = null;\n    }\n  }\n\n  private _getOverlayConfig(): OverlayConfig {\n    return new OverlayConfig({\n      positionStrategy: this._getOverlayPosition(),\n      scrollStrategy: this._scrollStrategy(),\n      width: this._getPanelWidth(),\n      direction: this._dir ?? undefined,\n      hasBackdrop: this._defaults?.hasBackdrop,\n      backdropClass: this._defaults?.backdropClass || 'cdk-overlay-transparent-backdrop',\n      panelClass: this._overlayPanelClass,\n      disableAnimations: this._animationsDisabled,\n    });\n  }\n\n  private _getOverlayPosition(): PositionStrategy {\n    // Set default Overlay Position\n    const strategy = createFlexibleConnectedPositionStrategy(\n      this._injector,\n      this._getConnectedElement(),\n    )\n      .withFlexibleDimensions(false)\n      .withPush(false)\n      .withPopoverLocation('inline');\n\n    this._setStrategyPositions(strategy);\n    this._positionStrategy = strategy;\n    return strategy;\n  }\n\n  /** Sets the positions on a position strategy based on the directive's input state. */\n  private _setStrategyPositions(positionStrategy: FlexibleConnectedPositionStrategy) {\n    // Note that we provide horizontal fallback positions, even though by default the dropdown\n    // width matches the input, because consumers can override the width. See #18854.\n    const belowPositions: ConnectedPosition[] = [\n      {originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top'},\n      {originX: 'end', originY: 'bottom', overlayX: 'end', overlayY: 'top'},\n    ];\n\n    // The overlay edge connected to the trigger should have squared corners, while\n    // the opposite end has rounded corners. We apply a CSS class to swap the\n    // border-radius based on the overlay position.\n    const panelClass = this._aboveClass;\n    const abovePositions: ConnectedPosition[] = [\n      {originX: 'start', originY: 'top', overlayX: 'start', overlayY: 'bottom', panelClass},\n      {originX: 'end', originY: 'top', overlayX: 'end', overlayY: 'bottom', panelClass},\n    ];\n\n    let positions: ConnectedPosition[];\n\n    if (this.position === 'above') {\n      positions = abovePositions;\n    } else if (this.position === 'below') {\n      positions = belowPositions;\n    } else {\n      positions = [...belowPositions, ...abovePositions];\n    }\n\n    positionStrategy.withPositions(positions);\n  }\n\n  private _getConnectedElement(): ElementRef<HTMLElement> {\n    if (this.connectedTo) {\n      return this.connectedTo.elementRef;\n    }\n\n    return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;\n  }\n\n  private _getPanelWidth(): number | string {\n    return this.autocomplete.panelWidth || this._getHostWidth();\n  }\n\n  /** Returns the width of the input element, so the panel width can match it. */\n  private _getHostWidth(): number {\n    return this._getConnectedElement().nativeElement.getBoundingClientRect().width;\n  }\n\n  /**\n   * Reset the active item to -1. This is so that pressing arrow keys will activate the correct\n   * option.\n   *\n   * If the consumer opted-in to automatically activatating the first option, activate the first\n   * *enabled* option.\n   */\n  private _resetActiveItem(): void {\n    const autocomplete = this.autocomplete;\n\n    if (autocomplete.autoActiveFirstOption) {\n      // Find the index of the first *enabled* option. Avoid calling `_keyManager.setActiveItem`\n      // because it activates the first option that passes the skip predicate, rather than the\n      // first *enabled* option.\n      let firstEnabledOptionIndex = -1;\n\n      for (let index = 0; index < autocomplete.options.length; index++) {\n        const option = autocomplete.options.get(index)!;\n        if (!option.disabled) {\n          firstEnabledOptionIndex = index;\n          break;\n        }\n      }\n      autocomplete._keyManager.setActiveItem(firstEnabledOptionIndex);\n    } else {\n      autocomplete._keyManager.setActiveItem(-1);\n    }\n  }\n\n  /** Determines whether the panel can be opened. */\n  private _canOpen(): boolean {\n    const element = this._element.nativeElement;\n    return !element.readOnly && !element.disabled && !this.autocompleteDisabled;\n  }\n\n  /** Scrolls to a particular option in the list. */\n  private _scrollToOption(index: number): void {\n    // Given that we are not actually focusing active options, we must manually adjust scroll\n    // to reveal options below the fold. First, we find the offset of the option from the top\n    // of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n    // the panel height + the option height, so the active option will be just visible at the\n    // bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n    // will become the offset. If that offset is visible within the panel already, the scrollTop is\n    // not adjusted.\n    const autocomplete = this.autocomplete;\n    const labelCount = _countGroupLabelsBeforeOption(\n      index,\n      autocomplete.options,\n      autocomplete.optionGroups,\n    );\n\n    if (index === 0 && labelCount === 1) {\n      // If we've got one group label before the option and we're at the top option,\n      // scroll the list to the top. This is better UX than scrolling the list to the\n      // top of the option, because it allows the user to read the top group's label.\n      autocomplete._setScrollTop(0);\n    } else if (autocomplete.panel) {\n      const option = autocomplete.options.toArray()[index];\n\n      if (option) {\n        const element = option._getHostElement();\n        const newScrollPosition = _getOptionScrollPosition(\n          element.offsetTop,\n          element.offsetHeight,\n          autocomplete._getScrollTop(),\n          autocomplete.panel.nativeElement.offsetHeight,\n        );\n\n        autocomplete._setScrollTop(newScrollPosition);\n      }\n    }\n  }\n\n  /**\n   * Track which modal we have modified the `aria-owns` attribute of. When the combobox trigger is\n   * inside an aria-modal, we apply aria-owns to the parent modal with the `id` of the options\n   * panel. Track the modal we have changed so we can undo the changes on destroy.\n   */\n  private _trackedModal: Element | null = null;\n\n  /**\n   * If the autocomplete trigger is inside of an `aria-modal` element, connect\n   * that modal to the options panel with `aria-owns`.\n   *\n   * For some browser + screen reader combinations, when navigation is inside\n   * of an `aria-modal` element, the screen reader treats everything outside\n   * of that modal as hidden or invisible.\n   *\n   * This causes a problem when the combobox trigger is _inside_ of a modal, because the\n   * options panel is rendered _outside_ of that modal, preventing screen reader navigation\n   * from reaching the panel.\n   *\n   * We can work around this issue by applying `aria-owns` to the modal with the `id` of\n   * the options panel. This effectively communicates to assistive technology that the\n   * options panel is part of the same interaction as the modal.\n   *\n   * At time of this writing, this issue is present in VoiceOver.\n   * See https://github.com/angular/components/issues/20694\n   */\n  private _applyModalPanelOwnership() {\n    // TODO(http://github.com/angular/components/issues/26853): consider de-duplicating this with\n    // the `LiveAnnouncer` and any other usages.\n    //\n    // Note that the selector here is limited to CDK overlays at the moment in order to reduce the\n    // section of the DOM we need to look through. This should cover all the cases we support, but\n    // the selector can be expanded if it turns out to be too narrow.\n    const modal = this._element.nativeElement.closest(\n      'body > .cdk-overlay-container [aria-modal=\"true\"]',\n    );\n\n    if (!modal) {\n      // Most commonly, the autocomplete trigger is not inside a modal.\n      return;\n    }\n\n    const panelId = this.autocomplete.id;\n\n    if (this._trackedModal) {\n      removeAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n    }\n\n    addAriaReferencedId(modal, 'aria-owns', panelId);\n    this._trackedModal = modal;\n  }\n\n  /** Clears the references to the listbox overlay element from the modal it was added to. */\n  private _clearFromModal() {\n    if (this._trackedModal) {\n      const panelId = this.autocomplete.id;\n\n      removeAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n      this._trackedModal = null;\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {MatOptionModule} from '../core';\nimport {BidiModule} from '@angular/cdk/bidi';\nimport {CdkScrollableModule} from '@angular/cdk/scrolling';\nimport {OverlayModule} from '@angular/cdk/overlay';\nimport {MatAutocomplete} from './autocomplete';\nimport {MatAutocompleteTrigger} from './autocomplete-trigger';\nimport {MatAutocompleteOrigin} from './autocomplete-origin';\n\n@NgModule({\n  imports: [\n    OverlayModule,\n    MatOptionModule,\n    MatAutocomplete,\n    MatAutocompleteTrigger,\n    MatAutocompleteOrigin,\n  ],\n  exports: [\n    CdkScrollableModule,\n    MatAutocomplete,\n    MatOptionModule,\n    BidiModule,\n    MatAutocompleteTrigger,\n    MatAutocompleteOrigin,\n  ],\n})\nexport class MatAutocompleteModule {}\n"],"names":["MatAutocompleteSelectedEvent","source","option","constructor","MAT_AUTOCOMPLETE_DEFAULT_OPTIONS","InjectionToken","providedIn","factory","autoActiveFirstOption","autoSelectActiveOption","hideSingleSelectionIndicator","requireSelection","hasBackdrop","MatAutocomplete","_changeDetectorRef","inject","ChangeDetectorRef","_elementRef","ElementRef","_defaults","_animationsDisabled","_activeOptionChanges","Subscription","EMPTY","_keyManager","showPanel","isOpen","_isOpen","_latestOpeningTrigger","_setColor","value","_color","markForCheck","template","panel","options","optionGroups","ariaLabel","ariaLabelledby","displayWith","panelWidth","disableRipple","optionSelected","EventEmitter","opened","closed","optionActivated","classList","_classList","nativeElement","className","_hideSingleSelectionIndicator","_syncParentProperties","id","_IdGenerator","getId","inertGroups","platform","Platform","SAFARI","ngAfterContentInit","ActiveDescendantKeyManager","withWrap","skipPredicate","_skipPredicate","change","subscribe","index","emit","toArray","_setVisibility","ngOnDestroy","destroy","unsubscribe","_setScrollTop","scrollTop","_getScrollTop","length","_emitSelectEvent","event","_getPanelAriaLabelledby","labelId","labelExpression","deps","target","i0","FactoryTarget","Component","cmp","ngDeclareComponent","minVersion","version","type","isStandalone","selector","inputs","booleanAttribute","outputs","host","classAttribute","providers","provide","MAT_OPTION_PARENT_COMPONENT","useExisting","queries","propertyName","predicate","MatOption","descendants","MAT_OPTGROUP","viewQueries","first","TemplateRef","styles","changeDetection","ChangeDetectionStrategy","OnPush","encapsulation","ViewEncapsulation","None","decorators","exportAs","ViewChild","args","static","ContentChildren","Input","transform","Output","MatAutocompleteOrigin","elementRef","Directive","ngImport","MAT_AUTOCOMPLETE_VALUE_ACCESSOR","NG_VALUE_ACCESSOR","forwardRef","MatAutocompleteTrigger","multi","getMatAutocompleteMissingPanelError","Error","MAT_AUTOCOMPLETE_SCROLL_STRATEGY","injector","Injector","createRepositionScrollStrategy","_environmentInjector","EnvironmentInjector","_element","_injector","_viewContainerRef","ViewContainerRef","_zone","NgZone","_dir","Directionality","optional","_formField","MAT_FORM_FIELD","_viewportRuler","ViewportRuler","_scrollStrategy","_renderer","Renderer2","_overlayRef","_portal","_componentDestroyed","_initialized","Subject","_keydownSubscription","_outsideClickSubscription","_cleanupWindowBlur","_previousValue","_valueOnAttach","_valueOnLastKeydown","_positionStrategy","_manuallyFloatingLabel","_closingActionsSubscription","_viewportSubscription","_breakpointObserver","BreakpointObserver","_handsetLandscapeSubscription","_canOpenOnNextFocus","_valueBeforeAutoSelection","_pendingAutoselectedOption","_closeKeyEventStream","_overlayPanelClass","coerceArray","overlayPanelClass","_windowBlurHandler","panelOpen","_hasFocus","_onChange","_onTouched","autocomplete","position","connectedTo","autocompleteAttribute","autocompleteDisabled","_aboveClass","ngAfterViewInit","next","complete","listen","ngOnChanges","changes","_setStrategyPositions","updatePosition","_destroyPanel","_clearFromModal","_overlayAttached","openPanel","_openPanelInternal","closePanel","_resetLabel","run","hasAttached","detach","_updatePanelState","detectChanges","_trackedModal","removeAriaReferencedId","panelClosingActions","merge","optionSelections","tabOut","pipe","filter","_getOutsideClickStream","detachments","observableOf","map","MatOptionSelectionChange","defer","startWith","switchMap","onSelectionChange","activeOption","activeItem","Observable","observer","listener","clickTarget","_getEventTarget","formField","getConnectedOverlayOrigin","customOrigin","contains","overlayElement","cleanups","forEach","current","writeValue","Promise","resolve","then","_assignOptionValue","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","disabled","_handleKeydown","e","keyCode","hasModifier","hasModifierKey","ESCAPE","preventDefault","ENTER","_selectViaInteraction","_resetActiveItem","prevActiveItem","isArrowKey","UP_ARROW","DOWN_ARROW","TAB","onKeydown","_canOpen","_scrollToOption","activeItemIndex","_handleInput","parseFloat","_clearPreviousSelectedOption","selectedOption","find","selected","display","_getDisplayValue","deselect","valueOnAttach","_handleFocus","_attachOverlay","_floatLabel","_handleClick","_getFocusedElementPierceShadowDom","shouldAnimate","floatLabel","_animateAndLockLabel","_subscribeToClosingActions","initialRender","subscriber","afterNextRender","optionChanges","tap","reapplyLastPosition","delay","wasOpen","_emitOpened","take","_setValueAndClose","dispose","toDisplay","_updateNativeInputValue","_control","toSelect","focus","skip","emitEvent","panelId","addAriaReferencedId","ngDevMode","overlayRef","TemplatePortal","getLabelId","createOverlayRef","_getOverlayConfig","updateSize","width","_getPanelWidth","observe","Breakpoints","HandsetLandscape","result","isHandsetLandscape","matches","withFlexibleDimensions","withGrowAfterOpen","withViewportMargin","setOrigin","_getConnectedElement","attach","color","_applyModalPanelOwnership","_handlePanelKeydown","stopPropagation","keydownEvents","outsidePointerEvents","OverlayConfig","positionStrategy","_getOverlayPosition","scrollStrategy","direction","undefined","backdropClass","panelClass","disableAnimations","strategy","createFlexibleConnectedPositionStrategy","withPush","withPopoverLocation","belowPositions","originX","originY","overlayX","overlayY","abovePositions","positions","withPositions","_getHostWidth","getBoundingClientRect","firstEnabledOptionIndex","get","setActiveItem","element","readOnly","labelCount","_countGroupLabelsBeforeOption","_getHostElement","newScrollPosition","_getOptionScrollPosition","offsetTop","offsetHeight","modal","closest","dir","ngDeclareDirective","listeners","properties","usesOnChanges","alias","MatAutocompleteModule","NgModule","mod","ngDeclareNgModule","OverlayModule","MatOptionModule","CdkScrollableModule","BidiModule","inj","ngDeclareInjector","imports","exports"],"mappings":"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"}