{"version":3,"file":"autocomplete.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/autocomplete/autocomplete.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/autocomplete/autocomplete-origin.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/autocomplete/autocomplete-trigger.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/autocomplete/autocomplete-module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  AfterContentInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  ElementRef,\n  EventEmitter,\n  InjectionToken,\n  Input,\n  OnDestroy,\n  Output,\n  QueryList,\n  TemplateRef,\n  ViewChild,\n  ViewEncapsulation,\n  booleanAttribute,\n  inject,\n} from '@angular/core';\nimport {\n  _animationsDisabled,\n  MAT_OPTGROUP,\n  MAT_OPTION_PARENT_COMPONENT,\n  MatOptgroup,\n  MatOption,\n  ThemePalette,\n} from '../core';\nimport {_IdGenerator, ActiveDescendantKeyManager} from '@angular/cdk/a11y';\nimport {Platform} from '@angular/cdk/platform';\nimport {Subscription} from 'rxjs';\n\n/** Event object that is emitted when an autocomplete option is selected. */\nexport class MatAutocompleteSelectedEvent {\n  constructor(\n    /** Reference to the autocomplete panel that emitted the event. */\n    public source: MatAutocomplete,\n    /** Option that was selected. */\n    public option: MatOption,\n  ) {}\n}\n\n/** Event object that is emitted when an autocomplete option is activated. */\nexport interface MatAutocompleteActivatedEvent {\n  /** Reference to the autocomplete panel that emitted the event. */\n  source: MatAutocomplete;\n\n  /** Option that was selected. */\n  option: MatOption | null;\n}\n\n/** Default `mat-autocomplete` options that can be overridden. */\nexport interface MatAutocompleteDefaultOptions {\n  /** Whether the first option should be highlighted when an autocomplete panel is opened. */\n  autoActiveFirstOption?: boolean;\n\n  /** Whether the active option should be selected as the user is navigating. */\n  autoSelectActiveOption?: boolean;\n\n  /**\n   * Whether the user is required to make a selection when\n   * they're interacting with the autocomplete.\n   */\n  requireSelection?: boolean;\n\n  /** Class to be applied to the autocomplete's backdrop. */\n  backdropClass?: string;\n\n  /** Whether the autocomplete has a backdrop. */\n  hasBackdrop?: boolean;\n\n  /** Class or list of classes to be applied to the autocomplete's overlay panel. */\n  overlayPanelClass?: string | string[];\n\n  /** Whether icon indicators should be hidden for single-selection. */\n  hideSingleSelectionIndicator?: boolean;\n}\n\n/** Injection token to be used to override the default options for `mat-autocomplete`. */\nexport const MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new InjectionToken<MatAutocompleteDefaultOptions>(\n  'mat-autocomplete-default-options',\n  {\n    providedIn: 'root',\n    factory: () => ({\n      autoActiveFirstOption: false,\n      autoSelectActiveOption: false,\n      hideSingleSelectionIndicator: false,\n      requireSelection: false,\n      hasBackdrop: false,\n    }),\n  },\n);\n\n/** Autocomplete component. */\n@Component({\n  selector: 'mat-autocomplete',\n  templateUrl: 'autocomplete.html',\n  styleUrl: 'autocomplete.css',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  exportAs: 'matAutocomplete',\n  host: {\n    'class': 'mat-mdc-autocomplete',\n  },\n  providers: [{provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatAutocomplete}],\n})\nexport class MatAutocomplete implements AfterContentInit, OnDestroy {\n  private _changeDetectorRef = inject(ChangeDetectorRef);\n  private _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  protected _defaults = inject<MatAutocompleteDefaultOptions>(MAT_AUTOCOMPLETE_DEFAULT_OPTIONS);\n  protected _animationsDisabled = _animationsDisabled();\n  private _activeOptionChanges = Subscription.EMPTY;\n\n  /** Manages active item in option list based on key events. */\n  _keyManager: ActiveDescendantKeyManager<MatOption>;\n\n  /** Whether the autocomplete panel should be visible, depending on option length. */\n  showPanel: boolean = false;\n\n  /** Whether the autocomplete panel is open. */\n  get isOpen(): boolean {\n    return this._isOpen && this.showPanel;\n  }\n  _isOpen: boolean = false;\n\n  /** Latest trigger that opened the autocomplete. */\n  _latestOpeningTrigger: unknown;\n\n  /** @docs-private Sets the theme color of the panel. */\n  _setColor(value: ThemePalette) {\n    this._color = value;\n    this._changeDetectorRef.markForCheck();\n  }\n  /** @docs-private theme color of the panel */\n  protected _color: ThemePalette;\n\n  // The @ViewChild query for TemplateRef here needs to be static because some code paths\n  // lead to the overlay being created before change detection has finished for this component.\n  // Notably, another component may trigger `focus` on the autocomplete-trigger.\n\n  /** @docs-private */\n  @ViewChild(TemplateRef, {static: true}) template: TemplateRef<any>;\n\n  /** Element for the panel containing the autocomplete options. */\n  @ViewChild('panel') panel: ElementRef;\n\n  /** Reference to all options within the autocomplete. */\n  @ContentChildren(MatOption, {descendants: true}) options: QueryList<MatOption>;\n\n  /** Reference to all option groups within the autocomplete. */\n  @ContentChildren(MAT_OPTGROUP, {descendants: true}) optionGroups: QueryList<MatOptgroup>;\n\n  /** Aria label of the autocomplete. */\n  @Input('aria-label') ariaLabel: string;\n\n  /** Input that can be used to specify the `aria-labelledby` attribute. */\n  @Input('aria-labelledby') ariaLabelledby: string;\n\n  /** Function that maps an option's control value to its display value in the trigger. */\n  @Input() displayWith: ((value: any) => string) | null = null;\n\n  /**\n   * Whether the first option should be highlighted when the autocomplete panel is opened.\n   * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\n   */\n  @Input({transform: booleanAttribute}) autoActiveFirstOption: boolean;\n\n  /** Whether the active option should be selected as the user is navigating. */\n  @Input({transform: booleanAttribute}) autoSelectActiveOption: boolean;\n\n  /**\n   * Whether the user is required to make a selection when they're interacting with the\n   * autocomplete. If the user moves away from the autocomplete without selecting an option from\n   * the list, the value will be reset. If the user opens the panel and closes it without\n   * interacting or selecting a value, the initial value will be kept.\n   */\n  @Input({transform: booleanAttribute}) requireSelection: boolean;\n\n  /**\n   * Specify the width of the autocomplete panel.  Can be any CSS sizing value, otherwise it will\n   * match the width of its host.\n   */\n  @Input() panelWidth: string | number;\n\n  /** Whether ripples are disabled within the autocomplete panel. */\n  @Input({transform: booleanAttribute}) disableRipple: boolean;\n\n  /** Event that is emitted whenever an option from the list is selected. */\n  @Output() readonly optionSelected: EventEmitter<MatAutocompleteSelectedEvent> =\n    new EventEmitter<MatAutocompleteSelectedEvent>();\n\n  /** Event that is emitted when the autocomplete panel is opened. */\n  @Output() readonly opened: EventEmitter<void> = new EventEmitter<void>();\n\n  /** Event that is emitted when the autocomplete panel is closed. */\n  @Output() readonly closed: EventEmitter<void> = new EventEmitter<void>();\n\n  /** Emits whenever an option is activated. */\n  @Output() readonly optionActivated: EventEmitter<MatAutocompleteActivatedEvent> =\n    new EventEmitter<MatAutocompleteActivatedEvent>();\n\n  /**\n   * Takes classes set on the host mat-autocomplete element and applies them to the panel\n   * inside the overlay container to allow for easy styling.\n   */\n  @Input('class')\n  set classList(value: string | string[]) {\n    this._classList = value;\n    this._elementRef.nativeElement.className = '';\n  }\n  _classList: string | string[];\n\n  /** Whether checkmark indicator for single-selection options is hidden. */\n  @Input({transform: booleanAttribute})\n  get hideSingleSelectionIndicator(): boolean {\n    return this._hideSingleSelectionIndicator;\n  }\n  set hideSingleSelectionIndicator(value: boolean) {\n    this._hideSingleSelectionIndicator = value;\n    this._syncParentProperties();\n  }\n  private _hideSingleSelectionIndicator: boolean;\n\n  /** Syncs the parent state with the individual options. */\n  _syncParentProperties(): void {\n    if (this.options) {\n      for (const option of this.options) {\n        option._changeDetectorRef.markForCheck();\n      }\n    }\n  }\n\n  /** Unique ID to be used by autocomplete trigger's \"aria-owns\" property. */\n  id: string = inject(_IdGenerator).getId('mat-autocomplete-');\n\n  /**\n   * Tells any descendant `mat-optgroup` to use the inert a11y pattern.\n   * @docs-private\n   */\n  readonly inertGroups: boolean;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const platform = inject(Platform);\n\n    // TODO(crisbeto): the problem that the `inertGroups` option resolves is only present on\n    // Safari using VoiceOver. We should occasionally check back to see whether the bug\n    // wasn't resolved in VoiceOver, and if it has, we can remove this and the `inertGroups`\n    // option altogether.\n    this.inertGroups = platform?.SAFARI || false;\n    this.autoActiveFirstOption = !!this._defaults.autoActiveFirstOption;\n    this.autoSelectActiveOption = !!this._defaults.autoSelectActiveOption;\n    this.requireSelection = !!this._defaults.requireSelection;\n    this._hideSingleSelectionIndicator = this._defaults.hideSingleSelectionIndicator ?? false;\n  }\n\n  ngAfterContentInit() {\n    this._keyManager = new ActiveDescendantKeyManager<MatOption>(this.options)\n      .withWrap()\n      .skipPredicate(this._skipPredicate);\n    this._activeOptionChanges = this._keyManager.change.subscribe(index => {\n      if (this.isOpen) {\n        this.optionActivated.emit({source: this, option: this.options.toArray()[index] || null});\n      }\n    });\n\n    // Set the initial visibility state.\n    this._setVisibility();\n  }\n\n  ngOnDestroy() {\n    this._keyManager?.destroy();\n    this._activeOptionChanges.unsubscribe();\n  }\n\n  /**\n   * Sets the panel scrollTop. This allows us to manually scroll to display options\n   * above or below the fold, as they are not actually being focused when active.\n   */\n  _setScrollTop(scrollTop: number): void {\n    if (this.panel) {\n      this.panel.nativeElement.scrollTop = scrollTop;\n    }\n  }\n\n  /** Returns the panel's scrollTop. */\n  _getScrollTop(): number {\n    return this.panel ? this.panel.nativeElement.scrollTop : 0;\n  }\n\n  /** Panel should hide itself when the option list is empty. */\n  _setVisibility() {\n    this.showPanel = !!this.options?.length;\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /** Emits the `select` event. */\n  _emitSelectEvent(option: MatOption): void {\n    const event = new MatAutocompleteSelectedEvent(this, option);\n    this.optionSelected.emit(event);\n  }\n\n  /** Gets the aria-labelledby for the autocomplete panel. */\n  _getPanelAriaLabelledby(labelId: string | null): string | null {\n    if (this.ariaLabel) {\n      return null;\n    }\n\n    const labelExpression = labelId ? labelId + ' ' : '';\n    return this.ariaLabelledby ? labelExpression + this.ariaLabelledby : labelId;\n  }\n\n  // `skipPredicate` determines if key manager should avoid putting a given option in the tab\n  // order. Allow disabled list items to receive focus via keyboard to align with WAI ARIA\n  // recommendation.\n  //\n  // Normally WAI ARIA's instructions are to exclude disabled items from the tab order, but it\n  // makes a few exceptions for compound widgets.\n  //\n  // From [Developing a Keyboard Interface](\n  // https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/):\n  //   \"For the following composite widget elements, keep them focusable when disabled: Options in a\n  //   Listbox...\"\n  //\n  // The user can focus disabled options using the keyboard, but the user cannot click disabled\n  // options.\n  protected _skipPredicate() {\n    return false;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive, ElementRef, inject} from '@angular/core';\n\n/**\n * Directive applied to an element to make it usable\n * as a connection point for an autocomplete panel.\n */\n@Directive({\n  selector: '[matAutocompleteOrigin]',\n  exportAs: 'matAutocompleteOrigin',\n})\nexport class MatAutocompleteOrigin {\n  elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n\n  constructor(...args: unknown[]);\n  constructor() {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {addAriaReferencedId, removeAriaReferencedId} from '@angular/cdk/a11y';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {DOWN_ARROW, ENTER, ESCAPE, TAB, UP_ARROW, hasModifierKey} from '@angular/cdk/keycodes';\nimport {BreakpointObserver, Breakpoints} from '@angular/cdk/layout';\nimport {\n  ConnectedPosition,\n  createFlexibleConnectedPositionStrategy,\n  createOverlayRef,\n  createRepositionScrollStrategy,\n  FlexibleConnectedPositionStrategy,\n  OverlayConfig,\n  OverlayRef,\n  PositionStrategy,\n  ScrollStrategy,\n} from '@angular/cdk/overlay';\nimport {_getEventTarget, _getFocusedElementPierceShadowDom} from '@angular/cdk/platform';\nimport {TemplatePortal} from '@angular/cdk/portal';\nimport {ViewportRuler} from '@angular/cdk/scrolling';\nimport {\n  AfterViewInit,\n  ChangeDetectorRef,\n  Directive,\n  ElementRef,\n  EnvironmentInjector,\n  InjectionToken,\n  Injector,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Renderer2,\n  SimpleChanges,\n  ViewContainerRef,\n  afterNextRender,\n  booleanAttribute,\n  forwardRef,\n  inject,\n} from '@angular/core';\nimport {coerceArray} from '@angular/cdk/coercion';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '@angular/forms';\nimport {\n  MatOption,\n  MatOptionSelectionChange,\n  _animationsDisabled,\n  _countGroupLabelsBeforeOption,\n  _getOptionScrollPosition,\n} from '../core';\nimport {MAT_FORM_FIELD, MatFormField} from '../form-field';\nimport {Observable, Subject, Subscription, defer, merge, of as observableOf} from 'rxjs';\nimport {delay, filter, map, startWith, switchMap, take, tap} from 'rxjs/operators';\nimport {\n  MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,\n  MatAutocomplete,\n  MatAutocompleteDefaultOptions,\n} from './autocomplete';\nimport {MatAutocompleteOrigin} from './autocomplete-origin';\n\n/**\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * @docs-private\n */\nexport const MAT_AUTOCOMPLETE_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatAutocompleteTrigger),\n  multi: true,\n};\n\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n * @docs-private\n */\nexport function getMatAutocompleteMissingPanelError(): Error {\n  return Error(\n    'Attempting to open an undefined instance of `mat-autocomplete`. ' +\n      'Make sure that the id passed to the `matAutocomplete` is correct and that ' +\n      \"you're attempting to open it after the ngAfterContentInit hook.\",\n  );\n}\n\n/** Injection token that determines the scroll handling while the autocomplete panel is open. */\nexport const MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new InjectionToken<() => ScrollStrategy>(\n  'mat-autocomplete-scroll-strategy',\n  {\n    providedIn: 'root',\n    factory: () => {\n      const injector = inject(Injector);\n      return () => createRepositionScrollStrategy(injector);\n    },\n  },\n);\n\n/** Base class with all of the `MatAutocompleteTrigger` functionality. */\n@Directive({\n  selector: `input[matAutocomplete], textarea[matAutocomplete]`,\n  host: {\n    'class': 'mat-mdc-autocomplete-trigger',\n    '[attr.autocomplete]': 'autocompleteAttribute',\n    '[attr.role]': 'autocompleteDisabled ? null : \"combobox\"',\n    '[attr.aria-autocomplete]': 'autocompleteDisabled ? null : \"list\"',\n    '[attr.aria-activedescendant]': '(panelOpen && activeOption) ? activeOption.id : null',\n    '[attr.aria-expanded]': 'autocompleteDisabled ? null : panelOpen.toString()',\n    '[attr.aria-controls]': '(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id',\n    '[attr.aria-haspopup]': 'autocompleteDisabled ? null : \"listbox\"',\n    // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\n    // a little earlier. This avoids issues where IE delays the focusing of the input.\n    '(focusin)': '_handleFocus()',\n    '(blur)': '_onTouched()',\n    '(input)': '_handleInput($event)',\n    '(keydown)': '_handleKeydown($event)',\n    '(click)': '_handleClick()',\n  },\n  exportAs: 'matAutocompleteTrigger',\n  providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR],\n})\nexport class MatAutocompleteTrigger\n  implements ControlValueAccessor, AfterViewInit, OnChanges, OnDestroy\n{\n  private _environmentInjector = inject(EnvironmentInjector);\n  private _element = inject<ElementRef<HTMLInputElement>>(ElementRef);\n  private _injector = inject(Injector);\n  private _viewContainerRef = inject(ViewContainerRef);\n  private _zone = inject(NgZone);\n  private _changeDetectorRef = inject(ChangeDetectorRef);\n  private _dir = inject(Directionality, {optional: true});\n  private _formField = inject<MatFormField | null>(MAT_FORM_FIELD, {optional: true, host: true});\n  private _viewportRuler = inject(ViewportRuler);\n  private _scrollStrategy = inject(MAT_AUTOCOMPLETE_SCROLL_STRATEGY);\n  private _renderer = inject(Renderer2);\n  private _animationsDisabled = _animationsDisabled();\n  private _defaults = inject<MatAutocompleteDefaultOptions | null>(\n    MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,\n    {optional: true},\n  );\n\n  private _overlayRef: OverlayRef | null;\n  private _portal: TemplatePortal;\n  private _componentDestroyed = false;\n  private _initialized = new Subject();\n  private _keydownSubscription: Subscription | null;\n  private _outsideClickSubscription: Subscription | null;\n  private _cleanupWindowBlur: (() => void) | undefined;\n\n  /** Old value of the native input. Used to work around issues with the `input` event on IE. */\n  private _previousValue: string | number | null;\n\n  /** Value of the input element when the panel was attached (even if there are no options). */\n  private _valueOnAttach: string | number | null;\n\n  /** Value on the previous keydown event. */\n  private _valueOnLastKeydown: string | null;\n\n  /** Strategy that is used to position the panel. */\n  private _positionStrategy: FlexibleConnectedPositionStrategy;\n\n  /** Whether or not the label state is being overridden. */\n  private _manuallyFloatingLabel = false;\n\n  /** The subscription for closing actions (some are bound to document). */\n  private _closingActionsSubscription: Subscription;\n\n  /** Subscription to viewport size changes. */\n  private _viewportSubscription = Subscription.EMPTY;\n\n  /** Implements BreakpointObserver to be used to detect handset landscape */\n  private _breakpointObserver = inject(BreakpointObserver);\n  private _handsetLandscapeSubscription = Subscription.EMPTY;\n\n  /**\n   * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n   * closed autocomplete from being reopened if the user switches to another browser tab and then\n   * comes back.\n   */\n  private _canOpenOnNextFocus = true;\n\n  /** Value inside the input before we auto-selected an option. */\n  private _valueBeforeAutoSelection: string | undefined;\n\n  /**\n   * Current option that we have auto-selected as the user is navigating,\n   * but which hasn't been propagated to the model value yet.\n   */\n  private _pendingAutoselectedOption: MatOption | null;\n\n  /** Stream of keyboard events that can close the panel. */\n  private readonly _closeKeyEventStream = new Subject<void>();\n\n  /** Classes to apply to the panel. Exposed as a public property for internal usage. */\n  readonly _overlayPanelClass = coerceArray(this._defaults?.overlayPanelClass || []);\n\n  /**\n   * Event handler for when the window is blurred. Needs to be an\n   * arrow function in order to preserve the context.\n   */\n  private _windowBlurHandler = () => {\n    // If the user blurred the window while the autocomplete is focused, it means that it'll be\n    // refocused when they come back. In this case we want to skip the first focus event, if the\n    // pane was closed, in order to avoid reopening it unintentionally.\n    this._canOpenOnNextFocus = this.panelOpen || !this._hasFocus();\n  };\n\n  /** `View -> model callback called when value changes` */\n  _onChange: (value: any) => void = () => {};\n\n  /** `View -> model callback called when autocomplete has been touched` */\n  _onTouched = () => {};\n\n  /** The autocomplete panel to be attached to this trigger. */\n  @Input('matAutocomplete') autocomplete: MatAutocomplete;\n\n  /**\n   * Position of the autocomplete panel relative to the trigger element. A position of `auto`\n   * will render the panel underneath the trigger if there is enough space for it to fit in\n   * the viewport, otherwise the panel will be shown above it. If the position is set to\n   * `above` or `below`, the panel will always be shown above or below the trigger. no matter\n   * whether it fits completely in the viewport.\n   */\n  @Input('matAutocompletePosition') position: 'auto' | 'above' | 'below' = 'auto';\n\n  /**\n   * Reference relative to which to position the autocomplete panel.\n   * Defaults to the autocomplete trigger element.\n   */\n  @Input('matAutocompleteConnectedTo') connectedTo: MatAutocompleteOrigin;\n\n  /**\n   * `autocomplete` attribute to be set on the input element.\n   * @docs-private\n   */\n  @Input('autocomplete') autocompleteAttribute: string = 'off';\n\n  /**\n   * Whether the autocomplete is disabled. When disabled, the element will\n   * act as a regular input and the user won't be able to open the panel.\n   */\n  @Input({alias: 'matAutocompleteDisabled', transform: booleanAttribute})\n  autocompleteDisabled: boolean;\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  /** Class to apply to the panel when it's above the input. */\n  private _aboveClass = 'mat-mdc-autocomplete-panel-above';\n\n  ngAfterViewInit() {\n    this._initialized.next();\n    this._initialized.complete();\n    this._cleanupWindowBlur = this._renderer.listen('window', 'blur', this._windowBlurHandler);\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    if (changes['position'] && this._positionStrategy) {\n      this._setStrategyPositions(this._positionStrategy);\n\n      if (this.panelOpen) {\n        this._overlayRef!.updatePosition();\n      }\n    }\n  }\n\n  ngOnDestroy() {\n    this._cleanupWindowBlur?.();\n    this._handsetLandscapeSubscription.unsubscribe();\n    this._viewportSubscription.unsubscribe();\n    this._componentDestroyed = true;\n    this._destroyPanel();\n    this._closeKeyEventStream.complete();\n    this._clearFromModal();\n  }\n\n  /** Whether or not the autocomplete panel is open. */\n  get panelOpen(): boolean {\n    return this._overlayAttached && this.autocomplete.showPanel;\n  }\n  private _overlayAttached: boolean = false;\n\n  /** Opens the autocomplete suggestion panel. */\n  openPanel(): void {\n    this._openPanelInternal();\n  }\n\n  /** Closes the autocomplete suggestion panel. */\n  closePanel(): void {\n    this._resetLabel();\n\n    if (!this._overlayAttached) {\n      return;\n    }\n\n    if (this.panelOpen) {\n      // Only emit if the panel was visible.\n      // `afterNextRender` always runs outside of the Angular zone, so all the subscriptions from\n      // `_subscribeToClosingActions()` are also outside of the Angular zone.\n      // We should manually run in Angular zone to update UI after panel closing.\n      this._zone.run(() => {\n        this.autocomplete.closed.emit();\n      });\n    }\n\n    // Only reset if this trigger is the latest one that opened the\n    // autocomplete since another may have taken it over.\n    if (this.autocomplete._latestOpeningTrigger === this) {\n      this.autocomplete._isOpen = false;\n      this.autocomplete._latestOpeningTrigger = null;\n    }\n\n    this._overlayAttached = false;\n    this._pendingAutoselectedOption = null;\n\n    if (this._overlayRef && this._overlayRef.hasAttached()) {\n      this._overlayRef.detach();\n      this._closingActionsSubscription.unsubscribe();\n    }\n\n    this._updatePanelState();\n\n    // Note that in some cases this can end up being called after the component is destroyed.\n    // Add a check to ensure that we don't try to run change detection on a destroyed view.\n    if (!this._componentDestroyed) {\n      // We need to trigger change detection manually, because\n      // `fromEvent` doesn't seem to do it at the proper time.\n      // This ensures that the label is reset when the\n      // user clicks outside.\n      this._changeDetectorRef.detectChanges();\n    }\n\n    // Remove aria-owns attribute when the autocomplete is no longer visible.\n    if (this._trackedModal) {\n      removeAriaReferencedId(this._trackedModal, 'aria-owns', this.autocomplete.id);\n    }\n  }\n\n  /**\n   * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n   * within the viewport.\n   */\n  updatePosition(): void {\n    if (this._overlayAttached) {\n      this._overlayRef!.updatePosition();\n    }\n  }\n\n  /**\n   * A stream of actions that should close the autocomplete panel, including\n   * when an option is selected, on blur, and when TAB is pressed.\n   */\n  get panelClosingActions(): Observable<MatOptionSelectionChange | null> {\n    return merge(\n      this.optionSelections,\n      this.autocomplete._keyManager.tabOut.pipe(filter(() => this._overlayAttached)),\n      this._closeKeyEventStream,\n      this._getOutsideClickStream(),\n      this._overlayRef\n        ? this._overlayRef.detachments().pipe(filter(() => this._overlayAttached))\n        : observableOf(),\n    ).pipe(\n      // Normalize the output so we return a consistent type.\n      map(event => (event instanceof MatOptionSelectionChange ? event : null)),\n    );\n  }\n\n  /** Stream of changes to the selection state of the autocomplete options. */\n  readonly optionSelections: Observable<MatOptionSelectionChange> = defer(() => {\n    const options = this.autocomplete ? this.autocomplete.options : null;\n\n    if (options) {\n      return options.changes.pipe(\n        startWith(options),\n        switchMap(() => merge(...options.map(option => option.onSelectionChange))),\n      );\n    }\n\n    // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n    // Return a stream that we'll replace with the real one once everything is in place.\n    return this._initialized.pipe(switchMap(() => this.optionSelections));\n  }) as Observable<MatOptionSelectionChange>;\n\n  /** The currently active option, coerced to MatOption type. */\n  get activeOption(): MatOption | null {\n    if (this.autocomplete && this.autocomplete._keyManager) {\n      return this.autocomplete._keyManager.activeItem;\n    }\n\n    return null;\n  }\n\n  /** Stream of clicks outside of the autocomplete panel. */\n  private _getOutsideClickStream(): Observable<any> {\n    return new Observable(observer => {\n      const listener = (event: MouseEvent | TouchEvent) => {\n        // If we're in the Shadow DOM, the event target will be the shadow root, so we have to\n        // fall back to check the first element in the path of the click event.\n        const clickTarget = _getEventTarget<HTMLElement>(event)!;\n        const formField = this._formField\n          ? this._formField.getConnectedOverlayOrigin().nativeElement\n          : null;\n        const customOrigin = this.connectedTo ? this.connectedTo.elementRef.nativeElement : null;\n\n        if (\n          this._overlayAttached &&\n          clickTarget !== this._element.nativeElement &&\n          // Normally focus moves inside `mousedown` so this condition will almost always be\n          // true. Its main purpose is to handle the case where the input is focused from an\n          // outside click which propagates up to the `body` listener within the same sequence\n          // and causes the panel to close immediately (see #3106).\n          !this._hasFocus() &&\n          (!formField || !formField.contains(clickTarget)) &&\n          (!customOrigin || !customOrigin.contains(clickTarget)) &&\n          !!this._overlayRef &&\n          !this._overlayRef.overlayElement.contains(clickTarget)\n        ) {\n          observer.next(event);\n        }\n      };\n\n      const cleanups = [\n        this._renderer.listen('document', 'click', listener),\n        this._renderer.listen('document', 'auxclick', listener),\n        this._renderer.listen('document', 'touchend', listener),\n      ];\n\n      return () => {\n        cleanups.forEach(current => current());\n      };\n    });\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  writeValue(value: any): void {\n    Promise.resolve(null).then(() => this._assignOptionValue(value));\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  registerOnChange(fn: (value: any) => {}): void {\n    this._onChange = fn;\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  registerOnTouched(fn: () => {}) {\n    this._onTouched = fn;\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  setDisabledState(isDisabled: boolean) {\n    this._element.nativeElement.disabled = isDisabled;\n  }\n\n  _handleKeydown(e: Event): void {\n    const event = e as KeyboardEvent;\n    const keyCode = event.keyCode;\n    const hasModifier = hasModifierKey(event);\n\n    // Prevent the default action on all escape key presses. This is here primarily to bring IE\n    // in line with other browsers. By default, pressing escape on IE will cause it to revert\n    // the input value to the one that it had on focus, however it won't dispatch any events\n    // which means that the model value will be out of sync with the view.\n    if (keyCode === ESCAPE && !hasModifier) {\n      event.preventDefault();\n    }\n\n    this._valueOnLastKeydown = this._element.nativeElement.value;\n\n    if (this.activeOption && keyCode === ENTER && this.panelOpen && !hasModifier) {\n      this.activeOption._selectViaInteraction();\n      this._resetActiveItem();\n      event.preventDefault();\n    } else if (this.autocomplete) {\n      const prevActiveItem = this.autocomplete._keyManager.activeItem;\n      const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\n\n      if (keyCode === TAB || (isArrowKey && !hasModifier && this.panelOpen)) {\n        this.autocomplete._keyManager.onKeydown(event);\n      } else if (isArrowKey && this._canOpen()) {\n        this._openPanelInternal(this._valueOnLastKeydown);\n      }\n\n      if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {\n        this._scrollToOption(this.autocomplete._keyManager.activeItemIndex || 0);\n\n        if (this.autocomplete.autoSelectActiveOption && this.activeOption) {\n          if (!this._pendingAutoselectedOption) {\n            this._valueBeforeAutoSelection = this._valueOnLastKeydown;\n          }\n\n          this._pendingAutoselectedOption = this.activeOption;\n          this._assignOptionValue(this.activeOption.value);\n        }\n      }\n    }\n  }\n\n  _handleInput(event: Event): void {\n    let target = event.target as HTMLInputElement;\n    let value: number | string | null = target.value;\n\n    // Based on `NumberValueAccessor` from forms.\n    if (target.type === 'number') {\n      value = value == '' ? null : parseFloat(value);\n    }\n\n    // If the input has a placeholder, IE will fire the `input` event on page load,\n    // focus and blur, in addition to when the user actually changed the value. To\n    // filter out all of the extra events, we save the value on focus and between\n    // `input` events, and we check whether it changed.\n    // See: https://connect.microsoft.com/IE/feedback/details/885747/\n    if (this._previousValue !== value) {\n      this._previousValue = value;\n      this._pendingAutoselectedOption = null;\n\n      // If selection is required we don't write to the CVA while the user is typing.\n      // At the end of the selection either the user will have picked something\n      // or we'll reset the value back to null.\n      if (!this.autocomplete || !this.autocomplete.requireSelection) {\n        this._onChange(value);\n      }\n\n      if (!value) {\n        this._clearPreviousSelectedOption(null, false);\n      } else if (this.panelOpen && !this.autocomplete.requireSelection) {\n        // Note that we don't reset this when `requireSelection` is enabled,\n        // because the option will be reset when the panel is closed.\n        const selectedOption = this.autocomplete.options?.find(option => option.selected);\n\n        if (selectedOption) {\n          const display = this._getDisplayValue(selectedOption.value);\n\n          if (value !== display) {\n            selectedOption.deselect(false);\n          }\n        }\n      }\n\n      if (this._canOpen() && this._hasFocus()) {\n        // When the `input` event fires, the input's value will have already changed. This means\n        // that if we take the `this._element.nativeElement.value` directly, it'll be one keystroke\n        // behind. This can be a problem when the user selects a value, changes a character while\n        // the input still has focus and then clicks away (see #28432). To work around it, we\n        // capture the value in `keydown` so we can use it here.\n        const valueOnAttach = this._valueOnLastKeydown ?? this._element.nativeElement.value;\n        this._valueOnLastKeydown = null;\n        this._openPanelInternal(valueOnAttach);\n      }\n    }\n  }\n\n  _handleFocus(): void {\n    if (!this._canOpenOnNextFocus) {\n      this._canOpenOnNextFocus = true;\n    } else if (this._canOpen()) {\n      this._previousValue = this._element.nativeElement.value;\n      this._attachOverlay(this._previousValue);\n      this._floatLabel(true);\n    }\n  }\n\n  _handleClick(): void {\n    if (this._canOpen() && !this.panelOpen) {\n      this._openPanelInternal();\n    }\n  }\n\n  /** Whether the input currently has focus. */\n  private _hasFocus(): boolean {\n    return _getFocusedElementPierceShadowDom() === this._element.nativeElement;\n  }\n\n  /**\n   * In \"auto\" mode, the label will animate down as soon as focus is lost.\n   * This causes the value to jump when selecting an option with the mouse.\n   * This method manually floats the label until the panel can be closed.\n   * @param shouldAnimate Whether the label should be animated when it is floated.\n   */\n  private _floatLabel(shouldAnimate = false): void {\n    if (this._formField && this._formField.floatLabel === 'auto') {\n      if (shouldAnimate) {\n        this._formField._animateAndLockLabel();\n      } else {\n        this._formField.floatLabel = 'always';\n      }\n\n      this._manuallyFloatingLabel = true;\n    }\n  }\n\n  /** If the label has been manually elevated, return it to its normal state. */\n  private _resetLabel(): void {\n    if (this._manuallyFloatingLabel) {\n      if (this._formField) {\n        this._formField.floatLabel = 'auto';\n      }\n      this._manuallyFloatingLabel = false;\n    }\n  }\n\n  /**\n   * This method listens to a stream of panel closing actions and resets the\n   * stream every time the option list changes.\n   */\n  private _subscribeToClosingActions(): Subscription {\n    const initialRender = new Observable(subscriber => {\n      afterNextRender(\n        () => {\n          subscriber.next();\n        },\n        {injector: this._environmentInjector},\n      );\n    });\n    const optionChanges =\n      this.autocomplete.options?.changes.pipe(\n        tap(() => this._positionStrategy.reapplyLastPosition()),\n        // Defer emitting to the stream until the next tick, because changing\n        // bindings in here will cause \"changed after checked\" errors.\n        delay(0),\n      ) ?? observableOf();\n\n    // When the options are initially rendered, and when the option list changes...\n    return (\n      merge(initialRender, optionChanges)\n        .pipe(\n          // create a new stream of panelClosingActions, replacing any previous streams\n          // that were created, and flatten it so our stream only emits closing events...\n          switchMap(() =>\n            this._zone.run(() => {\n              // `afterNextRender` always runs outside of the Angular zone, thus we have to re-enter\n              // the Angular zone. This will lead to change detection being called outside of the Angular\n              // zone and the `autocomplete.opened` will also emit outside of the Angular.\n              const wasOpen = this.panelOpen;\n              this._resetActiveItem();\n              this._updatePanelState();\n              this._changeDetectorRef.detectChanges();\n\n              if (this.panelOpen) {\n                this._overlayRef!.updatePosition();\n              }\n\n              if (wasOpen !== this.panelOpen) {\n                // If the `panelOpen` state changed, we need to make sure to emit the `opened` or\n                // `closed` event, because we may not have emitted it. This can happen\n                // - if the users opens the panel and there are no options, but the\n                //   options come in slightly later or as a result of the value changing,\n                // - if the panel is closed after the user entered a string that did not match any\n                //   of the available options,\n                // - if a valid string is entered after an invalid one.\n                if (this.panelOpen) {\n                  this._emitOpened();\n                } else {\n                  this.autocomplete.closed.emit();\n                }\n              }\n\n              return this.panelClosingActions;\n            }),\n          ),\n          // when the first closing event occurs...\n          take(1),\n        )\n        // set the value, close the panel, and complete.\n        .subscribe(event => this._setValueAndClose(event))\n    );\n  }\n\n  /**\n   * Emits the opened event once it's known that the panel will be shown and stores\n   * the state of the trigger right before the opening sequence was finished.\n   */\n  private _emitOpened() {\n    this.autocomplete.opened.emit();\n  }\n\n  /** Destroys the autocomplete suggestion panel. */\n  private _destroyPanel(): void {\n    if (this._overlayRef) {\n      this.closePanel();\n      this._overlayRef.dispose();\n      this._overlayRef = null;\n    }\n  }\n\n  /** Given a value, returns the string that should be shown within the input. */\n  private _getDisplayValue<T>(value: T): T | string {\n    const autocomplete = this.autocomplete;\n    return autocomplete && autocomplete.displayWith ? autocomplete.displayWith(value) : value;\n  }\n\n  private _assignOptionValue(value: any): void {\n    const toDisplay = this._getDisplayValue(value);\n\n    if (value == null) {\n      this._clearPreviousSelectedOption(null, false);\n    }\n\n    // Simply falling back to an empty string if the display value is falsy does not work properly.\n    // The display value can also be the number zero and shouldn't fall back to an empty string.\n    this._updateNativeInputValue(toDisplay != null ? toDisplay : '');\n  }\n\n  private _updateNativeInputValue(value: string): void {\n    // If it's used within a `MatFormField`, we should set it through the property so it can go\n    // through change detection.\n    if (this._formField) {\n      this._formField._control.value = value;\n    } else {\n      this._element.nativeElement.value = value;\n    }\n\n    this._previousValue = value;\n  }\n\n  /**\n   * This method closes the panel, and if a value is specified, also sets the associated\n   * control to that value. It will also mark the control as dirty if this interaction\n   * stemmed from the user.\n   */\n  private _setValueAndClose(event: MatOptionSelectionChange | null): void {\n    const panel = this.autocomplete;\n    const toSelect = event ? event.source : this._pendingAutoselectedOption;\n\n    if (toSelect) {\n      this._clearPreviousSelectedOption(toSelect);\n      this._assignOptionValue(toSelect.value);\n      // TODO(crisbeto): this should wait until the animation is done, otherwise the value\n      // gets reset while the panel is still animating which looks glitchy. It'll likely break\n      // some tests to change it at this point.\n      this._onChange(toSelect.value);\n      panel._emitSelectEvent(toSelect);\n      this._element.nativeElement.focus();\n    } else if (\n      panel.requireSelection &&\n      this._element.nativeElement.value !== this._valueOnAttach\n    ) {\n      this._clearPreviousSelectedOption(null);\n      this._assignOptionValue(null);\n      this._onChange(null);\n    }\n\n    this.closePanel();\n  }\n\n  /**\n   * Clear any previous selected option and emit a selection change event for this option\n   */\n  private _clearPreviousSelectedOption(skip: MatOption | null, emitEvent?: boolean) {\n    // Null checks are necessary here, because the autocomplete\n    // or its options may not have been assigned yet.\n    this.autocomplete?.options?.forEach(option => {\n      if (option !== skip && option.selected) {\n        option.deselect(emitEvent);\n      }\n    });\n  }\n\n  private _openPanelInternal(valueOnAttach = this._element.nativeElement.value) {\n    this._attachOverlay(valueOnAttach);\n    this._floatLabel();\n    // Add aria-owns attribute when the autocomplete becomes visible.\n    if (this._trackedModal) {\n      const panelId = this.autocomplete.id;\n      addAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n    }\n  }\n\n  private _attachOverlay(valueOnAttach: string): void {\n    if (!this.autocomplete && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatAutocompleteMissingPanelError();\n    }\n\n    let overlayRef = this._overlayRef;\n\n    if (!overlayRef) {\n      this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef, {\n        id: this._formField?.getLabelId(),\n      });\n      overlayRef = createOverlayRef(this._injector, this._getOverlayConfig());\n      this._overlayRef = overlayRef;\n      this._viewportSubscription = this._viewportRuler.change().subscribe(() => {\n        if (this.panelOpen && overlayRef) {\n          overlayRef.updateSize({width: this._getPanelWidth()});\n        }\n      });\n      // Subscribe to the breakpoint events stream to detect when screen is in\n      // handsetLandscape.\n      this._handsetLandscapeSubscription = this._breakpointObserver\n        .observe(Breakpoints.HandsetLandscape)\n        .subscribe(result => {\n          const isHandsetLandscape = result.matches;\n          // Check if result.matches Breakpoints.HandsetLandscape. Apply HandsetLandscape\n          // settings to prevent overlay cutoff in that breakpoint. Fixes b/284148377\n          if (isHandsetLandscape) {\n            this._positionStrategy\n              .withFlexibleDimensions(true)\n              .withGrowAfterOpen(true)\n              .withViewportMargin(8);\n          } else {\n            this._positionStrategy\n              .withFlexibleDimensions(false)\n              .withGrowAfterOpen(false)\n              .withViewportMargin(0);\n          }\n        });\n    } else {\n      // Update the trigger, panel width and direction, in case anything has changed.\n      this._positionStrategy.setOrigin(this._getConnectedElement());\n      overlayRef.updateSize({width: this._getPanelWidth()});\n    }\n\n    if (overlayRef && !overlayRef.hasAttached()) {\n      overlayRef.attach(this._portal);\n      this._valueOnAttach = valueOnAttach;\n      this._valueOnLastKeydown = null;\n      this._closingActionsSubscription = this._subscribeToClosingActions();\n    }\n\n    const wasOpen = this.panelOpen;\n\n    this.autocomplete._isOpen = this._overlayAttached = true;\n    this.autocomplete._latestOpeningTrigger = this;\n    this.autocomplete._setColor(this._formField?.color);\n    this._updatePanelState();\n    this._applyModalPanelOwnership();\n\n    // We need to do an extra `panelOpen` check in here, because the\n    // autocomplete won't be shown if there are no options.\n    if (this.panelOpen && wasOpen !== this.panelOpen) {\n      this._emitOpened();\n    }\n  }\n\n  /** Handles keyboard events coming from the overlay panel. */\n  private _handlePanelKeydown = (event: KeyboardEvent) => {\n    // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n    // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n    if (\n      (event.keyCode === ESCAPE && !hasModifierKey(event)) ||\n      (event.keyCode === UP_ARROW && hasModifierKey(event, 'altKey'))\n    ) {\n      // If the user had typed something in before we autoselected an option, and they decided\n      // to cancel the selection, restore the input value to the one they had typed in.\n      if (this._pendingAutoselectedOption) {\n        this._updateNativeInputValue(this._valueBeforeAutoSelection ?? '');\n        this._pendingAutoselectedOption = null;\n      }\n      this._closeKeyEventStream.next();\n      this._resetActiveItem();\n      // We need to stop propagation, otherwise the event will eventually\n      // reach the input itself and cause the overlay to be reopened.\n      event.stopPropagation();\n      event.preventDefault();\n    }\n  };\n\n  /** Updates the panel's visibility state and any trigger state tied to id. */\n  private _updatePanelState() {\n    this.autocomplete._setVisibility();\n\n    // Note that here we subscribe and unsubscribe based on the panel's visiblity state,\n    // because the act of subscribing will prevent events from reaching other overlays and\n    // we don't want to block the events if there are no options.\n    if (this.panelOpen) {\n      const overlayRef = this._overlayRef!;\n\n      if (!this._keydownSubscription) {\n        // Use the `keydownEvents` in order to take advantage of\n        // the overlay event targeting provided by the CDK overlay.\n        this._keydownSubscription = overlayRef.keydownEvents().subscribe(this._handlePanelKeydown);\n      }\n\n      if (!this._outsideClickSubscription) {\n        // Subscribe to the pointer events stream so that it doesn't get picked up by other overlays.\n        // TODO(crisbeto): we should switch `_getOutsideClickStream` eventually to use this stream,\n        // but the behvior isn't exactly the same and it ends up breaking some internal tests.\n        this._outsideClickSubscription = overlayRef.outsidePointerEvents().subscribe();\n      }\n    } else {\n      this._keydownSubscription?.unsubscribe();\n      this._outsideClickSubscription?.unsubscribe();\n      this._keydownSubscription = this._outsideClickSubscription = null;\n    }\n  }\n\n  private _getOverlayConfig(): OverlayConfig {\n    return new OverlayConfig({\n      positionStrategy: this._getOverlayPosition(),\n      scrollStrategy: this._scrollStrategy(),\n      width: this._getPanelWidth(),\n      direction: this._dir ?? undefined,\n      hasBackdrop: this._defaults?.hasBackdrop,\n      backdropClass: this._defaults?.backdropClass || 'cdk-overlay-transparent-backdrop',\n      panelClass: this._overlayPanelClass,\n      disableAnimations: this._animationsDisabled,\n    });\n  }\n\n  private _getOverlayPosition(): PositionStrategy {\n    // Set default Overlay Position\n    const strategy = createFlexibleConnectedPositionStrategy(\n      this._injector,\n      this._getConnectedElement(),\n    )\n      .withFlexibleDimensions(false)\n      .withPush(false);\n\n    this._setStrategyPositions(strategy);\n    this._positionStrategy = strategy;\n    return strategy;\n  }\n\n  /** Sets the positions on a position strategy based on the directive's input state. */\n  private _setStrategyPositions(positionStrategy: FlexibleConnectedPositionStrategy) {\n    // Note that we provide horizontal fallback positions, even though by default the dropdown\n    // width matches the input, because consumers can override the width. See #18854.\n    const belowPositions: ConnectedPosition[] = [\n      {originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top'},\n      {originX: 'end', originY: 'bottom', overlayX: 'end', overlayY: 'top'},\n    ];\n\n    // The overlay edge connected to the trigger should have squared corners, while\n    // the opposite end has rounded corners. We apply a CSS class to swap the\n    // border-radius based on the overlay position.\n    const panelClass = this._aboveClass;\n    const abovePositions: ConnectedPosition[] = [\n      {originX: 'start', originY: 'top', overlayX: 'start', overlayY: 'bottom', panelClass},\n      {originX: 'end', originY: 'top', overlayX: 'end', overlayY: 'bottom', panelClass},\n    ];\n\n    let positions: ConnectedPosition[];\n\n    if (this.position === 'above') {\n      positions = abovePositions;\n    } else if (this.position === 'below') {\n      positions = belowPositions;\n    } else {\n      positions = [...belowPositions, ...abovePositions];\n    }\n\n    positionStrategy.withPositions(positions);\n  }\n\n  private _getConnectedElement(): ElementRef<HTMLElement> {\n    if (this.connectedTo) {\n      return this.connectedTo.elementRef;\n    }\n\n    return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;\n  }\n\n  private _getPanelWidth(): number | string {\n    return this.autocomplete.panelWidth || this._getHostWidth();\n  }\n\n  /** Returns the width of the input element, so the panel width can match it. */\n  private _getHostWidth(): number {\n    return this._getConnectedElement().nativeElement.getBoundingClientRect().width;\n  }\n\n  /**\n   * Reset the active item to -1. This is so that pressing arrow keys will activate the correct\n   * option.\n   *\n   * If the consumer opted-in to automatically activatating the first option, activate the first\n   * *enabled* option.\n   */\n  private _resetActiveItem(): void {\n    const autocomplete = this.autocomplete;\n\n    if (autocomplete.autoActiveFirstOption) {\n      // Find the index of the first *enabled* option. Avoid calling `_keyManager.setActiveItem`\n      // because it activates the first option that passes the skip predicate, rather than the\n      // first *enabled* option.\n      let firstEnabledOptionIndex = -1;\n\n      for (let index = 0; index < autocomplete.options.length; index++) {\n        const option = autocomplete.options.get(index)!;\n        if (!option.disabled) {\n          firstEnabledOptionIndex = index;\n          break;\n        }\n      }\n      autocomplete._keyManager.setActiveItem(firstEnabledOptionIndex);\n    } else {\n      autocomplete._keyManager.setActiveItem(-1);\n    }\n  }\n\n  /** Determines whether the panel can be opened. */\n  private _canOpen(): boolean {\n    const element = this._element.nativeElement;\n    return !element.readOnly && !element.disabled && !this.autocompleteDisabled;\n  }\n\n  /** Scrolls to a particular option in the list. */\n  private _scrollToOption(index: number): void {\n    // Given that we are not actually focusing active options, we must manually adjust scroll\n    // to reveal options below the fold. First, we find the offset of the option from the top\n    // of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n    // the panel height + the option height, so the active option will be just visible at the\n    // bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n    // will become the offset. If that offset is visible within the panel already, the scrollTop is\n    // not adjusted.\n    const autocomplete = this.autocomplete;\n    const labelCount = _countGroupLabelsBeforeOption(\n      index,\n      autocomplete.options,\n      autocomplete.optionGroups,\n    );\n\n    if (index === 0 && labelCount === 1) {\n      // If we've got one group label before the option and we're at the top option,\n      // scroll the list to the top. This is better UX than scrolling the list to the\n      // top of the option, because it allows the user to read the top group's label.\n      autocomplete._setScrollTop(0);\n    } else if (autocomplete.panel) {\n      const option = autocomplete.options.toArray()[index];\n\n      if (option) {\n        const element = option._getHostElement();\n        const newScrollPosition = _getOptionScrollPosition(\n          element.offsetTop,\n          element.offsetHeight,\n          autocomplete._getScrollTop(),\n          autocomplete.panel.nativeElement.offsetHeight,\n        );\n\n        autocomplete._setScrollTop(newScrollPosition);\n      }\n    }\n  }\n\n  /**\n   * Track which modal we have modified the `aria-owns` attribute of. When the combobox trigger is\n   * inside an aria-modal, we apply aria-owns to the parent modal with the `id` of the options\n   * panel. Track the modal we have changed so we can undo the changes on destroy.\n   */\n  private _trackedModal: Element | null = null;\n\n  /**\n   * If the autocomplete trigger is inside of an `aria-modal` element, connect\n   * that modal to the options panel with `aria-owns`.\n   *\n   * For some browser + screen reader combinations, when navigation is inside\n   * of an `aria-modal` element, the screen reader treats everything outside\n   * of that modal as hidden or invisible.\n   *\n   * This causes a problem when the combobox trigger is _inside_ of a modal, because the\n   * options panel is rendered _outside_ of that modal, preventing screen reader navigation\n   * from reaching the panel.\n   *\n   * We can work around this issue by applying `aria-owns` to the modal with the `id` of\n   * the options panel. This effectively communicates to assistive technology that the\n   * options panel is part of the same interaction as the modal.\n   *\n   * At time of this writing, this issue is present in VoiceOver.\n   * See https://github.com/angular/components/issues/20694\n   */\n  private _applyModalPanelOwnership() {\n    // TODO(http://github.com/angular/components/issues/26853): consider de-duplicating this with\n    // the `LiveAnnouncer` and any other usages.\n    //\n    // Note that the selector here is limited to CDK overlays at the moment in order to reduce the\n    // section of the DOM we need to look through. This should cover all the cases we support, but\n    // the selector can be expanded if it turns out to be too narrow.\n    const modal = this._element.nativeElement.closest(\n      'body > .cdk-overlay-container [aria-modal=\"true\"]',\n    );\n\n    if (!modal) {\n      // Most commonly, the autocomplete trigger is not inside a modal.\n      return;\n    }\n\n    const panelId = this.autocomplete.id;\n\n    if (this._trackedModal) {\n      removeAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n    }\n\n    addAriaReferencedId(modal, 'aria-owns', panelId);\n    this._trackedModal = modal;\n  }\n\n  /** Clears the references to the listbox overlay element from the modal it was added to. */\n  private _clearFromModal() {\n    if (this._trackedModal) {\n      const panelId = this.autocomplete.id;\n\n      removeAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n      this._trackedModal = null;\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {MatOptionModule} from '../core';\nimport {BidiModule} from '@angular/cdk/bidi';\nimport {CdkScrollableModule} from '@angular/cdk/scrolling';\nimport {OverlayModule} from '@angular/cdk/overlay';\nimport {MatAutocomplete} from './autocomplete';\nimport {MatAutocompleteTrigger} from './autocomplete-trigger';\nimport {MatAutocompleteOrigin} from './autocomplete-origin';\n\n@NgModule({\n  imports: [\n    OverlayModule,\n    MatOptionModule,\n    MatAutocomplete,\n    MatAutocompleteTrigger,\n    MatAutocompleteOrigin,\n  ],\n  exports: [\n    CdkScrollableModule,\n    MatAutocomplete,\n    MatOptionModule,\n    BidiModule,\n    MatAutocompleteTrigger,\n    MatAutocompleteOrigin,\n  ],\n})\nexport class MatAutocompleteModule {}\n"],"names":["MatAutocompleteSelectedEvent","source","constructor","option","MAT_AUTOCOMPLETE_DEFAULT_OPTIONS","InjectionToken","providedIn","factory","autoActiveFirstOption","autoSelectActiveOption","hideSingleSelectionIndicator","requireSelection","hasBackdrop","MatAutocomplete","inject","ChangeDetectorRef","ElementRef","_animationsDisabled","_activeOptionChanges","Subscription","EMPTY","showPanel","isOpen","_isOpen","_setColor","value","_color","_changeDetectorRef","markForCheck","panel","ariaLabel","disableRipple","EventEmitter","closed","classList","_elementRef","nativeElement","className","_hideSingleSelectionIndicator","getId","Platform","platform","SAFARI","_defaults","ActiveDescendantKeyManager","options","_keyManager","change","subscribe","index","styles","MatOption","descendants","type","ContentChildren","MAT_OPTGROUP","Input","args","transform","booleanAttribute","opened","Output","MatAutocompleteOrigin","elementRef","MAT_AUTOCOMPLETE_VALUE_ACCESSOR","provide","NG_VALUE_ACCESSOR","multi","getMatAutocompleteMissingPanelError","Error","injector","Injector","createRepositionScrollStrategy","MatAutocompleteTrigger","_viewContainerRef","ViewContainerRef","_zone","NgZone","_dir","Directionality","optional","_scrollStrategy","MAT_AUTOCOMPLETE_SCROLL_STRATEGY","_renderer","Renderer2","_portal","_componentDestroyed","_initialized","Subject","_cleanupWindowBlur","_previousValue","_valueOnAttach","_valueOnLastKeydown","_positionStrategy","_closingActionsSubscription","_viewportSubscription","_handsetLandscapeSubscription","_canOpenOnNextFocus","_windowBlurHandler","_onChange","_onTouched","listen","ngOnChanges","changes","panelOpen","_overlayRef","updatePosition","ngOnDestroy","unsubscribe","_destroyPanel","autocomplete","_openPanelInternal","run","emit","_latestOpeningTrigger","_pendingAutoselectedOption","detach","_updatePanelState","detectChanges","_trackedModal","removeAriaReferencedId","id","panelClosingActions","merge","optionSelections","tabOut","pipe","filter","_overlayAttached","_closeKeyEventStream","_getOutsideClickStream","defer","startWith","switchMap","map","onSelectionChange","Observable","observer","listener","event","_formField","getConnectedOverlayOrigin","customOrigin","connectedTo","clickTarget","_element","_hasFocus","formField","contains","writeValue","resolve","then","_assignOptionValue","registerOnTouched","fn","disabled","isDisabled","e","ESCAPE","hasModifier","preventDefault","activeOption","keyCode","ENTER","_selectViaInteraction","activeItem","UP_ARROW","DOWN_ARROW","isArrowKey","onKeydown","prevActiveItem","activeItemIndex","_valueBeforeAutoSelection","target","selectedOption","display","_getDisplayValue","deselect","_canOpen","valueOnAttach","floatLabel","_manuallyFloatingLabel","_subscribeToClosingActions","optionChanges","wasOpen","_resetActiveItem","_emitOpened","_setValueAndClose","dispose","displayWith","toDisplay","_clearPreviousSelectedOption","_updateNativeInputValue","_control","toSelect","focus","closePanel","skip","emitEvent","panelId","getLabelId","overlayRef","createOverlayRef","_injector","_viewportRuler","updateSize","width","_getPanelWidth","_breakpointObserver","observe","Breakpoints","HandsetLandscape","result","isHandsetLandscape","matches","withFlexibleDimensions","withGrowAfterOpen","withViewportMargin","hasAttached","hasModifierKey","next","stopPropagation","_keydownSubscription","keydownEvents","_handlePanelKeydown","_outsideClickSubscription","outsidePointerEvents","backdropClass","ctorParameters","propDecorators","alias","fac","i0","ngDeclareFactory","minVersion","version","ngImport","MatAutocompleteModule","deps","FactoryTarget","NgModule","imports","OverlayModule","ngDeclareInjector","BidiModule","decorators","MatOptionModule"],"mappings":"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"}