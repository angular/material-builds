{"version":3,"file":"_ripple-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/core/ripple/ripple-ref.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/core/ripple/ripple-event-manager.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/core/ripple/ripple-renderer.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/core/ripple/ripple.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/** Possible states for a ripple element. */\nexport enum RippleState {\n  FADING_IN,\n  VISIBLE,\n  FADING_OUT,\n  HIDDEN,\n}\n\nexport type RippleConfig = {\n  color?: string;\n  centered?: boolean;\n  radius?: number;\n  persistent?: boolean;\n  animation?: RippleAnimationConfig;\n  terminateOnPointerUp?: boolean;\n};\n\n/**\n * Interface that describes the configuration for the animation of a ripple.\n * There are two animation phases with different durations for the ripples.\n */\nexport interface RippleAnimationConfig {\n  /** Duration in milliseconds for the enter animation (expansion from point of contact). */\n  enterDuration?: number;\n  /** Duration in milliseconds for the exit animation (fade-out). */\n  exitDuration?: number;\n}\n\n/**\n * Reference to a previously launched ripple element.\n */\nexport class RippleRef {\n  /** Current state of the ripple. */\n  state: RippleState = RippleState.HIDDEN;\n\n  constructor(\n    private _renderer: {fadeOutRipple(ref: RippleRef): void},\n    /** Reference to the ripple HTML element. */\n    public element: HTMLElement,\n    /** Ripple configuration used for the ripple. */\n    public config: RippleConfig,\n    /* Whether animations are forcibly disabled for ripples through CSS. */\n    public _animationForciblyDisabledThroughCss = false,\n  ) {}\n\n  /** Fades out the ripple element. */\n  fadeOut() {\n    this._renderer.fadeOutRipple(this);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {normalizePassiveListenerOptions, _getEventTarget} from '@angular/cdk/platform';\nimport {NgZone} from '@angular/core';\n\n/** Options used to bind a passive capturing event. */\nconst passiveCapturingEventOptions = normalizePassiveListenerOptions({\n  passive: true,\n  capture: true,\n});\n\n/** Manages events through delegation so that as few event handlers as possible are bound. */\nexport class RippleEventManager {\n  private _events = new Map<string, Map<HTMLElement, Set<EventListenerObject>>>();\n\n  /** Adds an event handler. */\n  addHandler(ngZone: NgZone, name: string, element: HTMLElement, handler: EventListenerObject) {\n    const handlersForEvent = this._events.get(name);\n\n    if (handlersForEvent) {\n      const handlersForElement = handlersForEvent.get(element);\n\n      if (handlersForElement) {\n        handlersForElement.add(handler);\n      } else {\n        handlersForEvent.set(element, new Set([handler]));\n      }\n    } else {\n      this._events.set(name, new Map([[element, new Set([handler])]]));\n\n      ngZone.runOutsideAngular(() => {\n        document.addEventListener(name, this._delegateEventHandler, passiveCapturingEventOptions);\n      });\n    }\n  }\n\n  /** Removes an event handler. */\n  removeHandler(name: string, element: HTMLElement, handler: EventListenerObject) {\n    const handlersForEvent = this._events.get(name);\n\n    if (!handlersForEvent) {\n      return;\n    }\n\n    const handlersForElement = handlersForEvent.get(element);\n\n    if (!handlersForElement) {\n      return;\n    }\n\n    handlersForElement.delete(handler);\n\n    if (handlersForElement.size === 0) {\n      handlersForEvent.delete(element);\n    }\n\n    if (handlersForEvent.size === 0) {\n      this._events.delete(name);\n      document.removeEventListener(name, this._delegateEventHandler, passiveCapturingEventOptions);\n    }\n  }\n\n  /** Event handler that is bound and which dispatches the events to the different targets. */\n  private _delegateEventHandler = (event: Event) => {\n    const target = _getEventTarget(event);\n\n    if (target) {\n      this._events.get(event.type)?.forEach((handlers, element) => {\n        if (element === target || element.contains(target as Node)) {\n          handlers.forEach(handler => handler.handleEvent(event));\n        }\n      });\n    }\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {\n  ElementRef,\n  NgZone,\n  Component,\n  ChangeDetectionStrategy,\n  ViewEncapsulation,\n  Injector,\n} from '@angular/core';\nimport {Platform, normalizePassiveListenerOptions, _getEventTarget} from '@angular/cdk/platform';\nimport {isFakeMousedownFromScreenReader, isFakeTouchstartFromScreenReader} from '@angular/cdk/a11y';\nimport {coerceElement} from '@angular/cdk/coercion';\nimport {_CdkPrivateStyleLoader} from '@angular/cdk/private';\nimport {RippleRef, RippleState, RippleConfig} from './ripple-ref';\nimport {RippleEventManager} from './ripple-event-manager';\n\n/**\n * Interface that describes the target for launching ripples.\n * It defines the ripple configuration and disabled state for interaction ripples.\n * @docs-private\n */\nexport interface RippleTarget {\n  /** Configuration for ripples that are launched on pointer down. */\n  rippleConfig: RippleConfig;\n  /** Whether ripples on pointer down should be disabled. */\n  rippleDisabled: boolean;\n}\n\n/** Interfaces the defines ripple element transition event listeners. */\ninterface RippleEventListeners {\n  onTransitionEnd: EventListener;\n  onTransitionCancel: EventListener;\n  fallbackTimer: ReturnType<typeof setTimeout> | null;\n}\n\n/**\n * Default ripple animation configuration for ripples without an explicit\n * animation config specified.\n */\nexport const defaultRippleAnimationConfig = {\n  enterDuration: 225,\n  exitDuration: 150,\n};\n\n/**\n * Timeout for ignoring mouse events. Mouse events will be temporary ignored after touch\n * events to avoid synthetic mouse events.\n */\nconst ignoreMouseEventsTimeout = 800;\n\n/** Options used to bind a passive capturing event. */\nconst passiveCapturingEventOptions = normalizePassiveListenerOptions({\n  passive: true,\n  capture: true,\n});\n\n/** Events that signal that the pointer is down. */\nconst pointerDownEvents = ['mousedown', 'touchstart'];\n\n/** Events that signal that the pointer is up. */\nconst pointerUpEvents = ['mouseup', 'mouseleave', 'touchend', 'touchcancel'];\n\n@Component({\n  template: '',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  styleUrl: 'ripple-structure.css',\n  host: {'mat-ripple-style-loader': ''},\n})\nexport class _MatRippleStylesLoader {}\n\n/**\n * Helper service that performs DOM manipulations. Not intended to be used outside this module.\n * The constructor takes a reference to the ripple directive's host element and a map of DOM\n * event handlers to be installed on the element that triggers ripple animations.\n * This will eventually become a custom renderer once Angular support exists.\n * @docs-private\n */\nexport class RippleRenderer implements EventListenerObject {\n  /** Element where the ripples are being added to. */\n  private _containerElement: HTMLElement;\n\n  /** Element which triggers the ripple elements on mouse events. */\n  private _triggerElement: HTMLElement | null;\n\n  /** Whether the pointer is currently down or not. */\n  private _isPointerDown = false;\n\n  /**\n   * Map of currently active ripple references.\n   * The ripple reference is mapped to its element event listeners.\n   * The reason why `| null` is used is that event listeners are added only\n   * when the condition is truthy (see the `_startFadeOutTransition` method).\n   */\n  private _activeRipples = new Map<RippleRef, RippleEventListeners | null>();\n\n  /** Latest non-persistent ripple that was triggered. */\n  private _mostRecentTransientRipple: RippleRef | null;\n\n  /** Time in milliseconds when the last touchstart event happened. */\n  private _lastTouchStartEvent: number;\n\n  /** Whether pointer-up event listeners have been registered. */\n  private _pointerUpEventsRegistered = false;\n\n  /**\n   * Cached dimensions of the ripple container. Set when the first\n   * ripple is shown and cleared once no more ripples are visible.\n   */\n  private _containerRect: DOMRect | null;\n\n  private static _eventManager = new RippleEventManager();\n\n  constructor(\n    private _target: RippleTarget,\n    private _ngZone: NgZone,\n    elementOrElementRef: HTMLElement | ElementRef<HTMLElement>,\n    private _platform: Platform,\n    injector?: Injector,\n  ) {\n    // Only do anything if we're on the browser.\n    if (_platform.isBrowser) {\n      this._containerElement = coerceElement(elementOrElementRef);\n    }\n\n    if (injector) {\n      injector.get(_CdkPrivateStyleLoader).load(_MatRippleStylesLoader);\n    }\n  }\n\n  /**\n   * Fades in a ripple at the given coordinates.\n   * @param x Coordinate within the element, along the X axis at which to start the ripple.\n   * @param y Coordinate within the element, along the Y axis at which to start the ripple.\n   * @param config Extra ripple options.\n   */\n  fadeInRipple(x: number, y: number, config: RippleConfig = {}): RippleRef {\n    const containerRect = (this._containerRect =\n      this._containerRect || this._containerElement.getBoundingClientRect());\n    const animationConfig = {...defaultRippleAnimationConfig, ...config.animation};\n\n    if (config.centered) {\n      x = containerRect.left + containerRect.width / 2;\n      y = containerRect.top + containerRect.height / 2;\n    }\n\n    const radius = config.radius || distanceToFurthestCorner(x, y, containerRect);\n    const offsetX = x - containerRect.left;\n    const offsetY = y - containerRect.top;\n    const enterDuration = animationConfig.enterDuration;\n\n    const ripple = document.createElement('div');\n    ripple.classList.add('mat-ripple-element');\n\n    ripple.style.left = `${offsetX - radius}px`;\n    ripple.style.top = `${offsetY - radius}px`;\n    ripple.style.height = `${radius * 2}px`;\n    ripple.style.width = `${radius * 2}px`;\n\n    // If a custom color has been specified, set it as inline style. If no color is\n    // set, the default color will be applied through the ripple theme styles.\n    if (config.color != null) {\n      ripple.style.backgroundColor = config.color;\n    }\n\n    ripple.style.transitionDuration = `${enterDuration}ms`;\n\n    this._containerElement.appendChild(ripple);\n\n    // By default the browser does not recalculate the styles of dynamically created\n    // ripple elements. This is critical to ensure that the `scale` animates properly.\n    // We enforce a style recalculation by calling `getComputedStyle` and *accessing* a property.\n    // See: https://gist.github.com/paulirish/5d52fb081b3570c81e3a\n    const computedStyles = window.getComputedStyle(ripple);\n    const userTransitionProperty = computedStyles.transitionProperty;\n    const userTransitionDuration = computedStyles.transitionDuration;\n\n    // Note: We detect whether animation is forcibly disabled through CSS (e.g. through\n    // `transition: none` or `display: none`). This is technically unexpected since animations are\n    // controlled through the animation config, but this exists for backwards compatibility. This\n    // logic does not need to be super accurate since it covers some edge cases which can be easily\n    // avoided by users.\n    const animationForciblyDisabledThroughCss =\n      userTransitionProperty === 'none' ||\n      // Note: The canonical unit for serialized CSS `<time>` properties is seconds. Additionally\n      // some browsers expand the duration for every property (in our case `opacity` and `transform`).\n      userTransitionDuration === '0s' ||\n      userTransitionDuration === '0s, 0s' ||\n      // If the container is 0x0, it's likely `display: none`.\n      (containerRect.width === 0 && containerRect.height === 0);\n\n    // Exposed reference to the ripple that will be returned.\n    const rippleRef = new RippleRef(this, ripple, config, animationForciblyDisabledThroughCss);\n\n    // Start the enter animation by setting the transform/scale to 100%. The animation will\n    // execute as part of this statement because we forced a style recalculation before.\n    // Note: We use a 3d transform here in order to avoid an issue in Safari where\n    // the ripples aren't clipped when inside the shadow DOM (see #24028).\n    ripple.style.transform = 'scale3d(1, 1, 1)';\n\n    rippleRef.state = RippleState.FADING_IN;\n\n    if (!config.persistent) {\n      this._mostRecentTransientRipple = rippleRef;\n    }\n\n    let eventListeners: RippleEventListeners | null = null;\n\n    // Do not register the `transition` event listener if fade-in and fade-out duration\n    // are set to zero. The events won't fire anyway and we can save resources here.\n    if (!animationForciblyDisabledThroughCss && (enterDuration || animationConfig.exitDuration)) {\n      this._ngZone.runOutsideAngular(() => {\n        const onTransitionEnd = () => {\n          // Clear the fallback timer since the transition fired correctly.\n          if (eventListeners) {\n            eventListeners.fallbackTimer = null;\n          }\n          clearTimeout(fallbackTimer);\n          this._finishRippleTransition(rippleRef);\n        };\n        const onTransitionCancel = () => this._destroyRipple(rippleRef);\n\n        // In some cases where there's a higher load on the browser, it can choose not to dispatch\n        // neither `transitionend` nor `transitioncancel` (see b/227356674). This timer serves as a\n        // fallback for such cases so that the ripple doesn't become stuck. We add a 100ms buffer\n        // because timers aren't precise. Note that another approach can be to transition the ripple\n        // to the `VISIBLE` state immediately above and to `FADING_IN` afterwards inside\n        // `transitionstart`. We go with the timer because it's one less event listener and\n        // it's less likely to break existing tests.\n        const fallbackTimer = setTimeout(onTransitionCancel, enterDuration + 100);\n\n        ripple.addEventListener('transitionend', onTransitionEnd);\n        // If the transition is cancelled (e.g. due to DOM removal), we destroy the ripple\n        // directly as otherwise we would keep it part of the ripple container forever.\n        // https://www.w3.org/TR/css-transitions-1/#:~:text=no%20longer%20in%20the%20document.\n        ripple.addEventListener('transitioncancel', onTransitionCancel);\n        eventListeners = {onTransitionEnd, onTransitionCancel, fallbackTimer};\n      });\n    }\n\n    // Add the ripple reference to the list of all active ripples.\n    this._activeRipples.set(rippleRef, eventListeners);\n\n    // In case there is no fade-in transition duration, we need to manually call the transition\n    // end listener because `transitionend` doesn't fire if there is no transition.\n    if (animationForciblyDisabledThroughCss || !enterDuration) {\n      this._finishRippleTransition(rippleRef);\n    }\n\n    return rippleRef;\n  }\n\n  /** Fades out a ripple reference. */\n  fadeOutRipple(rippleRef: RippleRef) {\n    // For ripples already fading out or hidden, this should be a noop.\n    if (rippleRef.state === RippleState.FADING_OUT || rippleRef.state === RippleState.HIDDEN) {\n      return;\n    }\n\n    const rippleEl = rippleRef.element;\n    const animationConfig = {...defaultRippleAnimationConfig, ...rippleRef.config.animation};\n\n    // This starts the fade-out transition and will fire the transition end listener that\n    // removes the ripple element from the DOM.\n    rippleEl.style.transitionDuration = `${animationConfig.exitDuration}ms`;\n    rippleEl.style.opacity = '0';\n    rippleRef.state = RippleState.FADING_OUT;\n\n    // In case there is no fade-out transition duration, we need to manually call the\n    // transition end listener because `transitionend` doesn't fire if there is no transition.\n    if (rippleRef._animationForciblyDisabledThroughCss || !animationConfig.exitDuration) {\n      this._finishRippleTransition(rippleRef);\n    }\n  }\n\n  /** Fades out all currently active ripples. */\n  fadeOutAll() {\n    this._getActiveRipples().forEach(ripple => ripple.fadeOut());\n  }\n\n  /** Fades out all currently active non-persistent ripples. */\n  fadeOutAllNonPersistent() {\n    this._getActiveRipples().forEach(ripple => {\n      if (!ripple.config.persistent) {\n        ripple.fadeOut();\n      }\n    });\n  }\n\n  /** Sets up the trigger event listeners */\n  setupTriggerEvents(elementOrElementRef: HTMLElement | ElementRef<HTMLElement>) {\n    const element = coerceElement(elementOrElementRef);\n\n    if (!this._platform.isBrowser || !element || element === this._triggerElement) {\n      return;\n    }\n\n    // Remove all previously registered event listeners from the trigger element.\n    this._removeTriggerEvents();\n    this._triggerElement = element;\n\n    // Use event delegation for the trigger events since they're\n    // set up during creation and are performance-sensitive.\n    pointerDownEvents.forEach(type => {\n      RippleRenderer._eventManager.addHandler(this._ngZone, type, element, this);\n    });\n  }\n\n  /**\n   * Handles all registered events.\n   * @docs-private\n   */\n  handleEvent(event: Event) {\n    if (event.type === 'mousedown') {\n      this._onMousedown(event as MouseEvent);\n    } else if (event.type === 'touchstart') {\n      this._onTouchStart(event as TouchEvent);\n    } else {\n      this._onPointerUp();\n    }\n\n    // If pointer-up events haven't been registered yet, do so now.\n    // We do this on-demand in order to reduce the total number of event listeners\n    // registered by the ripples, which speeds up the rendering time for large UIs.\n    if (!this._pointerUpEventsRegistered) {\n      // The events for hiding the ripple are bound directly on the trigger, because:\n      // 1. Some of them occur frequently (e.g. `mouseleave`) and any advantage we get from\n      // delegation will be diminished by having to look through all the data structures often.\n      // 2. They aren't as performance-sensitive, because they're bound only after the user\n      // has interacted with an element.\n      this._ngZone.runOutsideAngular(() => {\n        pointerUpEvents.forEach(type => {\n          this._triggerElement!.addEventListener(type, this, passiveCapturingEventOptions);\n        });\n      });\n\n      this._pointerUpEventsRegistered = true;\n    }\n  }\n\n  /** Method that will be called if the fade-in or fade-in transition completed. */\n  private _finishRippleTransition(rippleRef: RippleRef) {\n    if (rippleRef.state === RippleState.FADING_IN) {\n      this._startFadeOutTransition(rippleRef);\n    } else if (rippleRef.state === RippleState.FADING_OUT) {\n      this._destroyRipple(rippleRef);\n    }\n  }\n\n  /**\n   * Starts the fade-out transition of the given ripple if it's not persistent and the pointer\n   * is not held down anymore.\n   */\n  private _startFadeOutTransition(rippleRef: RippleRef) {\n    const isMostRecentTransientRipple = rippleRef === this._mostRecentTransientRipple;\n    const {persistent} = rippleRef.config;\n\n    rippleRef.state = RippleState.VISIBLE;\n\n    // When the timer runs out while the user has kept their pointer down, we want to\n    // keep only the persistent ripples and the latest transient ripple. We do this,\n    // because we don't want stacked transient ripples to appear after their enter\n    // animation has finished.\n    if (!persistent && (!isMostRecentTransientRipple || !this._isPointerDown)) {\n      rippleRef.fadeOut();\n    }\n  }\n\n  /** Destroys the given ripple by removing it from the DOM and updating its state. */\n  private _destroyRipple(rippleRef: RippleRef) {\n    const eventListeners = this._activeRipples.get(rippleRef) ?? null;\n    this._activeRipples.delete(rippleRef);\n\n    // Clear out the cached bounding rect if we have no more ripples.\n    if (!this._activeRipples.size) {\n      this._containerRect = null;\n    }\n\n    // If the current ref is the most recent transient ripple, unset it\n    // avoid memory leaks.\n    if (rippleRef === this._mostRecentTransientRipple) {\n      this._mostRecentTransientRipple = null;\n    }\n\n    rippleRef.state = RippleState.HIDDEN;\n    if (eventListeners !== null) {\n      rippleRef.element.removeEventListener('transitionend', eventListeners.onTransitionEnd);\n      rippleRef.element.removeEventListener('transitioncancel', eventListeners.onTransitionCancel);\n      if (eventListeners.fallbackTimer !== null) {\n        clearTimeout(eventListeners.fallbackTimer);\n      }\n    }\n    rippleRef.element.remove();\n  }\n\n  /** Function being called whenever the trigger is being pressed using mouse. */\n  private _onMousedown(event: MouseEvent) {\n    // Screen readers will fire fake mouse events for space/enter. Skip launching a\n    // ripple in this case for consistency with the non-screen-reader experience.\n    const isFakeMousedown = isFakeMousedownFromScreenReader(event);\n    const isSyntheticEvent =\n      this._lastTouchStartEvent &&\n      Date.now() < this._lastTouchStartEvent + ignoreMouseEventsTimeout;\n\n    if (!this._target.rippleDisabled && !isFakeMousedown && !isSyntheticEvent) {\n      this._isPointerDown = true;\n      this.fadeInRipple(event.clientX, event.clientY, this._target.rippleConfig);\n    }\n  }\n\n  /** Function being called whenever the trigger is being pressed using touch. */\n  private _onTouchStart(event: TouchEvent) {\n    if (!this._target.rippleDisabled && !isFakeTouchstartFromScreenReader(event)) {\n      // Some browsers fire mouse events after a `touchstart` event. Those synthetic mouse\n      // events will launch a second ripple if we don't ignore mouse events for a specific\n      // time after a touchstart event.\n      this._lastTouchStartEvent = Date.now();\n      this._isPointerDown = true;\n\n      // Use `changedTouches` so we skip any touches where the user put\n      // their finger down, but used another finger to tap the element again.\n      const touches = event.changedTouches as TouchList | undefined;\n\n      // According to the typings the touches should always be defined, but in some cases\n      // the browser appears to not assign them in tests which leads to flakes.\n      if (touches) {\n        for (let i = 0; i < touches.length; i++) {\n          this.fadeInRipple(touches[i].clientX, touches[i].clientY, this._target.rippleConfig);\n        }\n      }\n    }\n  }\n\n  /** Function being called whenever the trigger is being released. */\n  private _onPointerUp() {\n    if (!this._isPointerDown) {\n      return;\n    }\n\n    this._isPointerDown = false;\n\n    // Fade-out all ripples that are visible and not persistent.\n    this._getActiveRipples().forEach(ripple => {\n      // By default, only ripples that are completely visible will fade out on pointer release.\n      // If the `terminateOnPointerUp` option is set, ripples that still fade in will also fade out.\n      const isVisible =\n        ripple.state === RippleState.VISIBLE ||\n        (ripple.config.terminateOnPointerUp && ripple.state === RippleState.FADING_IN);\n\n      if (!ripple.config.persistent && isVisible) {\n        ripple.fadeOut();\n      }\n    });\n  }\n\n  private _getActiveRipples(): RippleRef[] {\n    return Array.from(this._activeRipples.keys());\n  }\n\n  /** Removes previously registered event listeners from the trigger element. */\n  _removeTriggerEvents() {\n    const trigger = this._triggerElement;\n\n    if (trigger) {\n      pointerDownEvents.forEach(type =>\n        RippleRenderer._eventManager.removeHandler(type, trigger, this),\n      );\n\n      if (this._pointerUpEventsRegistered) {\n        pointerUpEvents.forEach(type =>\n          trigger.removeEventListener(type, this, passiveCapturingEventOptions),\n        );\n\n        this._pointerUpEventsRegistered = false;\n      }\n    }\n  }\n}\n\n/**\n * Returns the distance from the point (x, y) to the furthest corner of a rectangle.\n */\nfunction distanceToFurthestCorner(x: number, y: number, rect: DOMRect) {\n  const distX = Math.max(Math.abs(x - rect.left), Math.abs(x - rect.right));\n  const distY = Math.max(Math.abs(y - rect.top), Math.abs(y - rect.bottom));\n  return Math.sqrt(distX * distX + distY * distY);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Platform} from '@angular/cdk/platform';\nimport {\n  Directive,\n  ElementRef,\n  InjectionToken,\n  Input,\n  NgZone,\n  OnDestroy,\n  OnInit,\n  Injector,\n  inject,\n} from '@angular/core';\nimport {_CdkPrivateStyleLoader} from '@angular/cdk/private';\nimport {RippleAnimationConfig, RippleConfig, RippleRef} from './ripple-ref';\nimport {RippleRenderer, RippleTarget} from './ripple-renderer';\nimport {_animationsDisabled} from '../animation/animation';\n\n/** Configurable options for `matRipple`. */\nexport interface RippleGlobalOptions {\n  /**\n   * Whether ripples should be disabled. Ripples can be still launched manually by using\n   * the `launch()` method. Therefore focus indicators will still show up.\n   */\n  disabled?: boolean;\n\n  /**\n   * Default configuration for the animation duration of the ripples. There are two phases with\n   * different durations for the ripples: `enter` and `leave`. The durations will be overwritten\n   * by the value of `matRippleAnimation` or if animations are disabled.\n   */\n  animation?: RippleAnimationConfig;\n\n  /**\n   * Whether ripples should start fading out immediately after the mouse or touch is released. By\n   * default, ripples will wait for the enter animation to complete and for mouse or touch release.\n   */\n  terminateOnPointerUp?: boolean;\n\n  /**\n   * A namespace to use for ripple loader to allow multiple instances to exist on the same page.\n   */\n  namespace?: string;\n}\n\n/** Injection token that can be used to specify the global ripple options. */\nexport const MAT_RIPPLE_GLOBAL_OPTIONS = new InjectionToken<RippleGlobalOptions>(\n  'mat-ripple-global-options',\n);\n\n@Directive({\n  selector: '[mat-ripple], [matRipple]',\n  exportAs: 'matRipple',\n  host: {\n    'class': 'mat-ripple',\n    '[class.mat-ripple-unbounded]': 'unbounded',\n  },\n})\nexport class MatRipple implements OnInit, OnDestroy, RippleTarget {\n  private _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  private _animationsDisabled = _animationsDisabled();\n\n  /** Custom color for all ripples. */\n  @Input('matRippleColor') color: string;\n\n  /** Whether the ripples should be visible outside the component's bounds. */\n  @Input('matRippleUnbounded') unbounded: boolean;\n\n  /**\n   * Whether the ripple always originates from the center of the host element's bounds, rather\n   * than originating from the location of the click event.\n   */\n  @Input('matRippleCentered') centered: boolean;\n\n  /**\n   * If set, the radius in pixels of foreground ripples when fully expanded. If unset, the radius\n   * will be the distance from the center of the ripple to the furthest corner of the host element's\n   * bounding rectangle.\n   */\n  @Input('matRippleRadius') radius: number = 0;\n\n  /**\n   * Configuration for the ripple animation. Allows modifying the enter and exit animation\n   * duration of the ripples. The animation durations will be overwritten if animations are\n   * disabled.\n   */\n  @Input('matRippleAnimation') animation: RippleAnimationConfig;\n\n  /**\n   * Whether click events will not trigger the ripple. Ripples can be still launched manually\n   * by using the `launch()` method.\n   */\n  @Input('matRippleDisabled')\n  get disabled() {\n    return this._disabled;\n  }\n  set disabled(value: boolean) {\n    if (value) {\n      this.fadeOutAllNonPersistent();\n    }\n    this._disabled = value;\n    this._setupTriggerEventsIfEnabled();\n  }\n  private _disabled: boolean = false;\n\n  /**\n   * The element that triggers the ripple when click events are received.\n   * Defaults to the directive's host element.\n   */\n  @Input('matRippleTrigger')\n  get trigger() {\n    return this._trigger || this._elementRef.nativeElement;\n  }\n  set trigger(trigger: HTMLElement) {\n    this._trigger = trigger;\n    this._setupTriggerEventsIfEnabled();\n  }\n  private _trigger: HTMLElement;\n\n  /** Renderer for the ripple DOM manipulations. */\n  private _rippleRenderer: RippleRenderer;\n\n  /** Options that are set globally for all ripples. */\n  private _globalOptions: RippleGlobalOptions;\n\n  /** @docs-private Whether ripple directive is initialized and the input bindings are set. */\n  _isInitialized: boolean = false;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const ngZone = inject(NgZone);\n    const platform = inject(Platform);\n    const globalOptions = inject<RippleGlobalOptions>(MAT_RIPPLE_GLOBAL_OPTIONS, {optional: true});\n    const injector = inject(Injector);\n\n    // Note: cannot use `inject()` here, because this class\n    // gets instantiated manually in the ripple loader.\n    this._globalOptions = globalOptions || {};\n    this._rippleRenderer = new RippleRenderer(this, ngZone, this._elementRef, platform, injector);\n  }\n\n  ngOnInit() {\n    this._isInitialized = true;\n    this._setupTriggerEventsIfEnabled();\n  }\n\n  ngOnDestroy() {\n    this._rippleRenderer._removeTriggerEvents();\n  }\n\n  /** Fades out all currently showing ripple elements. */\n  fadeOutAll() {\n    this._rippleRenderer.fadeOutAll();\n  }\n\n  /** Fades out all currently showing non-persistent ripple elements. */\n  fadeOutAllNonPersistent() {\n    this._rippleRenderer.fadeOutAllNonPersistent();\n  }\n\n  /**\n   * Ripple configuration from the directive's input values.\n   * @docs-private Implemented as part of RippleTarget\n   */\n  get rippleConfig(): RippleConfig {\n    return {\n      centered: this.centered,\n      radius: this.radius,\n      color: this.color,\n      animation: {\n        ...this._globalOptions.animation,\n        ...(this._animationsDisabled ? {enterDuration: 0, exitDuration: 0} : {}),\n        ...this.animation,\n      },\n      terminateOnPointerUp: this._globalOptions.terminateOnPointerUp,\n    };\n  }\n\n  /**\n   * Whether ripples on pointer-down are disabled or not.\n   * @docs-private Implemented as part of RippleTarget\n   */\n  get rippleDisabled(): boolean {\n    return this.disabled || !!this._globalOptions.disabled;\n  }\n\n  /** Sets up the trigger event listeners if ripples are enabled. */\n  private _setupTriggerEventsIfEnabled() {\n    if (!this.disabled && this._isInitialized) {\n      this._rippleRenderer.setupTriggerEvents(this.trigger);\n    }\n  }\n\n  /**\n   * Launches a manual ripple using the specified ripple configuration.\n   * @param config Configuration for the manual ripple.\n   */\n  launch(config: RippleConfig): RippleRef;\n\n  /**\n   * Launches a manual ripple at the specified coordinates relative to the viewport.\n   * @param x Coordinate along the X axis at which to fade-in the ripple. Coordinate\n   *   should be relative to the viewport.\n   * @param y Coordinate along the Y axis at which to fade-in the ripple. Coordinate\n   *   should be relative to the viewport.\n   * @param config Optional ripple configuration for the manual ripple.\n   */\n  launch(x: number, y: number, config?: RippleConfig): RippleRef;\n\n  /** Launches a manual ripple at the specified coordinated or just by the ripple config. */\n  launch(configOrX: number | RippleConfig, y: number = 0, config?: RippleConfig): RippleRef {\n    if (typeof configOrX === 'number') {\n      return this._rippleRenderer.fadeInRipple(configOrX, y, {...this.rippleConfig, ...config});\n    } else {\n      return this._rippleRenderer.fadeInRipple(0, 0, {...this.rippleConfig, ...configOrX});\n    }\n  }\n}\n"],"names":["RippleState","RippleRef","_renderer","element","RippleEventManager","name","handler","_events","get","handlersForEvent","handlersForElement","add","set","Set","Map","addEventListener","_delegateEventHandler","passiveCapturingEventOptions","removeHandler","delete","size","defaultRippleAnimationConfig","enterDuration","ignoreMouseEventsTimeout","normalizePassiveListenerOptions","passive","pointerDownEvents","ɵcmp","i0","ɵɵngDeclareComponent","minVersion","version","type","_MatRippleStylesLoader","isStandalone","selector","host","attributes","ngImport","template","isInline","styles","changeDetection","ChangeDetectionStrategy","OnPush","encapsulation","ViewEncapsulation","None","ɵɵngDeclareClassMetadata","decorators","Component","args","_isPointerDown","_activeRipples","_containerRect","constructor","_target","_ngZone","elementOrElementRef","_platform","injector","_containerElement","coerceElement","_CdkPrivateStyleLoader","load","radius","config","distanceToFurthestCorner","offsetX","x","containerRect","left","offsetY","y","top","animationConfig","document","createElement","color","backgroundColor","transitionDuration","appendChild","ripple","computedStyles","window","getComputedStyle","transitionProperty","userTransitionDuration","animationForciblyDisabledThroughCss","userTransitionProperty","width","height","rippleRef","state","FADING_IN","persistent","eventListeners","exitDuration","runOutsideAngular","onTransitionEnd","clearTimeout","fallbackTimer","_finishRippleTransition","onTransitionCancel","_destroyRipple","setTimeout","FADING_OUT","HIDDEN","rippleEl","animation","style","opacity","_getActiveRipples","forEach","fadeOut","fadeOutAllNonPersistent","setupTriggerEvents","isBrowser","_triggerElement","RippleRenderer","_eventManager","addHandler","handleEvent","event","_onMousedown","_onPointerUp","_pointerUpEventsRegistered","pointerUpEvents","isMostRecentTransientRipple","_mostRecentTransientRipple","MAT_RIPPLE_GLOBAL_OPTIONS","InjectionToken","MatRipple","inject","ElementRef","centered","_disabled","_trigger","_elementRef","nativeElement","platform","Platform","_globalOptions","globalOptions","_rippleRenderer","ngZone","ngOnInit","_removeTriggerEvents","ctorParameters","propDecorators","Input"],"mappings":"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"}