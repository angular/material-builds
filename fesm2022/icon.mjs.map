{"version":3,"file":"icon.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/icon/icon.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/icon/icon-module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  AfterViewChecked,\n  booleanAttribute,\n  ChangeDetectionStrategy,\n  Component,\n  ElementRef,\n  ErrorHandler,\n  inject,\n  InjectionToken,\n  Input,\n  OnDestroy,\n  OnInit,\n  ViewEncapsulation,\n  HostAttributeToken,\n  DOCUMENT,\n} from '@angular/core';\nimport {ThemePalette} from '../core';\nimport {Subscription} from 'rxjs';\nimport {take} from 'rxjs/operators';\n\nimport {MatIconRegistry} from './icon-registry';\n\n/** Default options for `mat-icon`.  */\nexport interface MatIconDefaultOptions {\n  /**\n   * Theme color of the icon. This API is supported in M2 themes only, it\n   * has no effect in M3 themes. For color customization in M3, see https://material.angular.dev/components/icon/styling.\n   *\n   * For information on applying color variants in M3, see\n   * https://material.angular.dev/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n   */\n  color?: ThemePalette;\n  /** Font set that the icon is a part of. */\n  fontSet?: string;\n}\n\n/** Injection token to be used to override the default options for `mat-icon`. */\nexport const MAT_ICON_DEFAULT_OPTIONS = new InjectionToken<MatIconDefaultOptions>(\n  'MAT_ICON_DEFAULT_OPTIONS',\n);\n\n/**\n * Injection token used to provide the current location to `MatIcon`.\n * Used to handle server-side rendering and to stub out during unit tests.\n * @docs-private\n */\nexport const MAT_ICON_LOCATION = new InjectionToken<MatIconLocation>('mat-icon-location', {\n  providedIn: 'root',\n  factory: () => {\n    const _document = inject(DOCUMENT);\n    const _location = _document ? _document.location : null;\n\n    return {\n      // Note that this needs to be a function, rather than a property, because Angular\n      // will only resolve it once, but we want the current path on each call.\n      getPathname: () => (_location ? _location.pathname + _location.search : ''),\n    };\n  },\n});\n\n/**\n * Stubbed out location for `MatIcon`.\n * @docs-private\n */\nexport interface MatIconLocation {\n  getPathname: () => string;\n}\n\n/** SVG attributes that accept a FuncIRI (e.g. `url(<something>)`). */\nconst funcIriAttributes = [\n  'clip-path',\n  'color-profile',\n  'src',\n  'cursor',\n  'fill',\n  'filter',\n  'marker',\n  'marker-start',\n  'marker-mid',\n  'marker-end',\n  'mask',\n  'stroke',\n];\n\n/** Selector that can be used to find all elements that are using a `FuncIRI`. */\nconst funcIriAttributeSelector = funcIriAttributes.map(attr => `[${attr}]`).join(', ');\n\n/** Regex that can be used to extract the id out of a FuncIRI. */\nconst funcIriPattern = /^url\\(['\"]?#(.*?)['\"]?\\)$/;\n\n/**\n * Component to display an icon. It can be used in the following ways:\n *\n * - Specify the svgIcon input to load an SVG icon from a URL previously registered with the\n *   addSvgIcon, addSvgIconInNamespace, addSvgIconSet, or addSvgIconSetInNamespace methods of\n *   MatIconRegistry. If the svgIcon value contains a colon it is assumed to be in the format\n *   \"[namespace]:[name]\", if not the value will be the name of an icon in the default namespace.\n *   Examples:\n *     `<mat-icon svgIcon=\"left-arrow\"></mat-icon>\n *     <mat-icon svgIcon=\"animals:cat\"></mat-icon>`\n *\n * - Use a font ligature as an icon by putting the ligature text in the `fontIcon` attribute or the\n *   content of the `<mat-icon>` component. If you register a custom font class, don't forget to also\n *   include the special class `mat-ligature-font`. It is recommended to use the attribute alternative\n *   to prevent the ligature text to be selectable and to appear in search engine results.\n *   By default, the Material icons font is used as described at\n *   http://google.github.io/material-design-icons/#icon-font-for-the-web. You can specify an\n *   alternate font by setting the fontSet input to either the CSS class to apply to use the\n *   desired font, or to an alias previously registered with MatIconRegistry.registerFontClassAlias.\n *   Examples:\n *     `<mat-icon fontIcon=\"home\"></mat-icon>\n *     <mat-icon>home</mat-icon>\n *     <mat-icon fontSet=\"myfont\" fontIcon=\"sun\"></mat-icon>\n *     <mat-icon fontSet=\"myfont\">sun</mat-icon>`\n *\n * - Specify a font glyph to be included via CSS rules by setting the fontSet input to specify the\n *   font, and the fontIcon input to specify the icon. Typically the fontIcon will specify a\n *   CSS class which causes the glyph to be displayed via a :before selector, as in\n *   https://fontawesome-v4.github.io/examples/\n *   Example:\n *     `<mat-icon fontSet=\"fa\" fontIcon=\"alarm\"></mat-icon>`\n */\n@Component({\n  template: '<ng-content></ng-content>',\n  selector: 'mat-icon',\n  exportAs: 'matIcon',\n  styleUrl: 'icon.css',\n  host: {\n    'role': 'img',\n    'class': 'mat-icon notranslate',\n    '[class]': 'color ? \"mat-\" + color : \"\"',\n    '[attr.data-mat-icon-type]': '_usingFontIcon() ? \"font\" : \"svg\"',\n    '[attr.data-mat-icon-name]': '_svgName || fontIcon',\n    '[attr.data-mat-icon-namespace]': '_svgNamespace || fontSet',\n    '[attr.fontIcon]': '_usingFontIcon() ? fontIcon : null',\n    '[class.mat-icon-inline]': 'inline',\n    '[class.mat-icon-no-color]': 'color !== \"primary\" && color !== \"accent\" && color !== \"warn\"',\n  },\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class MatIcon implements OnInit, AfterViewChecked, OnDestroy {\n  readonly _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  private _iconRegistry = inject(MatIconRegistry);\n  private _location = inject<MatIconLocation>(MAT_ICON_LOCATION);\n  private readonly _errorHandler = inject(ErrorHandler);\n  private _defaultColor: ThemePalette;\n\n  /**\n   * Theme color of the icon. This API is supported in M2 themes only, it\n   * has no effect in M3 themes. For color customization in M3, see https://material.angular.dev/components/icon/styling.\n   *\n   * For information on applying color variants in M3, see\n   * https://material.angular.dev/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n   */\n  @Input()\n  get color() {\n    return this._color || this._defaultColor;\n  }\n  set color(value: string | null | undefined) {\n    this._color = value;\n  }\n  private _color: string | null | undefined;\n\n  /**\n   * Whether the icon should be inlined, automatically sizing the icon to match the font size of\n   * the element the icon is contained in.\n   */\n  @Input({transform: booleanAttribute})\n  inline: boolean = false;\n\n  /** Name of the icon in the SVG icon set. */\n  @Input()\n  get svgIcon(): string {\n    return this._svgIcon;\n  }\n  set svgIcon(value: string) {\n    if (value !== this._svgIcon) {\n      if (value) {\n        this._updateSvgIcon(value);\n      } else if (this._svgIcon) {\n        this._clearSvgElement();\n      }\n      this._svgIcon = value;\n    }\n  }\n  private _svgIcon: string;\n\n  /** Font set that the icon is a part of. */\n  @Input()\n  get fontSet(): string {\n    return this._fontSet;\n  }\n  set fontSet(value: string) {\n    const newValue = this._cleanupFontValue(value);\n\n    if (newValue !== this._fontSet) {\n      this._fontSet = newValue;\n      this._updateFontIconClasses();\n    }\n  }\n  private _fontSet: string;\n\n  /** Name of an icon within a font set. */\n  @Input()\n  get fontIcon(): string {\n    return this._fontIcon;\n  }\n  set fontIcon(value: string) {\n    const newValue = this._cleanupFontValue(value);\n\n    if (newValue !== this._fontIcon) {\n      this._fontIcon = newValue;\n      this._updateFontIconClasses();\n    }\n  }\n  private _fontIcon: string;\n\n  private _previousFontSetClass: string[] = [];\n  private _previousFontIconClass: string;\n\n  _svgName: string | null;\n  _svgNamespace: string | null;\n\n  /** Keeps track of the current page path. */\n  private _previousPath?: string;\n\n  /** Keeps track of the elements and attributes that we've prefixed with the current path. */\n  private _elementsWithExternalReferences?: Map<Element, {name: string; value: string}[]>;\n\n  /** Subscription to the current in-progress SVG icon request. */\n  private _currentIconFetch = Subscription.EMPTY;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const ariaHidden = inject(new HostAttributeToken('aria-hidden'), {optional: true});\n    const defaults = inject<MatIconDefaultOptions>(MAT_ICON_DEFAULT_OPTIONS, {optional: true});\n\n    if (defaults) {\n      if (defaults.color) {\n        this.color = this._defaultColor = defaults.color;\n      }\n\n      if (defaults.fontSet) {\n        this.fontSet = defaults.fontSet;\n      }\n    }\n\n    // If the user has not explicitly set aria-hidden, mark the icon as hidden, as this is\n    // the right thing to do for the majority of icon use-cases.\n    if (!ariaHidden) {\n      this._elementRef.nativeElement.setAttribute('aria-hidden', 'true');\n    }\n  }\n\n  /**\n   * Splits an svgIcon binding value into its icon set and icon name components.\n   * Returns a 2-element array of [(icon set), (icon name)].\n   * The separator for the two fields is ':'. If there is no separator, an empty\n   * string is returned for the icon set and the entire value is returned for\n   * the icon name. If the argument is falsy, returns an array of two empty strings.\n   * Throws an error if the name contains two or more ':' separators.\n   * Examples:\n   *   `'social:cake' -> ['social', 'cake']\n   *   'penguin' -> ['', 'penguin']\n   *   null -> ['', '']\n   *   'a:b:c' -> (throws Error)`\n   */\n  private _splitIconName(iconName: string): [string, string] {\n    if (!iconName) {\n      return ['', ''];\n    }\n    const parts = iconName.split(':');\n    switch (parts.length) {\n      case 1:\n        return ['', parts[0]]; // Use default namespace.\n      case 2:\n        return <[string, string]>parts;\n      default:\n        throw Error(`Invalid icon name: \"${iconName}\"`); // TODO: add an ngDevMode check\n    }\n  }\n\n  ngOnInit() {\n    // Update font classes because ngOnChanges won't be called if none of the inputs are present,\n    // e.g. <mat-icon>arrow</mat-icon> In this case we need to add a CSS class for the default font.\n    this._updateFontIconClasses();\n  }\n\n  ngAfterViewChecked() {\n    const cachedElements = this._elementsWithExternalReferences;\n\n    if (cachedElements && cachedElements.size) {\n      const newPath = this._location.getPathname();\n\n      // We need to check whether the URL has changed on each change detection since\n      // the browser doesn't have an API that will let us react on link clicks and\n      // we can't depend on the Angular router. The references need to be updated,\n      // because while most browsers don't care whether the URL is correct after\n      // the first render, Safari will break if the user navigates to a different\n      // page and the SVG isn't re-rendered.\n      if (newPath !== this._previousPath) {\n        this._previousPath = newPath;\n        this._prependPathToReferences(newPath);\n      }\n    }\n  }\n\n  ngOnDestroy() {\n    this._currentIconFetch.unsubscribe();\n\n    if (this._elementsWithExternalReferences) {\n      this._elementsWithExternalReferences.clear();\n    }\n  }\n\n  _usingFontIcon(): boolean {\n    return !this.svgIcon;\n  }\n\n  private _setSvgElement(svg: SVGElement) {\n    this._clearSvgElement();\n\n    // Note: we do this fix here, rather than the icon registry, because the\n    // references have to point to the URL at the time that the icon was created.\n    const path = this._location.getPathname();\n    this._previousPath = path;\n    this._cacheChildrenWithExternalReferences(svg);\n    this._prependPathToReferences(path);\n    this._elementRef.nativeElement.appendChild(svg);\n  }\n\n  private _clearSvgElement() {\n    const layoutElement: HTMLElement = this._elementRef.nativeElement;\n    let childCount = layoutElement.childNodes.length;\n\n    if (this._elementsWithExternalReferences) {\n      this._elementsWithExternalReferences.clear();\n    }\n\n    // Remove existing non-element child nodes and SVGs, and add the new SVG element. Note that\n    // we can't use innerHTML, because IE will throw if the element has a data binding.\n    while (childCount--) {\n      const child = layoutElement.childNodes[childCount];\n\n      // 1 corresponds to Node.ELEMENT_NODE. We remove all non-element nodes in order to get rid\n      // of any loose text nodes, as well as any SVG elements in order to remove any old icons.\n      if (child.nodeType !== 1 || child.nodeName.toLowerCase() === 'svg') {\n        child.remove();\n      }\n    }\n  }\n\n  private _updateFontIconClasses() {\n    if (!this._usingFontIcon()) {\n      return;\n    }\n\n    const elem: HTMLElement = this._elementRef.nativeElement;\n    const fontSetClasses = (\n      this.fontSet\n        ? this._iconRegistry.classNameForFontAlias(this.fontSet).split(/ +/)\n        : this._iconRegistry.getDefaultFontSetClass()\n    ).filter(className => className.length > 0);\n\n    this._previousFontSetClass.forEach(className => elem.classList.remove(className));\n    fontSetClasses.forEach(className => elem.classList.add(className));\n    this._previousFontSetClass = fontSetClasses;\n\n    if (\n      this.fontIcon !== this._previousFontIconClass &&\n      !fontSetClasses.includes('mat-ligature-font')\n    ) {\n      if (this._previousFontIconClass) {\n        elem.classList.remove(this._previousFontIconClass);\n      }\n      if (this.fontIcon) {\n        elem.classList.add(this.fontIcon);\n      }\n      this._previousFontIconClass = this.fontIcon;\n    }\n  }\n\n  /**\n   * Cleans up a value to be used as a fontIcon or fontSet.\n   * Since the value ends up being assigned as a CSS class, we\n   * have to trim the value and omit space-separated values.\n   */\n  private _cleanupFontValue(value: string) {\n    return typeof value === 'string' ? value.trim().split(' ')[0] : value;\n  }\n\n  /**\n   * Prepends the current path to all elements that have an attribute pointing to a `FuncIRI`\n   * reference. This is required because WebKit browsers require references to be prefixed with\n   * the current path, if the page has a `base` tag.\n   */\n  private _prependPathToReferences(path: string) {\n    const elements = this._elementsWithExternalReferences;\n\n    if (elements) {\n      elements.forEach((attrs, element) => {\n        attrs.forEach(attr => {\n          element.setAttribute(attr.name, `url('${path}#${attr.value}')`);\n        });\n      });\n    }\n  }\n\n  /**\n   * Caches the children of an SVG element that have `url()`\n   * references that we need to prefix with the current path.\n   */\n  private _cacheChildrenWithExternalReferences(element: SVGElement) {\n    const elementsWithFuncIri = element.querySelectorAll(funcIriAttributeSelector);\n    const elements = (this._elementsWithExternalReferences =\n      this._elementsWithExternalReferences || new Map());\n\n    for (let i = 0; i < elementsWithFuncIri.length; i++) {\n      funcIriAttributes.forEach(attr => {\n        const elementWithReference = elementsWithFuncIri[i];\n        const value = elementWithReference.getAttribute(attr);\n        const match = value ? value.match(funcIriPattern) : null;\n\n        if (match) {\n          let attributes = elements.get(elementWithReference);\n\n          if (!attributes) {\n            attributes = [];\n            elements.set(elementWithReference, attributes);\n          }\n\n          attributes!.push({name: attr, value: match[1]});\n        }\n      });\n    }\n  }\n\n  /** Sets a new SVG icon with a particular name. */\n  private _updateSvgIcon(rawName: string | undefined) {\n    this._svgNamespace = null;\n    this._svgName = null;\n    this._currentIconFetch.unsubscribe();\n\n    if (rawName) {\n      const [namespace, iconName] = this._splitIconName(rawName);\n\n      if (namespace) {\n        this._svgNamespace = namespace;\n      }\n\n      if (iconName) {\n        this._svgName = iconName;\n      }\n\n      this._currentIconFetch = this._iconRegistry\n        .getNamedSvgIcon(iconName, namespace)\n        .pipe(take(1))\n        .subscribe(\n          svg => this._setSvgElement(svg),\n          (err: Error) => {\n            const errorMessage = `Error retrieving icon ${namespace}:${iconName}! ${err.message}`;\n            this._errorHandler.handleError(new Error(errorMessage));\n          },\n        );\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {BidiModule} from '@angular/cdk/bidi';\nimport {NgModule} from '@angular/core';\nimport {MatIcon} from './icon';\n\n@NgModule({\n  imports: [MatIcon],\n  exports: [MatIcon, BidiModule],\n})\nexport class MatIconModule {}\n"],"names":["MAT_ICON_DEFAULT_OPTIONS","InjectionToken","funcIriPattern","_updateSvgIcon","value","_svgIcon","_fontSet","newValue","_updateFontIconClasses","_fontIcon","_elementsWithExternalReferences","_currentIconFetch","Subscription","EMPTY","constructor","optional","defaults","inject","color","_defaultColor","fontSet","ariaHidden","_elementRef","nativeElement","setAttribute","parts","Error","iconName","cachedElements","size","newPath","_location","getPathname","_previousPath","_prependPathToReferences","unsubscribe","_usingFontIcon","svgIcon","_setSvgElement","svg","_clearSvgElement","path","appendChild","layoutElement","childCount","childNodes","length","clear","child","nodeType","nodeName","toLowerCase","remove","getDefaultFontSetClass","filter","className","forEach","elem","classList","_previousFontIconClass","includes","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","styles","ctorParameters","propDecorators","transform","booleanAttribute","Input","ɵmod","i0","ɵɵngDeclareNgModule","minVersion","version","ngImport","type","MatIconModule","imports","MatIcon","exports","BidiModule","decorators"],"mappings":"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"}