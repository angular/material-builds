{"version":3,"file":"timepicker.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/timepicker/util.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/timepicker/timepicker.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/timepicker/timepicker-input.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/timepicker/timepicker-toggle.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/timepicker/timepicker-module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken} from '@angular/core';\nimport {DateAdapter, MatDateFormats} from '../core';\n\n/** Pattern that interval strings have to match. */\nconst INTERVAL_PATTERN = /^(\\d*\\.?\\d+)\\s*(h|hour|hours|m|min|minute|minutes|s|second|seconds)?$/i;\n\n/**\n * Object that can be used to configure the default options for the timepicker component.\n */\nexport interface MatTimepickerConfig {\n  /** Default interval for all time pickers. */\n  interval?: string | number;\n\n  /** Whether ripples inside the timepicker should be disabled by default. */\n  disableRipple?: boolean;\n}\n\n/**\n * Injection token that can be used to configure the default options for the timepicker component.\n */\nexport const MAT_TIMEPICKER_CONFIG = new InjectionToken<MatTimepickerConfig>(\n  'MAT_TIMEPICKER_CONFIG',\n);\n\n/**\n * Time selection option that can be displayed within a `mat-timepicker`.\n */\nexport interface MatTimepickerOption<D = unknown> {\n  /** Date value of the option. */\n  value: D;\n\n  /** Label to show to the user. */\n  label: string;\n}\n\n/** Parses an interval value into seconds. */\nexport function parseInterval(value: number | string | null): number | null {\n  let result: number;\n\n  if (value === null) {\n    return null;\n  } else if (typeof value === 'number') {\n    result = value;\n  } else {\n    if (value.trim().length === 0) {\n      return null;\n    }\n\n    const parsed = value.match(INTERVAL_PATTERN);\n    const amount = parsed ? parseFloat(parsed[1]) : null;\n    const unit = parsed?.[2]?.toLowerCase() || null;\n\n    if (!parsed || amount === null || isNaN(amount)) {\n      return null;\n    }\n\n    if (unit === 'h' || unit === 'hour' || unit === 'hours') {\n      result = amount * 3600;\n    } else if (unit === 'm' || unit === 'min' || unit === 'minute' || unit === 'minutes') {\n      result = amount * 60;\n    } else {\n      result = amount;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Generates the options to show in a timepicker.\n * @param adapter Date adapter to be used to generate the options.\n * @param formats Formatting config to use when displaying the options.\n * @param min Time from which to start generating the options.\n * @param max Time at which to stop generating the options.\n * @param interval Amount of seconds between each option.\n */\nexport function generateOptions<D>(\n  adapter: DateAdapter<D>,\n  formats: MatDateFormats,\n  min: D,\n  max: D,\n  interval: number,\n): MatTimepickerOption<D>[] {\n  const options: MatTimepickerOption<D>[] = [];\n  let current = adapter.compareTime(min, max) < 1 ? min : max;\n\n  while (\n    adapter.sameDate(current, min) &&\n    adapter.compareTime(current, max) < 1 &&\n    adapter.isValid(current)\n  ) {\n    options.push({value: current, label: adapter.format(current, formats.display.timeOptionLabel)});\n    current = adapter.addSeconds(current, interval);\n  }\n\n  return options;\n}\n\n/** Checks whether a date adapter is set up correctly for use with the timepicker. */\nexport function validateAdapter(\n  adapter: DateAdapter<unknown> | null,\n  formats: MatDateFormats | null,\n) {\n  function missingAdapterError(provider: string) {\n    return Error(\n      `MatTimepicker: No provider found for ${provider}. You must add one of the following ` +\n        `to your app config: provideNativeDateAdapter, provideDateFnsAdapter, ` +\n        `provideLuxonDateAdapter, provideMomentDateAdapter, or provide a custom implementation.`,\n    );\n  }\n\n  if (!adapter) {\n    throw missingAdapterError('DateAdapter');\n  }\n\n  if (!formats) {\n    throw missingAdapterError('MAT_DATE_FORMATS');\n  }\n\n  if (\n    formats.display.timeInput === undefined ||\n    formats.display.timeOptionLabel === undefined ||\n    formats.parse.timeInput === undefined\n  ) {\n    throw new Error(\n      'MatTimepicker: Incomplete `MAT_DATE_FORMATS` has been provided. ' +\n        '`MAT_DATE_FORMATS` must provide `display.timeInput`, `display.timeOptionLabel` ' +\n        'and `parse.timeInput` formats in order to be compatible with MatTimepicker.',\n    );\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  afterNextRender,\n  AfterRenderRef,\n  booleanAttribute,\n  ChangeDetectionStrategy,\n  Component,\n  computed,\n  effect,\n  ElementRef,\n  inject,\n  InjectionToken,\n  Injector,\n  input,\n  InputSignal,\n  InputSignalWithTransform,\n  OnDestroy,\n  output,\n  OutputEmitterRef,\n  Signal,\n  signal,\n  TemplateRef,\n  untracked,\n  viewChild,\n  viewChildren,\n  ViewContainerRef,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {\n  _animationsDisabled,\n  DateAdapter,\n  MAT_DATE_FORMATS,\n  MAT_OPTION_PARENT_COMPONENT,\n  MatOption,\n  MatOptionParentComponent,\n} from '../core';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {\n  createFlexibleConnectedPositionStrategy,\n  createOverlayRef,\n  createRepositionScrollStrategy,\n  OverlayRef,\n  ScrollStrategy,\n} from '@angular/cdk/overlay';\nimport {TemplatePortal} from '@angular/cdk/portal';\nimport {_getEventTarget} from '@angular/cdk/platform';\nimport {ENTER, ESCAPE, hasModifierKey, TAB} from '@angular/cdk/keycodes';\nimport {_IdGenerator, ActiveDescendantKeyManager} from '@angular/cdk/a11y';\nimport {\n  generateOptions,\n  MAT_TIMEPICKER_CONFIG,\n  MatTimepickerOption,\n  parseInterval,\n  validateAdapter,\n} from './util';\nimport {Subscription} from 'rxjs';\n\n/** Event emitted when a value is selected in the timepicker. */\nexport interface MatTimepickerSelected<D> {\n  value: D;\n  source: MatTimepicker<D>;\n}\n\n/** Injection token used to configure the behavior of the timepicker dropdown while scrolling. */\nexport const MAT_TIMEPICKER_SCROLL_STRATEGY = new InjectionToken<() => ScrollStrategy>(\n  'MAT_TIMEPICKER_SCROLL_STRATEGY',\n  {\n    providedIn: 'root',\n    factory: () => {\n      const injector = inject(Injector);\n      return () => createRepositionScrollStrategy(injector);\n    },\n  },\n);\n\n/** Represents an input that is connected to a `mat-timepicker`. */\nexport interface MatTimepickerConnectedInput<D> {\n  /** Current value of the input. */\n  value: Signal<D | null>;\n\n  /** Minimum allowed time. */\n  min: Signal<D | null>;\n\n  /** Maximum allowed time. */\n  max: Signal<D | null>;\n\n  /** Whether the input is disabled. */\n  disabled: Signal<boolean>;\n\n  /** Focuses the input. */\n  focus(): void;\n\n  /** Gets the element to which to connect the timepicker overlay. */\n  getOverlayOrigin(): ElementRef<HTMLElement>;\n\n  /** Gets the ID of the input's label. */\n  getLabelId(): string | null;\n\n  /** Callback invoked when the timepicker assigns a value. */\n  timepickerValueAssigned(value: D | null): void;\n}\n\n/**\n * Renders out a listbox that can be used to select a time of day.\n * Intended to be used together with `MatTimepickerInput`.\n */\n@Component({\n  selector: 'mat-timepicker',\n  exportAs: 'matTimepicker',\n  templateUrl: 'timepicker.html',\n  styleUrl: 'timepicker.css',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  imports: [MatOption],\n  providers: [\n    {\n      provide: MAT_OPTION_PARENT_COMPONENT,\n      useExisting: MatTimepicker,\n    },\n  ],\n})\nexport class MatTimepicker<D> implements OnDestroy, MatOptionParentComponent {\n  private _dir = inject(Directionality, {optional: true});\n  private _viewContainerRef = inject(ViewContainerRef);\n  private _injector = inject(Injector);\n  private _defaultConfig = inject(MAT_TIMEPICKER_CONFIG, {optional: true});\n  private _dateAdapter = inject<DateAdapter<D>>(DateAdapter, {optional: true})!;\n  private _dateFormats = inject(MAT_DATE_FORMATS, {optional: true})!;\n  private _scrollStrategyFactory = inject(MAT_TIMEPICKER_SCROLL_STRATEGY);\n  protected _animationsDisabled = _animationsDisabled();\n\n  private _isOpen = signal(false);\n  private _activeDescendant = signal<string | null>(null);\n\n  private _input = signal<MatTimepickerConnectedInput<D> | null>(null);\n  private _overlayRef: OverlayRef | null = null;\n  private _portal: TemplatePortal<unknown> | null = null;\n  private _optionsCacheKey: string | null = null;\n  private _localeChanges: Subscription;\n  private _onOpenRender: AfterRenderRef | null = null;\n\n  protected _panelTemplate = viewChild.required<TemplateRef<unknown>>('panelTemplate');\n  protected _timeOptions: readonly MatTimepickerOption<D>[] = [];\n  protected _options = viewChildren(MatOption);\n\n  private _keyManager = new ActiveDescendantKeyManager(this._options, this._injector)\n    .withHomeAndEnd(true)\n    .withPageUpDown(true)\n    .withVerticalOrientation(true);\n\n  /**\n   * Interval between each option in the timepicker. The value can either be an amount of\n   * seconds (e.g. 90) or a number with a unit (e.g. 45m). Supported units are `s` for seconds,\n   * `m` for minutes or `h` for hours.\n   */\n  readonly interval: InputSignalWithTransform<number | null, number | string | null> = input(\n    parseInterval(this._defaultConfig?.interval || null),\n    {transform: parseInterval},\n  );\n\n  /**\n   * Array of pre-defined options that the user can select from, as an alternative to using the\n   * `interval` input. An error will be thrown if both `options` and `interval` are specified.\n   */\n  readonly options: InputSignal<readonly MatTimepickerOption<D>[] | null> = input<\n    readonly MatTimepickerOption<D>[] | null\n  >(null);\n\n  /** Whether the timepicker is open. */\n  readonly isOpen: Signal<boolean> = this._isOpen.asReadonly();\n\n  /** Emits when the user selects a time. */\n  readonly selected: OutputEmitterRef<MatTimepickerSelected<D>> = output();\n\n  /** Emits when the timepicker is opened. */\n  readonly opened: OutputEmitterRef<void> = output();\n\n  /** Emits when the timepicker is closed. */\n  readonly closed: OutputEmitterRef<void> = output();\n\n  /** ID of the active descendant option. */\n  readonly activeDescendant: Signal<string | null> = this._activeDescendant.asReadonly();\n\n  /** Unique ID of the timepicker's panel */\n  readonly panelId: string = inject(_IdGenerator).getId('mat-timepicker-panel-');\n\n  /** Whether ripples within the timepicker should be disabled. */\n  readonly disableRipple: InputSignalWithTransform<boolean, unknown> = input(\n    this._defaultConfig?.disableRipple ?? false,\n    {\n      transform: booleanAttribute,\n    },\n  );\n\n  /** ARIA label for the timepicker panel. */\n  readonly ariaLabel: InputSignal<string | null> = input<string | null>(null, {\n    alias: 'aria-label',\n  });\n\n  /** ID of the label element for the timepicker panel. */\n  readonly ariaLabelledby: InputSignal<string | null> = input<string | null>(null, {\n    alias: 'aria-labelledby',\n  });\n\n  /** Whether the timepicker is currently disabled. */\n  readonly disabled: Signal<boolean> = computed(() => !!this._input()?.disabled());\n\n  constructor() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      validateAdapter(this._dateAdapter, this._dateFormats);\n\n      effect(() => {\n        const options = this.options();\n        const interval = this.interval();\n\n        if (options !== null && interval !== null) {\n          throw new Error(\n            'Cannot specify both the `options` and `interval` inputs at the same time',\n          );\n        } else if (options?.length === 0) {\n          throw new Error('Value of `options` input cannot be an empty array');\n        }\n      });\n    }\n\n    // Since the panel ID is static, we can set it once without having to maintain a host binding.\n    const element = inject<ElementRef<HTMLElement>>(ElementRef);\n    element.nativeElement.setAttribute('mat-timepicker-panel-id', this.panelId);\n    this._handleLocaleChanges();\n    this._handleInputStateChanges();\n    this._keyManager.change.subscribe(() =>\n      this._activeDescendant.set(this._keyManager.activeItem?.id || null),\n    );\n  }\n\n  /** Opens the timepicker. */\n  open(): void {\n    const input = this._input();\n\n    if (!input) {\n      return;\n    }\n\n    // Focus should already be on the input, but this call is in case the timepicker is opened\n    // programmatically. We need to call this even if the timepicker is already open, because\n    // the user might be clicking the toggle.\n    input.focus();\n\n    if (this._isOpen()) {\n      return;\n    }\n\n    this._isOpen.set(true);\n    this._generateOptions();\n    const overlayRef = this._getOverlayRef();\n    overlayRef.updateSize({width: input.getOverlayOrigin().nativeElement.offsetWidth});\n    this._portal ??= new TemplatePortal(this._panelTemplate(), this._viewContainerRef);\n\n    // We need to check this in case `isOpen` was flipped, but change detection hasn't\n    // had a chance to run yet. See https://github.com/angular/components/issues/30637\n    if (!overlayRef.hasAttached()) {\n      overlayRef.attach(this._portal);\n    }\n\n    this._onOpenRender?.destroy();\n    this._onOpenRender = afterNextRender(\n      () => {\n        const options = this._options();\n        this._syncSelectedState(input.value(), options, options[0]);\n        this._onOpenRender = null;\n      },\n      {injector: this._injector},\n    );\n\n    this.opened.emit();\n  }\n\n  /** Closes the timepicker. */\n  close(): void {\n    if (this._isOpen()) {\n      this._isOpen.set(false);\n      this.closed.emit();\n\n      if (this._animationsDisabled) {\n        this._overlayRef?.detach();\n      }\n    }\n  }\n\n  /** Registers an input with the timepicker. */\n  registerInput(input: MatTimepickerConnectedInput<D>): void {\n    const currentInput = this._input();\n\n    if (currentInput && input !== currentInput && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw new Error('MatTimepicker can only be registered with one input at a time');\n    }\n\n    this._input.set(input);\n  }\n\n  ngOnDestroy(): void {\n    this._keyManager.destroy();\n    this._localeChanges.unsubscribe();\n    this._onOpenRender?.destroy();\n    this._overlayRef?.dispose();\n  }\n\n  /** Selects a specific time value. */\n  protected _selectValue(option: MatOption<D>) {\n    this.close();\n    this._keyManager.setActiveItem(option);\n    this._options().forEach(current => {\n      // This is primarily here so we don't show two selected options while animating away.\n      if (current !== option) {\n        current.deselect(false);\n      }\n    });\n    // Notify the input first so it can sync up the form control before emitting to `selected`.\n    this._input()?.timepickerValueAssigned(option.value);\n    this.selected.emit({value: option.value, source: this});\n    this._input()?.focus();\n  }\n\n  /** Gets the value of the `aria-labelledby` attribute. */\n  protected _getAriaLabelledby(): string | null {\n    if (this.ariaLabel()) {\n      return null;\n    }\n    return this.ariaLabelledby() || this._input()?.getLabelId() || null;\n  }\n\n  /** Handles animation events coming from the panel. */\n  protected _handleAnimationEnd(event: AnimationEvent) {\n    if (event.animationName === '_mat-timepicker-exit') {\n      this._overlayRef?.detach();\n    }\n  }\n\n  /** Creates an overlay reference for the timepicker panel. */\n  private _getOverlayRef(): OverlayRef {\n    if (this._overlayRef) {\n      return this._overlayRef;\n    }\n\n    const positionStrategy = createFlexibleConnectedPositionStrategy(\n      this._injector,\n      this._input()!.getOverlayOrigin(),\n    )\n      .withFlexibleDimensions(false)\n      .withPush(false)\n      .withTransformOriginOn('.mat-timepicker-panel')\n      .withPositions([\n        {\n          originX: 'start',\n          originY: 'bottom',\n          overlayX: 'start',\n          overlayY: 'top',\n        },\n        {\n          originX: 'start',\n          originY: 'top',\n          overlayX: 'start',\n          overlayY: 'bottom',\n          panelClass: 'mat-timepicker-above',\n        },\n      ]);\n\n    this._overlayRef = createOverlayRef(this._injector, {\n      positionStrategy,\n      scrollStrategy: this._scrollStrategyFactory(),\n      direction: this._dir || 'ltr',\n      hasBackdrop: false,\n      disableAnimations: this._animationsDisabled,\n    });\n\n    this._overlayRef.detachments().subscribe(() => this.close());\n    this._overlayRef.keydownEvents().subscribe(event => this._handleKeydown(event));\n    this._overlayRef.outsidePointerEvents().subscribe(event => {\n      const target = _getEventTarget(event) as HTMLElement;\n      const origin = this._input()?.getOverlayOrigin().nativeElement;\n\n      if (target && origin && target !== origin && !origin.contains(target)) {\n        this.close();\n      }\n    });\n\n    return this._overlayRef;\n  }\n\n  /** Generates the list of options from which the user can select.. */\n  private _generateOptions(): void {\n    // Default the interval to 30 minutes.\n    const interval = this.interval() ?? 30 * 60;\n    const options = this.options();\n\n    if (options !== null) {\n      this._timeOptions = options;\n    } else {\n      const input = this._input();\n      const adapter = this._dateAdapter;\n      const timeFormat = this._dateFormats.display.timeInput;\n      const min = input?.min() || adapter.setTime(adapter.today(), 0, 0, 0);\n      const max = input?.max() || adapter.setTime(adapter.today(), 23, 59, 0);\n      const cacheKey =\n        interval + '/' + adapter.format(min, timeFormat) + '/' + adapter.format(max, timeFormat);\n\n      // Don't re-generate the options if the inputs haven't changed.\n      if (cacheKey !== this._optionsCacheKey) {\n        this._optionsCacheKey = cacheKey;\n        this._timeOptions = generateOptions(adapter, this._dateFormats, min, max, interval);\n      }\n    }\n  }\n\n  /**\n   * Synchronizes the internal state of the component based on a specific selected date.\n   * @param value Currently selected date.\n   * @param options Options rendered out in the timepicker.\n   * @param fallback Option to set as active if no option is selected.\n   */\n  private _syncSelectedState(\n    value: D | null,\n    options: readonly MatOption[],\n    fallback: MatOption | null,\n  ): void {\n    let hasSelected = false;\n\n    for (const option of options) {\n      if (value && this._dateAdapter.sameTime(option.value, value)) {\n        option.select(false);\n        scrollOptionIntoView(option, 'center');\n        untracked(() => this._keyManager.setActiveItem(option));\n        hasSelected = true;\n      } else {\n        option.deselect(false);\n      }\n    }\n\n    // If no option was selected, we need to reset the key manager since\n    // it might be holding onto an option that no longer exists.\n    if (!hasSelected) {\n      if (fallback) {\n        untracked(() => this._keyManager.setActiveItem(fallback));\n        scrollOptionIntoView(fallback, 'center');\n      } else {\n        untracked(() => this._keyManager.setActiveItem(-1));\n      }\n    }\n  }\n\n  /** Handles keyboard events while the overlay is open. */\n  private _handleKeydown(event: KeyboardEvent): void {\n    const keyCode = event.keyCode;\n\n    if (keyCode === TAB) {\n      this.close();\n    } else if (keyCode === ESCAPE && !hasModifierKey(event)) {\n      event.preventDefault();\n      this.close();\n    } else if (keyCode === ENTER) {\n      event.preventDefault();\n\n      if (this._keyManager.activeItem) {\n        this._selectValue(this._keyManager.activeItem);\n      } else {\n        this.close();\n      }\n    } else {\n      const previousActive = this._keyManager.activeItem;\n      this._keyManager.onKeydown(event);\n      const currentActive = this._keyManager.activeItem;\n\n      if (currentActive && currentActive !== previousActive) {\n        scrollOptionIntoView(currentActive, 'nearest');\n      }\n    }\n  }\n\n  /** Sets up the logic that updates the timepicker when the locale changes. */\n  private _handleLocaleChanges(): void {\n    // Re-generate the options list if the locale changes.\n    this._localeChanges = this._dateAdapter.localeChanges.subscribe(() => {\n      this._optionsCacheKey = null;\n\n      if (this.isOpen()) {\n        this._generateOptions();\n      }\n    });\n  }\n\n  /**\n   * Sets up the logic that updates the timepicker when the state of the connected input changes.\n   */\n  private _handleInputStateChanges(): void {\n    effect(() => {\n      const input = this._input();\n      const options = this._options();\n\n      if (this._isOpen() && input) {\n        this._syncSelectedState(input.value(), options, null);\n      }\n    });\n  }\n}\n\n/**\n * Scrolls an option into view.\n * @param option Option to be scrolled into view.\n * @param position Position to which to align the option relative to the scrollable container.\n */\nfunction scrollOptionIntoView(option: MatOption, position: ScrollLogicalPosition) {\n  option._getHostElement().scrollIntoView({block: position, inline: position});\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  booleanAttribute,\n  computed,\n  Directive,\n  effect,\n  ElementRef,\n  inject,\n  input,\n  InputSignal,\n  InputSignalWithTransform,\n  model,\n  ModelSignal,\n  OnDestroy,\n  OutputRefSubscription,\n  Renderer2,\n  Signal,\n  signal,\n} from '@angular/core';\nimport {DateAdapter, MAT_DATE_FORMATS} from '../core';\nimport {\n  AbstractControl,\n  ControlValueAccessor,\n  NG_VALIDATORS,\n  NG_VALUE_ACCESSOR,\n  ValidationErrors,\n  Validator,\n  ValidatorFn,\n  Validators,\n} from '@angular/forms';\nimport {MAT_FORM_FIELD} from '../form-field';\nimport {MatTimepicker, MatTimepickerConnectedInput} from './timepicker';\nimport {MAT_INPUT_VALUE_ACCESSOR} from '../input';\nimport {Subscription} from 'rxjs';\nimport {DOWN_ARROW, ESCAPE, hasModifierKey, UP_ARROW} from '@angular/cdk/keycodes';\nimport {validateAdapter} from './util';\nimport {_getFocusedElementPierceShadowDom} from '@angular/cdk/platform';\n\n/**\n * Input that can be used to enter time and connect to a `mat-timepicker`.\n */\n@Directive({\n  selector: 'input[matTimepicker]',\n  exportAs: 'matTimepickerInput',\n  host: {\n    'class': 'mat-timepicker-input',\n    'role': 'combobox',\n    'type': 'text',\n    'aria-haspopup': 'listbox',\n    '[attr.aria-activedescendant]': '_ariaActiveDescendant()',\n    '[attr.aria-expanded]': '_ariaExpanded()',\n    '[attr.aria-controls]': '_ariaControls()',\n    '[attr.mat-timepicker-id]': 'timepicker()?.panelId',\n    '[disabled]': 'disabled()',\n    '(blur)': '_handleBlur()',\n    '(input)': '_handleInput($event)',\n    '(keydown)': '_handleKeydown($event)',\n  },\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: MatTimepickerInput,\n      multi: true,\n    },\n    {\n      provide: NG_VALIDATORS,\n      useExisting: MatTimepickerInput,\n      multi: true,\n    },\n    {\n      provide: MAT_INPUT_VALUE_ACCESSOR,\n      useExisting: MatTimepickerInput,\n    },\n  ],\n})\nexport class MatTimepickerInput<D>\n  implements MatTimepickerConnectedInput<D>, ControlValueAccessor, Validator, OnDestroy\n{\n  private _elementRef = inject<ElementRef<HTMLInputElement>>(ElementRef);\n  private _dateAdapter = inject<DateAdapter<D>>(DateAdapter, {optional: true})!;\n  private _dateFormats = inject(MAT_DATE_FORMATS, {optional: true})!;\n  private _formField = inject(MAT_FORM_FIELD, {optional: true});\n\n  private _onChange: ((value: any) => void) | undefined;\n  private _onTouched: (() => void) | undefined;\n  private _validatorOnChange: (() => void) | undefined;\n  private _cleanupClick: () => void;\n  private _accessorDisabled = signal(false);\n  private _localeSubscription: Subscription;\n  private _timepickerSubscription: OutputRefSubscription | undefined;\n  private _validator: ValidatorFn;\n  private _lastValueValid = true;\n  private _lastValidDate: D | null = null;\n\n  /** Value of the `aria-activedescendant` attribute. */\n  protected readonly _ariaActiveDescendant = computed(() => {\n    const timepicker = this.timepicker();\n    const isOpen = timepicker.isOpen();\n    const activeDescendant = timepicker.activeDescendant();\n    return isOpen && activeDescendant ? activeDescendant : null;\n  });\n\n  /** Value of the `aria-expanded` attribute. */\n  protected readonly _ariaExpanded = computed(() => this.timepicker().isOpen() + '');\n\n  /** Value of the `aria-controls` attribute. */\n  protected readonly _ariaControls = computed(() => {\n    const timepicker = this.timepicker();\n    return timepicker.isOpen() ? timepicker.panelId : null;\n  });\n\n  /** Current value of the input. */\n  readonly value: ModelSignal<D | null> = model<D | null>(null);\n\n  /** Timepicker that the input is associated with. */\n  readonly timepicker: InputSignal<MatTimepicker<D>> = input.required<MatTimepicker<D>>({\n    alias: 'matTimepicker',\n  });\n\n  /**\n   * Minimum time that can be selected or typed in. Can be either\n   * a date object (only time will be used) or a valid time string.\n   */\n  readonly min: InputSignalWithTransform<D | null, unknown> = input(null, {\n    alias: 'matTimepickerMin',\n    transform: (value: unknown) => this._transformDateInput<D>(value),\n  });\n\n  /**\n   * Maximum time that can be selected or typed in. Can be either\n   * a date object (only time will be used) or a valid time string.\n   */\n  readonly max: InputSignalWithTransform<D | null, unknown> = input(null, {\n    alias: 'matTimepickerMax',\n    transform: (value: unknown) => this._transformDateInput<D>(value),\n  });\n\n  /**\n   * Whether to open the timepicker overlay when clicking on the input. Enabled by default.\n   * Note that when disabling this option, you'll have to provide your own logic for opening\n   * the overlay.\n   */\n  readonly openOnClick: InputSignalWithTransform<boolean, unknown> = input(true, {\n    alias: 'matTimepickerOpenOnClick',\n    transform: booleanAttribute,\n  });\n\n  /** Whether the input is disabled. */\n  readonly disabled: Signal<boolean> = computed(\n    () => this.disabledInput() || this._accessorDisabled(),\n  );\n\n  /**\n   * Whether the input should be disabled through the template.\n   * @docs-private\n   */\n  readonly disabledInput: InputSignalWithTransform<boolean, unknown> = input(false, {\n    transform: booleanAttribute,\n    alias: 'disabled',\n  });\n\n  constructor() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      validateAdapter(this._dateAdapter, this._dateFormats);\n    }\n\n    const renderer = inject(Renderer2);\n    this._validator = this._getValidator();\n    this._respondToValueChanges();\n    this._respondToMinMaxChanges();\n    this._registerTimepicker();\n    this._localeSubscription = this._dateAdapter.localeChanges.subscribe(() => {\n      if (!this._hasFocus()) {\n        this._formatValue(this.value());\n      }\n    });\n\n    // Bind the click listener manually to the overlay origin, because we want the entire\n    // form field to be clickable, if the timepicker is used in `mat-form-field`.\n    this._cleanupClick = renderer.listen(\n      this.getOverlayOrigin().nativeElement,\n      'click',\n      this._handleClick,\n    );\n  }\n\n  /**\n   * Implemented as a part of `ControlValueAccessor`.\n   * @docs-private\n   */\n  writeValue(value: any): void {\n    // Note that we need to deserialize here, rather than depend on the value change effect,\n    // because `getValidDateOrNull` will clobber the value if it's parseable, but not created by\n    // the current adapter (see #30140).\n    const deserialized = this._dateAdapter.deserialize(value);\n    this.value.set(this._dateAdapter.getValidDateOrNull(deserialized));\n  }\n\n  /**\n   * Implemented as a part of `ControlValueAccessor`.\n   * @docs-private\n   */\n  registerOnChange(fn: (value: any) => void): void {\n    this._onChange = fn;\n  }\n\n  /**\n   * Implemented as a part of `ControlValueAccessor`.\n   * @docs-private\n   */\n  registerOnTouched(fn: () => void): void {\n    this._onTouched = fn;\n  }\n\n  /**\n   * Implemented as a part of `ControlValueAccessor`.\n   * @docs-private\n   */\n  setDisabledState(isDisabled: boolean): void {\n    this._accessorDisabled.set(isDisabled);\n  }\n\n  /**\n   * Implemented as a part of `Validator`.\n   * @docs-private\n   */\n  validate(control: AbstractControl): ValidationErrors | null {\n    return this._validator(control);\n  }\n\n  /**\n   * Implemented as a part of `Validator`.\n   * @docs-private\n   */\n  registerOnValidatorChange(fn: () => void): void {\n    this._validatorOnChange = fn;\n  }\n\n  /** Gets the element to which the timepicker popup should be attached. */\n  getOverlayOrigin(): ElementRef<HTMLElement> {\n    return this._formField?.getConnectedOverlayOrigin() || this._elementRef;\n  }\n\n  /** Focuses the input. */\n  focus(): void {\n    this._elementRef.nativeElement.focus();\n  }\n\n  ngOnDestroy(): void {\n    this._cleanupClick();\n    this._timepickerSubscription?.unsubscribe();\n    this._localeSubscription.unsubscribe();\n  }\n\n  /** Gets the ID of the input's label. */\n  getLabelId(): string | null {\n    return this._formField?.getLabelId() || null;\n  }\n\n  /** Handles clicks on the input or the containing form field. */\n  private _handleClick = (): void => {\n    if (!this.disabled() && this.openOnClick()) {\n      this.timepicker().open();\n    }\n  };\n\n  /** Handles the `input` event. */\n  protected _handleInput(event: Event) {\n    const value = (event.target as HTMLInputElement).value;\n    const currentValue = this.value();\n    const date = this._dateAdapter.parseTime(value, this._dateFormats.parse.timeInput);\n    const hasChanged = !this._dateAdapter.sameTime(date, currentValue);\n\n    if (!date || hasChanged || !!(value && !currentValue)) {\n      // We need to fire the CVA change event for all nulls, otherwise the validators won't run.\n      this._assignUserSelection(date, true);\n    } else {\n      // Call the validator even if the value hasn't changed since\n      // some fields change depending on what the user has entered.\n      this._validatorOnChange?.();\n    }\n  }\n\n  /** Handles the `blur` event. */\n  protected _handleBlur() {\n    const value = this.value();\n\n    // Only reformat on blur so the value doesn't change while the user is interacting.\n    if (value && this._isValid(value)) {\n      this._formatValue(value);\n    }\n\n    if (!this.timepicker().isOpen()) {\n      this._onTouched?.();\n    }\n  }\n\n  /** Handles the `keydown` event. */\n  protected _handleKeydown(event: KeyboardEvent) {\n    // All keyboard events while open are handled through the timepicker.\n    if (this.timepicker().isOpen() || this.disabled()) {\n      return;\n    }\n\n    if (event.keyCode === ESCAPE && !hasModifierKey(event) && this.value() !== null) {\n      event.preventDefault();\n      this.value.set(null);\n      this._formatValue(null);\n    } else if (event.keyCode === DOWN_ARROW || event.keyCode === UP_ARROW) {\n      event.preventDefault();\n      this.timepicker().open();\n    }\n  }\n\n  /** Called by the timepicker to sync up the user-selected value. */\n  timepickerValueAssigned(value: D | null) {\n    if (!this._dateAdapter.sameTime(value, this.value())) {\n      this._assignUserSelection(value, true);\n      this._formatValue(value);\n    }\n  }\n\n  /** Sets up the code that watches for changes in the value and adjusts the input. */\n  private _respondToValueChanges(): void {\n    effect(() => {\n      const value = this._dateAdapter.deserialize(this.value());\n      const wasValid = this._lastValueValid;\n      this._lastValueValid = this._isValid(value);\n\n      // Reformat the value if it changes while the user isn't interacting.\n      if (!this._hasFocus()) {\n        this._formatValue(value);\n      }\n\n      if (value && this._lastValueValid) {\n        this._lastValidDate = value;\n      }\n\n      // Trigger the validator if the state changed.\n      if (wasValid !== this._lastValueValid) {\n        this._validatorOnChange?.();\n      }\n    });\n  }\n\n  /** Sets up the logic that registers the input with the timepicker. */\n  private _registerTimepicker(): void {\n    effect(() => {\n      const timepicker = this.timepicker();\n      timepicker.registerInput(this);\n      timepicker.closed.subscribe(() => this._onTouched?.());\n    });\n  }\n\n  /** Sets up the logic that adjusts the input if the min/max changes. */\n  private _respondToMinMaxChanges(): void {\n    effect(() => {\n      // Read the min/max so the effect knows when to fire.\n      this.min();\n      this.max();\n      this._validatorOnChange?.();\n    });\n  }\n\n  /**\n   * Assigns a value set by the user to the input's model.\n   * @param selection Time selected by the user that should be assigned.\n   * @param propagateToAccessor Whether the value should be propagated to the ControlValueAccessor.\n   */\n  private _assignUserSelection(selection: D | null, propagateToAccessor: boolean) {\n    let toAssign: D | null;\n\n    if (selection == null || !this._isValid(selection)) {\n      toAssign = selection;\n    } else {\n      // If a datepicker and timepicker are writing to the same object and the user enters an\n      // invalid time into the timepicker, we may end up clearing their selection from the\n      // datepicker. If the user enters a valid time afterwards, the datepicker's selection will\n      // have been lost. This logic restores the previously-valid date and sets its time to\n      // the newly-selected time.\n      const adapter = this._dateAdapter;\n      const target = adapter.getValidDateOrNull(this._lastValidDate || this.value());\n      const hours = adapter.getHours(selection);\n      const minutes = adapter.getMinutes(selection);\n      const seconds = adapter.getSeconds(selection);\n      toAssign = target ? adapter.setTime(target, hours, minutes, seconds) : selection;\n    }\n\n    // Propagate to the form control before emitting to `valueChange`.\n    if (propagateToAccessor) {\n      this._onChange?.(toAssign);\n    }\n\n    this.value.set(toAssign);\n  }\n\n  /** Formats the current value and assigns it to the input. */\n  private _formatValue(value: D | null): void {\n    value = this._dateAdapter.getValidDateOrNull(value);\n    this._elementRef.nativeElement.value =\n      value == null ? '' : this._dateAdapter.format(value, this._dateFormats.display.timeInput);\n  }\n\n  /** Checks whether a value is valid. */\n  private _isValid(value: D | null): boolean {\n    return !value || this._dateAdapter.isValid(value);\n  }\n\n  /** Transforms an arbitrary value into a value that can be assigned to a date-based input. */\n  private _transformDateInput<D>(value: unknown): D | null {\n    const date =\n      typeof value === 'string'\n        ? this._dateAdapter.parseTime(value, this._dateFormats.parse.timeInput)\n        : this._dateAdapter.deserialize(value);\n    return date && this._dateAdapter.isValid(date) ? (date as D) : null;\n  }\n\n  /** Whether the input is currently focused. */\n  private _hasFocus(): boolean {\n    return _getFocusedElementPierceShadowDom() === this._elementRef.nativeElement;\n  }\n\n  /** Gets a function that can be used to validate the input. */\n  private _getValidator(): ValidatorFn {\n    return Validators.compose([\n      () =>\n        this._lastValueValid\n          ? null\n          : {'matTimepickerParse': {'text': this._elementRef.nativeElement.value}},\n      control => {\n        const controlValue = this._dateAdapter.getValidDateOrNull(\n          this._dateAdapter.deserialize(control.value),\n        );\n        const min = this.min();\n        return !min || !controlValue || this._dateAdapter.compareTime(min, controlValue) <= 0\n          ? null\n          : {'matTimepickerMin': {'min': min, 'actual': controlValue}};\n      },\n      control => {\n        const controlValue = this._dateAdapter.getValidDateOrNull(\n          this._dateAdapter.deserialize(control.value),\n        );\n        const max = this.max();\n        return !max || !controlValue || this._dateAdapter.compareTime(max, controlValue) >= 0\n          ? null\n          : {'matTimepickerMax': {'max': max, 'actual': controlValue}};\n      },\n    ])!;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  booleanAttribute,\n  ChangeDetectionStrategy,\n  Component,\n  computed,\n  HostAttributeToken,\n  inject,\n  input,\n  InputSignal,\n  InputSignalWithTransform,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {MatIconButton} from '../button';\nimport {MAT_TIMEPICKER_CONFIG} from './util';\nimport type {MatTimepicker} from './timepicker';\n\n/** Button that can be used to open a `mat-timepicker`. */\n@Component({\n  selector: 'mat-timepicker-toggle',\n  templateUrl: 'timepicker-toggle.html',\n  host: {\n    'class': 'mat-timepicker-toggle',\n    '[attr.tabindex]': 'null',\n    // Bind the `click` on the host, rather than the inner `button`, so that we can call\n    // `stopPropagation` on it without affecting the user's `click` handlers. We need to stop\n    // it so that the input doesn't get focused automatically by the form field (See #21836).\n    '(click)': '_open($event)',\n  },\n  exportAs: 'matTimepickerToggle',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [MatIconButton],\n})\nexport class MatTimepickerToggle<D> {\n  private _defaultConfig = inject(MAT_TIMEPICKER_CONFIG, {optional: true});\n  private _defaultTabIndex = (() => {\n    const value = inject(new HostAttributeToken('tabindex'), {optional: true});\n    const parsed = Number(value);\n    return isNaN(parsed) ? null : parsed;\n  })();\n\n  protected _isDisabled = computed(() => {\n    const timepicker = this.timepicker();\n    return this.disabled() || timepicker.disabled();\n  });\n\n  /** Timepicker instance that the button will toggle. */\n  readonly timepicker: InputSignal<MatTimepicker<D>> = input.required<MatTimepicker<D>>({\n    alias: 'for',\n  });\n\n  /** Screen-reader label for the button. */\n  readonly ariaLabel = input<string | undefined>(undefined, {\n    alias: 'aria-label',\n  });\n\n  /** Screen-reader labelled by id for the button. */\n  readonly ariaLabelledby = input<string | undefined>(undefined, {\n    alias: 'aria-labelledby',\n  });\n\n  /** Default aria-label for the toggle if none is provided. */\n  private readonly _defaultAriaLabel = 'Open timepicker options';\n\n  /** Whether the toggle button is disabled. */\n  readonly disabled: InputSignalWithTransform<boolean, unknown> = input(false, {\n    transform: booleanAttribute,\n    alias: 'disabled',\n  });\n\n  /** Tabindex for the toggle. */\n  readonly tabIndex: InputSignal<number | null> = input(this._defaultTabIndex);\n\n  /** Whether ripples on the toggle should be disabled. */\n  readonly disableRipple: InputSignalWithTransform<boolean, unknown> = input(\n    this._defaultConfig?.disableRipple ?? false,\n    {transform: booleanAttribute},\n  );\n\n  /** Opens the connected timepicker. */\n  protected _open(event: Event): void {\n    if (this.timepicker() && !this._isDisabled()) {\n      this.timepicker().open();\n      event.stopPropagation();\n    }\n  }\n\n  /**\n   * Checks for ariaLabelledby and if empty uses custom\n   * aria-label or defaultAriaLabel if neither is provided.\n   */\n  getAriaLabel(): string | null {\n    return this.ariaLabelledby() ? null : this.ariaLabel() || this._defaultAriaLabel;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {CdkScrollableModule} from '@angular/cdk/scrolling';\nimport {MatTimepicker} from './timepicker';\nimport {MatTimepickerInput} from './timepicker-input';\nimport {MatTimepickerToggle} from './timepicker-toggle';\n\n@NgModule({\n  imports: [MatTimepicker, MatTimepickerInput, MatTimepickerToggle],\n  exports: [CdkScrollableModule, MatTimepicker, MatTimepickerInput, MatTimepickerToggle],\n})\nexport class MatTimepickerModule {}\n"],"names":["MAT_TIMEPICKER_CONFIG","InjectionToken","parseInterval","value","result","trim","length","match","INTERVAL_PATTERN","amount","unit","parsed","toLowerCase","isNaN","MAT_TIMEPICKER_SCROLL_STRATEGY","providedIn","createRepositionScrollStrategy","MatTimepicker","_dir","inject","Directionality","optional","_viewContainerRef","ViewContainerRef","_scrollStrategyFactory","_animationsDisabled","_isOpen","signal","ngDevMode","debugName","_activeDescendant","_input","_overlayRef","_portal","_optionsCacheKey","_localeChanges","_onOpenRender","_panelTemplate","viewChild","required","_timeOptions","viewChildren","MatOption","_keyManager","ActiveDescendantKeyManager","_options","_injector","withHomeAndEnd","withPageUpDown","withVerticalOrientation","input","_defaultConfig","interval","transform","isOpen","asReadonly","disableRipple","booleanAttribute","alias","computed","disabled","constructor","validateAdapter","_dateAdapter","_dateFormats","effect","options","Error","ElementRef","setAttribute","panelId","change","subscribe","set","activeItem","id","open","_generateOptions","overlayRef","hasAttached","attach","destroy","afterNextRender","closed","emit","currentInput","unsubscribe","dispose","_selectValue","option","close","setActiveItem","forEach","current","deselect","timepickerValueAssigned","selected","source","focus","_getAriaLabelledby","ariaLabelledby","getLabelId","_handleAnimationEnd","event","detach","_getOverlayRef","positionStrategy","createFlexibleConnectedPositionStrategy","getOverlayOrigin","withFlexibleDimensions","withPush","withTransformOriginOn","withPositions","originX","overlayX","overlayY","decorators","exportAs","changeDetection","ChangeDetectionStrategy","OnPush","encapsulation","ViewEncapsulation","None","imports","providers","provide","MAT_OPTION_PARENT_COMPONENT","styles","ctorParameters","MatTimepickerInput","_elementRef","DateAdapter","_formField","MAT_FORM_FIELD","_onTouched","_cleanupClick","_accessorDisabled","_localeSubscription","_validator","_lastValueValid","_lastValidDate","_ariaActiveDescendant","timepicker","activeDescendant","model","min","_transformDateInput","disabledInput","renderer","Renderer2","_getValidator","_respondToValueChanges","_registerTimepicker","localeChanges","_formatValue","listen","nativeElement","_handleClick","registerOnChange","fn","_onChange","registerOnTouched","setDisabledState","isDisabled","control","registerOnValidatorChange","_validatorOnChange","ngOnDestroy","_timepickerSubscription","openOnClick","_handleInput","target","currentValue","parseTime","parse","timeInput","_assignUserSelection","date","_handleBlur","_isValid","_handleKeydown","keyCode","DOWN_ARROW","UP_ARROW","preventDefault","sameTime","wasValid","_hasFocus","_respondToMinMaxChanges","max","selection","propagateToAccessor","toAssign","adapter","getValidDateOrNull","hours","getHours","minutes","getMinutes","seconds","getSeconds","MAT_INPUT_VALUE_ACCESSOR","ngImport","i0","minVersion","version","type","Directive","host","NG_VALUE_ACCESSOR","useExisting","multi","NG_VALIDATORS","_defaultTabIndex","HostAttributeToken","Number","_isDisabled","undefined","MatIconButton","template","MatTimepickerModule","ɵfac","ɵɵngDeclareFactory","deps","ɵɵFactoryTarget","NgModule","ɵmod","ɵɵngDeclareNgModule","MatTimepickerToggle","exports","CdkScrollableModule"],"mappings":"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"}