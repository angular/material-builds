{"version":3,"file":"timepicker.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/timepicker/util.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/timepicker/timepicker.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/timepicker/timepicker-input.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/timepicker/timepicker-toggle.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/timepicker/timepicker-module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken} from '@angular/core';\nimport {DateAdapter, MatDateFormats} from '../core';\n\n/** Pattern that interval strings have to match. */\nconst INTERVAL_PATTERN = /^(\\d*\\.?\\d+)\\s*(h|hour|hours|m|min|minute|minutes|s|second|seconds)?$/i;\n\n/**\n * Object that can be used to configure the default options for the timepicker component.\n */\nexport interface MatTimepickerConfig {\n  /** Default interval for all time pickers. */\n  interval?: string | number;\n\n  /** Whether ripples inside the timepicker should be disabled by default. */\n  disableRipple?: boolean;\n}\n\n/**\n * Injection token that can be used to configure the default options for the timepicker component.\n */\nexport const MAT_TIMEPICKER_CONFIG = new InjectionToken<MatTimepickerConfig>(\n  'MAT_TIMEPICKER_CONFIG',\n);\n\n/**\n * Time selection option that can be displayed within a `mat-timepicker`.\n */\nexport interface MatTimepickerOption<D = unknown> {\n  /** Date value of the option. */\n  value: D;\n\n  /** Label to show to the user. */\n  label: string;\n}\n\n/** Parses an interval value into seconds. */\nexport function parseInterval(value: number | string | null): number | null {\n  let result: number;\n\n  if (value === null) {\n    return null;\n  } else if (typeof value === 'number') {\n    result = value;\n  } else {\n    if (value.trim().length === 0) {\n      return null;\n    }\n\n    const parsed = value.match(INTERVAL_PATTERN);\n    const amount = parsed ? parseFloat(parsed[1]) : null;\n    const unit = parsed?.[2]?.toLowerCase() || null;\n\n    if (!parsed || amount === null || isNaN(amount)) {\n      return null;\n    }\n\n    if (unit === 'h' || unit === 'hour' || unit === 'hours') {\n      result = amount * 3600;\n    } else if (unit === 'm' || unit === 'min' || unit === 'minute' || unit === 'minutes') {\n      result = amount * 60;\n    } else {\n      result = amount;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Generates the options to show in a timepicker.\n * @param adapter Date adapter to be used to generate the options.\n * @param formats Formatting config to use when displaying the options.\n * @param min Time from which to start generating the options.\n * @param max Time at which to stop generating the options.\n * @param interval Amount of seconds between each option.\n */\nexport function generateOptions<D>(\n  adapter: DateAdapter<D>,\n  formats: MatDateFormats,\n  min: D,\n  max: D,\n  interval: number,\n): MatTimepickerOption<D>[] {\n  const options: MatTimepickerOption<D>[] = [];\n  let current = adapter.compareTime(min, max) < 1 ? min : max;\n\n  while (\n    adapter.sameDate(current, min) &&\n    adapter.compareTime(current, max) < 1 &&\n    adapter.isValid(current)\n  ) {\n    options.push({value: current, label: adapter.format(current, formats.display.timeOptionLabel)});\n    current = adapter.addSeconds(current, interval);\n  }\n\n  return options;\n}\n\n/** Checks whether a date adapter is set up correctly for use with the timepicker. */\nexport function validateAdapter(\n  adapter: DateAdapter<unknown> | null,\n  formats: MatDateFormats | null,\n) {\n  function missingAdapterError(provider: string) {\n    return Error(\n      `MatTimepicker: No provider found for ${provider}. You must add one of the following ` +\n        `to your app config: provideNativeDateAdapter, provideDateFnsAdapter, ` +\n        `provideLuxonDateAdapter, provideMomentDateAdapter, or provide a custom implementation.`,\n    );\n  }\n\n  if (!adapter) {\n    throw missingAdapterError('DateAdapter');\n  }\n\n  if (!formats) {\n    throw missingAdapterError('MAT_DATE_FORMATS');\n  }\n\n  if (\n    formats.display.timeInput === undefined ||\n    formats.display.timeOptionLabel === undefined ||\n    formats.parse.timeInput === undefined\n  ) {\n    throw new Error(\n      'MatTimepicker: Incomplete `MAT_DATE_FORMATS` has been provided. ' +\n        '`MAT_DATE_FORMATS` must provide `display.timeInput`, `display.timeOptionLabel` ' +\n        'and `parse.timeInput` formats in order to be compatible with MatTimepicker.',\n    );\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  afterNextRender,\n  AfterRenderRef,\n  booleanAttribute,\n  ChangeDetectionStrategy,\n  Component,\n  computed,\n  effect,\n  ElementRef,\n  inject,\n  InjectionToken,\n  Injector,\n  input,\n  InputSignal,\n  InputSignalWithTransform,\n  OnDestroy,\n  output,\n  OutputEmitterRef,\n  Signal,\n  signal,\n  TemplateRef,\n  untracked,\n  viewChild,\n  viewChildren,\n  ViewContainerRef,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {\n  _animationsDisabled,\n  DateAdapter,\n  MAT_DATE_FORMATS,\n  MAT_OPTION_PARENT_COMPONENT,\n  MatOption,\n  MatOptionParentComponent,\n} from '../core';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {\n  createFlexibleConnectedPositionStrategy,\n  createOverlayRef,\n  createRepositionScrollStrategy,\n  OverlayRef,\n  ScrollStrategy,\n} from '@angular/cdk/overlay';\nimport {TemplatePortal} from '@angular/cdk/portal';\nimport {_getEventTarget} from '@angular/cdk/platform';\nimport {ENTER, ESCAPE, hasModifierKey, TAB} from '@angular/cdk/keycodes';\nimport {_IdGenerator, ActiveDescendantKeyManager} from '@angular/cdk/a11y';\nimport {\n  generateOptions,\n  MAT_TIMEPICKER_CONFIG,\n  MatTimepickerOption,\n  parseInterval,\n  validateAdapter,\n} from './util';\nimport {Subscription} from 'rxjs';\n\n/** Event emitted when a value is selected in the timepicker. */\nexport interface MatTimepickerSelected<D> {\n  value: D;\n  source: MatTimepicker<D>;\n}\n\n/** Injection token used to configure the behavior of the timepicker dropdown while scrolling. */\nexport const MAT_TIMEPICKER_SCROLL_STRATEGY = new InjectionToken<() => ScrollStrategy>(\n  'MAT_TIMEPICKER_SCROLL_STRATEGY',\n  {\n    providedIn: 'root',\n    factory: () => {\n      const injector = inject(Injector);\n      return () => createRepositionScrollStrategy(injector);\n    },\n  },\n);\n\n/** Represents an input that is connected to a `mat-timepicker`. */\nexport interface MatTimepickerConnectedInput<D> {\n  /** Current value of the input. */\n  value: Signal<D | null>;\n\n  /** Minimum allowed time. */\n  min: Signal<D | null>;\n\n  /** Maximum allowed time. */\n  max: Signal<D | null>;\n\n  /** Whether the input is disabled. */\n  disabled: Signal<boolean>;\n\n  /** Focuses the input. */\n  focus(): void;\n\n  /** Gets the element to which to connect the timepicker overlay. */\n  getOverlayOrigin(): ElementRef<HTMLElement>;\n\n  /** Gets the ID of the input's label. */\n  getLabelId(): string | null;\n\n  /** Callback invoked when the timepicker assigns a value. */\n  timepickerValueAssigned(value: D | null): void;\n}\n\n/**\n * Renders out a listbox that can be used to select a time of day.\n * Intended to be used together with `MatTimepickerInput`.\n */\n@Component({\n  selector: 'mat-timepicker',\n  exportAs: 'matTimepicker',\n  templateUrl: 'timepicker.html',\n  styleUrl: 'timepicker.css',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  imports: [MatOption],\n  providers: [\n    {\n      provide: MAT_OPTION_PARENT_COMPONENT,\n      useExisting: MatTimepicker,\n    },\n  ],\n})\nexport class MatTimepicker<D> implements OnDestroy, MatOptionParentComponent {\n  private _dir = inject(Directionality, {optional: true});\n  private _viewContainerRef = inject(ViewContainerRef);\n  private _injector = inject(Injector);\n  private _defaultConfig = inject(MAT_TIMEPICKER_CONFIG, {optional: true});\n  private _dateAdapter = inject<DateAdapter<D>>(DateAdapter, {optional: true})!;\n  private _dateFormats = inject(MAT_DATE_FORMATS, {optional: true})!;\n  private _scrollStrategyFactory = inject(MAT_TIMEPICKER_SCROLL_STRATEGY);\n  protected _animationsDisabled = _animationsDisabled();\n\n  private _isOpen = signal(false);\n  private _activeDescendant = signal<string | null>(null);\n\n  private _input = signal<MatTimepickerConnectedInput<D> | null>(null);\n  private _overlayRef: OverlayRef | null = null;\n  private _portal: TemplatePortal<unknown> | null = null;\n  private _optionsCacheKey: string | null = null;\n  private _localeChanges: Subscription;\n  private _onOpenRender: AfterRenderRef | null = null;\n\n  protected _panelTemplate = viewChild.required<TemplateRef<unknown>>('panelTemplate');\n  protected _timeOptions: readonly MatTimepickerOption<D>[] = [];\n  protected _options = viewChildren(MatOption);\n\n  private _keyManager = new ActiveDescendantKeyManager(this._options, this._injector)\n    .withHomeAndEnd(true)\n    .withPageUpDown(true)\n    .withVerticalOrientation(true);\n\n  /**\n   * Interval between each option in the timepicker. The value can either be an amount of\n   * seconds (e.g. 90) or a number with a unit (e.g. 45m). Supported units are `s` for seconds,\n   * `m` for minutes or `h` for hours.\n   */\n  readonly interval: InputSignalWithTransform<number | null, number | string | null> = input(\n    parseInterval(this._defaultConfig?.interval || null),\n    {transform: parseInterval},\n  );\n\n  /**\n   * Array of pre-defined options that the user can select from, as an alternative to using the\n   * `interval` input. An error will be thrown if both `options` and `interval` are specified.\n   */\n  readonly options: InputSignal<readonly MatTimepickerOption<D>[] | null> = input<\n    readonly MatTimepickerOption<D>[] | null\n  >(null);\n\n  /** Whether the timepicker is open. */\n  readonly isOpen: Signal<boolean> = this._isOpen.asReadonly();\n\n  /** Emits when the user selects a time. */\n  readonly selected: OutputEmitterRef<MatTimepickerSelected<D>> = output();\n\n  /** Emits when the timepicker is opened. */\n  readonly opened: OutputEmitterRef<void> = output();\n\n  /** Emits when the timepicker is closed. */\n  readonly closed: OutputEmitterRef<void> = output();\n\n  /** ID of the active descendant option. */\n  readonly activeDescendant: Signal<string | null> = this._activeDescendant.asReadonly();\n\n  /** Unique ID of the timepicker's panel */\n  readonly panelId: string = inject(_IdGenerator).getId('mat-timepicker-panel-');\n\n  /** Whether ripples within the timepicker should be disabled. */\n  readonly disableRipple: InputSignalWithTransform<boolean, unknown> = input(\n    this._defaultConfig?.disableRipple ?? false,\n    {\n      transform: booleanAttribute,\n    },\n  );\n\n  /** ARIA label for the timepicker panel. */\n  readonly ariaLabel: InputSignal<string | null> = input<string | null>(null, {\n    alias: 'aria-label',\n  });\n\n  /** ID of the label element for the timepicker panel. */\n  readonly ariaLabelledby: InputSignal<string | null> = input<string | null>(null, {\n    alias: 'aria-labelledby',\n  });\n\n  /** Whether the timepicker is currently disabled. */\n  readonly disabled: Signal<boolean> = computed(() => !!this._input()?.disabled());\n\n  constructor() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      validateAdapter(this._dateAdapter, this._dateFormats);\n\n      effect(() => {\n        const options = this.options();\n        const interval = this.interval();\n\n        if (options !== null && interval !== null) {\n          throw new Error(\n            'Cannot specify both the `options` and `interval` inputs at the same time',\n          );\n        } else if (options?.length === 0) {\n          throw new Error('Value of `options` input cannot be an empty array');\n        }\n      });\n    }\n\n    // Since the panel ID is static, we can set it once without having to maintain a host binding.\n    const element = inject<ElementRef<HTMLElement>>(ElementRef);\n    element.nativeElement.setAttribute('mat-timepicker-panel-id', this.panelId);\n    this._handleLocaleChanges();\n    this._handleInputStateChanges();\n    this._keyManager.change.subscribe(() =>\n      this._activeDescendant.set(this._keyManager.activeItem?.id || null),\n    );\n  }\n\n  /** Opens the timepicker. */\n  open(): void {\n    const input = this._input();\n\n    if (!input) {\n      return;\n    }\n\n    // Focus should already be on the input, but this call is in case the timepicker is opened\n    // programmatically. We need to call this even if the timepicker is already open, because\n    // the user might be clicking the toggle.\n    input.focus();\n\n    if (this._isOpen()) {\n      return;\n    }\n\n    this._isOpen.set(true);\n    this._generateOptions();\n    const overlayRef = this._getOverlayRef();\n    overlayRef.updateSize({width: input.getOverlayOrigin().nativeElement.offsetWidth});\n    this._portal ??= new TemplatePortal(this._panelTemplate(), this._viewContainerRef);\n\n    // We need to check this in case `isOpen` was flipped, but change detection hasn't\n    // had a chance to run yet. See https://github.com/angular/components/issues/30637\n    if (!overlayRef.hasAttached()) {\n      overlayRef.attach(this._portal);\n    }\n\n    this._onOpenRender?.destroy();\n    this._onOpenRender = afterNextRender(\n      () => {\n        const options = this._options();\n        this._syncSelectedState(input.value(), options, options[0]);\n        this._onOpenRender = null;\n      },\n      {injector: this._injector},\n    );\n\n    this.opened.emit();\n  }\n\n  /** Closes the timepicker. */\n  close(): void {\n    if (this._isOpen()) {\n      this._isOpen.set(false);\n      this.closed.emit();\n\n      if (this._animationsDisabled) {\n        this._overlayRef?.detach();\n      }\n    }\n  }\n\n  /** Registers an input with the timepicker. */\n  registerInput(input: MatTimepickerConnectedInput<D>): void {\n    const currentInput = this._input();\n\n    if (currentInput && input !== currentInput && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw new Error('MatTimepicker can only be registered with one input at a time');\n    }\n\n    this._input.set(input);\n  }\n\n  ngOnDestroy(): void {\n    this._keyManager.destroy();\n    this._localeChanges.unsubscribe();\n    this._onOpenRender?.destroy();\n    this._overlayRef?.dispose();\n  }\n\n  _getOverlayHost() {\n    return this._overlayRef?.hostElement;\n  }\n\n  /** Selects a specific time value. */\n  protected _selectValue(option: MatOption<D>) {\n    this.close();\n    this._keyManager.setActiveItem(option);\n    this._options().forEach(current => {\n      // This is primarily here so we don't show two selected options while animating away.\n      if (current !== option) {\n        current.deselect(false);\n      }\n    });\n    // Notify the input first so it can sync up the form control before emitting to `selected`.\n    this._input()?.timepickerValueAssigned(option.value);\n    this.selected.emit({value: option.value, source: this});\n    this._input()?.focus();\n  }\n\n  /** Gets the value of the `aria-labelledby` attribute. */\n  protected _getAriaLabelledby(): string | null {\n    if (this.ariaLabel()) {\n      return null;\n    }\n    return this.ariaLabelledby() || this._input()?.getLabelId() || null;\n  }\n\n  /** Handles animation events coming from the panel. */\n  protected _handleAnimationEnd(event: AnimationEvent) {\n    if (event.animationName === '_mat-timepicker-exit') {\n      this._overlayRef?.detach();\n    }\n  }\n\n  /** Creates an overlay reference for the timepicker panel. */\n  private _getOverlayRef(): OverlayRef {\n    if (this._overlayRef) {\n      return this._overlayRef;\n    }\n\n    const positionStrategy = createFlexibleConnectedPositionStrategy(\n      this._injector,\n      this._input()!.getOverlayOrigin(),\n    )\n      .withFlexibleDimensions(false)\n      .withPush(false)\n      .withTransformOriginOn('.mat-timepicker-panel')\n      .withPositions([\n        {\n          originX: 'start',\n          originY: 'bottom',\n          overlayX: 'start',\n          overlayY: 'top',\n        },\n        {\n          originX: 'start',\n          originY: 'top',\n          overlayX: 'start',\n          overlayY: 'bottom',\n          panelClass: 'mat-timepicker-above',\n        },\n      ]);\n\n    this._overlayRef = createOverlayRef(this._injector, {\n      positionStrategy,\n      scrollStrategy: this._scrollStrategyFactory(),\n      direction: this._dir || 'ltr',\n      hasBackdrop: false,\n      disableAnimations: this._animationsDisabled,\n    });\n\n    this._overlayRef.detachments().subscribe(() => this.close());\n    this._overlayRef.keydownEvents().subscribe(event => this._handleKeydown(event));\n    this._overlayRef.outsidePointerEvents().subscribe(event => {\n      const target = _getEventTarget(event) as HTMLElement;\n      const origin = this._input()?.getOverlayOrigin().nativeElement;\n\n      if (target && origin && target !== origin && !origin.contains(target)) {\n        this.close();\n      }\n    });\n\n    return this._overlayRef;\n  }\n\n  /** Generates the list of options from which the user can select.. */\n  private _generateOptions(): void {\n    // Default the interval to 30 minutes.\n    const interval = this.interval() ?? 30 * 60;\n    const options = this.options();\n\n    if (options !== null) {\n      this._timeOptions = options;\n    } else {\n      const input = this._input();\n      const adapter = this._dateAdapter;\n      const timeFormat = this._dateFormats.display.timeInput;\n      const min = input?.min() || adapter.setTime(adapter.today(), 0, 0, 0);\n      const max = input?.max() || adapter.setTime(adapter.today(), 23, 59, 0);\n      const cacheKey =\n        interval + '/' + adapter.format(min, timeFormat) + '/' + adapter.format(max, timeFormat);\n\n      // Don't re-generate the options if the inputs haven't changed.\n      if (cacheKey !== this._optionsCacheKey) {\n        this._optionsCacheKey = cacheKey;\n        this._timeOptions = generateOptions(adapter, this._dateFormats, min, max, interval);\n      }\n    }\n  }\n\n  /**\n   * Synchronizes the internal state of the component based on a specific selected date.\n   * @param value Currently selected date.\n   * @param options Options rendered out in the timepicker.\n   * @param fallback Option to set as active if no option is selected.\n   */\n  private _syncSelectedState(\n    value: D | null,\n    options: readonly MatOption[],\n    fallback: MatOption | null,\n  ): void {\n    let hasSelected = false;\n\n    for (const option of options) {\n      if (value && this._dateAdapter.sameTime(option.value, value)) {\n        option.select(false);\n        scrollOptionIntoView(option, 'center');\n        untracked(() => this._keyManager.setActiveItem(option));\n        hasSelected = true;\n      } else {\n        option.deselect(false);\n      }\n    }\n\n    // If no option was selected, we need to reset the key manager since\n    // it might be holding onto an option that no longer exists.\n    if (!hasSelected) {\n      if (fallback) {\n        untracked(() => this._keyManager.setActiveItem(fallback));\n        scrollOptionIntoView(fallback, 'center');\n      } else {\n        untracked(() => this._keyManager.setActiveItem(-1));\n      }\n    }\n  }\n\n  /** Handles keyboard events while the overlay is open. */\n  private _handleKeydown(event: KeyboardEvent): void {\n    const keyCode = event.keyCode;\n\n    if (keyCode === TAB) {\n      this.close();\n    } else if (keyCode === ESCAPE && !hasModifierKey(event)) {\n      event.preventDefault();\n      this.close();\n    } else if (keyCode === ENTER) {\n      event.preventDefault();\n\n      if (this._keyManager.activeItem) {\n        this._selectValue(this._keyManager.activeItem);\n      } else {\n        this.close();\n      }\n    } else {\n      const previousActive = this._keyManager.activeItem;\n      this._keyManager.onKeydown(event);\n      const currentActive = this._keyManager.activeItem;\n\n      if (currentActive && currentActive !== previousActive) {\n        scrollOptionIntoView(currentActive, 'nearest');\n      }\n    }\n  }\n\n  /** Sets up the logic that updates the timepicker when the locale changes. */\n  private _handleLocaleChanges(): void {\n    // Re-generate the options list if the locale changes.\n    this._localeChanges = this._dateAdapter.localeChanges.subscribe(() => {\n      this._optionsCacheKey = null;\n\n      if (this.isOpen()) {\n        this._generateOptions();\n      }\n    });\n  }\n\n  /**\n   * Sets up the logic that updates the timepicker when the state of the connected input changes.\n   */\n  private _handleInputStateChanges(): void {\n    effect(() => {\n      const input = this._input();\n      const options = this._options();\n\n      if (this._isOpen() && input) {\n        this._syncSelectedState(input.value(), options, null);\n      }\n    });\n  }\n}\n\n/**\n * Scrolls an option into view.\n * @param option Option to be scrolled into view.\n * @param position Position to which to align the option relative to the scrollable container.\n */\nfunction scrollOptionIntoView(option: MatOption, position: ScrollLogicalPosition) {\n  option._getHostElement().scrollIntoView({block: position, inline: position});\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  booleanAttribute,\n  computed,\n  Directive,\n  effect,\n  ElementRef,\n  inject,\n  input,\n  InputSignal,\n  InputSignalWithTransform,\n  model,\n  ModelSignal,\n  OnDestroy,\n  OutputRefSubscription,\n  Renderer2,\n  Signal,\n  signal,\n} from '@angular/core';\nimport {DateAdapter, MAT_DATE_FORMATS} from '../core';\nimport {\n  AbstractControl,\n  ControlValueAccessor,\n  NG_VALIDATORS,\n  NG_VALUE_ACCESSOR,\n  ValidationErrors,\n  Validator,\n  ValidatorFn,\n  Validators,\n} from '@angular/forms';\nimport {MAT_FORM_FIELD} from '../form-field';\nimport {MatTimepicker, MatTimepickerConnectedInput} from './timepicker';\nimport {MAT_INPUT_VALUE_ACCESSOR} from '../input';\nimport {Subscription} from 'rxjs';\nimport {DOWN_ARROW, ESCAPE, hasModifierKey, UP_ARROW} from '@angular/cdk/keycodes';\nimport {validateAdapter} from './util';\nimport {_getEventTarget, _getFocusedElementPierceShadowDom} from '@angular/cdk/platform';\n\n/**\n * Input that can be used to enter time and connect to a `mat-timepicker`.\n */\n@Directive({\n  selector: 'input[matTimepicker]',\n  exportAs: 'matTimepickerInput',\n  host: {\n    'class': 'mat-timepicker-input',\n    'role': 'combobox',\n    'type': 'text',\n    'aria-haspopup': 'listbox',\n    '[attr.aria-activedescendant]': '_ariaActiveDescendant()',\n    '[attr.aria-expanded]': '_ariaExpanded()',\n    '[attr.aria-controls]': '_ariaControls()',\n    '[attr.mat-timepicker-id]': 'timepicker()?.panelId',\n    '[disabled]': 'disabled()',\n    '(blur)': '_handleBlur()',\n    '(input)': '_handleInput($event)',\n    '(keydown)': '_handleKeydown($event)',\n  },\n  providers: [\n    {\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: MatTimepickerInput,\n      multi: true,\n    },\n    {\n      provide: NG_VALIDATORS,\n      useExisting: MatTimepickerInput,\n      multi: true,\n    },\n    {\n      provide: MAT_INPUT_VALUE_ACCESSOR,\n      useExisting: MatTimepickerInput,\n    },\n  ],\n})\nexport class MatTimepickerInput<D>\n  implements MatTimepickerConnectedInput<D>, ControlValueAccessor, Validator, OnDestroy\n{\n  private _elementRef = inject<ElementRef<HTMLInputElement>>(ElementRef);\n  private _dateAdapter = inject<DateAdapter<D>>(DateAdapter, {optional: true})!;\n  private _dateFormats = inject(MAT_DATE_FORMATS, {optional: true})!;\n  private _formField = inject(MAT_FORM_FIELD, {optional: true});\n\n  private _onChange: ((value: any) => void) | undefined;\n  private _onTouched: (() => void) | undefined;\n  private _validatorOnChange: (() => void) | undefined;\n  private _cleanupClick: () => void;\n  private _accessorDisabled = signal(false);\n  private _localeSubscription: Subscription;\n  private _timepickerSubscription: OutputRefSubscription | undefined;\n  private _validator: ValidatorFn;\n  private _lastValueValid = true;\n  private _lastValidDate: D | null = null;\n\n  /** Value of the `aria-activedescendant` attribute. */\n  protected readonly _ariaActiveDescendant = computed(() => {\n    const timepicker = this.timepicker();\n    const isOpen = timepicker.isOpen();\n    const activeDescendant = timepicker.activeDescendant();\n    return isOpen && activeDescendant ? activeDescendant : null;\n  });\n\n  /** Value of the `aria-expanded` attribute. */\n  protected readonly _ariaExpanded = computed(() => this.timepicker().isOpen() + '');\n\n  /** Value of the `aria-controls` attribute. */\n  protected readonly _ariaControls = computed(() => {\n    const timepicker = this.timepicker();\n    return timepicker.isOpen() ? timepicker.panelId : null;\n  });\n\n  /** Current value of the input. */\n  readonly value: ModelSignal<D | null> = model<D | null>(null);\n\n  /** Timepicker that the input is associated with. */\n  readonly timepicker: InputSignal<MatTimepicker<D>> = input.required<MatTimepicker<D>>({\n    alias: 'matTimepicker',\n  });\n\n  /**\n   * Minimum time that can be selected or typed in. Can be either\n   * a date object (only time will be used) or a valid time string.\n   */\n  readonly min: InputSignalWithTransform<D | null, unknown> = input(null, {\n    alias: 'matTimepickerMin',\n    transform: (value: unknown) => this._transformDateInput<D>(value),\n  });\n\n  /**\n   * Maximum time that can be selected or typed in. Can be either\n   * a date object (only time will be used) or a valid time string.\n   */\n  readonly max: InputSignalWithTransform<D | null, unknown> = input(null, {\n    alias: 'matTimepickerMax',\n    transform: (value: unknown) => this._transformDateInput<D>(value),\n  });\n\n  /**\n   * Whether to open the timepicker overlay when clicking on the input. Enabled by default.\n   * Note that when disabling this option, you'll have to provide your own logic for opening\n   * the overlay.\n   */\n  readonly openOnClick: InputSignalWithTransform<boolean, unknown> = input(true, {\n    alias: 'matTimepickerOpenOnClick',\n    transform: booleanAttribute,\n  });\n\n  /** Whether the input is disabled. */\n  readonly disabled: Signal<boolean> = computed(\n    () => this.disabledInput() || this._accessorDisabled(),\n  );\n\n  /**\n   * Whether the input should be disabled through the template.\n   * @docs-private\n   */\n  readonly disabledInput: InputSignalWithTransform<boolean, unknown> = input(false, {\n    transform: booleanAttribute,\n    alias: 'disabled',\n  });\n\n  constructor() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      validateAdapter(this._dateAdapter, this._dateFormats);\n    }\n\n    const renderer = inject(Renderer2);\n    this._validator = this._getValidator();\n    this._respondToValueChanges();\n    this._respondToMinMaxChanges();\n    this._registerTimepicker();\n    this._localeSubscription = this._dateAdapter.localeChanges.subscribe(() => {\n      if (!this._hasFocus()) {\n        this._formatValue(this.value());\n      }\n    });\n\n    // Bind the click listener manually to the overlay origin, because we want the entire\n    // form field to be clickable, if the timepicker is used in `mat-form-field`.\n    this._cleanupClick = renderer.listen(\n      this.getOverlayOrigin().nativeElement,\n      'click',\n      this._handleClick,\n    );\n  }\n\n  /**\n   * Implemented as a part of `ControlValueAccessor`.\n   * @docs-private\n   */\n  writeValue(value: any): void {\n    // Note that we need to deserialize here, rather than depend on the value change effect,\n    // because `getValidDateOrNull` will clobber the value if it's parseable, but not created by\n    // the current adapter (see #30140).\n    const deserialized = this._dateAdapter.deserialize(value);\n    this.value.set(this._dateAdapter.getValidDateOrNull(deserialized));\n  }\n\n  /**\n   * Implemented as a part of `ControlValueAccessor`.\n   * @docs-private\n   */\n  registerOnChange(fn: (value: any) => void): void {\n    this._onChange = fn;\n  }\n\n  /**\n   * Implemented as a part of `ControlValueAccessor`.\n   * @docs-private\n   */\n  registerOnTouched(fn: () => void): void {\n    this._onTouched = fn;\n  }\n\n  /**\n   * Implemented as a part of `ControlValueAccessor`.\n   * @docs-private\n   */\n  setDisabledState(isDisabled: boolean): void {\n    this._accessorDisabled.set(isDisabled);\n  }\n\n  /**\n   * Implemented as a part of `Validator`.\n   * @docs-private\n   */\n  validate(control: AbstractControl): ValidationErrors | null {\n    return this._validator(control);\n  }\n\n  /**\n   * Implemented as a part of `Validator`.\n   * @docs-private\n   */\n  registerOnValidatorChange(fn: () => void): void {\n    this._validatorOnChange = fn;\n  }\n\n  /** Gets the element to which the timepicker popup should be attached. */\n  getOverlayOrigin(): ElementRef<HTMLElement> {\n    return this._formField?.getConnectedOverlayOrigin() || this._elementRef;\n  }\n\n  /** Focuses the input. */\n  focus(): void {\n    this._elementRef.nativeElement.focus();\n  }\n\n  ngOnDestroy(): void {\n    this._cleanupClick();\n    this._timepickerSubscription?.unsubscribe();\n    this._localeSubscription.unsubscribe();\n  }\n\n  /** Gets the ID of the input's label. */\n  getLabelId(): string | null {\n    return this._formField?.getLabelId() || null;\n  }\n\n  /** Handles clicks on the input or the containing form field. */\n  private _handleClick = (event: MouseEvent): void => {\n    if (this.disabled() || !this.openOnClick()) {\n      return;\n    }\n\n    const target = _getEventTarget(event) as Node | null;\n    const overlayHost = this.timepicker()._getOverlayHost();\n\n    if (!target || !overlayHost || !overlayHost.contains(target)) {\n      this.timepicker().open();\n    }\n  };\n\n  /** Handles the `input` event. */\n  protected _handleInput(event: Event) {\n    const value = (event.target as HTMLInputElement).value;\n    const currentValue = this.value();\n    const date = this._dateAdapter.parseTime(value, this._dateFormats.parse.timeInput);\n    const hasChanged = !this._dateAdapter.sameTime(date, currentValue);\n\n    if (!date || hasChanged || !!(value && !currentValue)) {\n      // We need to fire the CVA change event for all nulls, otherwise the validators won't run.\n      this._assignUserSelection(date, true);\n    } else {\n      // Call the validator even if the value hasn't changed since\n      // some fields change depending on what the user has entered.\n      this._validatorOnChange?.();\n    }\n  }\n\n  /** Handles the `blur` event. */\n  protected _handleBlur() {\n    const value = this.value();\n\n    // Only reformat on blur so the value doesn't change while the user is interacting.\n    if (value && this._isValid(value)) {\n      this._formatValue(value);\n    }\n\n    if (!this.timepicker().isOpen()) {\n      this._onTouched?.();\n    }\n  }\n\n  /** Handles the `keydown` event. */\n  protected _handleKeydown(event: KeyboardEvent) {\n    // All keyboard events while open are handled through the timepicker.\n    if (this.timepicker().isOpen() || this.disabled()) {\n      return;\n    }\n\n    if (event.keyCode === ESCAPE && !hasModifierKey(event) && this.value() !== null) {\n      event.preventDefault();\n      this.value.set(null);\n      this._formatValue(null);\n    } else if (event.keyCode === DOWN_ARROW || event.keyCode === UP_ARROW) {\n      event.preventDefault();\n      this.timepicker().open();\n    }\n  }\n\n  /** Called by the timepicker to sync up the user-selected value. */\n  timepickerValueAssigned(value: D | null) {\n    if (!this._dateAdapter.sameTime(value, this.value())) {\n      this._assignUserSelection(value, true);\n      this._formatValue(value);\n    }\n  }\n\n  /** Sets up the code that watches for changes in the value and adjusts the input. */\n  private _respondToValueChanges(): void {\n    effect(() => {\n      const value = this._dateAdapter.deserialize(this.value());\n      const wasValid = this._lastValueValid;\n      this._lastValueValid = this._isValid(value);\n\n      // Reformat the value if it changes while the user isn't interacting.\n      if (!this._hasFocus()) {\n        this._formatValue(value);\n      }\n\n      if (value && this._lastValueValid) {\n        this._lastValidDate = value;\n      }\n\n      // Trigger the validator if the state changed.\n      if (wasValid !== this._lastValueValid) {\n        this._validatorOnChange?.();\n      }\n    });\n  }\n\n  /** Sets up the logic that registers the input with the timepicker. */\n  private _registerTimepicker(): void {\n    effect(() => {\n      const timepicker = this.timepicker();\n      timepicker.registerInput(this);\n      timepicker.closed.subscribe(() => this._onTouched?.());\n    });\n  }\n\n  /** Sets up the logic that adjusts the input if the min/max changes. */\n  private _respondToMinMaxChanges(): void {\n    effect(() => {\n      // Read the min/max so the effect knows when to fire.\n      this.min();\n      this.max();\n      this._validatorOnChange?.();\n    });\n  }\n\n  /**\n   * Assigns a value set by the user to the input's model.\n   * @param selection Time selected by the user that should be assigned.\n   * @param propagateToAccessor Whether the value should be propagated to the ControlValueAccessor.\n   */\n  private _assignUserSelection(selection: D | null, propagateToAccessor: boolean) {\n    let toAssign: D | null;\n\n    if (selection == null || !this._isValid(selection)) {\n      toAssign = selection;\n    } else {\n      // If a datepicker and timepicker are writing to the same object and the user enters an\n      // invalid time into the timepicker, we may end up clearing their selection from the\n      // datepicker. If the user enters a valid time afterwards, the datepicker's selection will\n      // have been lost. This logic restores the previously-valid date and sets its time to\n      // the newly-selected time.\n      const adapter = this._dateAdapter;\n      const target = adapter.getValidDateOrNull(this._lastValidDate || this.value());\n      const hours = adapter.getHours(selection);\n      const minutes = adapter.getMinutes(selection);\n      const seconds = adapter.getSeconds(selection);\n      toAssign = target ? adapter.setTime(target, hours, minutes, seconds) : selection;\n    }\n\n    // Propagate to the form control before emitting to `valueChange`.\n    if (propagateToAccessor) {\n      this._onChange?.(toAssign);\n    }\n\n    this.value.set(toAssign);\n  }\n\n  /** Formats the current value and assigns it to the input. */\n  private _formatValue(value: D | null): void {\n    value = this._dateAdapter.getValidDateOrNull(value);\n    this._elementRef.nativeElement.value =\n      value == null ? '' : this._dateAdapter.format(value, this._dateFormats.display.timeInput);\n  }\n\n  /** Checks whether a value is valid. */\n  private _isValid(value: D | null): boolean {\n    return !value || this._dateAdapter.isValid(value);\n  }\n\n  /** Transforms an arbitrary value into a value that can be assigned to a date-based input. */\n  private _transformDateInput<D>(value: unknown): D | null {\n    const date =\n      typeof value === 'string'\n        ? this._dateAdapter.parseTime(value, this._dateFormats.parse.timeInput)\n        : this._dateAdapter.deserialize(value);\n    return date && this._dateAdapter.isValid(date) ? (date as D) : null;\n  }\n\n  /** Whether the input is currently focused. */\n  private _hasFocus(): boolean {\n    return _getFocusedElementPierceShadowDom() === this._elementRef.nativeElement;\n  }\n\n  /** Gets a function that can be used to validate the input. */\n  private _getValidator(): ValidatorFn {\n    return Validators.compose([\n      () =>\n        this._lastValueValid\n          ? null\n          : {'matTimepickerParse': {'text': this._elementRef.nativeElement.value}},\n      control => {\n        const controlValue = this._dateAdapter.getValidDateOrNull(\n          this._dateAdapter.deserialize(control.value),\n        );\n        const min = this.min();\n        return !min || !controlValue || this._dateAdapter.compareTime(min, controlValue) <= 0\n          ? null\n          : {'matTimepickerMin': {'min': min, 'actual': controlValue}};\n      },\n      control => {\n        const controlValue = this._dateAdapter.getValidDateOrNull(\n          this._dateAdapter.deserialize(control.value),\n        );\n        const max = this.max();\n        return !max || !controlValue || this._dateAdapter.compareTime(max, controlValue) >= 0\n          ? null\n          : {'matTimepickerMax': {'max': max, 'actual': controlValue}};\n      },\n    ])!;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  booleanAttribute,\n  ChangeDetectionStrategy,\n  Component,\n  computed,\n  HostAttributeToken,\n  inject,\n  input,\n  InputSignal,\n  InputSignalWithTransform,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {MatIconButton} from '../button';\nimport {MAT_TIMEPICKER_CONFIG} from './util';\nimport type {MatTimepicker} from './timepicker';\n\n/** Button that can be used to open a `mat-timepicker`. */\n@Component({\n  selector: 'mat-timepicker-toggle',\n  templateUrl: 'timepicker-toggle.html',\n  host: {\n    'class': 'mat-timepicker-toggle',\n    '[attr.tabindex]': 'null',\n    // Bind the `click` on the host, rather than the inner `button`, so that we can call\n    // `stopPropagation` on it without affecting the user's `click` handlers. We need to stop\n    // it so that the input doesn't get focused automatically by the form field (See #21836).\n    '(click)': '_open($event)',\n  },\n  exportAs: 'matTimepickerToggle',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [MatIconButton],\n})\nexport class MatTimepickerToggle<D> {\n  private _defaultConfig = inject(MAT_TIMEPICKER_CONFIG, {optional: true});\n  private _defaultTabIndex = (() => {\n    const value = inject(new HostAttributeToken('tabindex'), {optional: true});\n    const parsed = Number(value);\n    return isNaN(parsed) ? null : parsed;\n  })();\n\n  protected _isDisabled = computed(() => {\n    const timepicker = this.timepicker();\n    return this.disabled() || timepicker.disabled();\n  });\n\n  /** Timepicker instance that the button will toggle. */\n  readonly timepicker: InputSignal<MatTimepicker<D>> = input.required<MatTimepicker<D>>({\n    alias: 'for',\n  });\n\n  /** Screen-reader label for the button. */\n  readonly ariaLabel = input<string | undefined>(undefined, {\n    alias: 'aria-label',\n  });\n\n  /** Screen-reader labelled by id for the button. */\n  readonly ariaLabelledby = input<string | undefined>(undefined, {\n    alias: 'aria-labelledby',\n  });\n\n  /** Default aria-label for the toggle if none is provided. */\n  private readonly _defaultAriaLabel = 'Open timepicker options';\n\n  /** Whether the toggle button is disabled. */\n  readonly disabled: InputSignalWithTransform<boolean, unknown> = input(false, {\n    transform: booleanAttribute,\n    alias: 'disabled',\n  });\n\n  /** Tabindex for the toggle. */\n  readonly tabIndex: InputSignal<number | null> = input(this._defaultTabIndex);\n\n  /** Whether ripples on the toggle should be disabled. */\n  readonly disableRipple: InputSignalWithTransform<boolean, unknown> = input(\n    this._defaultConfig?.disableRipple ?? false,\n    {transform: booleanAttribute},\n  );\n\n  /** Opens the connected timepicker. */\n  protected _open(event: Event): void {\n    if (this.timepicker() && !this._isDisabled()) {\n      this.timepicker().open();\n      event.stopPropagation();\n    }\n  }\n\n  /**\n   * Checks for ariaLabelledby and if empty uses custom\n   * aria-label or defaultAriaLabel if neither is provided.\n   */\n  getAriaLabel(): string | null {\n    return this.ariaLabelledby() ? null : this.ariaLabel() || this._defaultAriaLabel;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {CdkScrollableModule} from '@angular/cdk/scrolling';\nimport {MatTimepicker} from './timepicker';\nimport {MatTimepickerInput} from './timepicker-input';\nimport {MatTimepickerToggle} from './timepicker-toggle';\n\n@NgModule({\n  imports: [MatTimepicker, MatTimepickerInput, MatTimepickerToggle],\n  exports: [CdkScrollableModule, MatTimepicker, MatTimepickerInput, MatTimepickerToggle],\n})\nexport class MatTimepickerModule {}\n"],"names":["MAT_TIMEPICKER_CONFIG","InjectionToken","parseInterval","value","result","trim","length","match","INTERVAL_PATTERN","amount","unit","parsed","toLowerCase","isNaN","MAT_TIMEPICKER_SCROLL_STRATEGY","providedIn","createRepositionScrollStrategy","MatTimepicker","_dir","inject","Directionality","optional","_viewContainerRef","ViewContainerRef","_scrollStrategyFactory","_animationsDisabled","_isOpen","signal","ngDevMode","debugName","_activeDescendant","_input","_overlayRef","_portal","_optionsCacheKey","_localeChanges","_onOpenRender","_panelTemplate","viewChild","required","_timeOptions","viewChildren","MatOption","_keyManager","ActiveDescendantKeyManager","_options","_injector","withHomeAndEnd","withPageUpDown","withVerticalOrientation","input","_defaultConfig","interval","transform","isOpen","asReadonly","closed","output","disableRipple","booleanAttribute","alias","computed","disabled","constructor","validateAdapter","_dateAdapter","_dateFormats","effect","options","Error","ElementRef","change","subscribe","set","activeItem","id","open","overlayRef","updateSize","width","getOverlayOrigin","nativeElement","offsetWidth","hasAttached","attach","destroy","afterNextRender","_syncSelectedState","emit","registerInput","currentInput","ngOnDestroy","unsubscribe","_getOverlayHost","hostElement","close","forEach","current","option","deselect","timepickerValueAssigned","selected","source","ariaLabel","ariaLabelledby","getLabelId","event","animationName","detach","positionStrategy","createFlexibleConnectedPositionStrategy","withFlexibleDimensions","withPush","withTransformOriginOn","overlayX","decorators","exportAs","changeDetection","ChangeDetectionStrategy","OnPush","encapsulation","ViewEncapsulation","None","imports","providers","provide","MAT_OPTION_PARENT_COMPONENT","styles","ctorParameters","MatTimepickerInput","_elementRef","DateAdapter","_formField","MAT_FORM_FIELD","_onTouched","_cleanupClick","_accessorDisabled","_localeSubscription","_validator","_lastValueValid","_lastValidDate","_ariaActiveDescendant","timepicker","activeDescendant","model","min","_transformDateInput","disabledInput","renderer","Renderer2","_getValidator","_respondToValueChanges","_respondToMinMaxChanges","_registerTimepicker","localeChanges","_formatValue","listen","_handleClick","registerOnChange","fn","_onChange","registerOnTouched","isDisabled","validate","control","registerOnValidatorChange","focus","target","_getEventTarget","overlayHost","parseTime","parse","timeInput","_assignUserSelection","_validatorOnChange","_handleBlur","_isValid","_handleKeydown","keyCode","DOWN_ARROW","UP_ARROW","sameTime","deserialize","wasValid","max","selection","propagateToAccessor","toAssign","adapter","getValidDateOrNull","hours","getHours","MAT_INPUT_VALUE_ACCESSOR","ngImport","i0","minVersion","version","type","Directive","host","NG_VALUE_ACCESSOR","useExisting","multi","NG_VALIDATORS","_defaultTabIndex","HostAttributeToken","Number","_isDisabled","undefined","MatIconButton","template","MatTimepickerModule","ɵfac","ɵɵngDeclareFactory","deps","ɵɵFactoryTarget","NgModule","ɵmod","ɵɵngDeclareNgModule","MatTimepickerToggle","exports","CdkScrollableModule"],"mappings":"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"}