{"version":3,"file":"select.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/select/select-errors.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/select/select.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/select/select-module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n// Note that these have been copied over verbatim from\n// `material/select` so that we don't have to expose them publicly.\n\n/**\n * Returns an exception to be thrown when attempting to change a select's `multiple` option\n * after initialization.\n * @docs-private\n */\nexport function getMatSelectDynamicMultipleError(): Error {\n  return Error('Cannot change `multiple` mode of select after initialization.');\n}\n\n/**\n * Returns an exception to be thrown when attempting to assign a non-array value to a select\n * in `multiple` mode. Note that `undefined` and `null` are still valid values to allow for\n * resetting the value.\n * @docs-private\n */\nexport function getMatSelectNonArrayValueError(): Error {\n  return Error('Value must be an array in multiple-selection mode.');\n}\n\n/**\n * Returns an exception to be thrown when assigning a non-function value to the comparator\n * used to determine if a value corresponds to an option. Note that whether the function\n * actually takes two values and returns a boolean is not checked.\n */\nexport function getMatSelectNonFunctionValueError(): Error {\n  return Error('`compareWith` must be a function.');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  _IdGenerator,\n  ActiveDescendantKeyManager,\n  addAriaReferencedId,\n  LiveAnnouncer,\n  removeAriaReferencedId,\n} from '@angular/cdk/a11y';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {SelectionModel} from '@angular/cdk/collections';\nimport {\n  A,\n  DOWN_ARROW,\n  ENTER,\n  ESCAPE,\n  hasModifierKey,\n  LEFT_ARROW,\n  RIGHT_ARROW,\n  SPACE,\n  UP_ARROW,\n} from '@angular/cdk/keycodes';\nimport {\n  CdkConnectedOverlay,\n  CdkOverlayOrigin,\n  ConnectedPosition,\n  createRepositionScrollStrategy,\n  ScrollStrategy,\n} from '@angular/cdk/overlay';\nimport {ViewportRuler} from '@angular/cdk/scrolling';\nimport {\n  AfterContentInit,\n  booleanAttribute,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChild,\n  ContentChildren,\n  Directive,\n  DoCheck,\n  ElementRef,\n  EventEmitter,\n  inject,\n  InjectionToken,\n  Input,\n  numberAttribute,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Output,\n  QueryList,\n  SimpleChanges,\n  ViewChild,\n  ViewEncapsulation,\n  HostAttributeToken,\n  Renderer2,\n  Injector,\n  signal,\n} from '@angular/core';\nimport {\n  AbstractControl,\n  ControlValueAccessor,\n  FormGroupDirective,\n  NgControl,\n  NgForm,\n  Validators,\n} from '@angular/forms';\nimport {\n  _animationsDisabled,\n  _countGroupLabelsBeforeOption,\n  _ErrorStateTracker,\n  _getOptionScrollPosition,\n  ErrorStateMatcher,\n  MAT_OPTGROUP,\n  MAT_OPTION_PARENT_COMPONENT,\n  MatOptgroup,\n  MatOption,\n  MatOptionSelectionChange,\n} from '../core';\nimport {MAT_FORM_FIELD, MatFormField, MatFormFieldControl} from '../form-field';\nimport {defer, merge, Observable, Subject} from 'rxjs';\nimport {filter, map, startWith, switchMap, take, takeUntil} from 'rxjs/operators';\nimport {\n  getMatSelectDynamicMultipleError,\n  getMatSelectNonArrayValueError,\n  getMatSelectNonFunctionValueError,\n} from './select-errors';\nimport {NgClass} from '@angular/common';\n\n/** Injection token that determines the scroll handling while a select is open. */\nexport const MAT_SELECT_SCROLL_STRATEGY = new InjectionToken<() => ScrollStrategy>(\n  'mat-select-scroll-strategy',\n  {\n    providedIn: 'root',\n    factory: () => {\n      const injector = inject(Injector);\n      return () => createRepositionScrollStrategy(injector);\n    },\n  },\n);\n\n/** Object that can be used to configure the default options for the select module. */\nexport interface MatSelectConfig {\n  /** Whether option centering should be disabled. */\n  disableOptionCentering?: boolean;\n\n  /** Time to wait in milliseconds after the last keystroke before moving focus to an item. */\n  typeaheadDebounceInterval?: number;\n\n  /** Class or list of classes to be applied to the menu's overlay panel. */\n  overlayPanelClass?: string | string[];\n\n  /** Whether icon indicators should be hidden for single-selection. */\n  hideSingleSelectionIndicator?: boolean;\n\n  /**\n   * Width of the panel. If set to `auto`, the panel will match the trigger width.\n   * If set to null or an empty string, the panel will grow to match the longest option's text.\n   */\n  panelWidth?: string | number | null;\n\n  /**\n   * Whether nullable options can be selected by default.\n   * See `MatSelect.canSelectNullableOptions` for more information.\n   */\n  canSelectNullableOptions?: boolean;\n}\n\n/** Injection token that can be used to provide the default options the select module. */\nexport const MAT_SELECT_CONFIG = new InjectionToken<MatSelectConfig>('MAT_SELECT_CONFIG');\n\n/**\n * Injection token that can be used to reference instances of `MatSelectTrigger`. It serves as\n * alternative token to the actual `MatSelectTrigger` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const MAT_SELECT_TRIGGER = new InjectionToken<MatSelectTrigger>('MatSelectTrigger');\n\n/** Change event object that is emitted when the select value has changed. */\nexport class MatSelectChange<T = any> {\n  constructor(\n    /** Reference to the select that emitted the change event. */\n    public source: MatSelect,\n    /** Current value of the select that emitted the event. */\n    public value: T,\n  ) {}\n}\n\n@Component({\n  selector: 'mat-select',\n  exportAs: 'matSelect',\n  templateUrl: 'select.html',\n  styleUrl: 'select.css',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  host: {\n    'role': 'combobox',\n    'aria-haspopup': 'listbox',\n    'class': 'mat-mdc-select',\n    '[attr.id]': 'id',\n    '[attr.tabindex]': 'disabled ? -1 : tabIndex',\n    '[attr.aria-controls]': 'panelOpen ? id + \"-panel\" : null',\n    '[attr.aria-expanded]': 'panelOpen',\n    '[attr.aria-label]': 'ariaLabel || null',\n    '[attr.aria-required]': 'required.toString()',\n    '[attr.aria-disabled]': 'disabled.toString()',\n    '[attr.aria-invalid]': 'errorState',\n    '[attr.aria-activedescendant]': '_getAriaActiveDescendant()',\n    '[class.mat-mdc-select-disabled]': 'disabled',\n    '[class.mat-mdc-select-invalid]': 'errorState',\n    '[class.mat-mdc-select-required]': 'required',\n    '[class.mat-mdc-select-empty]': 'empty',\n    '[class.mat-mdc-select-multiple]': 'multiple',\n    '[class.mat-select-open]': 'panelOpen',\n    '(keydown)': '_handleKeydown($event)',\n    '(focus)': '_onFocus()',\n    '(blur)': '_onBlur()',\n  },\n  providers: [\n    {provide: MatFormFieldControl, useExisting: MatSelect},\n    {provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatSelect},\n  ],\n  imports: [CdkOverlayOrigin, CdkConnectedOverlay, NgClass],\n})\nexport class MatSelect\n  implements\n    AfterContentInit,\n    OnChanges,\n    OnDestroy,\n    OnInit,\n    DoCheck,\n    ControlValueAccessor,\n    MatFormFieldControl<any>\n{\n  protected _viewportRuler = inject(ViewportRuler);\n  protected _changeDetectorRef = inject(ChangeDetectorRef);\n  readonly _elementRef = inject(ElementRef);\n  private _dir = inject(Directionality, {optional: true});\n  private _idGenerator = inject(_IdGenerator);\n  private _renderer = inject(Renderer2);\n  protected _parentFormField = inject<MatFormField>(MAT_FORM_FIELD, {optional: true});\n  ngControl = inject(NgControl, {self: true, optional: true})!;\n  private _liveAnnouncer = inject(LiveAnnouncer);\n  protected _defaultOptions = inject(MAT_SELECT_CONFIG, {optional: true});\n  protected _animationsDisabled = _animationsDisabled();\n  private _initialized = new Subject();\n  private _cleanupDetach: (() => void) | undefined;\n\n  /** All of the defined select options. */\n  @ContentChildren(MatOption, {descendants: true}) options: QueryList<MatOption>;\n\n  // TODO(crisbeto): this is only necessary for the non-MDC select, but it's technically a\n  // public API so we have to keep it. It should be deprecated and removed eventually.\n  /** All of the defined groups of options. */\n  @ContentChildren(MAT_OPTGROUP, {descendants: true}) optionGroups: QueryList<MatOptgroup>;\n\n  /** User-supplied override of the trigger element. */\n  @ContentChild(MAT_SELECT_TRIGGER) customTrigger: MatSelectTrigger;\n\n  /**\n   * This position config ensures that the top \"start\" corner of the overlay\n   * is aligned with with the top \"start\" of the origin by default (overlapping\n   * the trigger completely). If the panel cannot fit below the trigger, it\n   * will fall back to a position above the trigger.\n   */\n  _positions: ConnectedPosition[] = [\n    {\n      originX: 'start',\n      originY: 'bottom',\n      overlayX: 'start',\n      overlayY: 'top',\n    },\n    {\n      originX: 'end',\n      originY: 'bottom',\n      overlayX: 'end',\n      overlayY: 'top',\n    },\n    {\n      originX: 'start',\n      originY: 'top',\n      overlayX: 'start',\n      overlayY: 'bottom',\n      panelClass: 'mat-mdc-select-panel-above',\n    },\n    {\n      originX: 'end',\n      originY: 'top',\n      overlayX: 'end',\n      overlayY: 'bottom',\n      panelClass: 'mat-mdc-select-panel-above',\n    },\n  ];\n\n  /** Scrolls a particular option into the view. */\n  _scrollOptionIntoView(index: number): void {\n    const option = this.options.toArray()[index];\n\n    if (option) {\n      const panel: HTMLElement = this.panel.nativeElement;\n      const labelCount = _countGroupLabelsBeforeOption(index, this.options, this.optionGroups);\n      const element = option._getHostElement();\n\n      if (index === 0 && labelCount === 1) {\n        // If we've got one group label before the option and we're at the top option,\n        // scroll the list to the top. This is better UX than scrolling the list to the\n        // top of the option, because it allows the user to read the top group's label.\n        panel.scrollTop = 0;\n      } else {\n        panel.scrollTop = _getOptionScrollPosition(\n          element.offsetTop,\n          element.offsetHeight,\n          panel.scrollTop,\n          panel.offsetHeight,\n        );\n      }\n    }\n  }\n\n  /** Called when the panel has been opened and the overlay has settled on its final position. */\n  private _positioningSettled() {\n    this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0);\n  }\n\n  /** Creates a change event object that should be emitted by the select. */\n  private _getChangeEvent(value: any) {\n    return new MatSelectChange(this, value);\n  }\n\n  /** Factory function used to create a scroll strategy for this select. */\n  private _scrollStrategyFactory = inject(MAT_SELECT_SCROLL_STRATEGY);\n\n  /** Whether or not the overlay panel is open. */\n  private _panelOpen = false;\n\n  /** Comparison function to specify which option is displayed. Defaults to object equality. */\n  private _compareWith = (o1: any, o2: any) => o1 === o2;\n\n  /** Unique id for this input. */\n  private _uid = this._idGenerator.getId('mat-select-');\n\n  /** Current `aria-labelledby` value for the select trigger. */\n  private _triggerAriaLabelledBy: string | null = null;\n\n  /**\n   * Keeps track of the previous form control assigned to the select.\n   * Used to detect if it has changed.\n   */\n  private _previousControl: AbstractControl | null | undefined;\n\n  /** Emits whenever the component is destroyed. */\n  protected readonly _destroy = new Subject<void>();\n\n  /** Tracks the error state of the select. */\n  private _errorStateTracker: _ErrorStateTracker;\n\n  /**\n   * Emits whenever the component state changes and should cause the parent\n   * form-field to update. Implemented as part of `MatFormFieldControl`.\n   * @docs-private\n   */\n  readonly stateChanges = new Subject<void>();\n\n  /**\n   * Disable the automatic labeling to avoid issues like #27241.\n   * @docs-private\n   */\n  readonly disableAutomaticLabeling = true;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input('aria-describedby') userAriaDescribedBy: string;\n\n  /** Deals with the selection logic. */\n  _selectionModel: SelectionModel<MatOption>;\n\n  /** Manages keyboard events for options in the panel. */\n  _keyManager: ActiveDescendantKeyManager<MatOption>;\n\n  /** Ideal origin for the overlay panel. */\n  _preferredOverlayOrigin: CdkOverlayOrigin | ElementRef | undefined;\n\n  /** Width of the overlay panel. */\n  _overlayWidth: string | number;\n\n  /** `View -> model callback called when value changes` */\n  _onChange: (value: any) => void = () => {};\n\n  /** `View -> model callback called when select has been touched` */\n  _onTouched = () => {};\n\n  /** ID for the DOM node containing the select's value. */\n  _valueId = this._idGenerator.getId('mat-select-value-');\n\n  /** Strategy that will be used to handle scrolling while the select panel is open. */\n  _scrollStrategy: ScrollStrategy;\n\n  _overlayPanelClass: string | string[] = this._defaultOptions?.overlayPanelClass || '';\n\n  /** Whether the select is focused. */\n  get focused(): boolean {\n    return this._focused || this._panelOpen;\n  }\n  private _focused = false;\n\n  /** A name for this control that can be used by `mat-form-field`. */\n  controlType = 'mat-select';\n\n  /** Trigger that opens the select. */\n  @ViewChild('trigger') trigger: ElementRef;\n\n  /** Panel containing the select options. */\n  @ViewChild('panel') panel: ElementRef;\n\n  /** Overlay pane containing the options. */\n  @ViewChild(CdkConnectedOverlay)\n  protected _overlayDir: CdkConnectedOverlay;\n\n  /** Classes to be passed to the select panel. Supports the same syntax as `ngClass`. */\n  @Input() panelClass: string | string[] | Set<string> | {[key: string]: any};\n\n  /** Whether the select is disabled. */\n  @Input({transform: booleanAttribute})\n  disabled: boolean = false;\n\n  /** Whether ripples in the select are disabled. */\n  @Input({transform: booleanAttribute})\n  get disableRipple() {\n    return this._disableRipple();\n  }\n  set disableRipple(value: boolean) {\n    this._disableRipple.set(value);\n  }\n  private _disableRipple = signal(false);\n\n  /** Tab index of the select. */\n  @Input({\n    transform: (value: unknown) => (value == null ? 0 : numberAttribute(value)),\n  })\n  tabIndex: number = 0;\n\n  /** Whether checkmark indicator for single-selection options is hidden. */\n  @Input({transform: booleanAttribute})\n  get hideSingleSelectionIndicator(): boolean {\n    return this._hideSingleSelectionIndicator;\n  }\n  set hideSingleSelectionIndicator(value: boolean) {\n    this._hideSingleSelectionIndicator = value;\n    this._syncParentProperties();\n  }\n  private _hideSingleSelectionIndicator: boolean =\n    this._defaultOptions?.hideSingleSelectionIndicator ?? false;\n\n  /** Placeholder to be shown if no value has been selected. */\n  @Input()\n  get placeholder(): string {\n    return this._placeholder;\n  }\n  set placeholder(value: string) {\n    this._placeholder = value;\n    this.stateChanges.next();\n  }\n  private _placeholder: string;\n\n  /** Whether the component is required. */\n  @Input({transform: booleanAttribute})\n  get required(): boolean {\n    return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;\n  }\n  set required(value: boolean) {\n    this._required = value;\n    this.stateChanges.next();\n  }\n  private _required: boolean | undefined;\n\n  /** Whether the user should be allowed to select multiple options. */\n  @Input({transform: booleanAttribute})\n  get multiple(): boolean {\n    return this._multiple;\n  }\n  set multiple(value: boolean) {\n    if (this._selectionModel && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatSelectDynamicMultipleError();\n    }\n\n    this._multiple = value;\n  }\n  private _multiple: boolean = false;\n\n  /** Whether to center the active option over the trigger. */\n  @Input({transform: booleanAttribute})\n  disableOptionCentering = this._defaultOptions?.disableOptionCentering ?? false;\n\n  /**\n   * Function to compare the option values with the selected values. The first argument\n   * is a value from an option. The second is a value from the selection. A boolean\n   * should be returned.\n   */\n  @Input()\n  get compareWith() {\n    return this._compareWith;\n  }\n  set compareWith(fn: (o1: any, o2: any) => boolean) {\n    if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatSelectNonFunctionValueError();\n    }\n    this._compareWith = fn;\n    if (this._selectionModel) {\n      // A different comparator means the selection could change.\n      this._initializeSelection();\n    }\n  }\n\n  /** Value of the select control. */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(newValue: any) {\n    const hasAssigned = this._assignValue(newValue);\n\n    if (hasAssigned) {\n      this._onChange(newValue);\n    }\n  }\n  private _value: any;\n\n  /** Aria label of the select. */\n  @Input('aria-label') ariaLabel: string = '';\n\n  /** Input that can be used to specify the `aria-labelledby` attribute. */\n  @Input('aria-labelledby') ariaLabelledby: string;\n\n  /** Object used to control when error messages are shown. */\n  @Input()\n  get errorStateMatcher() {\n    return this._errorStateTracker.matcher;\n  }\n  set errorStateMatcher(value: ErrorStateMatcher) {\n    this._errorStateTracker.matcher = value;\n  }\n\n  /** Time to wait in milliseconds after the last keystroke before moving focus to an item. */\n  @Input({transform: numberAttribute})\n  typeaheadDebounceInterval: number;\n\n  /**\n   * Function used to sort the values in a select in multiple mode.\n   * Follows the same logic as `Array.prototype.sort`.\n   */\n  @Input() sortComparator: (a: MatOption, b: MatOption, options: MatOption[]) => number;\n\n  /** Unique id of the element. */\n  @Input()\n  get id(): string {\n    return this._id;\n  }\n  set id(value: string) {\n    this._id = value || this._uid;\n    this.stateChanges.next();\n  }\n  private _id: string;\n\n  /** Whether the select is in an error state. */\n  get errorState() {\n    return this._errorStateTracker.errorState;\n  }\n  set errorState(value: boolean) {\n    this._errorStateTracker.errorState = value;\n  }\n\n  /**\n   * Width of the panel. If set to `auto`, the panel will match the trigger width.\n   * If set to null or an empty string, the panel will grow to match the longest option's text.\n   */\n  @Input() panelWidth: string | number | null =\n    this._defaultOptions && typeof this._defaultOptions.panelWidth !== 'undefined'\n      ? this._defaultOptions.panelWidth\n      : 'auto';\n\n  /**\n   * By default selecting an option with a `null` or `undefined` value will reset the select's\n   * value. Enable this option if the reset behavior doesn't match your requirements and instead\n   * the nullable options should become selected. The value of this input can be controlled app-wide\n   * using the `MAT_SELECT_CONFIG` injection token.\n   */\n  @Input({transform: booleanAttribute})\n  canSelectNullableOptions: boolean = this._defaultOptions?.canSelectNullableOptions ?? false;\n\n  /** Combined stream of all of the child options' change events. */\n  readonly optionSelectionChanges: Observable<MatOptionSelectionChange> = defer(() => {\n    const options = this.options;\n\n    if (options) {\n      return options.changes.pipe(\n        startWith(options),\n        switchMap(() => merge(...options.map(option => option.onSelectionChange))),\n      );\n    }\n\n    return this._initialized.pipe(switchMap(() => this.optionSelectionChanges));\n  });\n\n  /** Event emitted when the select panel has been toggled. */\n  @Output() readonly openedChange: EventEmitter<boolean> = new EventEmitter<boolean>();\n\n  /** Event emitted when the select has been opened. */\n  @Output('opened') readonly _openedStream: Observable<void> = this.openedChange.pipe(\n    filter(o => o),\n    map(() => {}),\n  );\n\n  /** Event emitted when the select has been closed. */\n  @Output('closed') readonly _closedStream: Observable<void> = this.openedChange.pipe(\n    filter(o => !o),\n    map(() => {}),\n  );\n\n  /** Event emitted when the selected value has been changed by the user. */\n  @Output() readonly selectionChange = new EventEmitter<MatSelectChange>();\n\n  /**\n   * Event that emits whenever the raw value of the select changes. This is here primarily\n   * to facilitate the two-way binding for the `value` input.\n   * @docs-private\n   */\n  @Output() readonly valueChange: EventEmitter<any> = new EventEmitter<any>();\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const defaultErrorStateMatcher = inject(ErrorStateMatcher);\n    const parentForm = inject(NgForm, {optional: true});\n    const parentFormGroup = inject(FormGroupDirective, {optional: true});\n    const tabIndex = inject(new HostAttributeToken('tabindex'), {optional: true});\n\n    if (this.ngControl) {\n      // Note: we provide the value accessor through here, instead of\n      // the `providers` to avoid running into a circular import.\n      this.ngControl.valueAccessor = this;\n    }\n\n    // Note that we only want to set this when the defaults pass it in, otherwise it should\n    // stay as `undefined` so that it falls back to the default in the key manager.\n    if (this._defaultOptions?.typeaheadDebounceInterval != null) {\n      this.typeaheadDebounceInterval = this._defaultOptions.typeaheadDebounceInterval;\n    }\n\n    this._errorStateTracker = new _ErrorStateTracker(\n      defaultErrorStateMatcher,\n      this.ngControl,\n      parentFormGroup,\n      parentForm,\n      this.stateChanges,\n    );\n    this._scrollStrategy = this._scrollStrategyFactory();\n    this.tabIndex = tabIndex == null ? 0 : parseInt(tabIndex) || 0;\n\n    // Force setter to be called in case id was not specified.\n    this.id = this.id;\n  }\n\n  ngOnInit() {\n    this._selectionModel = new SelectionModel<MatOption>(this.multiple);\n    this.stateChanges.next();\n    this._viewportRuler\n      .change()\n      .pipe(takeUntil(this._destroy))\n      .subscribe(() => {\n        if (this.panelOpen) {\n          this._overlayWidth = this._getOverlayWidth(this._preferredOverlayOrigin);\n          this._changeDetectorRef.detectChanges();\n        }\n      });\n  }\n\n  ngAfterContentInit() {\n    this._initialized.next();\n    this._initialized.complete();\n\n    this._initKeyManager();\n\n    this._selectionModel.changed.pipe(takeUntil(this._destroy)).subscribe(event => {\n      event.added.forEach(option => option.select());\n      event.removed.forEach(option => option.deselect());\n    });\n\n    this.options.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe(() => {\n      this._resetOptions();\n      this._initializeSelection();\n    });\n  }\n\n  ngDoCheck() {\n    const newAriaLabelledby = this._getTriggerAriaLabelledby();\n    const ngControl = this.ngControl;\n\n    // We have to manage setting the `aria-labelledby` ourselves, because part of its value\n    // is computed as a result of a content query which can cause this binding to trigger a\n    // \"changed after checked\" error.\n    if (newAriaLabelledby !== this._triggerAriaLabelledBy) {\n      const element: HTMLElement = this._elementRef.nativeElement;\n      this._triggerAriaLabelledBy = newAriaLabelledby;\n      if (newAriaLabelledby) {\n        element.setAttribute('aria-labelledby', newAriaLabelledby);\n      } else {\n        element.removeAttribute('aria-labelledby');\n      }\n    }\n\n    if (ngControl) {\n      // The disabled state might go out of sync if the form group is swapped out. See #17860.\n      if (this._previousControl !== ngControl.control) {\n        if (\n          this._previousControl !== undefined &&\n          ngControl.disabled !== null &&\n          ngControl.disabled !== this.disabled\n        ) {\n          this.disabled = ngControl.disabled;\n        }\n\n        this._previousControl = ngControl.control;\n      }\n\n      this.updateErrorState();\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    // Updating the disabled state is handled by the input, but we need to additionally let\n    // the parent form field know to run change detection when the disabled state changes.\n    if (changes['disabled'] || changes['userAriaDescribedBy']) {\n      this.stateChanges.next();\n    }\n\n    if (changes['typeaheadDebounceInterval'] && this._keyManager) {\n      this._keyManager.withTypeAhead(this.typeaheadDebounceInterval);\n    }\n  }\n\n  ngOnDestroy() {\n    this._cleanupDetach?.();\n    this._keyManager?.destroy();\n    this._destroy.next();\n    this._destroy.complete();\n    this.stateChanges.complete();\n    this._clearFromModal();\n  }\n\n  /** Toggles the overlay panel open or closed. */\n  toggle(): void {\n    this.panelOpen ? this.close() : this.open();\n  }\n\n  /** Opens the overlay panel. */\n  open(): void {\n    if (!this._canOpen()) {\n      return;\n    }\n\n    // It's important that we read this as late as possible, because doing so earlier will\n    // return a different element since it's based on queries in the form field which may\n    // not have run yet. Also this needs to be assigned before we measure the overlay width.\n    if (this._parentFormField) {\n      this._preferredOverlayOrigin = this._parentFormField.getConnectedOverlayOrigin();\n    }\n\n    this._cleanupDetach?.();\n    this._overlayWidth = this._getOverlayWidth(this._preferredOverlayOrigin);\n    this._applyModalPanelOwnership();\n    this._panelOpen = true;\n    this._overlayDir.positionChange.pipe(take(1)).subscribe(() => {\n      this._changeDetectorRef.detectChanges();\n      this._positioningSettled();\n    });\n    this._overlayDir.attachOverlay();\n    this._keyManager.withHorizontalOrientation(null);\n    this._highlightCorrectOption();\n    this._changeDetectorRef.markForCheck();\n\n    // Required for the MDC form field to pick up when the overlay has been opened.\n    this.stateChanges.next();\n\n    // Simulate the animation event before we moved away from `@angular/animations`.\n    Promise.resolve().then(() => this.openedChange.emit(true));\n  }\n\n  /**\n   * Track which modal we have modified the `aria-owns` attribute of. When the combobox trigger is\n   * inside an aria-modal, we apply aria-owns to the parent modal with the `id` of the options\n   * panel. Track the modal we have changed so we can undo the changes on destroy.\n   */\n  private _trackedModal: Element | null = null;\n\n  /**\n   * If the autocomplete trigger is inside of an `aria-modal` element, connect\n   * that modal to the options panel with `aria-owns`.\n   *\n   * For some browser + screen reader combinations, when navigation is inside\n   * of an `aria-modal` element, the screen reader treats everything outside\n   * of that modal as hidden or invisible.\n   *\n   * This causes a problem when the combobox trigger is _inside_ of a modal, because the\n   * options panel is rendered _outside_ of that modal, preventing screen reader navigation\n   * from reaching the panel.\n   *\n   * We can work around this issue by applying `aria-owns` to the modal with the `id` of\n   * the options panel. This effectively communicates to assistive technology that the\n   * options panel is part of the same interaction as the modal.\n   *\n   * At time of this writing, this issue is present in VoiceOver.\n   * See https://github.com/angular/components/issues/20694\n   */\n  private _applyModalPanelOwnership() {\n    // TODO(http://github.com/angular/components/issues/26853): consider de-duplicating this with\n    // the `LiveAnnouncer` and any other usages.\n    //\n    // Note that the selector here is limited to CDK overlays at the moment in order to reduce the\n    // section of the DOM we need to look through. This should cover all the cases we support, but\n    // the selector can be expanded if it turns out to be too narrow.\n    const modal = this._elementRef.nativeElement.closest(\n      'body > .cdk-overlay-container [aria-modal=\"true\"]',\n    );\n\n    if (!modal) {\n      // Most commonly, the autocomplete trigger is not inside a modal.\n      return;\n    }\n\n    const panelId = `${this.id}-panel`;\n\n    if (this._trackedModal) {\n      removeAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n    }\n\n    addAriaReferencedId(modal, 'aria-owns', panelId);\n    this._trackedModal = modal;\n  }\n\n  /** Clears the reference to the listbox overlay element from the modal it was added to. */\n  private _clearFromModal() {\n    if (!this._trackedModal) {\n      // Most commonly, the autocomplete trigger is not used inside a modal.\n      return;\n    }\n\n    const panelId = `${this.id}-panel`;\n\n    removeAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n    this._trackedModal = null;\n  }\n\n  /** Closes the overlay panel and focuses the host element. */\n  close(): void {\n    if (this._panelOpen) {\n      this._panelOpen = false;\n      this._exitAndDetach();\n      this._keyManager.withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr');\n      this._changeDetectorRef.markForCheck();\n      this._onTouched();\n      // Required for the MDC form field to pick up when the overlay has been closed.\n      this.stateChanges.next();\n\n      // Simulate the animation event before we moved away from `@angular/animations`.\n      Promise.resolve().then(() => this.openedChange.emit(false));\n    }\n  }\n\n  /** Triggers the exit animation and detaches the overlay at the end. */\n  private _exitAndDetach() {\n    if (this._animationsDisabled || !this.panel) {\n      this._detachOverlay();\n      return;\n    }\n\n    this._cleanupDetach?.();\n    this._cleanupDetach = () => {\n      cleanupEvent();\n      clearTimeout(exitFallbackTimer);\n      this._cleanupDetach = undefined;\n    };\n\n    const panel: HTMLElement = this.panel.nativeElement;\n    const cleanupEvent = this._renderer.listen(panel, 'animationend', (event: AnimationEvent) => {\n      if (event.animationName === '_mat-select-exit') {\n        this._cleanupDetach?.();\n        this._detachOverlay();\n      }\n    });\n\n    // Since closing the overlay depends on the animation, we have a fallback in case the panel\n    // doesn't animate. This can happen in some internal tests that do `* {animation: none}`.\n    const exitFallbackTimer = setTimeout(() => {\n      this._cleanupDetach?.();\n      this._detachOverlay();\n    }, 200);\n\n    panel.classList.add('mat-select-panel-exit');\n  }\n\n  /** Detaches the current overlay directive. */\n  private _detachOverlay() {\n    this._overlayDir.detachOverlay();\n    // Some of the overlay detachment logic depends on change detection.\n    // Mark for check to ensure that things get picked up in a timely manner.\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /**\n   * Sets the select's value. Part of the ControlValueAccessor interface\n   * required to integrate with Angular's core forms API.\n   *\n   * @param value New value to be written to the model.\n   */\n  writeValue(value: any): void {\n    this._assignValue(value);\n  }\n\n  /**\n   * Saves a callback function to be invoked when the select's value\n   * changes from user input. Part of the ControlValueAccessor interface\n   * required to integrate with Angular's core forms API.\n   *\n   * @param fn Callback to be triggered when the value changes.\n   */\n  registerOnChange(fn: (value: any) => void): void {\n    this._onChange = fn;\n  }\n\n  /**\n   * Saves a callback function to be invoked when the select is blurred\n   * by the user. Part of the ControlValueAccessor interface required\n   * to integrate with Angular's core forms API.\n   *\n   * @param fn Callback to be triggered when the component has been touched.\n   */\n  registerOnTouched(fn: () => {}): void {\n    this._onTouched = fn;\n  }\n\n  /**\n   * Disables the select. Part of the ControlValueAccessor interface required\n   * to integrate with Angular's core forms API.\n   *\n   * @param isDisabled Sets whether the component is disabled.\n   */\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n    this._changeDetectorRef.markForCheck();\n    this.stateChanges.next();\n  }\n\n  /** Whether or not the overlay panel is open. */\n  get panelOpen(): boolean {\n    return this._panelOpen;\n  }\n\n  /** The currently selected option. */\n  get selected(): MatOption | MatOption[] {\n    return this.multiple ? this._selectionModel?.selected || [] : this._selectionModel?.selected[0];\n  }\n\n  /** The value displayed in the trigger. */\n  get triggerValue(): string {\n    if (this.empty) {\n      return '';\n    }\n\n    if (this._multiple) {\n      const selectedOptions = this._selectionModel.selected.map(option => option.viewValue);\n\n      if (this._isRtl()) {\n        selectedOptions.reverse();\n      }\n\n      // TODO(crisbeto): delimiter should be configurable for proper localization.\n      return selectedOptions.join(', ');\n    }\n\n    return this._selectionModel.selected[0].viewValue;\n  }\n\n  /** Refreshes the error state of the select. */\n  updateErrorState() {\n    this._errorStateTracker.updateErrorState();\n  }\n\n  /** Whether the element is in RTL mode. */\n  _isRtl(): boolean {\n    return this._dir ? this._dir.value === 'rtl' : false;\n  }\n\n  /** Handles all keydown events on the select. */\n  _handleKeydown(event: KeyboardEvent): void {\n    if (!this.disabled) {\n      this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);\n    }\n  }\n\n  /** Handles keyboard events while the select is closed. */\n  private _handleClosedKeydown(event: KeyboardEvent): void {\n    const keyCode = event.keyCode;\n    const isArrowKey =\n      keyCode === DOWN_ARROW ||\n      keyCode === UP_ARROW ||\n      keyCode === LEFT_ARROW ||\n      keyCode === RIGHT_ARROW;\n    const isOpenKey = keyCode === ENTER || keyCode === SPACE;\n    const manager = this._keyManager;\n\n    // Open the select on ALT + arrow key to match the native <select>\n    if (\n      (!manager.isTyping() && isOpenKey && !hasModifierKey(event)) ||\n      ((this.multiple || event.altKey) && isArrowKey)\n    ) {\n      event.preventDefault(); // prevents the page from scrolling down when pressing space\n      this.open();\n    } else if (!this.multiple) {\n      const previouslySelectedOption = this.selected;\n      manager.onKeydown(event);\n      const selectedOption = this.selected;\n\n      // Since the value has changed, we need to announce it ourselves.\n      if (selectedOption && previouslySelectedOption !== selectedOption) {\n        // We set a duration on the live announcement, because we want the live element to be\n        // cleared after a while so that users can't navigate to it using the arrow keys.\n        this._liveAnnouncer.announce((selectedOption as MatOption).viewValue, 10000);\n      }\n    }\n  }\n\n  /** Handles keyboard events when the selected is open. */\n  private _handleOpenKeydown(event: KeyboardEvent): void {\n    const manager = this._keyManager;\n    const keyCode = event.keyCode;\n    const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;\n    const isTyping = manager.isTyping();\n\n    if (isArrowKey && event.altKey) {\n      // Close the select on ALT + arrow key to match the native <select>\n      event.preventDefault();\n      this.close();\n      // Don't do anything in this case if the user is typing,\n      // because the typing sequence can include the space key.\n    } else if (\n      !isTyping &&\n      (keyCode === ENTER || keyCode === SPACE) &&\n      manager.activeItem &&\n      !hasModifierKey(event)\n    ) {\n      event.preventDefault();\n      manager.activeItem._selectViaInteraction();\n    } else if (!isTyping && this._multiple && keyCode === A && event.ctrlKey) {\n      event.preventDefault();\n      const hasDeselectedOptions = this.options.some(opt => !opt.disabled && !opt.selected);\n\n      this.options.forEach(option => {\n        if (!option.disabled) {\n          hasDeselectedOptions ? option.select() : option.deselect();\n        }\n      });\n    } else {\n      const previouslyFocusedIndex = manager.activeItemIndex;\n\n      manager.onKeydown(event);\n\n      if (\n        this._multiple &&\n        isArrowKey &&\n        event.shiftKey &&\n        manager.activeItem &&\n        manager.activeItemIndex !== previouslyFocusedIndex\n      ) {\n        manager.activeItem._selectViaInteraction();\n      }\n    }\n  }\n\n  /** Handles keyboard events coming from the overlay. */\n  protected _handleOverlayKeydown(event: KeyboardEvent): void {\n    // TODO(crisbeto): prior to #30363 this was being handled inside the overlay directive, but we\n    // need control over the animation timing so we do it manually. We should remove the `keydown`\n    // listener from `.mat-mdc-select-panel` and handle all the events here. That may cause\n    // further test breakages so it's left for a follow-up.\n    if (event.keyCode === ESCAPE && !hasModifierKey(event)) {\n      event.preventDefault();\n      this.close();\n    }\n  }\n\n  _onFocus() {\n    if (!this.disabled) {\n      this._focused = true;\n      this.stateChanges.next();\n    }\n  }\n\n  /**\n   * Calls the touched callback only if the panel is closed. Otherwise, the trigger will\n   * \"blur\" to the panel when it opens, causing a false positive.\n   */\n  _onBlur() {\n    this._focused = false;\n    this._keyManager?.cancelTypeahead();\n\n    if (!this.disabled && !this.panelOpen) {\n      this._onTouched();\n      this._changeDetectorRef.markForCheck();\n      this.stateChanges.next();\n    }\n  }\n\n  /** Returns the theme to be used on the panel. */\n  _getPanelTheme(): string {\n    return this._parentFormField ? `mat-${this._parentFormField.color}` : '';\n  }\n\n  /** Whether the select has a value. */\n  get empty(): boolean {\n    return !this._selectionModel || this._selectionModel.isEmpty();\n  }\n\n  private _initializeSelection(): void {\n    // Defer setting the value in order to avoid the \"Expression\n    // has changed after it was checked\" errors from Angular.\n    Promise.resolve().then(() => {\n      if (this.ngControl) {\n        this._value = this.ngControl.value;\n      }\n\n      this._setSelectionByValue(this._value);\n      this.stateChanges.next();\n    });\n  }\n\n  /**\n   * Sets the selected option based on a value. If no option can be\n   * found with the designated value, the select trigger is cleared.\n   */\n  private _setSelectionByValue(value: any | any[]): void {\n    this.options.forEach(option => option.setInactiveStyles());\n    this._selectionModel.clear();\n\n    if (this.multiple && value) {\n      if (!Array.isArray(value) && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getMatSelectNonArrayValueError();\n      }\n\n      value.forEach((currentValue: any) => this._selectOptionByValue(currentValue));\n      this._sortValues();\n    } else {\n      const correspondingOption = this._selectOptionByValue(value);\n\n      // Shift focus to the active item. Note that we shouldn't do this in multiple\n      // mode, because we don't know what option the user interacted with last.\n      if (correspondingOption) {\n        this._keyManager.updateActiveItem(correspondingOption);\n      } else if (!this.panelOpen) {\n        // Otherwise reset the highlighted option. Note that we only want to do this while\n        // closed, because doing it while open can shift the user's focus unnecessarily.\n        this._keyManager.updateActiveItem(-1);\n      }\n    }\n\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /**\n   * Finds and selects and option based on its value.\n   * @returns Option that has the corresponding value.\n   */\n  private _selectOptionByValue(value: any): MatOption | undefined {\n    const correspondingOption = this.options.find((option: MatOption) => {\n      // Skip options that are already in the model. This allows us to handle cases\n      // where the same primitive value is selected multiple times.\n      if (this._selectionModel.isSelected(option)) {\n        return false;\n      }\n\n      try {\n        // Treat null as a special reset value.\n        return (\n          (option.value != null || this.canSelectNullableOptions) &&\n          this._compareWith(option.value, value)\n        );\n      } catch (error) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          // Notify developers of errors in their comparator.\n          console.warn(error);\n        }\n        return false;\n      }\n    });\n\n    if (correspondingOption) {\n      this._selectionModel.select(correspondingOption);\n    }\n\n    return correspondingOption;\n  }\n\n  /** Assigns a specific value to the select. Returns whether the value has changed. */\n  private _assignValue(newValue: any | any[]): boolean {\n    // Always re-assign an array, because it might have been mutated.\n    if (newValue !== this._value || (this._multiple && Array.isArray(newValue))) {\n      if (this.options) {\n        this._setSelectionByValue(newValue);\n      }\n\n      this._value = newValue;\n      return true;\n    }\n    return false;\n  }\n\n  // `skipPredicate` determines if key manager should avoid putting a given option in the tab\n  // order. Allow disabled list items to receive focus via keyboard to align with WAI ARIA\n  // recommendation.\n  //\n  // Normally WAI ARIA's instructions are to exclude disabled items from the tab order, but it\n  // makes a few exceptions for compound widgets.\n  //\n  // From [Developing a Keyboard Interface](\n  // https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/):\n  //   \"For the following composite widget elements, keep them focusable when disabled: Options in a\n  //   Listbox...\"\n  //\n  // The user can focus disabled options using the keyboard, but the user cannot click disabled\n  // options.\n  private _skipPredicate = (option: MatOption) => {\n    if (this.panelOpen) {\n      // Support keyboard focusing disabled options in an ARIA listbox.\n      return false;\n    }\n\n    // When the panel is closed, skip over disabled options. Support options via the UP/DOWN arrow\n    // keys on a closed select. ARIA listbox interaction pattern is less relevant when the panel is\n    // closed.\n    return option.disabled;\n  };\n\n  /** Gets how wide the overlay panel should be. */\n  private _getOverlayWidth(\n    preferredOrigin: ElementRef<ElementRef> | CdkOverlayOrigin | undefined,\n  ): string | number {\n    if (this.panelWidth === 'auto') {\n      const refToMeasure =\n        preferredOrigin instanceof CdkOverlayOrigin\n          ? preferredOrigin.elementRef\n          : preferredOrigin || this._elementRef;\n      return refToMeasure.nativeElement.getBoundingClientRect().width;\n    }\n\n    return this.panelWidth === null ? '' : this.panelWidth;\n  }\n  /** Syncs the parent state with the individual options. */\n  _syncParentProperties(): void {\n    if (this.options) {\n      for (const option of this.options) {\n        option._changeDetectorRef.markForCheck();\n      }\n    }\n  }\n\n  /** Sets up a key manager to listen to keyboard events on the overlay panel. */\n  private _initKeyManager() {\n    this._keyManager = new ActiveDescendantKeyManager<MatOption>(this.options)\n      .withTypeAhead(this.typeaheadDebounceInterval)\n      .withVerticalOrientation()\n      .withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr')\n      .withHomeAndEnd()\n      .withPageUpDown()\n      .withAllowedModifierKeys(['shiftKey'])\n      .skipPredicate(this._skipPredicate);\n\n    this._keyManager.tabOut.subscribe(() => {\n      if (this.panelOpen) {\n        // Select the active item when tabbing away. This is consistent with how the native\n        // select behaves. Note that we only want to do this in single selection mode.\n        if (!this.multiple && this._keyManager.activeItem) {\n          this._keyManager.activeItem._selectViaInteraction();\n        }\n\n        // Restore focus to the trigger before closing. Ensures that the focus\n        // position won't be lost if the user got focus into the overlay.\n        this.focus();\n        this.close();\n      }\n    });\n\n    this._keyManager.change.subscribe(() => {\n      if (this._panelOpen && this.panel) {\n        this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0);\n      } else if (!this._panelOpen && !this.multiple && this._keyManager.activeItem) {\n        this._keyManager.activeItem._selectViaInteraction();\n      }\n    });\n  }\n\n  /** Drops current option subscriptions and IDs and resets from scratch. */\n  private _resetOptions(): void {\n    const changedOrDestroyed = merge(this.options.changes, this._destroy);\n\n    this.optionSelectionChanges.pipe(takeUntil(changedOrDestroyed)).subscribe(event => {\n      this._onSelect(event.source, event.isUserInput);\n\n      if (event.isUserInput && !this.multiple && this._panelOpen) {\n        this.close();\n        this.focus();\n      }\n    });\n\n    // Listen to changes in the internal state of the options and react accordingly.\n    // Handles cases like the labels of the selected options changing.\n    merge(...this.options.map(option => option._stateChanges))\n      .pipe(takeUntil(changedOrDestroyed))\n      .subscribe(() => {\n        // `_stateChanges` can fire as a result of a change in the label's DOM value which may\n        // be the result of an expression changing. We have to use `detectChanges` in order\n        // to avoid \"changed after checked\" errors (see #14793).\n        this._changeDetectorRef.detectChanges();\n        this.stateChanges.next();\n      });\n  }\n\n  /** Invoked when an option is clicked. */\n  private _onSelect(option: MatOption, isUserInput: boolean): void {\n    const wasSelected = this._selectionModel.isSelected(option);\n\n    if (!this.canSelectNullableOptions && option.value == null && !this._multiple) {\n      option.deselect();\n      this._selectionModel.clear();\n\n      if (this.value != null) {\n        this._propagateChanges(option.value);\n      }\n    } else {\n      if (wasSelected !== option.selected) {\n        option.selected\n          ? this._selectionModel.select(option)\n          : this._selectionModel.deselect(option);\n      }\n\n      if (isUserInput) {\n        this._keyManager.setActiveItem(option);\n      }\n\n      if (this.multiple) {\n        this._sortValues();\n\n        if (isUserInput) {\n          // In case the user selected the option with their mouse, we\n          // want to restore focus back to the trigger, in order to\n          // prevent the select keyboard controls from clashing with\n          // the ones from `mat-option`.\n          this.focus();\n        }\n      }\n    }\n\n    if (wasSelected !== this._selectionModel.isSelected(option)) {\n      this._propagateChanges();\n    }\n\n    this.stateChanges.next();\n  }\n\n  /** Sorts the selected values in the selected based on their order in the panel. */\n  private _sortValues() {\n    if (this.multiple) {\n      const options = this.options.toArray();\n\n      this._selectionModel.sort((a, b) => {\n        return this.sortComparator\n          ? this.sortComparator(a, b, options)\n          : options.indexOf(a) - options.indexOf(b);\n      });\n      this.stateChanges.next();\n    }\n  }\n\n  /** Emits change event to set the model value. */\n  private _propagateChanges(fallbackValue?: any): void {\n    let valueToEmit: any;\n\n    if (this.multiple) {\n      valueToEmit = (this.selected as MatOption[]).map(option => option.value);\n    } else {\n      valueToEmit = this.selected ? (this.selected as MatOption).value : fallbackValue;\n    }\n\n    this._value = valueToEmit;\n    this.valueChange.emit(valueToEmit);\n    this._onChange(valueToEmit);\n    this.selectionChange.emit(this._getChangeEvent(valueToEmit));\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /**\n   * Highlights the selected item. If no option is selected, it will highlight\n   * the first *enabled* option.\n   */\n  private _highlightCorrectOption(): void {\n    if (this._keyManager) {\n      if (this.empty) {\n        // Find the index of the first *enabled* option. Avoid calling `_keyManager.setActiveItem`\n        // because it activates the first option that passes the skip predicate, rather than the\n        // first *enabled* option.\n        let firstEnabledOptionIndex = -1;\n        for (let index = 0; index < this.options.length; index++) {\n          const option = this.options.get(index)!;\n          if (!option.disabled) {\n            firstEnabledOptionIndex = index;\n            break;\n          }\n        }\n\n        this._keyManager.setActiveItem(firstEnabledOptionIndex);\n      } else {\n        this._keyManager.setActiveItem(this._selectionModel.selected[0]);\n      }\n    }\n  }\n\n  /** Whether the panel is allowed to open. */\n  protected _canOpen(): boolean {\n    return !this._panelOpen && !this.disabled && this.options?.length > 0 && !!this._overlayDir;\n  }\n\n  /** Focuses the select element. */\n  focus(options?: FocusOptions): void {\n    this._elementRef.nativeElement.focus(options);\n  }\n\n  /** Gets the aria-labelledby for the select panel. */\n  _getPanelAriaLabelledby(): string | null {\n    if (this.ariaLabel) {\n      return null;\n    }\n\n    const labelId = this._parentFormField?.getLabelId() || null;\n    const labelExpression = labelId ? labelId + ' ' : '';\n    return this.ariaLabelledby ? labelExpression + this.ariaLabelledby : labelId;\n  }\n\n  /** Determines the `aria-activedescendant` to be set on the host. */\n  _getAriaActiveDescendant(): string | null {\n    if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {\n      return this._keyManager.activeItem.id;\n    }\n\n    return null;\n  }\n\n  /** Gets the aria-labelledby of the select component trigger. */\n  private _getTriggerAriaLabelledby(): string | null {\n    if (this.ariaLabel) {\n      return null;\n    }\n\n    let value = this._parentFormField?.getLabelId() || '';\n\n    if (this.ariaLabelledby) {\n      value += ' ' + this.ariaLabelledby;\n    }\n\n    // The value should not be used for the trigger's aria-labelledby,\n    // but this currently \"breaks\" accessibility tests since they complain\n    // there is no aria-labelledby. This is because they are not setting an\n    // appropriate label on the form field or select.\n    // TODO: remove this conditional after fixing clients by ensuring their\n    // selects have a label applied.\n    if (!value) {\n      value = this._valueId;\n    }\n\n    return value;\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get describedByIds(): string[] {\n    const element = this._elementRef.nativeElement;\n    const existingDescribedBy = element.getAttribute('aria-describedby');\n\n    return existingDescribedBy?.split(' ') || [];\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  setDescribedByIds(ids: string[]) {\n    if (ids.length) {\n      this._elementRef.nativeElement.setAttribute('aria-describedby', ids.join(' '));\n    } else {\n      this._elementRef.nativeElement.removeAttribute('aria-describedby');\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  onContainerClick() {\n    this.focus();\n    this.open();\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get shouldLabelFloat(): boolean {\n    // Since the panel doesn't overlap the trigger, we\n    // want the label to only float when there's a value.\n    return this.panelOpen || !this.empty || (this.focused && !!this.placeholder);\n  }\n}\n\n/**\n * Allows the user to customize the trigger that is displayed when the select has a value.\n */\n@Directive({\n  selector: 'mat-select-trigger',\n  providers: [{provide: MAT_SELECT_TRIGGER, useExisting: MatSelectTrigger}],\n})\nexport class MatSelectTrigger {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {OverlayModule} from '@angular/cdk/overlay';\nimport {NgModule} from '@angular/core';\nimport {MatOptionModule} from '../core';\nimport {MatFormFieldModule} from '../form-field';\nimport {CdkScrollableModule} from '@angular/cdk/scrolling';\nimport {MatSelect, MatSelectTrigger} from './select';\nimport {BidiModule} from '@angular/cdk/bidi';\n\n@NgModule({\n  imports: [OverlayModule, MatOptionModule, MatSelect, MatSelectTrigger],\n  exports: [\n    BidiModule,\n    CdkScrollableModule,\n    MatFormFieldModule,\n    MatSelect,\n    MatSelectTrigger,\n    MatOptionModule,\n  ],\n})\nexport class MatSelectModule {}\n"],"names":["getMatSelectDynamicMultipleError","Error","getMatSelectNonArrayValueError","MAT_SELECT_SCROLL_STRATEGY","InjectionToken","providedIn","factory","injector","inject","Injector","createRepositionScrollStrategy","source","value","_viewportRuler","ViewportRuler","_changeDetectorRef","ChangeDetectorRef","Directionality","optional","_idGenerator","_IdGenerator","_parentFormField","MAT_FORM_FIELD","ngControl","self","_liveAnnouncer","LiveAnnouncer","_defaultOptions","MAT_SELECT_CONFIG","_animationsDisabled","_initialized","Subject","_cleanupDetach","optionGroups","_positions","originX","originY","overlayY","overlayX","panelClass","_scrollOptionIntoView","index","option","options","toArray","panel","nativeElement","labelCount","_countGroupLabelsBeforeOption","element","_getHostElement","scrollTop","_getOptionScrollPosition","offsetTop","offsetHeight","_positioningSettled","_keyManager","activeItemIndex","_getChangeEvent","MatSelectChange","_panelOpen","_compareWith","o1","o2","_triggerAriaLabelledBy","_previousControl","_destroy","_selectionModel","_onChange","_onTouched","overlayPanelClass","focused","trigger","disabled","disableRipple","_disableRipple","set","signal","ngDevMode","debugName","hideSingleSelectionIndicator","_hideSingleSelectionIndicator","_syncParentProperties","placeholder","stateChanges","next","_required","control","hasValidator","Validators","required","_multiple","multiple","disableOptionCentering","compareWith","fn","_initializeSelection","_value","errorStateMatcher","typeaheadDebounceInterval","sortComparator","id","_errorStateTracker","errorState","panelWidth","canSelectNullableOptions","pipe","switchMap","optionSelectionChanges","EventEmitter","openedChange","filter","o","map","constructor","defaultErrorStateMatcher","ErrorStateMatcher","valueAccessor","_ErrorStateTracker","parentFormGroup","parentForm","_scrollStrategy","_scrollStrategyFactory","tabIndex","parseInt","SelectionModel","change","takeUntil","_overlayWidth","_preferredOverlayOrigin","detectChanges","ngAfterContentInit","complete","changed","subscribe","event","added","forEach","select","changes","startWith","ngDoCheck","newAriaLabelledby","_getTriggerAriaLabelledby","_elementRef","setAttribute","undefined","updateErrorState","withTypeAhead","ngOnDestroy","destroy","_clearFromModal","toggle","panelOpen","close","open","getConnectedOverlayOrigin","_getOverlayWidth","_applyModalPanelOwnership","_overlayDir","positionChange","take","withHorizontalOrientation","_highlightCorrectOption","markForCheck","Promise","resolve","then","emit","closest","_trackedModal","modal","panelId","_exitAndDetach","_isRtl","_detachOverlay","cleanupEvent","clearTimeout","exitFallbackTimer","_renderer","listen","animationName","setTimeout","detachOverlay","writeValue","registerOnChange","setDisabledState","isDisabled","triggerValue","empty","selectedOptions","selected","viewValue","reverse","_handleClosedKeydown","keyCode","isArrowKey","DOWN_ARROW","RIGHT_ARROW","manager","isOpenKey","hasModifierKey","altKey","previouslySelectedOption","onKeydown","selectedOption","announce","_handleOpenKeydown","preventDefault","ENTER","SPACE","A","ctrlKey","hasDeselectedOptions","some","opt","deselect","previouslyFocusedIndex","shiftKey","activeItem","_selectViaInteraction","_handleOverlayKeydown","_onFocus","_focused","cancelTypeahead","isEmpty","_setSelectionByValue","setInactiveStyles","correspondingOption","_selectOptionByValue","updateActiveItem","find","Array","isArray","newValue","withHomeAndEnd","withPageUpDown","None","changeDetection","ChangeDetectionStrategy","OnPush","host","provide","MatFormFieldControl","useExisting","MatSelect","MAT_OPTION_PARENT_COMPONENT","CdkOverlayOrigin","CdkConnectedOverlay","NgClass","template","styles","ctorParameters","descendants","MAT_SELECT_TRIGGER","type","Input","ViewChild","args","transform","booleanAttribute","numberAttribute","_openedStream","minVersion","version","ngImport","i0","MatSelectModule","imports","OverlayModule","MatOptionModule","MatSelectTrigger","exports","BidiModule","decorators"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBE,SAAAA,gCAAA,GAAA;AACF,EAAA,OAAAC,KAAA,CAAA,+DAAA,CAAA;;AAUA,SAAAC,8BAAA,GAAA;;;;;;;ACwNIC,MAAAA,0BAAA,GAAAC,IAAAA,cAAA,CAAA,4BAAA,EAAA;AACEC,EAAAA,UAAA,EAAA;EACAC,OAAA,EAAAA,MAAA;AACA,IAAA,MACAC,QAAA,GAAAC,MAAA,CAAAC,QAAA,CAAkB;IAIlB,OAAA,MAAAC,8BAAc,CAAAH,QAAA,CAAA;;AAEd,CAAA;uBAIH,OAAAH,cAAA,CAAA,mBAAA;;;;;AA2DkBO,EAAAA,WAAAA,CAAAA,MAAA,EAKnBC,KAAA,EAAA;;IAKS,IAAAA,CAAAA,KAAA,GAAAA,KAAA;;;;EADNC,cAAA,GAAAL,MAAA,CAAAM,aAAA,CAAA;EACMC,kBAAe,GAAAP,MAAA,CAAAQ,iBAAA,CAAA;;MAAf,GAAAR,MAAA,CAAYS,cAAG,EAAA;IAAAC,QAAA,EAAA;AAAA,GAAA,CAAA;EAExBC,YAAA,GAAAX,MAAA,CAAAY,YAAA,CAAA;;EAuDUC,gBAAA,GAAWb,MAAA,CAAAc,cAAA,EAAA;IAAAJ,QAAA,EAAA;AAAA,GAAA,CAAA;EAefK,SAAA,GAAAf,gBAAoB,EAAA;AAAAgB,IAAAA,IAAA,EAAM,IAAA;IAAAN,QAAA,EAAA;AAAA,GAAA,CAAA;EAChCO,cAAA,GAAAjB,MAAA,CAAAkB,aAAA,CAAA;EACQC,eAAiB,GAAAnB,MAAO,CAAAoB;;;EAEDC,mBAAA,GAAAA,mBAAA,EAAA;EAIvBC,YAAY,GAAA,IAAAC,OAAA,EAAA;EAEsDC,cAAA;;EAOpEC,YAAsB;;AAgBaC,EAAAA,UAAA,GAAA,CAGvC;;;;;GAMM,EAAA;IAERC,OAAA,EAAA,KAAA;AACAC,IAAAA,OACY,EAAA,QAAA;YACH,EAAA,KAAA;AACTC,IAAAA,QAAA,EAAA;;;WAIE,EAAA,KAAA;AAEAC,IAAAA,QAAK,EAAA,OAAY;AACnBD,IAAAA,QAAA,EAAA,QAAA;IACiBE,UAAY,EAAA;GAE+B,EAE5D;AAEAJ,IAAAA,OAAA,EAAA,KAAA;;;;AAIGI,IAAAA,UAAA,EAAA;GACH;AAIIC,EAAAA,qBAAAA,CAAYC,KAAA,EAAA;AACdC,IAAAA,MAAAA,MAAW,GAAA,IAAE,CAAAC,OAAA,CAAAC,OAAA,GAAAH,KAAA,CAAA;gBACL;iBACR,GAAA,IAAAI,CAAAA,KAAA,CAAAC,aAAA;MACA,MAAAC,UAAA,GAAAC,6BAAA,CAAAP,KAAA,EAAAE,IAAAA,CAAAA,OAAA,OAAAV,YAAA,CAAA;AACA,MAAA,MAAAgB,OAAA,GAAAP,MAAA,CAAAQ,eAAA,EAAA;;aASO,CAAAC,SAAW,GAAA,CAAA;OAEhB,MAAA;AAGEN,QAAAA,KAAA,CAAAM,SAAa,GAAAC,wBAAA,CAAAH,OAAA,CAAAI,SAAA,EAAAJ,OAAA,CAAAK,YAAA,EAAAT,KAAA,CAAAM,SAAA,EAAAN,KAAA,CAAAS,YAAA,CAAA;;;;qBAMaC,GAAA;8BAAA,CAAAC,IAAAA,CAAAA,WAAA,CAAAC,eAAA,IAAA,CAAA,CAAA;;AAW5BC,EAAAA,eAAAA,CAAA9C,KAAA,EAAA;IACF,OAAA+C,IAAAA,eAAA,OAAA/C,KAAA,CAAA;;wBAOF,GAAAJ,MAAA,CAAAL,0BAAA,CAAA;EAGGyD,UAAA,GAAA,KAAA;AAG6B,EAAA,YAAA,GAAAC,CAAAC,EAAA,EAAAC,EAAA,KAAAD,EAAA,KAAAC,EAAA;;EAO9BC,sBAAA,GAAA,IAAA;EAQEC,gBAAyB;AAI7BC,EAAAA,QAAA,OAAAnC,OAAA,EAAA;;;;;EAoCwCoC,eAAA;;AAcxC,EAAA,uBAAA;;AASAC,EAAAA,SAAA,GAAAA,MAAA,EAAA;AAGEC,EAAAA,UAAA,GAAAA,MAAA,EAAA;oCAIiE,CAAA,mBAAA,CAAA;;oBAKsB,GAAA,IAAA,CAAA1C,eAAA,EAAA2C,iBAAA,IAAA,EAAA;aAGrFC,GAAI;;AAUN;;gBAOM,YAAA;EAGNC,OAAA;EAEG3B,KAAA;;EAMDN,UAAA;EAIFkC,QAAA,GAAA,KAAA;AAKA,EAAA,IAAAC,aAAA,GAAA;IAEE,OAAM,IAAgC,CAAAC,cAAA,EAAA;;mBAIlBD,CAAA9D,KAAA,EAAA;AAEtB,IAAA,IAAA,CAAA+D,cAAA,CAAAC,GAAA,CAAAhE,KAAA,CAAA;;EAKA+D,cAAA,GAAAE,MAAA,CAAA,KAAA,EAAA,IAAAC,SAAA,GAAA,CAAA;IAAgCC,SAAA,EAAA;AAAA,GAAA,CAAA,GAAA,EAAA,CAAA,CAAA;aAIC,CAAA;AAE/B,EAAA,IAAAC,4BAA6CA,GAAA;AAC7C,IAAA,OAAA,KAAAC,6BAAK;;EAEH,IAAAD;sCACK,GAAApE,KAAA;QAKL,CAAAsE,qBAAW,EAAA;;AAGXD,EAAAA,gCAEoB,IAAA,CAAAtD,eAAA,EAAAqD,4BAAA,IAAA,KAAA;AAGlB,EAAA,IAAAG,WAAA,GAAA;;;;;IAON,IAAAC,CAAAA,YAAA,CAAAC,IAAA,EAAA;;;;WAUI,IAAA,CAAAC,SAAmC,IAAA,IAAA,CAAA/D,SAAA,EAAAgE,OAAA,EAAAC,YAAA,CAAAC,UAAA,CAAAC,QAAA,CAAA,IAAA,KAAA;;cAEvCA,CAAA9E,KAAA,EAAA;;IAGS,IAAAwE,CAAAA,YAAA,CAAAC,IAAA,EAAA;AAET;EACAC,SACA;;AAGF,IAAA,OAAA,IAAA,CAAAK,SAAA;;AAGAC,EAAAA,IAAAA,QAAMA,CAAAhF,KAAA,EAAA;AACJ,IAAA,IAAA,IAAA,CAAAuD,eAAA,KAAA,OAAAW,SAAA,KAAA,WAAA,IAAAA,SAAA,CAAA,EAAA;AACF,MAAA,MAAA9E,gCAAA,EAAA;;kBAKW,GAAAY,KAAA;;;AAK+E,EAAA,sBAAA,GAAA,IAAA,CAAAe,eAAA,EAAAkE,sBAAA,IAAA,KAAA;AASxF,EAAA,IAAAC,WAAA,GAAA;4BAE0B;AAE1B;;;;;qBAQgF,GAAAC,EAAA;IAChF,IAAA,IAAA,CAAA5B,eAAsB,EAAA;AAGxB,MAAA,IAAA,CAAA6B,oBAAA,EAAA;;;AAIGpF,EAAAA,IAAAA,KAAAA,GAAA;IACK,OAAa,IAAA,CAAAqF,MAAA;;;;;;;;;;;;;;EAsB0E,IAAAC,iBAAAA,CAAAtF,KAAA,EAAA;;AAGC;EAG9FuF,yBAIY;EAOZC,cAAA;AAKA,EAAA,IAAAC,EAAA,GAAA;;;;;qBAOS,CAAAhB,IAAA,EAAA;AAGT;;;AAOG,IAAA,OAAA,IAAA,CAAAiB,kBAAA,CAAAC,UAAA;;MAEDA,UAAAA,CAAA3F,KAAA,EAAK;;AAEL;AAOA4F,EAAAA,UAAA,GAAA,IAAA,CAAA7E,eAAsB,IAAA,OAAA,IAAA,CAAAA,eAAA,CAAA6E,UAAA,KAAA,WAAA,OACxB,CAAA7E,eAAA,CAAA6E,UAAA;0BAYE,GAAA7E,IAAAA,CAAAA,eAAA,EAAA8E,wBAAA,IAAA,KAAA;;;;;AAQE;4BAEF,CAAAC,IAAA,CAAAC,SAAA,CAAA,MAAA,KAAAC,sBAAA,CAAA,CAAA;;cAKF,GAAuBC,IAAAA,YAAA,EAAA;kBAGjB,IAAAC,CAAAA,YAAC,CAAAJ,IAEP,CAAAK,MAAe,CAAAC,CAAA,IAAAA,CAAA,MACjB,CAAA,MAAA,EAAA,CAAA,CAAA;AAKsE,EAAA,aAAA,GAAA,IAAAF,CAAAA,YAAA,CAAAJ,IAAA,CAAAK,MAAA,CAAAC,CAAA,IAAA,CAAAA,CAAA,CAAA,EAAAC,GAAA,CAAA,MAAA,EAAA,CAAA,CAAA;;;EAqBnEC,WAAA,GAAA;AAED,IAAA,MAAAC,wBAAA,GAAA3G,MAAA,CAAA4G,iBAAA,CAAA;;;;;;;;;;;AAWA,MAAA,IAAA,CAAA7F,SAAA,CAAA8F,aAAoB,GAAA,IAAA;AACtB;;;;AAQA,IAAA,IAAA,CAAAf,kBAAiB,GAAA,IAAAgB,kBAAmB,CAAAH,wBAAA,EAAA,IAAA,CAAA5F,SAAA,EAAAgG,eAAA,EAAAC,UAAA,EAAA,IAAA,CAAApC,YAAA,CAAA;IAClC,IAAA,CAAAqC,eAAA,GAAA,IAAA,CAAAC,sBAAA,EAAA;AAEA,IAAA,IAAA,CAAAC,QAAA,GAAAA,QAAA,IAAAC,IAAAA,GAAAA,CAAAA,GAAAA,QAAA,CAAAD,QAAA,CAAA,IAAA,CAAA;AAGF,IAAA,IAAgD,CAAAtB,EAAA,GAAA,IAAA,CAAAA,EAAA;;;AAKhD,IAAA,IAAqC,CAAAlC,eAAA,GAAA,IAAA0D,cAAA,MAAAjC,QACrC,CAAA;AAOI,IAAA,IAAA,CAAAR,YAAA,CAAAC,IAAS,EAAA;QACX,CAAAxE,cAAA,CAGEiH,MAAA,EAAA,CAEApB,IAAA,CAAAqB,SAAe,CAAA,IAAA,CAAA7D,QAAA,CAAA,CAAA;;AAKf,QAAA,IAAA,CAAA8D,qCAAiC,CAAA,IAAA,CAAAC,uBAAA,CAAA;QACnC,IAAAlH,CAAAA,kBAAA,CAAAmH,aAAA,EAAA;AAEA;;;AAIcC,EAAAA,kBAAAA,GAAA;QACd,CAAArG,YAAK,CAAAuD,IAAA,EAAA;AACP,IAAA,IAAA,CAAA,YAAA,CAAA+C,QAAA,EAAA;AAE0C,IAAA,IAAA,CAAA,eAAA,EAAA;AACpC,IAAA,IAAA,CAAAjE,eAAA,CAAAkE,OAAA,CAAA3B,IAAA,CAAAqB,SAAA,CAAA,IAAA,CAAA7D,QAAA,CAAA,CAAA,CAAAoE,SAAA,CAAAC,KAAA,IAAA;MACJA,KAAA,CAAAC,KAAA,CAAAC,OAAA,CAAA/F,MAAA,IAAAA,MAAA,CAAAgG,MAAA,EAAA,CAAA;;AAIF,KAAA,CAAA;AACE,IAAA,IAAA,CAAA/F,OAAA,CAAAgG,OAAU,CAAAjC,IAAU,CAAAkC,SAAA,CAAAb,IAAAA,CAAAA,EAAAA,SAAA,CAAA7D,IAAAA,CAAAA,QAAA,GAAAoE,SAAA,CAAA,MAAA;;AAGtB,MAAA,IAAA,CAAAtC,oBAAA,EAAA;AAGQ,KAAA,CAAA;;WAEN6C,GAAA;IAEE,MAAAC,iBAAA,QAAAC,yBAAA,EAAA;mBAEO;IAKT,IAAAD,iBAAA,UAAA9E,sBAAA,EAAA;AAIE,MAAA,MAAAf,OAAA,GAAA,IAAA,CAAA+F,WAAA,CAAAlG,aAAA;iCACW,GAAAgG,iBAAA;UACbA,iBAAA,EAAA;QACE7F,OAAA,CAAAgG,YAAA,CAAA,iBAAA,EAAAH,iBAAA,CAAA;OAEA,MAAA;+BAEiE,CAAA,iBAAA,CAAA;AACjE;;;;AAIA,QAAA,IAAA,IAAA,CAAA7E,gBAAA,KAAAiF,SAAA,IACF3H,SAAA,CAAAkD,QAAA,KAAA,IACFlD,IAAAA,SAAA,CAAAkD,QAAA,UAAAA,QAAA,EAAA;AAEyD,UAAA,IAAA,CAAAA,QAAA,GAAAlD,SAAA,CAAAkD,QAAA;AAEvD;AACA,QAAA,IAAA,CAAAR,gBAAA,GAAA1C,SAAA,CAAAgE,OAAA;;AAEA,MAAA,IAAA,CAAA4D;;;uBAM0D;AAIxDR,IAAAA,IAAAA,OAAA,gBAAAA,OAAA,CAAA,qBAAA,CAAA,EAAA;AAEA,MAAA,IAAA,CAAAvD,YAAA,CAAAC,IAAe,EAAM;;IAGrB,IAAAsD,OAAA,sCAAAnF,WAAA,EAAA;AACK,MAAA,IAAA,CAAAA,WAA+B,CAAA4F,aAAA,MAAAjD,yBAAA,CAAA;;;aAIpCkD,GAAA;AACE,IAAA,IAAA,CAAArH,cAAA,IAAK;IACH,IAAA,CAAAwB,WAAA,EAAA8F,OAAA,EAAA;IAEJ,IAAA,CAAApF,QAAE,CAAAmB,IAAA,EAAA;iBACJ,CAAA+C,QAAA,EAAA;;AACE,IAAA,IAAA,CAAAmB,eAAA,EAAA;;AAOEC,EAAAA,MAAAA,GAAA;AACA,IAAA,IAAA,CAAAC,SAAA,GAAA,IAAkB,CAAAC,KAAA,UAAAC,IAAA,EAAA;;;;;AASd;AAKR,IAAA,IAAA,IAAA,CAAAtI,gBAAA,EAAA;WACO4G,uBAAe,GAAA5G,IAAAA,CAAAA,gBAAA,CAAAuI,yBAAA,EAAA;;;AAKxB,IAAA,IAAA,CAAA5B,aAAA,GAAA,IAAA,CAAA6B,gBAAA,CAAA,IAAA,CAAA5B,uBAAA,CAAA;AACE,IAAA,IAAA,CAAA6B,yBAAA,EAAA;AACE,IAAA,IAAA,CAAAlG,UAAA,GAAA,IAAA;IACA,IAAA,CAAAmG,WAAA,CAAAC,cAAkB,CAAAtD,IAAA,CAAAuD,IAAA,CAAA,CAAA,CAAA,CAAA,CAAA3B,SAAA,CAAA,MAAA;UACpB,CAAAvH,kBAAA,CAAAmH,aAAA,EAAA;AACF,MAAA,IAAA,CAAA3E,mBAAA,EAAA;;;IAKG,IAAA,CAAAC,WAAA,CAAA0G,yBAAA,CAAA,IAAA,CAAA;AACH,IAAA,IAAO,CAAAC,uBAAA,EAAA;AACL,IAAA,IAAA,CAAApJ,kBAAa,CAAAqJ,YAAQ,EAAA;qBAGjB,CAAA/E,IAAA,EAAA;IAEFgF,OAAA,CAAAC,OAAA,EAAK,CAAAC,IAAA,CAAmB,MAAA,IAAA,CAAAzD,YAAA,CAAA0D,IAAA,CAAA,IAAA,CAAA,CAAA;;eAWnB,GAAA,IAAA;;kCAiCC,CAAA1H,aAAA,CAAA2H,OAAA,CAAA,mDAAA,CAAA;;;AAKJ;;AACK,IAAA,IAAA,IAAA,CAAAC,aAAA,EAAA;4BAC6E,CAAA,IAAA,CAAAA,aAAA,EAAA;;uBAMtF,CAAAC,KAAA,eAAAC,OAAA,CAAA;QACF,CAAAF,aAAA,GAAAC,KAAA;;iBAMQpB,GAAA;;;AAKF;;;sBAMG,GAAA,IAAA;;;AAIH,IAAA,IAAA,KAAA3F,UAAA,EAAA;MAEE,IAAA,CAAAA,UAAA,GAAQ,KAAA;AAEV,MAAA,IAAA,CAAAiH;sBACF,CAAAX,yBAAA,MAAAY,MAAA,EAAA,GAAA,KAAA,GAAA,KAAA,CAAA;MACF,IAAA/J,CAAAA,kBAAA,CAAAqJ,YAAA,EAAA;AAGE,MAAA,IAAA,CAAA/F,UAAA,EAAA;MAGF,IAAA,CAAAe;AAGmFiF,MAAAA,OAAA,CAAAC,OAAA,EAAA,CAAAC,IAAA,CAAAzD,MAAAA,IAAAA,CAAAA,YAAA,CAAA0D,IAAA,CAAA,KAAA,CAAA,CAAA;;;gBAIjFK,GAAA;AACE,IAAA,IAAA,IAAA,CAAAhJ,mBAAK,IAAA,CAAA,IAAA,CAAAgB,KAAA,EAAA;AAGP,MAAA,IAAA,CAAAkI,cAAA,EAAA;AACA,MAAA;;AAEF,IAAA,IAAA,CAAA/I,cAAA,IAAA;;MAIsFgJ,YAAA,EAAA;AACtEC,MAAAA,YAAA,CAAAC,iBAAA,CAAA;MAChB,IAAA,CAAAlJ,cAAA,GAAAkH,SAAA;;AAEF,IAAA,MAA+CrG,KAAA,GAAA,IAAA,CAAAA,KAAA,CAAAC,aAAA;IAE/C,MAA0CkI,YAAA,GAAA,IAAA,CAAAG,SAAA,CAAAC,MAAA,CAAAvI,KAAA,EAAA,cAAA,EAAA0F,KAAA,IAAA;MACwB,IAAAA,KAAA,CAAA8C,aAAA,KAAA,kBAAA,EAAA;AACgC,QAAA,IAAA,CAAArJ,cAAA,IAAA;AAClF,QAAA,IAAA,CAAA+I,cAAA,EAAA;AACd;AACF,KAA6F,CAAA;2BAIxB,GAAAO,UAAA,CAAA,MAAA;AACjE,MAAA,IAAA,CAAAtJ,cAAA,IAAY;AACd,MAAA,IAAA,CAAA+I,cAAA,EAAA;;;;gBAQ+CA,GAAA;QACzC,CAAAhB,WAAA,CAAAwB,aACgE,EAAA;IAMhE,IAAAxK,CAAAA,kBAAiB,CAAAqJ,YAAA,EAAA;;AAUnBoB,EAAAA,UAAAA,CAAA5K,KAAA,EAAA;;;AAaD6K,EAAAA,gBAAAA,CAAA1F,EAAA,EAAA;;;;;;AAsBC2F,EAAAA,gBAAAA,CAAAC,UAAA,EAAA;IAEJ,IAAAlH,CAAAA,QAAA,GAAAkH,UAAA;;;;MAOAlC,SAAA,GAAA;gBACgB7F,UAAA;;;;;AAUhBgI,EAAAA,IAAAA,YAASA,GAAA;AACN,IAAA,IAAA,IAAA,CAAAC,KAAA,EAAA;;;sBAIyD,EAAA;AACxD,MAAA,MAAAC,eAAA,GAAA,IAAA,CAAA3H,eAAA,CAAA4H,QAAA,CAAA9E,GAAA,CAAAvE,MAAA,IAAAA,MAAA,CAAAsJ,SAAA,CAAA;AAEF,MAAA,IAAA,IAAA,CAAAlB,MAAA,EAAA,EAAA;AACJgB,QAAAA,eAAA,CAAAG,OAAA,EAAA;AAEyC;;;AAMrC,IAAA,OAAA,IAAA,CAAA9H,eAAK,CAAA4H,QAAgB,IAAAC,SAAO;;;QAM5B,CAAA1F,kBAAA,CAAA6C,gBAAA,EAAA;;;;;;;8CAe6D,CAAAZ,KAAA,CAAA2D,GAAAA,IAAAA,CAAAA,oBAAA,CAAA3D,KAAA,CAAA;;;;iBAM/D,GAAAA,KAAA,CAAA4D,OAAA;UAEIC,UAAA,GAAAD,OAAgB,KAAAE,UAAA,wBACI,8BAGxBF,OAAA,KAAAG,WAAA;4DAGiF;AAChE,IAAA,MAAAC,OAAA,GAAA,IAAA,CAAA/I,WAAA;+BAIXgJ,SAAgB,IAAA,CAAAC,cAAA,CAAAlE,KAAA,CAAA,kBACX,IAAAA,KAAA,CAAAmE,MAAA,KAAAN,UAAA,EAAA;4BACgB;AACrB,MAAA,IAAA,CAAAzC,IAAA,EAAA;KAEJ,MAAA,IAAA,CAAK,IAAA,CAAA/D,QAAA,EAAA;MAET,MAAA+G,wBAAA,QAAAZ,QAAA;AAGQQ,MAAAA,OAAA,CAAAK,SAAA,CAAqCrE,KAAA,CAAA;MAC3C,MAAIsE,cAAgB,GAAA,IAAA,CAAAd,QAAA;UAIpBc,cAAA,IAAAF,wBAAA,KAAAE,cAAA,EAAA;AACE,QAAA,IAAA,CAAApL,cAAA,CAAAqL,QAA2B,CAAAD,cAAS,CAAAb,SAAA,EAAA,KAAA,CAAA;;;;AAOtCe,EAAAA,kBAAAA,CAAAxE,KAAA,EAAA;AACF,IAAA,MAAA,OAAA,GAAA,IAAA,CAAA/E,WAAA;iBAEA,GAAA+E,KAAA,CAAA4D,OAAA;;;AAGG,IAAA,IAAAC,UAAA,IAAA7D,KAAA,CAAAmE,MAAA,EAAA;AAGCnE,MAAAA,KAAA,CAAAyE,cAAgB,EAAA;gBAC4E,EAAA;AAG1F,KAAA,mBAEQ,KACNb,OAAA,KAAAc,KAAA,IAAAd,OAAA,KAAAe,KAAA,CAAA;;;AAMF,KAAA,MAAA,aACF,IAAAvH,IAAAA,CAAAA,SAAA,IAAAwG,OAAA,KAAAgB,CAAA,IAAA5E,KAAA,CAAA6E,OAAA,EAAA;0BAAO,EAAA;AACL,MAAA,MAAAC,oBAAK,GAAA,IAAA,CAAA1K,OAAA,CAAA2K,IAAA,CAAAC,GAAA,IAAAA,CAAAA,GAAA,CAAA9I,QAAA,IAAA8I,CAAAA,GAAA,CAAAxB,QAAA,CAAA;0BACP,CAAArJ;QAEJ,IAAA,CAAAA,MAAA,CAAA+B,QAAA,EAAA;AAE4C4I,UAAAA,oBAAA,GAAA3K,MAAA,CAAAgG,MAAA,EAAAhG,GAAAA,MAAA,CAAA8K,QAAA,EAAA;AAC1B;AAAA,OAAA,CAAA;AAElB,KAAA,MAAA;AAGA,MAAA,MAA4BC,sBAAA,GAAAlB,OAAA,CAAA9I,eAAA;aAC1B,CAAImJ,gBAAa;AACnB,MAAA,IAAA,IAAA,CAAAjH,SAAA,IAEqDyG,UAAA,IAC9B7D,KAAA,CAAAmF,QAAA,IACrBnB,OAAA,CAAAoB,UAAA,IAAIpB,OAAA,CAAA9I,eAAA,KAAAgK,sBAAA,EAAA;QACFlB,OAAA,CAAAoB,UAAA,CAAAC,qBAAW,EAAA;;;;AAULC,EAAAA,qBAAAA,CAAAtF,KAAA,EAAA;;AAUNA,MAAAA,KAAA,CAAAyE,cAAA,EAAA;AACF,MAAA,IAAA,CAAAtD,KAAA,EAAA;;;UAKEoE,GAAA;;AAGF,MAAA,IAAA,CAAkEC,QAAA,GAAA,IAAA;UACI3I,CAAAA,YAAA,CAAAC,IAAA,EAAA;;;AAStE,EAAA,OAAA,GAAA;AACF,IAAA,IAAA,CAAA0I,QAAA,GAAA,KAAA;IAEA,IAAAvK,CAAAA,WAAA,EAAAwK,eAAA,EAAA;;;;MAKE,IAAA5I,CAAAA,YAAA,CAAAC,IAAA,EAAA;;;;;;AAWAwG,EAAAA,IAAAA,KAAAA,GAAA;AACE,IAAA,OAAA,CAAA,IAAA,CAAA1H,eAAA,IAAA,IAAA,CAAAA,eAAA,CAAA8J,OAAA,EAAA;;sBAEIjI,GAAA;;;AAOL,QAAA,IAAA,CAAAC,MAAA,GAAA1E,IAAAA,CAAAA,SAAA,CAAAX,KAAA;;MAGG,IAAAsN,CAAAA,oBAAO,MAAAjI,MAAA,CAAA;MACb,IAAAb,CAAAA,YAAA,CAAAC,IAAA,EAAA;AAEA,KAAA,CAAA;;AAOS6I,EAAAA,oBAAAA,CAAAtN,KAAc,EAAA;IACvB,IAAA,CAAA+B,OAAA,CAAA8F,OAAA,CAAA/F,MAAA,IAAAA,MAAA,CAAAyL,iBAAA,EAAA,CAAA;;IAtxCE,IAAAvI,IAAAA,CAAAA,QAAA,IAAAhF,KAAA,EAAA;;;;;sBA/BM,EAAA;KASN,MAAA;AACA,MAAA,MAAAwN,mBAAO,GAAA,IAAkB,CAAAC,oBAAA,CAAAzN,KAAA,CAAA;AAIzB,MAAA,IAAAwN,mBAAA,EAAA;AACA,QAAA,IAAA,CAAA5K,WAAA,CAAA8K,gBAAA,CAAAF,mBAAA,CAAA;AACA,OAAA,MAAA,UAAA3E,SAAA,EAAA;QAIA,IAAAjG,CAAAA,WAAA,CAAA8K,gBAAA,CAAA,CAAA,CAAA,CAAA;AACA;;QAEA,CAAAvN,kBAAA,CAAAqJ,YAAA,EAAA;;AAKAiE,EAAAA,oBAAAA,CAAAzN,KAAA,EAAA;AAGA,IAAA,MAAAwN,kCAAU,CAAAG,IAAA,CAAA7L,MAAA,IAAA;;;;;;;;;;;;;;;;;;;gCAiNJ,IAAS,IAAAiD,CAAAA,SAAA,IAAmB6I,KAAA,CAAAC,OAAA,CAAAC,QAAA,CAAA,EAAA;;QAU7B,IAAAR,CAAAA,oBAAA,CAAAQ,QAAA,CAAA;;;aAMD,IAAA;;gBAaF;;;;aAgFiB,KAAA;;0BAeE;;;;qHAoCf,IAAA,IAAA,CAAA1F,WAAA;;;WAqBDxC,IAAAA,CAAAA,eAAS,IAAA,GAAA,EAAA,GAAA,IAAA,CAAAA,UAAA;;;;2BAmBT,IAAA7D,CAAAA,OAAA,EAAA;;;AAk4BN;AAKH;;2IAJWuH,CAAAA,yBAAA,MAAAY,MAAA,EAAA,GAAA,KAAA,GAAA,KAAA,CAAA,CACT6D,cAAA,EAAA,CAEDC,cAAA,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAxlCW,MAAA,aAAA,EAAA,iBAAA,CAAAC,IAAA;MAAWC,eAAA,EAAAC,uBAAA,CAAAC,MAAA;MAAAC,IAAA,EAAA;QARgB,MAAA,EAAA,UAAA;QACR,eAAA,EAAA,SAAA;;;;QA7C1B,sBAAA,EAAA,kCAAA;8BAC8B,EAEjC,WAAA;QAOA,mBAAe,EAAA,mBAAA;AAEf,QAAA,sBAAwD,EAAA,qBAAA;AACxD,QAAA,sBAAA,EAAW,qBAAA;QAEX,qBAA0C,EAAA,YAAA;AAC1C,QAAA,8BAAA,EAAuB,4BAAA;QAEvB,iCAAkC,EAAA,UAAA;AAClC,QAAA,gCAAa,EAAA,YAAA;AAEb,QAAA,iCAAyD,EAAA,UAAA;QACzD,8BAA0C,EAAA,OAAA;AAE1C,QAAA,iCAAmE,EAAA,UAAA;AACnE,QAAA,yBAAqB,EAAA,WAAA;QAErB,WAAyD,EAAA,wBAAA;AACzD,QAAA,SAAA,EAAA,YAAA;AAEA,QAAA,QAAA,EAAA;;eACA,EAEA,CAAA;AAAAC,QAAAA,OAAA,EAAAC,mBAA6C;AAAAC,QAAAA,WAAA,EAAAC;OAE7C,EAAA;AAAAH,QAAAA,OAAA,EAAAI,2BAAqC;AAAAF,QAAAA,WAAA,EAAAC;;AACrC,MAAA,OAAA,EAAA,CAAAE,gBAAW,EAAAC,mBAAA,EAAAC,OAAA,CAAA;MAAAC,QAAA,EAAA,ktEAAA;MAAAC,MAAA,EAAA,CAAA,yjKAAA;AAAA,KAAA;;AACT,EAAA,cAAA,EAAAC,MAAO,EAAA;;;AACT,MAAA,IAAA,EAAA,eAAA;sBACgB,EAAA;QAAAC,WAAQ,EAAA;AAAA,OAAA;;;AAKa,MAAA,IAAA,EAAA,eAAA;AACR,MAAA,IAAA,EAAA,CAAA,YAAA,EAAA;QAAAA,WAAA,EAAA;AAAA,OAAA;;mBAGJ,CAAA;;AA0CzB,MAAA,IAAA,EAAA,CAAAC,kBACe;;uBAAA,EAAA,CAAA;AAKWC,MAAAA,IAAA,EAAAC,KAAA;YAAxB,CAAK,kBAAA;;AAAA,IAAA,OAAA,EAAA,CAAA;AAIkCD,MAAAA,IAAA,EAAAE,SAAA;;;AAAA,IAAA,KAAA,EAAA,CAAA;;;;;AAkNzCF,MAAAA,IAAA,EAAAE,SAAA;gCAAA;;AAAA,IAAA,UAAA,EAAA,CAAA;AAIOF,MAAAA,IAAA,EAAaC;;AAAlB,IAAA,QAAA,EAAA,CAAA;AAAK,MAAA,IAAA,EAAA,KAAA;MAMHE,IAAA,EAAA,CAAA;AAAAC,QAAAA,SAAM,EAAAC;AAAA,OAAA;;iBADN,EAAA,CAAA;AAAA,MAAA,IAAA,EAAA,KAAA;;iBAKkB,EAAAA;AAAA,OAAA;;;iBAKb;;QAFTD,SAAA,EAAAvP,KAAA,IAAAA,KAAA,IAAA,IAAAyP,GAAAA,CAAAA,GAAAA,eAAA,CAAAzP,KAAA;;;AAME,IAAA,4BAAA,EAAA,CAAA;AAAuF,MAAA,IAAA,EAAA,KAAA;;AAanFuP,QAAAA,SAAA,EAAAC;AAAA,OAAA;;AAJA,IAAA,WAAA,EAAA,CAAA;;;;;;;AASoB,OAAA;;YAFpB,EAAA,CAAA;AAAA,MAAA,IAAA,EAAA,KAAA;;iBAkBA,EAAAA;AAAA,OAAA;;AADJ,IAAA,sBAAA,EAAA,CAAA;AAcAL,MAAAA,IAAA,EAAAC,KAAK;AADL,MAAA,IAAA,EAAA,CAAA;AAAAG,QAAAA,SAAA,EAAAC;AAAA,OAAA;;AAAA,IAAA,WAAA,EAAA,CAAA;;;AAaA,IAAA,KAAA,EAAA,CAAA;;;;YAgBEJ,KAAA;aAAA,YAAK;;kBAWyE,EAAA,CAAA;YAFhFA,KAAA;;;;AAiC6FD,MAAAA,IAAA,EAAAC;;AAA7F,IAAA,yBAAA,EAAA,CAAA;AAA6F,MAAA,IAAA,EAAA,KAAA;MAGCE,IAAA,EAAA,CAAA;AAAAC,QAAAA,SAAA,EAAAE;AAAA,OAAA;;AAA9F,IAAA,cAAA,EAAA,CAAA;;;;AAGAL,MAAAA,IAAAA,EAAAA;;IAgBAxJ,UAAA,EAAA,CAAA;AADAwJ,MAAAA,IAAAA,EAAAA;;AAAA,IAAA,wBAAA,EAAA,CAAA;;;;;;IAcAlJ,YAAA,EAAA,CAAA;;;IAwBAwJ,aAAA,EAAA,CAAA;kBAAA;;;;;AAmCFJ,MAAAA,IAAA,EAAA,CAAA,QAAA;;AAAA,IAAA,eAAA,EAAA,CAAA;;;;;;;AAUA,CAAA,CAAA;AAMG,MAAA,gBAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sCCx2BkB,CAAA;IAAAK,UAAA,EAAA,QAAA;IAAAC,OAAA,EAAA,eAAA;AAAAC,IAAAA,QAAA,EAAAC,EAAA;AAAAX,IAAAA,IAAA,EAAAY,eAAA;AAAAC,IAAAA,OAAA,GAAAC,aAAA,EAAAC,eAAA,EAAAzB,SAAA,EAAA0B,gBAAA,CAAA;IAAAC,OAAA,EAAA,CAAAC,UAAA,qBACD,oBACT,WACO;AAHG,GAAA,CAAA;;;;;yBAAA;IAAAL,OAAA,EAAA,CAAAC,aAAA,EAAAC,eAAA,EAAAG,UAAA;;;2BAJb,CAAA;EAAAV,UAAA,EAAA,QAAA;EAAAC,OAAA,EAAA,eAAA;AAAAC,EAAAA,QAAA,EAAAC,EAAA;AAAAX,EAAAA,IAAA,EAAAY,eAAA;EAAAO,UAAA,EAAA,CAAA;;;;qEAWG7B,SAAA,EAAA0B,gBAAA,iBAPT;;;;;;;"}