{"version":3,"file":"form-field-testing.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/form-field/testing/form-field-harness.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ComponentHarness,\n  ComponentHarnessConstructor,\n  HarnessPredicate,\n  HarnessQuery,\n  parallel,\n} from '@angular/cdk/testing';\nimport {ErrorHarnessFilters, MatErrorHarness} from './error-harness';\nimport {MatInputHarness} from '../../input/testing';\nimport {MatFormFieldControlHarness} from './control';\nimport {MatSelectHarness} from '../../select/testing';\nimport {MatDatepickerInputHarness, MatDateRangeInputHarness} from '../../datepicker/testing';\nimport {FormFieldHarnessFilters} from './form-field-harness-filters';\n\n/** Possible harnesses of controls which can be bound to a form-field. */\nexport type FormFieldControlHarness =\n  | MatInputHarness\n  | MatSelectHarness\n  | MatDatepickerInputHarness\n  | MatDateRangeInputHarness;\n\nexport class MatFormFieldHarness extends ComponentHarness {\n  private _prefixContainer = this.locatorForOptional('.mat-mdc-form-field-text-prefix');\n  private _suffixContainer = this.locatorForOptional('.mat-mdc-form-field-text-suffix');\n  private _label = this.locatorForOptional('.mdc-floating-label');\n  private _hints = this.locatorForAll('.mat-mdc-form-field-hint');\n  private _inputControl = this.locatorForOptional(MatInputHarness);\n  private _selectControl = this.locatorForOptional(MatSelectHarness);\n  private _datepickerInputControl = this.locatorForOptional(MatDatepickerInputHarness);\n  private _dateRangeInputControl = this.locatorForOptional(MatDateRangeInputHarness);\n  private _textField = this.locatorFor('.mat-mdc-text-field-wrapper');\n  private _errorHarness = MatErrorHarness;\n\n  static hostSelector = '.mat-mdc-form-field';\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a form field with specific\n   * attributes.\n   * @param options Options for filtering which form field instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with<T extends MatFormFieldHarness>(\n    this: ComponentHarnessConstructor<T>,\n    options: FormFieldHarnessFilters = {},\n  ): HarnessPredicate<T> {\n    return new HarnessPredicate(this, options)\n      .addOption('floatingLabelText', options.floatingLabelText, async (harness, text) =>\n        HarnessPredicate.stringMatches(await harness.getLabel(), text),\n      )\n      .addOption(\n        'hasErrors',\n        options.hasErrors,\n        async (harness, hasErrors) => (await harness.hasErrors()) === hasErrors,\n      )\n      .addOption(\n        'isValid',\n        options.isValid,\n        async (harness, isValid) => (await harness.isControlValid()) === isValid,\n      );\n  }\n\n  /** Gets the appearance of the form-field. */\n  async getAppearance(): Promise<'fill' | 'outline'> {\n    const textFieldEl = await this._textField();\n    if (await textFieldEl.hasClass('mdc-text-field--outlined')) {\n      return 'outline';\n    }\n    return 'fill';\n  }\n\n  /** Whether the form-field has a label. */\n  async hasLabel(): Promise<boolean> {\n    return (await this._label()) !== null;\n  }\n\n  /** Whether the label is currently floating. */\n  async isLabelFloating(): Promise<boolean> {\n    const labelEl = await this._label();\n    return labelEl !== null ? await labelEl.hasClass('mdc-floating-label--float-above') : false;\n  }\n\n  /** Gets the label of the form-field. */\n  async getLabel(): Promise<string | null> {\n    const labelEl = await this._label();\n    return labelEl ? labelEl.text() : null;\n  }\n\n  /** Whether the form-field has errors. */\n  async hasErrors(): Promise<boolean> {\n    return (await this.getTextErrors()).length > 0;\n  }\n\n  /** Whether the form-field is disabled. */\n  async isDisabled(): Promise<boolean> {\n    return (await this.host()).hasClass('mat-form-field-disabled');\n  }\n\n  /** Whether the form-field is currently autofilled. */\n  async isAutofilled(): Promise<boolean> {\n    return (await this.host()).hasClass('mat-form-field-autofilled');\n  }\n\n  /**\n   * Gets the harness of the control that is bound to the form-field. Only\n   * default controls such as \"MatInputHarness\" and \"MatSelectHarness\" are\n   * supported.\n   */\n  async getControl(): Promise<FormFieldControlHarness | null>;\n\n  /**\n   * Gets the harness of the control that is bound to the form-field. Searches\n   * for a control that matches the specified harness type.\n   */\n  async getControl<X extends MatFormFieldControlHarness>(\n    type: ComponentHarnessConstructor<X>,\n  ): Promise<X | null>;\n\n  /**\n   * Gets the harness of the control that is bound to the form-field. Searches\n   * for a control that matches the specified harness predicate.\n   */\n  async getControl<X extends MatFormFieldControlHarness>(\n    type: HarnessPredicate<X>,\n  ): Promise<X | null>;\n\n  // Implementation of the \"getControl\" method overload signatures.\n  async getControl<X extends MatFormFieldControlHarness>(type?: HarnessQuery<X>) {\n    if (type) {\n      return this.locatorForOptional(type)();\n    }\n    const [select, input, datepickerInput, dateRangeInput] = await parallel(() => [\n      this._selectControl(),\n      this._inputControl(),\n      this._datepickerInputControl(),\n      this._dateRangeInputControl(),\n    ]);\n\n    // Match the datepicker inputs first since they can also have a `MatInput`.\n    return datepickerInput || dateRangeInput || select || input;\n  }\n\n  /** Gets the theme color of the form-field. */\n  async getThemeColor(): Promise<'primary' | 'accent' | 'warn'> {\n    const hostEl = await this.host();\n    const [isAccent, isWarn] = await parallel(() => {\n      return [hostEl.hasClass('mat-accent'), hostEl.hasClass('mat-warn')];\n    });\n    if (isAccent) {\n      return 'accent';\n    } else if (isWarn) {\n      return 'warn';\n    }\n    return 'primary';\n  }\n\n  /** Gets error messages which are currently displayed in the form-field. */\n  async getTextErrors(): Promise<string[]> {\n    const errors = await this.getErrors();\n    return parallel(() => errors.map(e => e.getText()));\n  }\n\n  /** Gets all of the error harnesses in the form field. */\n  async getErrors(filter: ErrorHarnessFilters = {}): Promise<MatErrorHarness[]> {\n    return this.locatorForAll(this._errorHarness.with(filter))();\n  }\n\n  /** Gets hint messages which are currently displayed in the form-field. */\n  async getTextHints(): Promise<string[]> {\n    const hints = await this._hints();\n    return parallel(() => hints.map(e => e.text()));\n  }\n\n  /** Gets the text inside the prefix element. */\n  async getPrefixText(): Promise<string> {\n    const prefix = await this._prefixContainer();\n    return prefix ? prefix.text() : '';\n  }\n\n  /** Gets the text inside the suffix element. */\n  async getSuffixText(): Promise<string> {\n    const suffix = await this._suffixContainer();\n    return suffix ? suffix.text() : '';\n  }\n\n  /**\n   * Whether the form control has been touched. Returns \"null\"\n   * if no form control is set up.\n   */\n  async isControlTouched(): Promise<boolean | null> {\n    if (!(await this._hasFormControl())) {\n      return null;\n    }\n    return (await this.host()).hasClass('ng-touched');\n  }\n\n  /**\n   * Whether the form control is dirty. Returns \"null\"\n   * if no form control is set up.\n   */\n  async isControlDirty(): Promise<boolean | null> {\n    if (!(await this._hasFormControl())) {\n      return null;\n    }\n    return (await this.host()).hasClass('ng-dirty');\n  }\n\n  /**\n   * Whether the form control is valid. Returns \"null\"\n   * if no form control is set up.\n   */\n  async isControlValid(): Promise<boolean | null> {\n    if (!(await this._hasFormControl())) {\n      return null;\n    }\n    return (await this.host()).hasClass('ng-valid');\n  }\n\n  /**\n   * Whether the form control is pending validation. Returns \"null\"\n   * if no form control is set up.\n   */\n  async isControlPending(): Promise<boolean | null> {\n    if (!(await this._hasFormControl())) {\n      return null;\n    }\n    return (await this.host()).hasClass('ng-pending');\n  }\n\n  /** Checks whether the form-field control has set up a form control. */\n  private async _hasFormControl(): Promise<boolean> {\n    const hostEl = await this.host();\n    // If no form \"NgControl\" is bound to the form-field control, the form-field\n    // is not able to forward any control status classes. Therefore if either the\n    // \"ng-touched\" or \"ng-untouched\" class is set, we know that it has a form control\n    const [isTouched, isUntouched] = await parallel(() => [\n      hostEl.hasClass('ng-touched'),\n      hostEl.hasClass('ng-untouched'),\n    ]);\n    return isTouched || isUntouched;\n  }\n}\n"],"names":["_prefixContainer","locatorForOptional","_suffixContainer","_hints","locatorForAll","MatDatepickerInputHarness","_dateRangeInputControl","MatDateRangeInputHarness","_textField","locatorFor","_errorHarness","hostSelector","with","options","HarnessPredicate","getAppearance","textFieldEl","hasClass","_label","isLabelFloating","labelEl","getLabel","hasErrors","getTextErrors","length","isDisabled","host","isAutofilled","getControl","type","select","datepickerInput","dateRangeInput","parallel","_selectControl","_inputControl","_datepickerInputControl","input","getThemeColor","isAccent","isWarn","hostEl","errors","getErrors","map","e","getText","filter","getTextHints"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AA8BUA,EAAAA,gBAAA,QAAAC,kBAAA,CAAA,iCAAA,CAAA;EAEAC,gBACA,GAAA,IAEA,CAAAD,kBAEA,CACA,iCAAA,CAAA;kCAC+B,CAAA,qBAAA,CAAA;EAEvCE,MAAA,GAAA,IAAA,CAAAC,aAAsB,CAAA,0BAAqB,CAAA;;;yBA4BE,GAAA,IAAA,CAAAH,kBAAA,CAAAI,yBAAA,CAAA;AACvCC,EAAAA,sBAAa,GAAA,IAAA,CAAAL,kBAAA,CAAAM,wBAAA,CAAA;EACjBC,UAAA,GAAA,IAAoB,CAAAC,UAAM,CAAiB,6BAAA,CAAA;AACvCC,EAAAA;AACF,EAAA,OAAAC,eAAgB,qBAAA;SAU2BC,IAAAA,CAAAC,OAAA,GAAA,EAAA,EAAA;IAE7C,OAAAC,IAAAA,gBAAA,CAAAD,IAAAA,EAAAA,OAAA;;EAOA,MAAAE,aAGFA,GAAyC;qBAEhC,GAAA,MAAA,IAAY,CAAAP,UAAiB,EAAA;cACtCQ,WAAA,CAAAC,QAAA,CAAA,0BAAA,CAAA,EAAA;aAIE,SACF;;;;;kBAuCQ,IAAAC,CAAAA;;AAINC,EAAAA,MAAAA;;AAIF,IAAA,OAAAC,OAAA,KAAA,IAAA,GAAA,MAAAA,OAAmB,CAAAH,QAAA,CAAA,iCAAA,CAAA,GAAA,KAAA;AACjB;AAEE,EAAA,MAAAI,QAAA,GAAA;;AAGA,IAAA,OAAAD,OAAA;;AAEA,EAAA,MAAAE,SAAA,GAAA;IAEF,OAAAC,CAAAA,MAAAA,IAAAA,CAAAA,aAAA,IAAgBC,MAAA,GAAA,CAAA;;AAIlBC,EAAAA,MAAAA,UAAmBA,GAAA;IACjB,OAAAC,CAAAA,MAAAA,IAAAA,CAAAA,IAAA,IAAAT,QAAA,CAAA,yBAAA,CAAA;;AAKFU,EAAAA,MAAAA,YAAMA,GAAA;IACJ,OAAAD,CAAAA,MAAAA,IAAAA,CAAAA,IAAA,IAAAT,QAAA,CAAA,2BAAA,CAAA;;QAKAW,UAAAA,CAAAC,MAAc;AACd,IAAA,IAAAA,IAAA,EAAA;;AAIF;IACE,MAAAC,CAAAA,MAAA,OAAe,EAAAC,eAAW,EAAAC,cAAA,CAAkBC,GAAAA,MAAAA,QAAA,CAC5C,MAAA,CAAA,IAAA,CAAAC,cAAA,EA4BA,EAAA,IAAA,CAAAC,aAAA,EACF,EAAA,IAAA,CAAAC,uBAAA,EAEA,EAAA,IAAA,CAAA9B,sBAAA;AAGG,IAAA,OAAAyB,eAAA,IAAAC,cAAA,IAAAF,MAAA,IAAAO,KAAA;;qBAGCC,GAAA;gBACF,GAAA,MAAA,IAAA,CAAAZ,IAAA,EAAA;AACA,IAAA,MAAA,CAAAa,QAAA,EAAAC,MAAA,CAAA,GAAA,MAAAP,QAAA,CAAA,MAAA;AAGF,MAAA,OAAA,CAAAQ,MAAA,CAAAxB,QAAA,CAAAwB,YAAAA,CAAAA,EAAAA,MAAA,CAAAxB,QAAA,CAAA,UAAA,CAAA,CAAA;;;AAIA,MAAA,OAAA,QAAA;WAEI,IAAAuB,MAAO,EAAA;aACT,MAAA;;IAEF,OAAA,SAAA;;QAIEjB,aAAA,GAAA;UAAAmB,SAAe,MAAA,IAAA,CAAAC,SAAA,EAAA;mBAC6D,CAAA,MAAAD,MAAA,CAAAE,GAAA,CAAAC,CAAA,IAAAA,CAAA,CAAAC,OAAA,EAAA,CAAA,CAAA;;;AAK1E,IAAA,OAAA,IAAA,CAAA1C,aAAA,CAAAM,IAAAA,CAAAA,aAAA,CAAAE,IAAA,CAAAmC,MAAA,CAAA,CAAA,EAAA;AACD;AAEHC,EAAAA,MAAAA,YAAAA,GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}