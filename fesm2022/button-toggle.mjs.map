{"version":3,"file":"button-toggle.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/button-toggle/button-toggle.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/button-toggle/button-toggle-module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {_IdGenerator, FocusMonitor} from '@angular/cdk/a11y';\nimport {Direction, Directionality} from '@angular/cdk/bidi';\nimport {SelectionModel} from '@angular/cdk/collections';\nimport {\n  DOWN_ARROW,\n  ENTER,\n  LEFT_ARROW,\n  RIGHT_ARROW,\n  SPACE,\n  UP_ARROW,\n  hasModifierKey,\n} from '@angular/cdk/keycodes';\nimport {_CdkPrivateStyleLoader} from '@angular/cdk/private';\nimport {\n  AfterContentInit,\n  AfterViewInit,\n  booleanAttribute,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  forwardRef,\n  HostAttributeToken,\n  inject,\n  InjectionToken,\n  Input,\n  OnDestroy,\n  OnInit,\n  Output,\n  QueryList,\n  signal,\n  ViewChild,\n  ViewEncapsulation,\n  WritableSignal,\n} from '@angular/core';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '@angular/forms';\nimport {_animationsDisabled, _StructuralStylesLoader, MatPseudoCheckbox, MatRipple} from '../core';\n\n/**\n * @deprecated No longer used.\n * @breaking-change 11.0.0\n */\nexport type ToggleType = 'checkbox' | 'radio';\n\n/** Possible appearance styles for the button toggle. */\nexport type MatButtonToggleAppearance = 'legacy' | 'standard';\n\n/**\n * Represents the default options for the button toggle that can be configured\n * using the `MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS` injection token.\n */\nexport interface MatButtonToggleDefaultOptions {\n  /**\n   * Default appearance to be used by button toggles. Can be overridden by explicitly\n   * setting an appearance on a button toggle or group.\n   */\n  appearance?: MatButtonToggleAppearance;\n  /** Whether icon indicators should be hidden for single-selection button toggle groups. */\n  hideSingleSelectionIndicator?: boolean;\n  /** Whether icon indicators should be hidden for multiple-selection button toggle groups. */\n  hideMultipleSelectionIndicator?: boolean;\n  /** Whether disabled toggle buttons should be interactive. */\n  disabledInteractive?: boolean;\n}\n\n/**\n * Injection token that can be used to configure the\n * default options for all button toggles within an app.\n */\nexport const MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS = new InjectionToken<MatButtonToggleDefaultOptions>(\n  'MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS',\n  {\n    providedIn: 'root',\n    factory: () => ({\n      hideSingleSelectionIndicator: false,\n      hideMultipleSelectionIndicator: false,\n      disabledInteractive: false,\n    }),\n  },\n);\n\n/**\n * Injection token that can be used to reference instances of `MatButtonToggleGroup`.\n * It serves as alternative token to the actual `MatButtonToggleGroup` class which\n * could cause unnecessary retention of the class and its component metadata.\n */\nexport const MAT_BUTTON_TOGGLE_GROUP = new InjectionToken<MatButtonToggleGroup>(\n  'MatButtonToggleGroup',\n);\n\n/**\n * Provider Expression that allows mat-button-toggle-group to register as a ControlValueAccessor.\n * This allows it to support [(ngModel)].\n * @docs-private\n */\nexport const MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatButtonToggleGroup),\n  multi: true,\n};\n\n/** Change event object emitted by button toggle. */\nexport class MatButtonToggleChange {\n  constructor(\n    /** The button toggle that emits the event. */\n    public source: MatButtonToggle,\n\n    /** The value assigned to the button toggle. */\n    public value: any,\n  ) {}\n}\n\n/** Exclusive selection button toggle group that behaves like a radio-button group. */\n@Directive({\n  selector: 'mat-button-toggle-group',\n  providers: [\n    MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR,\n    {provide: MAT_BUTTON_TOGGLE_GROUP, useExisting: MatButtonToggleGroup},\n  ],\n  host: {\n    'class': 'mat-button-toggle-group',\n    '(keydown)': '_keydown($event)',\n    '[attr.role]': \"multiple ? 'group' : 'radiogroup'\",\n    '[attr.aria-disabled]': 'disabled',\n    '[class.mat-button-toggle-vertical]': 'vertical',\n    '[class.mat-button-toggle-group-appearance-standard]': 'appearance === \"standard\"',\n  },\n  exportAs: 'matButtonToggleGroup',\n})\nexport class MatButtonToggleGroup implements ControlValueAccessor, OnInit, AfterContentInit {\n  private _changeDetector = inject(ChangeDetectorRef);\n  private _dir = inject(Directionality, {optional: true});\n\n  private _multiple = false;\n  private _disabled = false;\n  private _disabledInteractive = false;\n  private _selectionModel: SelectionModel<MatButtonToggle>;\n\n  /**\n   * Reference to the raw value that the consumer tried to assign. The real\n   * value will exclude any values from this one that don't correspond to a\n   * toggle. Useful for the cases where the value is assigned before the toggles\n   * have been initialized or at the same that they're being swapped out.\n   */\n  private _rawValue: any;\n\n  /**\n   * The method to be called in order to update ngModel.\n   * Now `ngModel` binding is not supported in multiple selection mode.\n   */\n  _controlValueAccessorChangeFn: (value: any) => void = () => {};\n\n  /** onTouch function registered via registerOnTouch (ControlValueAccessor). */\n  _onTouched: () => any = () => {};\n\n  /** Child button toggle buttons. */\n  @ContentChildren(forwardRef(() => MatButtonToggle), {\n    // Note that this would technically pick up toggles\n    // from nested groups, but that's not a case that we support.\n    descendants: true,\n  })\n  _buttonToggles: QueryList<MatButtonToggle>;\n\n  /** The appearance for all the buttons in the group. */\n  @Input() appearance: MatButtonToggleAppearance;\n\n  /** `name` attribute for the underlying `input` element. */\n  @Input()\n  get name(): string {\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    this._markButtonsForCheck();\n  }\n  private _name = inject(_IdGenerator).getId('mat-button-toggle-group-');\n\n  /** Whether the toggle group is vertical. */\n  @Input({transform: booleanAttribute}) vertical: boolean;\n\n  /** Value of the toggle group. */\n  @Input()\n  get value(): any {\n    const selected = this._selectionModel ? this._selectionModel.selected : [];\n\n    if (this.multiple) {\n      return selected.map(toggle => toggle.value);\n    }\n\n    return selected[0] ? selected[0].value : undefined;\n  }\n  set value(newValue: any) {\n    this._setSelectionByValue(newValue);\n    this.valueChange.emit(this.value);\n  }\n\n  /**\n   * Event that emits whenever the value of the group changes.\n   * Used to facilitate two-way data binding.\n   * @docs-private\n   */\n  @Output() readonly valueChange = new EventEmitter<any>();\n\n  /** Selected button toggles in the group. */\n  get selected(): MatButtonToggle | MatButtonToggle[] {\n    const selected = this._selectionModel ? this._selectionModel.selected : [];\n    return this.multiple ? selected : selected[0] || null;\n  }\n\n  /** Whether multiple button toggles can be selected. */\n  @Input({transform: booleanAttribute})\n  get multiple(): boolean {\n    return this._multiple;\n  }\n  set multiple(value: boolean) {\n    this._multiple = value;\n    this._markButtonsForCheck();\n  }\n\n  /** Whether multiple button toggle group is disabled. */\n  @Input({transform: booleanAttribute})\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(value: boolean) {\n    this._disabled = value;\n    this._markButtonsForCheck();\n  }\n\n  /** Whether buttons in the group should be interactive while they're disabled. */\n  @Input({transform: booleanAttribute})\n  get disabledInteractive(): boolean {\n    return this._disabledInteractive;\n  }\n  set disabledInteractive(value: boolean) {\n    this._disabledInteractive = value;\n    this._markButtonsForCheck();\n  }\n\n  /** The layout direction of the toggle button group. */\n  get dir(): Direction {\n    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n  }\n\n  /** Event emitted when the group's value changes. */\n  @Output() readonly change: EventEmitter<MatButtonToggleChange> =\n    new EventEmitter<MatButtonToggleChange>();\n\n  /** Whether checkmark indicator for single-selection button toggle groups is hidden. */\n  @Input({transform: booleanAttribute})\n  get hideSingleSelectionIndicator(): boolean {\n    return this._hideSingleSelectionIndicator;\n  }\n  set hideSingleSelectionIndicator(value: boolean) {\n    this._hideSingleSelectionIndicator = value;\n    this._markButtonsForCheck();\n  }\n  private _hideSingleSelectionIndicator: boolean;\n\n  /** Whether checkmark indicator for multiple-selection button toggle groups is hidden. */\n  @Input({transform: booleanAttribute})\n  get hideMultipleSelectionIndicator(): boolean {\n    return this._hideMultipleSelectionIndicator;\n  }\n  set hideMultipleSelectionIndicator(value: boolean) {\n    this._hideMultipleSelectionIndicator = value;\n    this._markButtonsForCheck();\n  }\n  private _hideMultipleSelectionIndicator: boolean;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const defaultOptions = inject<MatButtonToggleDefaultOptions>(\n      MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS,\n      {optional: true},\n    );\n\n    this.appearance =\n      defaultOptions && defaultOptions.appearance ? defaultOptions.appearance : 'standard';\n    this.hideSingleSelectionIndicator = defaultOptions?.hideSingleSelectionIndicator ?? false;\n    this.hideMultipleSelectionIndicator = defaultOptions?.hideMultipleSelectionIndicator ?? false;\n  }\n\n  ngOnInit() {\n    this._selectionModel = new SelectionModel<MatButtonToggle>(this.multiple, undefined, false);\n  }\n\n  ngAfterContentInit() {\n    this._selectionModel.select(...this._buttonToggles.filter(toggle => toggle.checked));\n    if (!this.multiple) {\n      this._initializeTabIndex();\n    }\n  }\n\n  /**\n   * Sets the model value. Implemented as part of ControlValueAccessor.\n   * @param value Value to be set to the model.\n   */\n  writeValue(value: any) {\n    this.value = value;\n    this._changeDetector.markForCheck();\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  registerOnChange(fn: (value: any) => void) {\n    this._controlValueAccessorChangeFn = fn;\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  registerOnTouched(fn: any) {\n    this._onTouched = fn;\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  setDisabledState(isDisabled: boolean): void {\n    this.disabled = isDisabled;\n  }\n\n  /** Handle keydown event calling to single-select button toggle. */\n  protected _keydown(event: KeyboardEvent) {\n    if (this.multiple || this.disabled || hasModifierKey(event)) {\n      return;\n    }\n\n    const target = event.target as HTMLButtonElement;\n    const buttonId = target.id;\n    const index = this._buttonToggles.toArray().findIndex(toggle => {\n      return toggle.buttonId === buttonId;\n    });\n\n    let nextButton: MatButtonToggle | null = null;\n    switch (event.keyCode) {\n      case SPACE:\n      case ENTER:\n        nextButton = this._buttonToggles.get(index) || null;\n        break;\n      case UP_ARROW:\n        nextButton = this._getNextButton(index, -1);\n        break;\n      case LEFT_ARROW:\n        nextButton = this._getNextButton(index, this.dir === 'ltr' ? -1 : 1);\n        break;\n      case DOWN_ARROW:\n        nextButton = this._getNextButton(index, 1);\n        break;\n      case RIGHT_ARROW:\n        nextButton = this._getNextButton(index, this.dir === 'ltr' ? 1 : -1);\n        break;\n      default:\n        return;\n    }\n\n    if (nextButton) {\n      event.preventDefault();\n      nextButton._onButtonClick();\n      nextButton.focus();\n    }\n  }\n\n  /** Dispatch change event with current selection and group value. */\n  _emitChangeEvent(toggle: MatButtonToggle): void {\n    const event = new MatButtonToggleChange(toggle, this.value);\n    this._rawValue = event.value;\n    this._controlValueAccessorChangeFn(event.value);\n    this.change.emit(event);\n  }\n\n  /**\n   * Syncs a button toggle's selected state with the model value.\n   * @param toggle Toggle to be synced.\n   * @param select Whether the toggle should be selected.\n   * @param isUserInput Whether the change was a result of a user interaction.\n   * @param deferEvents Whether to defer emitting the change events.\n   */\n  _syncButtonToggle(\n    toggle: MatButtonToggle,\n    select: boolean,\n    isUserInput = false,\n    deferEvents = false,\n  ) {\n    // Deselect the currently-selected toggle, if we're in single-selection\n    // mode and the button being toggled isn't selected at the moment.\n    if (!this.multiple && this.selected && !toggle.checked) {\n      (this.selected as MatButtonToggle).checked = false;\n    }\n\n    if (this._selectionModel) {\n      if (select) {\n        this._selectionModel.select(toggle);\n      } else {\n        this._selectionModel.deselect(toggle);\n      }\n    } else {\n      deferEvents = true;\n    }\n\n    // We need to defer in some cases in order to avoid \"changed after checked errors\", however\n    // the side-effect is that we may end up updating the model value out of sequence in others\n    // The `deferEvents` flag allows us to decide whether to do it on a case-by-case basis.\n    if (deferEvents) {\n      Promise.resolve().then(() => this._updateModelValue(toggle, isUserInput));\n    } else {\n      this._updateModelValue(toggle, isUserInput);\n    }\n  }\n\n  /** Checks whether a button toggle is selected. */\n  _isSelected(toggle: MatButtonToggle) {\n    return this._selectionModel && this._selectionModel.isSelected(toggle);\n  }\n\n  /** Determines whether a button toggle should be checked on init. */\n  _isPrechecked(toggle: MatButtonToggle) {\n    if (typeof this._rawValue === 'undefined') {\n      return false;\n    }\n\n    if (this.multiple && Array.isArray(this._rawValue)) {\n      return this._rawValue.some(value => toggle.value != null && value === toggle.value);\n    }\n\n    return toggle.value === this._rawValue;\n  }\n\n  /** Initializes the tabindex attribute using the radio pattern. */\n  private _initializeTabIndex() {\n    this._buttonToggles.forEach(toggle => {\n      toggle.tabIndex = -1;\n    });\n    if (this.selected) {\n      (this.selected as MatButtonToggle).tabIndex = 0;\n    } else {\n      for (let i = 0; i < this._buttonToggles.length; i++) {\n        const toggle = this._buttonToggles.get(i)!;\n\n        if (!toggle.disabled) {\n          toggle.tabIndex = 0;\n          break;\n        }\n      }\n    }\n  }\n\n  /** Obtain the subsequent toggle to which the focus shifts. */\n  private _getNextButton(startIndex: number, offset: number): MatButtonToggle | null {\n    const items = this._buttonToggles;\n\n    for (let i = 1; i <= items.length; i++) {\n      const index = (startIndex + offset * i + items.length) % items.length;\n      const item = items.get(index);\n\n      if (item && !item.disabled) {\n        return item;\n      }\n    }\n\n    return null;\n  }\n\n  /** Updates the selection state of the toggles in the group based on a value. */\n  private _setSelectionByValue(value: any | any[]) {\n    this._rawValue = value;\n\n    if (!this._buttonToggles) {\n      return;\n    }\n\n    const toggles = this._buttonToggles.toArray();\n\n    if (this.multiple && value) {\n      if (!Array.isArray(value) && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('Value must be an array in multiple-selection mode.');\n      }\n\n      this._clearSelection();\n      value.forEach((currentValue: any) => this._selectValue(currentValue, toggles));\n    } else {\n      this._clearSelection();\n      this._selectValue(value, toggles);\n    }\n\n    // In single selection mode we need at least one enabled toggle to always be focusable.\n    if (!this.multiple && toggles.every(toggle => toggle.tabIndex === -1)) {\n      for (const toggle of toggles) {\n        if (!toggle.disabled) {\n          toggle.tabIndex = 0;\n          break;\n        }\n      }\n    }\n  }\n\n  /** Clears the selected toggles. */\n  private _clearSelection() {\n    this._selectionModel.clear();\n    this._buttonToggles.forEach(toggle => {\n      toggle.checked = false;\n      // If the button toggle is in single select mode, initialize the tabIndex.\n      if (!this.multiple) {\n        toggle.tabIndex = -1;\n      }\n    });\n  }\n\n  /** Selects a value if there's a toggle that corresponds to it. */\n  private _selectValue(value: any, toggles: MatButtonToggle[]) {\n    for (const toggle of toggles) {\n      if (toggle.value === value) {\n        toggle.checked = true;\n        this._selectionModel.select(toggle);\n        if (!this.multiple) {\n          // If the button toggle is in single select mode, reset the tabIndex.\n          toggle.tabIndex = 0;\n        }\n        break;\n      }\n    }\n  }\n\n  /** Syncs up the group's value with the model and emits the change event. */\n  private _updateModelValue(toggle: MatButtonToggle, isUserInput: boolean) {\n    // Only emit the change event for user input.\n    if (isUserInput) {\n      this._emitChangeEvent(toggle);\n    }\n\n    // Note: we emit this one no matter whether it was a user interaction, because\n    // it is used by Angular to sync up the two-way data binding.\n    this.valueChange.emit(this.value);\n  }\n\n  /** Marks all of the child button toggles to be checked. */\n  private _markButtonsForCheck() {\n    this._buttonToggles?.forEach(toggle => toggle._markForCheck());\n  }\n}\n\n/** Single button inside of a toggle group. */\n@Component({\n  selector: 'mat-button-toggle',\n  templateUrl: 'button-toggle.html',\n  styleUrl: 'button-toggle.css',\n  encapsulation: ViewEncapsulation.None,\n  exportAs: 'matButtonToggle',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  host: {\n    '[class.mat-button-toggle-standalone]': '!buttonToggleGroup',\n    '[class.mat-button-toggle-checked]': 'checked',\n    '[class.mat-button-toggle-disabled]': 'disabled',\n    '[class.mat-button-toggle-disabled-interactive]': 'disabledInteractive',\n    '[class.mat-button-toggle-appearance-standard]': 'appearance === \"standard\"',\n    'class': 'mat-button-toggle',\n    '[attr.aria-label]': 'null',\n    '[attr.aria-labelledby]': 'null',\n    '[attr.id]': 'id',\n    '[attr.name]': 'null',\n    '(focus)': 'focus()',\n    'role': 'presentation',\n  },\n  imports: [MatRipple, MatPseudoCheckbox],\n})\nexport class MatButtonToggle implements OnInit, AfterViewInit, OnDestroy {\n  private _changeDetectorRef = inject(ChangeDetectorRef);\n  private _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  private _focusMonitor = inject(FocusMonitor);\n  private _idGenerator = inject(_IdGenerator);\n  private _animationDisabled = _animationsDisabled();\n  private _checked = false;\n\n  /**\n   * Attached to the aria-label attribute of the host element. In most cases, aria-labelledby will\n   * take precedence so this may be omitted.\n   */\n  @Input('aria-label') ariaLabel: string;\n\n  /**\n   * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element\n   */\n  @Input('aria-labelledby') ariaLabelledby: string | null = null;\n\n  /** Underlying native `button` element. */\n  @ViewChild('button') _buttonElement: ElementRef<HTMLButtonElement>;\n\n  /** The parent button toggle group (exclusive selection). Optional. */\n  buttonToggleGroup: MatButtonToggleGroup;\n\n  /** Unique ID for the underlying `button` element. */\n  get buttonId(): string {\n    return `${this.id}-button`;\n  }\n\n  /** The unique ID for this button toggle. */\n  @Input() id: string;\n\n  /** HTML's 'name' attribute used to group radios for unique selection. */\n  @Input() name: string;\n\n  /** MatButtonToggleGroup reads this to assign its own value. */\n  @Input() value: any;\n\n  /** Tabindex of the toggle. */\n  @Input()\n  get tabIndex(): number | null {\n    return this._tabIndex();\n  }\n  set tabIndex(value: number | null) {\n    this._tabIndex.set(value);\n  }\n  private _tabIndex: WritableSignal<number | null>;\n\n  /** Whether ripples are disabled on the button toggle. */\n  @Input({transform: booleanAttribute}) disableRipple: boolean;\n\n  /** The appearance style of the button. */\n  @Input()\n  get appearance(): MatButtonToggleAppearance {\n    return this.buttonToggleGroup ? this.buttonToggleGroup.appearance : this._appearance;\n  }\n  set appearance(value: MatButtonToggleAppearance) {\n    this._appearance = value;\n  }\n  private _appearance: MatButtonToggleAppearance;\n\n  /** Whether the button is checked. */\n  @Input({transform: booleanAttribute})\n  get checked(): boolean {\n    return this.buttonToggleGroup ? this.buttonToggleGroup._isSelected(this) : this._checked;\n  }\n  set checked(value: boolean) {\n    if (value !== this._checked) {\n      this._checked = value;\n\n      if (this.buttonToggleGroup) {\n        this.buttonToggleGroup._syncButtonToggle(this, this._checked);\n      }\n\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n\n  /** Whether the button is disabled. */\n  @Input({transform: booleanAttribute})\n  get disabled(): boolean {\n    return this._disabled || (this.buttonToggleGroup && this.buttonToggleGroup.disabled);\n  }\n  set disabled(value: boolean) {\n    this._disabled = value;\n  }\n  private _disabled: boolean = false;\n\n  /** Whether the button should remain interactive when it is disabled. */\n  @Input({transform: booleanAttribute})\n  get disabledInteractive(): boolean {\n    return (\n      this._disabledInteractive ||\n      (this.buttonToggleGroup !== null && this.buttonToggleGroup.disabledInteractive)\n    );\n  }\n  set disabledInteractive(value: boolean) {\n    this._disabledInteractive = value;\n  }\n  private _disabledInteractive: boolean;\n\n  /** Event emitted when the group value changes. */\n  @Output() readonly change: EventEmitter<MatButtonToggleChange> =\n    new EventEmitter<MatButtonToggleChange>();\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    inject(_CdkPrivateStyleLoader).load(_StructuralStylesLoader);\n    const toggleGroup = inject<MatButtonToggleGroup>(MAT_BUTTON_TOGGLE_GROUP, {optional: true})!;\n    const defaultTabIndex = inject(new HostAttributeToken('tabindex'), {optional: true}) || '';\n    const defaultOptions = inject<MatButtonToggleDefaultOptions>(\n      MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS,\n      {optional: true},\n    );\n\n    this._tabIndex = signal<number | null>(parseInt(defaultTabIndex) || 0);\n    this.buttonToggleGroup = toggleGroup;\n    this.appearance =\n      defaultOptions && defaultOptions.appearance ? defaultOptions.appearance : 'standard';\n    this.disabledInteractive = defaultOptions?.disabledInteractive ?? false;\n  }\n\n  ngOnInit() {\n    const group = this.buttonToggleGroup;\n    this.id = this.id || this._idGenerator.getId('mat-button-toggle-');\n\n    if (group) {\n      if (group._isPrechecked(this)) {\n        this.checked = true;\n      } else if (group._isSelected(this) !== this._checked) {\n        // As side effect of the circular dependency between the toggle group and the button,\n        // we may end up in a state where the button is supposed to be checked on init, but it\n        // isn't, because the checked value was assigned too early. This can happen when Ivy\n        // assigns the static input value before the `ngOnInit` has run.\n        group._syncButtonToggle(this, this._checked);\n      }\n    }\n  }\n\n  ngAfterViewInit() {\n    // This serves two purposes:\n    // 1. We don't want the animation to fire on the first render for pre-checked toggles so we\n    //    delay adding the class until the view is rendered.\n    // 2. We don't want to animate if animations are disabled.\n    if (!this._animationDisabled) {\n      this._elementRef.nativeElement.classList.add('mat-button-toggle-animations-enabled');\n    }\n\n    this._focusMonitor.monitor(this._elementRef, true);\n  }\n\n  ngOnDestroy() {\n    const group = this.buttonToggleGroup;\n\n    this._focusMonitor.stopMonitoring(this._elementRef);\n\n    // Remove the toggle from the selection once it's destroyed. Needs to happen\n    // on the next tick in order to avoid \"changed after checked\" errors.\n    if (group && group._isSelected(this)) {\n      group._syncButtonToggle(this, false, false, true);\n    }\n  }\n\n  /** Focuses the button. */\n  focus(options?: FocusOptions): void {\n    this._buttonElement.nativeElement.focus(options);\n  }\n\n  /** Checks the button toggle due to an interaction with the underlying native button. */\n  _onButtonClick() {\n    if (this.disabled) {\n      return;\n    }\n\n    const newChecked = this.isSingleSelector() ? true : !this._checked;\n\n    if (newChecked !== this._checked) {\n      this._checked = newChecked;\n      if (this.buttonToggleGroup) {\n        this.buttonToggleGroup._syncButtonToggle(this, this._checked, true);\n        this.buttonToggleGroup._onTouched();\n      }\n    }\n\n    if (this.isSingleSelector()) {\n      const focusable = this.buttonToggleGroup._buttonToggles.find(toggle => {\n        return toggle.tabIndex === 0;\n      });\n      // Modify the tabindex attribute of the last focusable button toggle to -1.\n      if (focusable) {\n        focusable.tabIndex = -1;\n      }\n      // Modify the tabindex attribute of the presently selected button toggle to 0.\n      this.tabIndex = 0;\n    }\n\n    // Emit a change event when it's the single selector\n    this.change.emit(new MatButtonToggleChange(this, this.value));\n  }\n\n  /**\n   * Marks the button toggle as needing checking for change detection.\n   * This method is exposed because the parent button toggle group will directly\n   * update bound properties of the radio button.\n   */\n  _markForCheck() {\n    // When the group value changes, the button will not be notified.\n    // Use `markForCheck` to explicit update button toggle's status.\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /** Gets the name that should be assigned to the inner DOM node. */\n  _getButtonName(): string | null {\n    if (this.isSingleSelector()) {\n      return this.buttonToggleGroup.name;\n    }\n    return this.name || null;\n  }\n\n  /** Whether the toggle is in single selection mode. */\n  isSingleSelector(): boolean {\n    return this.buttonToggleGroup && !this.buttonToggleGroup.multiple;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {BidiModule} from '@angular/cdk/bidi';\nimport {MatRippleModule} from '../core';\nimport {MatButtonToggle, MatButtonToggleGroup} from './button-toggle';\n\n@NgModule({\n  imports: [MatRippleModule, MatButtonToggleGroup, MatButtonToggle],\n  exports: [BidiModule, MatButtonToggleGroup, MatButtonToggle],\n})\nexport class MatButtonToggleModule {}\n"],"names":["MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS","InjectionToken","MAT_BUTTON_TOGGLE_GROUP","MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR","NG_VALUE_ACCESSOR","source","value","constructor","MatButtonToggleGroup","_changeDetector","inject","ChangeDetectorRef","Directionality","optional","_selectionModel","_rawValue","_onTouched","_name","_IdGenerator","getId","selected","map","toggle","undefined","newValue","_setSelectionByValue","valueChange","emit","EventEmitter","multiple","disabledInteractive","_disabledInteractive","_markButtonsForCheck","_dir","_hideSingleSelectionIndicator","hideSingleSelectionIndicator","hideMultipleSelectionIndicator","defaultOptions","appearance","SelectionModel","ngAfterContentInit","select","_buttonToggles","filter","checked","setDisabledState","isDisabled","disabled","_keydown","event","hasModifierKey","target","buttonId","id","SPACE","ENTER","nextButton","get","index","_getNextButton","LEFT_ARROW","dir","DOWN_ARROW","RIGHT_ARROW","preventDefault","_onButtonClick","focus","change","deselect","deferEvents","resolve","then","_updateModelValue","isUserInput","_isSelected","isSelected","isArray","i","length","tabIndex","offset","items","startIndex","item","toggles","toArray","Array","ngDevMode","Error","_clearSelection","forEach","currentValue","_selectValue","every","clear","_emitChangeEvent","_markForCheck","ɵfac","i0","ɵɵngDeclareFactory","minVersion","version","ngImport","type","deps","ɵɵFactoryTarget","Directive","ɵdir","ɵɵngDeclareDirective","isStandalone","selector","inputs","name","vertical","booleanAttribute","outputs","host","listeners","properties","classAttribute","providers","predicate","forwardRef","MatButtonToggle","descendants","exportAs","ctorParameters","propDecorators","Output","transform","Input","args","ElementRef","FocusMonitor","buttonToggleGroup","_tabIndex","set","_appearance","_checked","_syncButtonToggle","_changeDetectorRef","markForCheck","load","_StructuralStylesLoader","MatRipple","MatPseudoCheckbox","template","styles","ariaLabel","ɵmod","ɵɵngDeclareNgModule","MatButtonToggleModule","imports","MatRippleModule","exports","BidiModule","decorators"],"mappings":";;;;;;;;;;;;;;;;;MAoHiBA,iCAAA,GAAA,IAAAC,cAAA,CAAA,mCAAA,EAAA;YAGN,EAAA,MAAA;;;;;;;AAyETC,MAAAA,uBAAA,OAAAD,cAAA,CAAA,sBAAA;AAWE,MAAAE,sCAAA,GAAA;WACKC,iBAAA;;;;;EAWPC,MAAA;EACEC,KAAA;EACAC,WAAAA,cAOF,EAAA;IAGM,IAAAF,CAAAA,MAAA,GAAAA,MAAA;IAKM,IAAAC,CAAAA,KAAA,GAAAA,KAAA;;;AAFZ,MAAAE,oBAAA,CAAA;EAEYC,eAAA,GAAAC,MAAA,CAAAC,iBAAA,CAAA;MALN,GAAAD,MAAA,CAAAE,cAAqB,EAAA;IAAAC,QAAA,EAAA;AAAA,GAAA,CAAA;AAKf,EAAA,SAAA,GAAA,KAAA;;;EAIVC,eAAA;EA+BFC,SAAA;;AAUMC,EAAAA,UAAqB,GAAAA,MAAA,EAAA;;AAYzB,EAAA,UAAA;;WAIF,IAAA,CAAAC,KAAA;AAGE;gBAOA,EAAA;IAGF,IAAAA,CAAAA,KAAA,GAAAX,KAAA;;AAGG;AACHW,EAAAA,KACE,GAAAP,MAAA,CAAAQ,YAAA,EAAAC,KAAA,CAAA,0BAAA,CAAA;;AAKFb,EAAAA,IAAAA,KAAAA,GAAA;AACE,IAAA,MAAAc,QAAA,GAAAN,IAAAA,CAAAA,eAAK,GAAAA,IAAAA,CAAAA,eAAA,CAAAM,QAAA,GAAA,EAAA;;MAGwC,OAAAA,QAAA,CAAAC,GAAA,CAAAC,MAAA,IAAAA,MAAA,CAAAhB,KAAA,CAAA;AAE7C;AACF,IAAA,OAAAc,QAAA,CAAAA,CAAAA,CAAAA,GAAAA,QAAA,CAAAd,CAAAA,CAAAA,CAAAA,KAAA,GAAAiB,SAAA;AAGA;EACE,IACFjB,KAAAA,CAAAkB,QAAA,EAAA;IAEA,IAAAC,CAAAA,oBAAmE,CAAAD,QAAA,CAAA;AAEjE,IAAA,IAAA,CAAAE,WAAQ,CAASC,IAAA,MAAArB,KAAA,CAAA;;AAUb,EAAA,WAAA,GAAA,IAAAsB,YAAyC,EAAA;AAG3C,EAAA,IAAAR,QAAA,GAAA;;;;EAKQ,IAAAS,QAAAA,GAAA;;;AAIRA,EAAAA,IAAAA,QAAAA,CAAAvB,KAAe,EAAA;kBACb,GAAAA,KAAU;;;;;;oBAUN,EAAA;;;;yBAQFwB,GAAY;AAClB,IAAA,OAAA,IAAA,CAAAC,oBAAA;AACA;AACAD,EAAAA,IAAAA,yBAAiB,EAAA;IACnB,IAAA,CAAAC,oBAAA,GAAAzB,KAAA;AAEA,IAAA,IAAA,CAAA0B,oBAAA,EAAA;;;AAMG,IAAA,OAAA,IAAA,CAAAC,IAAA,IAAA,IAAA,CAAAA,IAAA,CAAA3B,KAAA,KAAA,KAAA,GAAA,KAAA,GAAA,KAAA;;WAQiE,IAAAsB,YAAA,EAAA;;AAKlE,IAAA,OAAA,KAAAM,6BAAA;;AAEI,EAAA,IAAAC,6BAAA7B,KAAA,EAAA;;AAEK,IAAA,IAAe,qBACtB,EAAA;;;;+CAOqF;;AAErF8B,EAAAA,IAAAA,8BAAsBA,CAAA9B,KAAA,EAAA;;6BACjB,EAAA;;iCAKyC;aAClDC,GAAA;AACE,IAAA,MAAA8B,cAAA,GAAA3B,MAAA,CAAAV,iCAAA,EAAA;MAAAa,QAAA,EAAA;AAAA,KAAA,CAAA;IACF,IAAAyB,CAAAA,UAAA,GAEoED,cAAA,IAAAA,cAAA,CAAAC,UAAA,GAAAD,cAAA,CAAAC,UAAA,GAAA,UAAA;AACpE,IAAA,IAAA,CAAAH,4BAAqC,GAAAE,cAAA,EAAAF,4BAAA,IAAA,KAAA;AACnC,IAAA,IAAA,CAAAC,8BAAA,GAAAC,cAAA,EAAAD,8BAAA,IAAA,KAAA;AACE;;IAOF,IAAAtB,CAAAA,eAAc,GAAK,IAAAyB,cACrB,MAAAV,QAAA,EAAAN,SAEkE,EAAA,KAAA,CAAA;;oBAIhEiB,GAAA;AACA,IAAA,IAAA,CAAA1B,eAAA,CAAA2B,MAAA,QAAmB,CAAAC,cAAA,CAAAC,MAAA,CAAArB,MAAA,IAAAA,MAAA,CAAAsB,OAAA,CAAA,CAAA;IAChB,IAAA,CAAA,KAAAf,QAAA,EAAA;;AAED;;kBAQF,EAAA;IACF,IAAA,CAAAvB,KAAA,GAAAA,KAAA;;AAIE;;;AAME;;;;AASIuC,EAAAA,gBAAAA,CAAAC,UAAA,EAAA;IACN,IAAAC,CAAAA,QAAA,GAAAD,UAAA;;AAMAE,EAAAA,QAAAA,CAAMC,KAAA,EAAA;AAEN,IAAA,IAAA,IAAA,CAAApB,QAAA,IAAAkB,IAAAA,CAAAA,QAAA,IAAAG,cAAA,CAAAD,KAAA,CAAA,EAAA;AAEI,MAAA;;mBAGGA,KAAe,CAAAE,MAAA;AACpB,IAAA,MAAAC,QAAA,GAAAD,MAAA,CAAAE,EAAA;oEACK;AACe,MAAA,OAAE/B,MAAA,CAAA8B,QAAA,KAAAA,QAAA;AACtB,KAAA,CAAA;kBACF,GAAA,IAAA;;AAIE,MAAA,KAAAE,KAAA;AACE,MAAA,KAAAC,KAAA;AACEC,QAAAA,UAAA,GAAA,IAAAd,CAAAA,cAAkB,CAACe,GAAA,CAAAC,KAAA,CAAA,IAAA,IAAA;;;AAIzBF,QAAAA,UAAA,GAAA,IAAA,CAAAG,cAAA,CAAAD,KAAA,EAAA,CAAA,CAAA,CAAA;AACF,QAAA;AAEmC,MAAA,KAAAE,UAAA;AACZJ,QAAAA,UAAA,GAAAG,IAAAA,CAAAA,cAAA,CAAAD,KAAA,OAAAG,GAAA,KAAA,KAAA,GAAA,CAAA,CAAA,GAAA,CAAA,CAAA;AACrB,QAAA;WACAC,UAAmB;QACjBN,UAAO,GAAA,IAAA,CAAAG,cAAA,CAAAD,KAAA,EAAA,CAAA,CAAA;;WAEPK,WAAA;AACEP,QAAAA,UAAA,GAAA,IAAAG,CAAAA,cAAA,CAAAD,KAAA,OAAAG,GAAA,KAAA,KAAA,GAAA,CAAA,GAAA,CAAA,CAAA,CAAA;;;AAGN,QAAA;;AAGoB,IAAA,IAAA,UAAA,EAAA;AAClBZ,MAAAA,KAAA,CAAAe,cAAW,EAAA;AACT,MAAA,UAAA,CAAAC,cAAW,EAAA;AACT,MAAA,UAAA,CAAAC,KAAA,EAAA;;;yBAKA,EAAA;2CACM,CAAA5C,MAAA,OAAAhB,KAAA,CAAA;kBACR,GAAA2C,KAAA,CAAA3C,KAAA;sCACF,CAAA2C,KAAA,CAAA3C,KAAA,CAAA;AACF,IAAA,IAAA,CAAA6D,MAAA,CAAAxC,IAAA,CAAAsB,KAAA,CAAA;;;;;;;AAjZE,MAAA,IAAAR,MACD,EAAA;AAJD,QAAA,IAAA,CAAA3B,eAAA,CAAA2B,MAAA,CAAAnB,MAAA,CAAA;;AAGE,QAAA,IAAA,CAAAR,eAAU,CAAAsD,QAAA,CAAA9C,MAAA,CAAA;AACX;KAGC,MAAA;AACA,MAAA,WAAA,GAAA,IAAA;;AAID,IAAA,IAAA+C,WAAA,EAAA;aAAA,CAAAC,OAAA,GAAAC,IAAA,CAAA,MAAA,IAAA,CAAAC,iBAAA,CAAAlD,MAAA,EAAAmD,WAAA,CAAA,CAAA;AAEF,KAAA,MAAA;;AA4BkB;;AAGfC,EAAAA,WAAAA,CAAApD,MAAA,EAAA;AACD,IAAA,OAAA,KAAAR,eAAA,IAAA,IAAA,CAAAA,eAAA,CAAA6D,UAAA,CAAArD,MAAA,CAAA;;;;;;+BAkBOsD,OAAW,CAAA,IAAA,CAAA7D,SAAA,CAAiB,EAAA;;;uBAuB7B,KAAA,IAAA,CAAAA,SAAA;;;+BAmBD,CAAAO,MAAA,IAAA;;;uBAUC;;;sBAmBCuD,CAAA,GAAA,IAAA,CAAAnC,cAAW,CAAAoC,MAAA,EAAAD,CAAA,EAAA,EAAA;oBAYe,GAAA,IAAA,CAAAnC,cAAA,CAAAe,GAAA,CAAAoB,CAAA,CAAA;;iBAD3BE,QAAC,GAAA,CAAA;;AAsRoC;;;;AA4BrB,EAAA,cAAA,CAAA,UAAA,EAAAC,MAAM,EAAC;AACJ,IAAA,MAAA,KAAA,GAAA,IAAA,CAAAtC,cAAA;AACVmC,IAAAA,KAAAA,IAAAA,CAAA,MAAAA,CAAA,IAAAI,KAAA,CAAAH,MAAA,EAAAD,CAAA,EAAA,EAAA;AAEhB,MAAA,MAAAnB,KAAA,GAAA,CAAAwB,UAAA,GAAAF,MAAA,GAAAH,CAAA,GAAAI,KAAA,CAAAH,MAAA,IAAAG,KAAA,CAAAH,MAAA;;;AAIqB,QAAA,OAAAK,IAAA;AAErB;;AAG0B,IAAA,OAAc,IAAA;;AAMxC1D,EAAAA,oBAAAA,CAAAnB,KAAiB,EAAA;AAEoC,IAAA,IAAA,CAAA,SAAA,GAAAA,KAAA;AACrD,IAAA,IAAA,CAAA,KAAAoC,cAAA,EAAA;AACE,MAAA;AAGF;AACS,IAAA,MAAA0C,OAAA,GAAA,IAAA,CAAA1C,cAAA,CAAA2C,OAAA,EAAA;IAGA,IAAAxD,IAAAA,CAAAA,QAAA,IAAAvB,KAAA,EAAA;MAEsD,IAAAgF,CAAAA,KAAA,CAAAV,OAAA,CAAAtE,KAAA,CAAAiF,KAAAA,OAAAA,SAAA,oBAAAA,SAAA,CAAA,EAAA;AACjD,QAAA,MAAAC,KAAA,CAAA,oDAAA,CAAA;AAIV;AACF,MAAA,IAAA,CAAAC,eAAA,EAAA;MACFnF,KAAA,CAAAoF,OAAA,CAAAC,YAAA,SAAAC,YAAA,CAAAD,YAAA,EAAAP,OAAA,CAAA,CAAA;KAIQ,MAAA;AAEiD,MAAA,IAAA,CAAAK,eAAA,EAAA;AACnB,MAAA,IAAA,CAAAG,YAAa,CAAAtF,KAAA,EAAA8E,OAAA,CAAA;;AAMnD,IAAA,IAAA,CAAA,IAAA,CAAAvD,QAAA,IAAAuD,OAAA,CAAAS,KAAA,CAAAvE,MAAA,IAAAA,MAAA,CAAAyD,QAAA,KAAA,CAAA,CAAA,CAAA,EAAA;MACI,KAAAzD,MAAAA,MAAA,IAAA8D,OAAA,EAAA;QAAA,IAAA9D,CAAAA,MAAA,CAAAyB,QAAA,EAAA;AACFzB,UAAAA,MAAA,CAAAyD,QAAmB,GAAA,CAAA;AACrB,UAAA;AACQ;AAGR;;;AAKE,EAAA,eAAA,GAAA;AACM,IAAA,IAAA,CAAA,eAAA,CAAAe,KAAA,EAAA;uBAEJ,CAAAJ,OAAA,CAAApE,MAAA,IAAA;;AAIA,MAAA,IAAA,CAAA,IAAA,CAAAO,QAAA,EAAA;;AAIkC;AACtC,KAAA,CAAA;;cAII+D,CAAAtF,KAAA,EAAA8E,OAAA,EAAA;SACF,MAAA9D,MAAK,IAAA8D,OAAY,EAAA;UACnB9D,MAAA,CAAAhB,KAAA,KAAAA,KAAA,EAAA;AACiBgB,QAAAA,MAAA,CAAAsB,OAAA,GAAA,IAAA;AAEuD,QAAA,IAAA,CAAA9B,eAAA,CAAA2B,MAAA,CAAAnB,MAAA,CAAA;AACxE,QAAA,IAAA,CAAA,IAAA,CAAAO,QAAA,EAAA;AAMAP,UAAAA,MAAA,CAAAyD,QAAA,GAAA,CAAA;AACI;AACF,QAAA;;;;mBAUFP,CAAAlD,MAAA,EAAAmD,WAAA,EAAA;AAEQ,IAAA,IAAA,WAAA,EAAA;MACN,IAAA,CAAAsB,gBAAA,CAAAzE,MAAA,CAAA;AACA;AAQE,IAAA,IAAA,CAAAI,WAAkB,CAAAC,IAAe,CAAA,IAAA,CAAArB,KAAA,CAA4B;;sBAIzD0B,GAAA;IACN,IAAA,CAAAU,cAAA,EAAAgD,OAAA,CAAApE,MAAA,IAAAA,MAAA,CAAA0E,aAAA,EAAA,CAAA;;SAIEC,IAAA,GAAAC,EAAA,CAAAC,kBAAA,CAAA;IAAAC,UAAA,EAAA,QAAA;IAAAC,OAA+B,EAAA,eAAA;AAAAC,IAAAA,QAAA,EAAAJ,EAAA;AAAAK,IAAAA,IAAA,EAAA/F,oBAAA;IAAAgG,IAAA,EAAA,EAAA;AAAArD,IAAAA,MAAA,EAAA+C,EAAA,CAAAO,eAAA,CAAAC;AAAA,GAAA,CAAA;AAC7BC,EAAAA,OAAAA,IAAA,GAAAT,EAAA,CAAAU,oBAAmB,CAAA;IAAAR,UAAA,EAAA,QAAA;IAAAC,OAAA,EAAA,eAAA;AAAAE,IAAAA,IAAA,EAAA/F,oBAAA;IAAAqG,YAAA,EAAA,IAAA;IAAAC,QAAA,EAAA,yBAAA;IAAAC,MAAA,EAAA;MAAAzE,UAAA,EAAA,YAAA;MAAA0E,IAAA,EAAA,MAAA;AAAAC,MAAAA,QAAA,2BAAAC,gBAAA,CAAA;MAAA5G,KAAA,EAAA,OAAA;AAAAuB,MAAAA,QAAA,2BAAAqF,gBAAA,CAAA;AAAAnE,MAAAA,QAAA,2BAAAmE,gBAAA,CAAA;AAAApF,MAAAA,mBAAA,iDAAAoF,gBAAA,CAAA;AAAA/E,MAAAA,4BAAA,mEAAA+E,gBAAA,CAAA;AAAA9E,MAAAA,8BAAA,uEAAA8E,gBAAA;AAAA,KAAA;IAAAC,OAAA,EAAA;MAAAzF,WAAA,EAAA,aAAA;MAAAyC,MAAA,EAAA;AAAA,KAAA;IAAAiD,IAAA,EAAA;MAAAC,SAAA,EAAA;AAAA,QAAA,SAAA,EAAA;AAAA,OAAA;MAAAC,UAAA,EAAA;AAAA,QAAA,WAAA,EAAA,mCAAA;AAAA,QAAA,oBAAA,EAAA,UAAA;AAAA,QAAA,kCAAA,EAAA,UAAA;AAAA,QAAA,mDAAA,EAAA;AAAA,OAAA;MAAAC,cAAA,EAAA;AAAA,KAAA;IAAAC,SAAA,EAAA;;;;;kBAGmE,EAAA,gBAAA;AAAAC,MAAAA,SAAA,EAAAvB,EAAA,CAAAwB,UAAA,OAAAC,eAAA,CAAA;MAAAC,WAAA,EAAA;AAAA,KAAA,CAAA;IAAAC,QAAA,EAAA,CAAA,sBAAA,CAAA;AAAAvB,IAAAA,QAAA,EAAAJ;AAAA,GAAA,CAAA;;;;;;;;;;AAjd5FY,MAAAA,QAAA,EACuB,yBAAA;eACd,EAAA;;;;;AANH,QAAA,OAAA,EAAA,yBAAA;mBACN,EAAA,kBAAA;qBAEiF,EAAA,mCAAA;AACjF,QAAA,sBAAA,EAAA,UAAA;4CAEc,EAAoB,UAAA;;;AAGhC,MAAA,QAAA,EAAA;;;AAEF,EAAA,cAAA,EAAAgB,MAAA,EAAA;EAAAC,cAAA,EAAA;IAAArF,cAAA,EAAA,CAAA;AAEA,MAAA,IAAA,EAAA,eAAA;AACA,MAAA,IAAA,EAAA,CAAA,UAAA,CAAA,MAAAiF,eAAA,CAAA,EAAA;mBAIoD,EAAA;AACjC,OAAA;;;;;AAyCnB,IAAA,IAAA,EAAA,CAAA;;;;AAIE,MAAA,IAAA,EAAA,KAAA;;;;;;;;IAUAjG,WAAA,EAAA,CAAA;AADFsG,MAAAA,IAAAA,EAAAA;;IAaAnG,QAAA,EAAA,CAAA;iBAAA;AAAA,MAAA,IAAA,EAAA,CAAA;AAAAoG,QAAAA,SAAA,EAAAf;OAAA;;IAKAnE,QAAA,EAAA,CAAA;YADEmF,KAAA;MAuBUC,IAAA,EAAA,CAAA;AAAAF,QAAAA,SAAA,EAAAf;AAAA,OAAA;;;AAURX,MAAAA,IAAA,EAAA2B,KAAA;;;;;;AAYJ3B,MAAAA,IAAA,EAAAyB;;AADoE,IAAA,4BAAA,EAAA,CAAA;AAAA,MAAA,IAAA,EAAA,KAAA;;;;;;;AA+BzDG,MAAAA,IAAA,EAAe,CAAA;AAAAF,QAAAA,SAAA,EAAAf;AAAA,OAAA;;;;;+CAGX,CAAA;AAamCxG,EAAAA,WAAAA,GAAAA,MAAA,CAAA0H,UAAA,CAAA;yBAFlDC,YAAA,CAAA;AAAA,EAAA,YAAA,GAAA,MAAA,CAAAnH,YAAA,CAAA;;;;;AAmVM,EAAA,cAAA;EAIJoH,iBAAA;MAEIlF,QAAA,GAAA;IACA,OAAA,CAAA,EAAA,IAAA,CAAAC,EAAA,CAAA,OAAA,CAAA;;;;AAWN,EAAA,KAAA;;;;EAQmE,IAAA0B,QAAAA,CAAAzE,KAAA,EAAA;AAEjE,IAAA,IAAA,CAAAiI,SAAA,CAAAC,GAAA,CAAAlI,KAAA,CAAA;AACF;;AAME,EAAA,aAAA;MAEFgC,UAAAA,GAAA;AAEA,IAAA,OAAsD,KAAAgG,iBAAA,GAAA,IAAA,CAAAA,iBAAA,CAAAhG,UAAA,QAAAmG,WAAA;;EAE7C,IAAAnG,UAAgCA,CAAAhC,KAAA,EAAA;;AA/N9B;;AAfTsC,EAAAA,IAAAA,OAAAA,GAAA;AACA,IAAA,OAAA,IAAA,CAAA0F,iBAAA,GAAAA,IAAAA,CAAAA,iBAAA,CAAA5D,WAAA,cAAAgE,QAAA;AACA;AACA9F,EAAAA,IAAAA,OAAAA,CAAAtC,KAAA,EAAA;IACA,IAAAA,KAAA,UAAAoI,QAAA,EAAA;MACA,IAA4B,CAAAA,QAAA,GAAApI,KAAA;AAE5B,MAAA,IAAA,IAAA,CAAAgI,iBAAA,EAAA;AAEA,QAAA,IAAA,CAAAA,iBAAA,CAAAK,iBAAA,CAAA,IAAA,EAAA,IAAA,CAAAD,QAAA,CAAA;AACA;MACA,IAAAE,CAAAA,kBAAA,CAAAC,YAAA,EAAA;AACD;;;iCAoBK,CAAAP,iBAAA,IAAA,IAAA,CAAAA,iBAAA,CAAAvF,QAAA;;;;;;4BAoBA;8DAGA,KAAAuF,IAAAA,IAAAA,IAAAA,CAAAA,iBAAA,CAAAxG,mBAAA;;;6BAUa,GAAAxB,KAAA;;;;;iCAwCb,CAAAwI,CAAAA,IAAA,CAAAC,uBAAA,CAAA;8BAAE,CAAA7I,uBAAW,EAAA;MAAAW,QAAA,EAAA;AAAA,KAAA,CAAA;;;;wBAaZ,GAAAH,MAAA,CAAAV,iCAAA,EAAA;MAAAa,QAAA,EAAA;AAAA,KAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiEP,QAAA,+CAAA,EAAA,2BAAA;eA7BA,EAAA,mBAAA;2BAEe,EAAA,MAAA;;;AAUf,QAAA,aAAA,EAAA,MAAA;AAEA,QAAA,SAAA,EAAA,SAAA;AACE,QAAA,MAAA,EAAA;;eAEI,CAACmI,SAAA,EAAAC,iBAAc,CAAA;MAAAC,QAAA,EAAA,88CAAA;MAAAC,MAAA,EAAA,CAAA,y/TAAA;AAAA,KAAA;;;gBAEyD,EAAA;IAAAC,SAAA,EAAA,CAAA;;AAExE,MAAA,IAAA,EAAA,CAAA,YAAA;;;;AAGN,MAAA,IAAA,EAAA,CAAA,iBAAA;;oBAG4B,CAAA;;;;;AAuBtB7C,MAAAA,IAAA,EAAA2B;;AAAF,IAAA,IAAA,EAAA,CAAA;;;IAGE5H,KAAA,EAAA,CAAA;AAAA4H,MAAAA,IAAAA,EAAAA;;AAAA,IAAA,QAAA,EAAA,CAAA;;;;AAgB6D3B,MAAAA,IAAA,EAAA2B,KAAA;;iBAAjE,EAAAhB;AAAA,OAAA;;IAGF5E,UAAA,EAAA,CAAA;;;AAKIM,IAAAA,OAAA,EAAA,CAAA;YADFsF,KAAA;MAvNSC,IAAA,EAAA,CAAA;AAAAF,QAAAA,SAAA,EAAAf;AAAA,OAAA;;YAAA,EAAA,CAAA;AAAA,MAAA,IAAA,EAAA,KAAA;;;;;;AANTX,MAAAA,IAAA,EAAA2B,KAAA;AADA,MAAA,IAAA,EAAA,CAAA;AAAAD,QAAAA,SAAA,EAAAf;AAAA,OAAA;;YAAA,CAAA;;;;;;;;;;;;;;;ACriBS,EAAA,OAAAmC,IAAA,GAAAnD,EAAA,CAAAoD,mBAAA,CAAA;IAAAlD,UAAA,EAAA,QAAA;IAAAC,OAAA,EAAA,eAAA;AAAAC,IAAAA,QAAA,EAAAJ,EAAA;AAAAK,IAAAA,IAAA,EAAAgD,qBAAA;AAAAC,IAAAA,OAAA,EAAAC,CAAAA,eAAA,EAAAjJ,oBAAA,EAAAmH,eAAA,CAAA;AAAA+B,IAAAA,OAAA,EAAAC,CAAAA,UAAA,EAAAnJ,oBAAA,EAAAmH,eAAA;AAAA,GAAA,CAAA;;;;;;;;;2BAJJ,CAAA;AAAAvB,EAAAA,UAAA,EAAA,QAAA;AAAAC,EAAAA,OAAA,EAAA,eAAA;AAAAC,EAAAA,QAAA,EAAAJ,EAAA;AAAAK,EAAAA,IAAA,EAAAgD,qBAAA;EAAAK,UAAA,EAAA,CAAA;;;;;;;;;;;"}