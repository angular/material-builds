{"version":3,"file":"_form-field-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/form-field/directives/label.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/form-field/directives/error.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/form-field/directives/hint.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/form-field/directives/prefix.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/form-field/directives/suffix.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/form-field/directives/floating-label.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/form-field/directives/line-ripple.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/form-field/directives/notched-outline.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/form-field/form-field-control.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/form-field/form-field-errors.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/form-field/form-field.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive} from '@angular/core';\n\n/** The floating label for a `mat-form-field`. */\n@Directive({\n  selector: 'mat-label',\n})\nexport class MatLabel {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive, InjectionToken, Input, inject} from '@angular/core';\nimport {_IdGenerator} from '@angular/cdk/a11y';\n\n/**\n * Injection token that can be used to reference instances of `MatError`. It serves as\n * alternative token to the actual `MatError` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const MAT_ERROR = new InjectionToken<MatError>('MatError');\n\n/** Single error message to be shown underneath the form-field. */\n@Directive({\n  selector: 'mat-error, [matError]',\n  host: {\n    'class': 'mat-mdc-form-field-error mat-mdc-form-field-bottom-align',\n    '[id]': 'id',\n  },\n  providers: [{provide: MAT_ERROR, useExisting: MatError}],\n})\nexport class MatError {\n  @Input() id: string = inject(_IdGenerator).getId('mat-mdc-error-');\n\n  constructor(...args: unknown[]);\n\n  constructor() {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive, inject, Input} from '@angular/core';\nimport {_IdGenerator} from '@angular/cdk/a11y';\n\n/** Hint text to be shown underneath the form field control. */\n@Directive({\n  selector: 'mat-hint',\n  host: {\n    'class': 'mat-mdc-form-field-hint mat-mdc-form-field-bottom-align',\n    '[class.mat-mdc-form-field-hint-end]': 'align === \"end\"',\n    '[id]': 'id',\n    // Remove align attribute to prevent it from interfering with layout.\n    '[attr.align]': 'null',\n  },\n})\nexport class MatHint {\n  /** Whether to align the hint label at the start or end of the line. */\n  @Input() align: 'start' | 'end' = 'start';\n\n  /** Unique ID for the hint. Used for the aria-describedby on the form field control. */\n  @Input() id: string = inject(_IdGenerator).getId('mat-mdc-hint-');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive, InjectionToken, Input} from '@angular/core';\n\n/**\n * Injection token that can be used to reference instances of `MatPrefix`. It serves as\n * alternative token to the actual `MatPrefix` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const MAT_PREFIX = new InjectionToken<MatPrefix>('MatPrefix');\n\n/** Prefix to be placed in front of the form field. */\n@Directive({\n  selector: '[matPrefix], [matIconPrefix], [matTextPrefix]',\n  providers: [{provide: MAT_PREFIX, useExisting: MatPrefix}],\n})\nexport class MatPrefix {\n  @Input('matTextPrefix')\n  set _isTextSelector(value: '') {\n    this._isText = true;\n  }\n\n  _isText = false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive, InjectionToken, Input} from '@angular/core';\n\n/**\n * Injection token that can be used to reference instances of `MatSuffix`. It serves as\n * alternative token to the actual `MatSuffix` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const MAT_SUFFIX = new InjectionToken<MatSuffix>('MatSuffix');\n\n/** Suffix to be placed at the end of the form field. */\n@Directive({\n  selector: '[matSuffix], [matIconSuffix], [matTextSuffix]',\n  providers: [{provide: MAT_SUFFIX, useExisting: MatSuffix}],\n})\nexport class MatSuffix {\n  @Input('matTextSuffix')\n  set _isTextSelector(value: '') {\n    this._isText = true;\n  }\n\n  _isText = false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Directive,\n  ElementRef,\n  inject,\n  Input,\n  NgZone,\n  OnDestroy,\n  InjectionToken,\n} from '@angular/core';\nimport {SharedResizeObserver} from '@angular/cdk/observers/private';\nimport {Subscription} from 'rxjs';\n\n/** An interface that the parent form-field should implement to receive resize events. */\nexport interface FloatingLabelParent {\n  _handleLabelResized(): void;\n}\n\n/** An injion token for the parent form-field. */\nexport const FLOATING_LABEL_PARENT = new InjectionToken<FloatingLabelParent>('FloatingLabelParent');\n\n/**\n * Internal directive that maintains a MDC floating label. This directive does not\n * use the `MDCFloatingLabelFoundation` class, as it is not worth the size cost of\n * including it just to measure the label width and toggle some classes.\n *\n * The use of a directive allows us to conditionally render a floating label in the\n * template without having to manually manage instantiation and destruction of the\n * floating label component based on.\n *\n * The component is responsible for setting up the floating label styles, measuring label\n * width for the outline notch, and providing inputs that can be used to toggle the\n * label's floating or required state.\n */\n@Directive({\n  selector: 'label[matFormFieldFloatingLabel]',\n  host: {\n    'class': 'mdc-floating-label mat-mdc-floating-label',\n    '[class.mdc-floating-label--float-above]': 'floating',\n  },\n})\nexport class MatFormFieldFloatingLabel implements OnDestroy {\n  private _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n\n  /** Whether the label is floating. */\n  @Input()\n  get floating() {\n    return this._floating;\n  }\n  set floating(value: boolean) {\n    this._floating = value;\n    if (this.monitorResize) {\n      this._handleResize();\n    }\n  }\n  private _floating = false;\n\n  /** Whether to monitor for resize events on the floating label. */\n  @Input()\n  get monitorResize() {\n    return this._monitorResize;\n  }\n  set monitorResize(value: boolean) {\n    this._monitorResize = value;\n    if (this._monitorResize) {\n      this._subscribeToResize();\n    } else {\n      this._resizeSubscription.unsubscribe();\n    }\n  }\n  private _monitorResize = false;\n\n  /** The shared ResizeObserver. */\n  private _resizeObserver = inject(SharedResizeObserver);\n\n  /** The Angular zone. */\n  private _ngZone = inject(NgZone);\n\n  /** The parent form-field. */\n  private _parent = inject(FLOATING_LABEL_PARENT);\n\n  /** The current resize event subscription. */\n  private _resizeSubscription = new Subscription();\n\n  constructor(...args: unknown[]);\n  constructor() {}\n\n  ngOnDestroy() {\n    this._resizeSubscription.unsubscribe();\n  }\n\n  /** Gets the width of the label. Used for the outline notch. */\n  getWidth(): number {\n    return estimateScrollWidth(this._elementRef.nativeElement);\n  }\n\n  /** Gets the HTML element for the floating label. */\n  get element(): HTMLElement {\n    return this._elementRef.nativeElement;\n  }\n\n  /** Handles resize events from the ResizeObserver. */\n  private _handleResize() {\n    // In the case where the label grows in size, the following sequence of events occurs:\n    // 1. The label grows by 1px triggering the ResizeObserver\n    // 2. The notch is expanded to accommodate the entire label\n    // 3. The label expands to its full width, triggering the ResizeObserver again\n    //\n    // This is expected, but If we allow this to all happen within the same macro task it causes an\n    // error: `ResizeObserver loop limit exceeded`. Therefore we push the notch resize out until\n    // the next macro task.\n    setTimeout(() => this._parent._handleLabelResized());\n  }\n\n  /** Subscribes to resize events. */\n  private _subscribeToResize() {\n    this._resizeSubscription.unsubscribe();\n    this._ngZone.runOutsideAngular(() => {\n      this._resizeSubscription = this._resizeObserver\n        .observe(this._elementRef.nativeElement, {box: 'border-box'})\n        .subscribe(() => this._handleResize());\n    });\n  }\n}\n\n/**\n * Estimates the scroll width of an element.\n * via https://github.com/material-components/material-components-web/blob/c0a11ef0d000a098fd0c372be8f12d6a99302855/packages/mdc-dom/ponyfill.ts\n */\nfunction estimateScrollWidth(element: HTMLElement): number {\n  // Check the offsetParent. If the element inherits display: none from any\n  // parent, the offsetParent property will be null (see\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent).\n  // This check ensures we only clone the node when necessary.\n  const htmlEl = element as HTMLElement;\n  if (htmlEl.offsetParent !== null) {\n    return htmlEl.scrollWidth;\n  }\n\n  const clone = htmlEl.cloneNode(true) as HTMLElement;\n  clone.style.setProperty('position', 'absolute');\n  clone.style.setProperty('transform', 'translate(-9999px, -9999px)');\n  document.documentElement.appendChild(clone);\n  const scrollWidth = clone.scrollWidth;\n  clone.remove();\n  return scrollWidth;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive, ElementRef, NgZone, OnDestroy, Renderer2, inject} from '@angular/core';\n\n/** Class added when the line ripple is active. */\nconst ACTIVATE_CLASS = 'mdc-line-ripple--active';\n\n/** Class added when the line ripple is being deactivated. */\nconst DEACTIVATING_CLASS = 'mdc-line-ripple--deactivating';\n\n/**\n * Internal directive that creates an instance of the MDC line-ripple component. Using a\n * directive allows us to conditionally render a line-ripple in the template without having\n * to manually create and destroy the `MDCLineRipple` component whenever the condition changes.\n *\n * The directive sets up the styles for the line-ripple and provides an API for activating\n * and deactivating the line-ripple.\n */\n@Directive({\n  selector: 'div[matFormFieldLineRipple]',\n  host: {\n    'class': 'mdc-line-ripple',\n  },\n})\nexport class MatFormFieldLineRipple implements OnDestroy {\n  private _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  private _cleanupTransitionEnd: () => void;\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const ngZone = inject(NgZone);\n    const renderer = inject(Renderer2);\n\n    ngZone.runOutsideAngular(() => {\n      this._cleanupTransitionEnd = renderer.listen(\n        this._elementRef.nativeElement,\n        'transitionend',\n        this._handleTransitionEnd,\n      );\n    });\n  }\n\n  activate() {\n    const classList = this._elementRef.nativeElement.classList;\n    classList.remove(DEACTIVATING_CLASS);\n    classList.add(ACTIVATE_CLASS);\n  }\n\n  deactivate() {\n    this._elementRef.nativeElement.classList.add(DEACTIVATING_CLASS);\n  }\n\n  private _handleTransitionEnd = (event: TransitionEvent) => {\n    const classList = this._elementRef.nativeElement.classList;\n    const isDeactivating = classList.contains(DEACTIVATING_CLASS);\n\n    if (event.propertyName === 'opacity' && isDeactivating) {\n      classList.remove(ACTIVATE_CLASS, DEACTIVATING_CLASS);\n    }\n  };\n\n  ngOnDestroy() {\n    this._cleanupTransitionEnd();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  Component,\n  ElementRef,\n  Input,\n  NgZone,\n  ViewChild,\n  ViewEncapsulation,\n  inject,\n} from '@angular/core';\n\n/**\n * Internal component that creates an instance of the MDC notched-outline component.\n *\n * The component sets up the HTML structure and styles for the notched-outline. It provides\n * inputs to toggle the notch state and width.\n */\n@Component({\n  selector: 'div[matFormFieldNotchedOutline]',\n  templateUrl: './notched-outline.html',\n  host: {\n    'class': 'mdc-notched-outline',\n    // Besides updating the notch state through the MDC component, we toggle this class through\n    // a host binding in order to ensure that the notched-outline renders correctly on the server.\n    '[class.mdc-notched-outline--notched]': 'open',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n})\nexport class MatFormFieldNotchedOutline implements AfterViewInit {\n  private _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  private _ngZone = inject(NgZone);\n\n  /** Whether the notch should be opened. */\n  @Input('matFormFieldNotchedOutlineOpen') open: boolean = false;\n\n  @ViewChild('notch') _notch: ElementRef<HTMLElement>;\n\n  ngAfterViewInit(): void {\n    const element = this._elementRef.nativeElement;\n    const label = element.querySelector<HTMLElement>('.mdc-floating-label');\n\n    if (label) {\n      element.classList.add('mdc-notched-outline--upgraded');\n\n      if (typeof requestAnimationFrame === 'function') {\n        label.style.transitionDuration = '0s';\n        this._ngZone.runOutsideAngular(() => {\n          requestAnimationFrame(() => (label.style.transitionDuration = ''));\n        });\n      }\n    } else {\n      element.classList.add('mdc-notched-outline--no-label');\n    }\n  }\n\n  _setNotchWidth(labelWidth: number) {\n    const notch = this._notch.nativeElement;\n\n    if (!this.open || !labelWidth) {\n      notch.style.width = '';\n    } else {\n      const NOTCH_ELEMENT_PADDING = 8;\n      const NOTCH_ELEMENT_BORDER = 1;\n      notch.style.width = `calc(${labelWidth}px * var(--mat-mdc-form-field-floating-label-scale, 0.75) + ${\n        NOTCH_ELEMENT_PADDING + NOTCH_ELEMENT_BORDER\n      }px)`;\n    }\n  }\n\n  _setMaxWidth(prefixAndSuffixWidth: number) {\n    // Set this only on the notch to avoid style recalculations in other parts of the form field.\n    this._notch.nativeElement.style.setProperty(\n      '--mat-form-field-notch-max-width',\n      `calc(100% - ${prefixAndSuffixWidth}px)`,\n    );\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Observable} from 'rxjs';\nimport {AbstractControlDirective, NgControl} from '@angular/forms';\nimport {Directive} from '@angular/core';\n\n/** An interface which allows a control to work inside of a `MatFormField`. */\n@Directive()\nexport abstract class MatFormFieldControl<T> {\n  /** The value of the control. */\n  value: T | null;\n\n  /**\n   * Stream that emits whenever the state of the control changes such that the parent `MatFormField`\n   * needs to run change detection.\n   */\n  readonly stateChanges: Observable<void>;\n\n  /** The element ID for this control. */\n  readonly id: string;\n\n  /** The placeholder for this control. */\n  readonly placeholder: string;\n\n  /** Gets the AbstractControlDirective for this control. */\n  readonly ngControl: NgControl | AbstractControlDirective | null;\n\n  /** Whether the control is focused. */\n  readonly focused: boolean;\n\n  /** Whether the control is empty. */\n  readonly empty: boolean;\n\n  /** Whether the `MatFormField` label should try to float. */\n  readonly shouldLabelFloat: boolean;\n\n  /** Whether the control is required. */\n  readonly required: boolean;\n\n  /** Whether the control is disabled. */\n  readonly disabled: boolean;\n\n  /** Whether the control is in an error state. */\n  readonly errorState: boolean;\n\n  /**\n   * An optional name for the control type that can be used to distinguish `mat-form-field` elements\n   * based on their control type. The form field will add a class,\n   * `mat-form-field-type-{{controlType}}` to its root element.\n   */\n  readonly controlType?: string;\n\n  /**\n   * Whether the input is currently in an autofilled state. If property is not present on the\n   * control it is assumed to be false.\n   */\n  readonly autofilled?: boolean;\n\n  /**\n   * Value of `aria-describedby` that should be merged with the described-by ids\n   * which are set by the form-field.\n   */\n  readonly userAriaDescribedBy?: string;\n\n  /**\n   * Whether to automatically assign the ID of the form field as the `for` attribute\n   * on the `<label>` inside the form field. Set this to true to prevent the form\n   * field from associating the label with non-native elements.\n   */\n  readonly disableAutomaticLabeling?: boolean;\n\n  /** Gets the list of element IDs that currently describe this control. */\n  readonly describedByIds?: string[];\n\n  /** Sets the list of element IDs that currently describe this control. */\n  abstract setDescribedByIds(ids: string[]): void;\n\n  /** Handles a click on the control's container. */\n  abstract onContainerClick(event: MouseEvent): void;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/** @docs-private */\nexport function getMatFormFieldPlaceholderConflictError(): Error {\n  return Error('Placeholder attribute and child element were both specified.');\n}\n\n/** @docs-private */\nexport function getMatFormFieldDuplicatedHintError(align: string): Error {\n  return Error(`A hint was already declared for 'align=\"${align}\"'.`);\n}\n\n/** @docs-private */\nexport function getMatFormFieldMissingControlError(): Error {\n  return Error('mat-form-field must contain a MatFormFieldControl.');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {_IdGenerator} from '@angular/cdk/a11y';\nimport {Direction, Directionality} from '@angular/cdk/bidi';\nimport {BooleanInput, coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {Platform} from '@angular/cdk/platform';\nimport {NgTemplateOutlet} from '@angular/common';\nimport {\n  AfterContentChecked,\n  AfterContentInit,\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChild,\n  ContentChildren,\n  ElementRef,\n  InjectionToken,\n  Input,\n  NgZone,\n  OnDestroy,\n  QueryList,\n  ViewChild,\n  ViewEncapsulation,\n  afterRenderEffect,\n  computed,\n  contentChild,\n  effect,\n  inject,\n  signal,\n  viewChild,\n} from '@angular/core';\nimport {AbstractControlDirective, ValidatorFn} from '@angular/forms';\nimport {Subject, Subscription, merge} from 'rxjs';\nimport {filter, map, pairwise, startWith, takeUntil} from 'rxjs/operators';\nimport {ThemePalette, _animationsDisabled} from '../core';\nimport {MAT_ERROR, MatError} from './directives/error';\nimport {\n  FLOATING_LABEL_PARENT,\n  FloatingLabelParent,\n  MatFormFieldFloatingLabel,\n} from './directives/floating-label';\nimport {MatHint} from './directives/hint';\nimport {MatLabel} from './directives/label';\nimport {MatFormFieldLineRipple} from './directives/line-ripple';\nimport {MatFormFieldNotchedOutline} from './directives/notched-outline';\nimport {MAT_PREFIX, MatPrefix} from './directives/prefix';\nimport {MAT_SUFFIX, MatSuffix} from './directives/suffix';\nimport {MatFormFieldControl as _MatFormFieldControl} from './form-field-control';\nimport {\n  getMatFormFieldDuplicatedHintError,\n  getMatFormFieldMissingControlError,\n} from './form-field-errors';\n\n/** Type for the available floatLabel values. */\nexport type FloatLabelType = 'always' | 'auto';\n\n/** Possible appearance styles for the form field. */\nexport type MatFormFieldAppearance = 'fill' | 'outline';\n\n/** Behaviors for how the subscript height is set. */\nexport type SubscriptSizing = 'fixed' | 'dynamic';\n\n/**\n * Represents the default options for the form field that can be configured\n * using the `MAT_FORM_FIELD_DEFAULT_OPTIONS` injection token.\n */\nexport interface MatFormFieldDefaultOptions {\n  /** Default form field appearance style. */\n  appearance?: MatFormFieldAppearance;\n  /**\n   * Default theme color of the form field. This API is supported in M2 themes only, it has no\n   * effect in M3 themes. For color customization in M3, see https://material.angular.dev/components/form-field/styling.\n   *\n   * For information on applying color variants in M3, see\n   * https://material.angular.dev/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n   */\n  color?: ThemePalette;\n  /** Whether the required marker should be hidden by default. */\n  hideRequiredMarker?: boolean;\n  /**\n   * Whether the label for form fields should by default float `always`,\n   * `never`, or `auto` (only when necessary).\n   */\n  floatLabel?: FloatLabelType;\n  /** Whether the form field should reserve space for one line by default. */\n  subscriptSizing?: SubscriptSizing;\n}\n\n/**\n * Injection token that can be used to inject an instances of `MatFormField`. It serves\n * as alternative token to the actual `MatFormField` class which would cause unnecessary\n * retention of the `MatFormField` class and its component metadata.\n */\nexport const MAT_FORM_FIELD = new InjectionToken<MatFormField>('MatFormField');\n\n/**\n * Injection token that can be used to configure the\n * default options for all form field within an app.\n */\nexport const MAT_FORM_FIELD_DEFAULT_OPTIONS = new InjectionToken<MatFormFieldDefaultOptions>(\n  'MAT_FORM_FIELD_DEFAULT_OPTIONS',\n);\n\n/** Styles that are to be applied to the label elements in the outlined appearance. */\ntype OutlinedLabelStyles =\n  | [floatingLabelTransform: string, notchedOutlineWidth: number | null]\n  | null;\n\n/** Default appearance used by the form field. */\nconst DEFAULT_APPEARANCE: MatFormFieldAppearance = 'fill';\n\n/**\n * Whether the label for form fields should by default float `always`,\n * `never`, or `auto`.\n */\nconst DEFAULT_FLOAT_LABEL: FloatLabelType = 'auto';\n\n/** Default way that the subscript element height is set. */\nconst DEFAULT_SUBSCRIPT_SIZING: SubscriptSizing = 'fixed';\n\n/**\n * Default transform for docked floating labels in a MDC text-field. This value has been\n * extracted from the MDC text-field styles because we programmatically modify the docked\n * label transform, but do not want to accidentally discard the default label transform.\n */\nconst FLOATING_LABEL_DEFAULT_DOCKED_TRANSFORM = `translateY(-50%)`;\n\n/**\n * Despite `MatFormFieldControl` being an abstract class, most of our usages enforce its shape\n * using `implements` instead of `extends`. This appears to be problematic when Closure compiler\n * is configured to use type information to rename properties, because it can't figure out which\n * class properties are coming from. This interface seems to work around the issue while preserving\n * our type safety (alternative being using `any` everywhere).\n * @docs-private\n */\ninterface MatFormFieldControl<T> extends _MatFormFieldControl<T> {}\n\n/** Container for form controls that applies Material Design styling and behavior. */\n@Component({\n  selector: 'mat-form-field',\n  exportAs: 'matFormField',\n  templateUrl: './form-field.html',\n  styleUrl: './form-field.css',\n  host: {\n    'class': 'mat-mdc-form-field',\n    '[class.mat-mdc-form-field-label-always-float]': '_shouldAlwaysFloat()',\n    '[class.mat-mdc-form-field-has-icon-prefix]': '_hasIconPrefix',\n    '[class.mat-mdc-form-field-has-icon-suffix]': '_hasIconSuffix',\n    // Note that these classes reuse the same names as the non-MDC version, because they can be\n    // considered a public API since custom form controls may use them to style themselves.\n    // See https://github.com/angular/components/pull/20502#discussion_r486124901.\n    '[class.mat-form-field-invalid]': '_control.errorState',\n    '[class.mat-form-field-disabled]': '_control.disabled',\n    '[class.mat-form-field-autofilled]': '_control.autofilled',\n    '[class.mat-form-field-appearance-fill]': 'appearance == \"fill\"',\n    '[class.mat-form-field-appearance-outline]': 'appearance == \"outline\"',\n    '[class.mat-form-field-hide-placeholder]': '_hasFloatingLabel() && !_shouldLabelFloat()',\n    '[class.mat-primary]': 'color !== \"accent\" && color !== \"warn\"',\n    '[class.mat-accent]': 'color === \"accent\"',\n    '[class.mat-warn]': 'color === \"warn\"',\n    '[class.ng-untouched]': '_shouldForward(\"untouched\")',\n    '[class.ng-touched]': '_shouldForward(\"touched\")',\n    '[class.ng-pristine]': '_shouldForward(\"pristine\")',\n    '[class.ng-dirty]': '_shouldForward(\"dirty\")',\n    '[class.ng-valid]': '_shouldForward(\"valid\")',\n    '[class.ng-invalid]': '_shouldForward(\"invalid\")',\n    '[class.ng-pending]': '_shouldForward(\"pending\")',\n  },\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  providers: [\n    {provide: MAT_FORM_FIELD, useExisting: MatFormField},\n    {provide: FLOATING_LABEL_PARENT, useExisting: MatFormField},\n  ],\n  imports: [\n    MatFormFieldFloatingLabel,\n    MatFormFieldNotchedOutline,\n    NgTemplateOutlet,\n    MatFormFieldLineRipple,\n    MatHint,\n  ],\n})\nexport class MatFormField\n  implements FloatingLabelParent, AfterContentInit, AfterContentChecked, AfterViewInit, OnDestroy\n{\n  _elementRef = inject(ElementRef);\n  private _changeDetectorRef = inject(ChangeDetectorRef);\n  private _platform = inject(Platform);\n  private _idGenerator = inject(_IdGenerator);\n  private _ngZone = inject(NgZone);\n  private _defaults = inject<MatFormFieldDefaultOptions>(MAT_FORM_FIELD_DEFAULT_OPTIONS, {\n    optional: true,\n  });\n  private _currentDirection: Direction;\n\n  @ViewChild('textField') _textField: ElementRef<HTMLElement>;\n  @ViewChild('iconPrefixContainer') _iconPrefixContainer: ElementRef<HTMLElement>;\n  @ViewChild('textPrefixContainer') _textPrefixContainer: ElementRef<HTMLElement>;\n  @ViewChild('iconSuffixContainer') _iconSuffixContainer: ElementRef<HTMLElement>;\n  @ViewChild('textSuffixContainer') _textSuffixContainer: ElementRef<HTMLElement>;\n  @ViewChild(MatFormFieldFloatingLabel) _floatingLabel: MatFormFieldFloatingLabel | undefined;\n  @ViewChild(MatFormFieldNotchedOutline) _notchedOutline: MatFormFieldNotchedOutline | undefined;\n  @ViewChild(MatFormFieldLineRipple) _lineRipple: MatFormFieldLineRipple | undefined;\n\n  private _iconPrefixContainerSignal = viewChild<ElementRef<HTMLElement>>('iconPrefixContainer');\n  private _textPrefixContainerSignal = viewChild<ElementRef<HTMLElement>>('textPrefixContainer');\n  private _iconSuffixContainerSignal = viewChild<ElementRef<HTMLElement>>('iconSuffixContainer');\n  private _textSuffixContainerSignal = viewChild<ElementRef<HTMLElement>>('textSuffixContainer');\n  private _prefixSuffixContainers = computed(() => {\n    return [\n      this._iconPrefixContainerSignal(),\n      this._textPrefixContainerSignal(),\n      this._iconSuffixContainerSignal(),\n      this._textSuffixContainerSignal(),\n    ]\n      .map(container => container?.nativeElement)\n      .filter(e => e !== undefined);\n  });\n\n  @ContentChild(_MatFormFieldControl) _formFieldControl: MatFormFieldControl<any>;\n  @ContentChildren(MAT_PREFIX, {descendants: true}) _prefixChildren: QueryList<MatPrefix>;\n  @ContentChildren(MAT_SUFFIX, {descendants: true}) _suffixChildren: QueryList<MatSuffix>;\n  @ContentChildren(MAT_ERROR, {descendants: true}) _errorChildren: QueryList<MatError>;\n  @ContentChildren(MatHint, {descendants: true}) _hintChildren: QueryList<MatHint>;\n\n  private readonly _labelChild = contentChild(MatLabel);\n\n  /** Whether the required marker should be hidden. */\n  @Input()\n  get hideRequiredMarker(): boolean {\n    return this._hideRequiredMarker;\n  }\n  set hideRequiredMarker(value: BooleanInput) {\n    this._hideRequiredMarker = coerceBooleanProperty(value);\n  }\n  private _hideRequiredMarker = false;\n\n  /**\n   * Theme color of the form field. This API is supported in M2 themes only, it\n   * has no effect in M3 themes. For color customization in M3, see https://material.angular.dev/components/form-field/styling.\n   *\n   * For information on applying color variants in M3, see\n   * https://material.angular.dev/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n   */\n  @Input() color: ThemePalette = 'primary';\n\n  /** Whether the label should always float or float as the user types. */\n  @Input()\n  get floatLabel(): FloatLabelType {\n    return this._floatLabel || this._defaults?.floatLabel || DEFAULT_FLOAT_LABEL;\n  }\n  set floatLabel(value: FloatLabelType) {\n    if (value !== this._floatLabel) {\n      this._floatLabel = value;\n      // For backwards compatibility. Custom form field controls or directives might set\n      // the \"floatLabel\" input and expect the form field view to be updated automatically.\n      // e.g. autocomplete trigger. Ideally we'd get rid of this and the consumers would just\n      // emit the \"stateChanges\" observable. TODO(devversion): consider removing.\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n  private _floatLabel: FloatLabelType;\n\n  /** The form field appearance style. */\n  @Input()\n  get appearance(): MatFormFieldAppearance {\n    return this._appearanceSignal();\n  }\n  set appearance(value: MatFormFieldAppearance) {\n    const newAppearance = value || this._defaults?.appearance || DEFAULT_APPEARANCE;\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (newAppearance !== 'fill' && newAppearance !== 'outline') {\n        throw new Error(\n          `MatFormField: Invalid appearance \"${newAppearance}\", valid values are \"fill\" or \"outline\".`,\n        );\n      }\n    }\n    this._appearanceSignal.set(newAppearance);\n  }\n  private _appearanceSignal = signal(DEFAULT_APPEARANCE);\n\n  /**\n   * Whether the form field should reserve space for one line of hint/error text (default)\n   * or to have the spacing grow from 0px as needed based on the size of the hint/error content.\n   * Note that when using dynamic sizing, layout shifts will occur when hint/error text changes.\n   */\n  @Input()\n  get subscriptSizing(): SubscriptSizing {\n    return this._subscriptSizing || this._defaults?.subscriptSizing || DEFAULT_SUBSCRIPT_SIZING;\n  }\n  set subscriptSizing(value: SubscriptSizing) {\n    this._subscriptSizing = value || this._defaults?.subscriptSizing || DEFAULT_SUBSCRIPT_SIZING;\n  }\n  private _subscriptSizing: SubscriptSizing | null = null;\n\n  /** Text for the form field hint. */\n  @Input()\n  get hintLabel(): string {\n    return this._hintLabel;\n  }\n  set hintLabel(value: string) {\n    this._hintLabel = value;\n    this._processHints();\n  }\n  private _hintLabel = '';\n\n  _hasIconPrefix = false;\n  _hasTextPrefix = false;\n  _hasIconSuffix = false;\n  _hasTextSuffix = false;\n\n  // Unique id for the internal form field label.\n  readonly _labelId = this._idGenerator.getId('mat-mdc-form-field-label-');\n\n  // Unique id for the hint label.\n  readonly _hintLabelId = this._idGenerator.getId('mat-mdc-hint-');\n\n  // Ids obtained from the error and hint fields\n  private _describedByIds: string[] | undefined;\n\n  /** Gets the current form field control */\n  get _control(): MatFormFieldControl<any> {\n    return this._explicitFormFieldControl || this._formFieldControl;\n  }\n  set _control(value) {\n    this._explicitFormFieldControl = value;\n  }\n\n  private _destroyed = new Subject<void>();\n  private _isFocused: boolean | null = null;\n  private _explicitFormFieldControl: MatFormFieldControl<any>;\n  private _previousControl: MatFormFieldControl<unknown> | null = null;\n  private _previousControlValidatorFn: ValidatorFn | null = null;\n  private _stateChanges: Subscription | undefined;\n  private _valueChanges: Subscription | undefined;\n  private _describedByChanges: Subscription | undefined;\n  private _outlineLabelOffsetResizeObserver: ResizeObserver | null = null;\n  protected readonly _animationsDisabled = _animationsDisabled();\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const defaults = this._defaults;\n    const dir = inject(Directionality);\n\n    if (defaults) {\n      if (defaults.appearance) {\n        this.appearance = defaults.appearance;\n      }\n      this._hideRequiredMarker = Boolean(defaults?.hideRequiredMarker);\n      if (defaults.color) {\n        this.color = defaults.color;\n      }\n    }\n\n    // We need this value inside a `afterRenderEffect`, however at the time of writing, reading the\n    // signal directly causes a memory leak (see https://github.com/angular/angular/issues/62980).\n    // TODO(crisbeto): clean this up once the framework issue is resolved.\n    effect(() => (this._currentDirection = dir.valueSignal()));\n    this._syncOutlineLabelOffset();\n  }\n\n  ngAfterViewInit() {\n    // Initial focus state sync. This happens rarely, but we want to account for\n    // it in case the form field control has \"focused\" set to true on init.\n    this._updateFocusState();\n\n    if (!this._animationsDisabled) {\n      this._ngZone.runOutsideAngular(() => {\n        // Enable animations after a certain amount of time so that they don't run on init.\n        setTimeout(() => {\n          this._elementRef.nativeElement.classList.add('mat-form-field-animations-enabled');\n        }, 300);\n      });\n    }\n\n    // Because the above changes a value used in the template after it was checked, we need\n    // to trigger CD or the change might not be reflected if there is no other CD scheduled.\n    this._changeDetectorRef.detectChanges();\n  }\n\n  ngAfterContentInit() {\n    this._assertFormFieldControl();\n    this._initializeSubscript();\n    this._initializePrefixAndSuffix();\n  }\n\n  ngAfterContentChecked() {\n    this._assertFormFieldControl();\n\n    // if form field was being used with an input in first place and then replaced by other\n    // component such as select.\n    if (this._control !== this._previousControl) {\n      this._initializeControl(this._previousControl);\n\n      // keep a reference for last validator we had.\n      if (this._control.ngControl && this._control.ngControl.control) {\n        this._previousControlValidatorFn = this._control.ngControl.control.validator;\n      }\n\n      this._previousControl = this._control;\n    }\n\n    // make sure the the control has been initialized.\n    if (this._control.ngControl && this._control.ngControl.control) {\n      // get the validators for current control.\n      const validatorFn = this._control.ngControl.control.validator;\n\n      // if our current validatorFn isn't equal to it might be we are CD behind, marking the\n      // component will allow us to catch up.\n      if (validatorFn !== this._previousControlValidatorFn) {\n        this._changeDetectorRef.markForCheck();\n      }\n    }\n  }\n\n  ngOnDestroy() {\n    this._outlineLabelOffsetResizeObserver?.disconnect();\n    this._stateChanges?.unsubscribe();\n    this._valueChanges?.unsubscribe();\n    this._describedByChanges?.unsubscribe();\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n\n  /**\n   * Gets the id of the label element. If no label is present, returns `null`.\n   */\n  getLabelId = computed(() => (this._hasFloatingLabel() ? this._labelId : null));\n\n  /**\n   * Gets an ElementRef for the element that a overlay attached to the form field\n   * should be positioned relative to.\n   */\n  getConnectedOverlayOrigin(): ElementRef {\n    return this._textField || this._elementRef;\n  }\n\n  /** Animates the placeholder up and locks it in position. */\n  _animateAndLockLabel(): void {\n    // This is for backwards compatibility only. Consumers of the form field might use\n    // this method. e.g. the autocomplete trigger. This method has been added to the non-MDC\n    // form field because setting \"floatLabel\" to \"always\" caused the label to float without\n    // animation. This is different in MDC where the label always animates, so this method\n    // is no longer necessary. There doesn't seem any benefit in adding logic to allow changing\n    // the floating label state without animations. The non-MDC implementation was inconsistent\n    // because it always animates if \"floatLabel\" is set away from \"always\".\n    // TODO(devversion): consider removing this method when releasing the MDC form field.\n    if (this._hasFloatingLabel()) {\n      this.floatLabel = 'always';\n    }\n  }\n\n  /** Initializes the registered form field control. */\n  private _initializeControl(previousControl: MatFormFieldControl<unknown> | null) {\n    const control = this._control;\n    const classPrefix = 'mat-mdc-form-field-type-';\n\n    if (previousControl) {\n      this._elementRef.nativeElement.classList.remove(classPrefix + previousControl.controlType);\n    }\n\n    if (control.controlType) {\n      this._elementRef.nativeElement.classList.add(classPrefix + control.controlType);\n    }\n\n    // Subscribe to changes in the child control state in order to update the form field UI.\n    this._stateChanges?.unsubscribe();\n    this._stateChanges = control.stateChanges.subscribe(() => {\n      this._updateFocusState();\n      this._changeDetectorRef.markForCheck();\n    });\n\n    // Updating the `aria-describedby` touches the DOM. Only do it if it actually needs to change.\n    this._describedByChanges?.unsubscribe();\n    this._describedByChanges = control.stateChanges\n      .pipe(\n        startWith([undefined, undefined] as const),\n        map(() => [control.errorState, control.userAriaDescribedBy] as const),\n        pairwise(),\n        filter(([[prevErrorState, prevDescribedBy], [currentErrorState, currentDescribedBy]]) => {\n          return prevErrorState !== currentErrorState || prevDescribedBy !== currentDescribedBy;\n        }),\n      )\n      .subscribe(() => this._syncDescribedByIds());\n\n    this._valueChanges?.unsubscribe();\n\n    // Run change detection if the value changes.\n    if (control.ngControl && control.ngControl.valueChanges) {\n      this._valueChanges = control.ngControl.valueChanges\n        .pipe(takeUntil(this._destroyed))\n        .subscribe(() => this._changeDetectorRef.markForCheck());\n    }\n  }\n\n  private _checkPrefixAndSuffixTypes() {\n    this._hasIconPrefix = !!this._prefixChildren.find(p => !p._isText);\n    this._hasTextPrefix = !!this._prefixChildren.find(p => p._isText);\n    this._hasIconSuffix = !!this._suffixChildren.find(s => !s._isText);\n    this._hasTextSuffix = !!this._suffixChildren.find(s => s._isText);\n  }\n\n  /** Initializes the prefix and suffix containers. */\n  private _initializePrefixAndSuffix() {\n    this._checkPrefixAndSuffixTypes();\n    // Mark the form field as dirty whenever the prefix or suffix children change. This\n    // is necessary because we conditionally display the prefix/suffix containers based\n    // on whether there is projected content.\n    merge(this._prefixChildren.changes, this._suffixChildren.changes).subscribe(() => {\n      this._checkPrefixAndSuffixTypes();\n      this._changeDetectorRef.markForCheck();\n    });\n  }\n\n  /**\n   * Initializes the subscript by validating hints and synchronizing \"aria-describedby\" ids\n   * with the custom form field control. Also subscribes to hint and error changes in order\n   * to be able to validate and synchronize ids on change.\n   */\n  private _initializeSubscript() {\n    // Re-validate when the number of hints changes.\n    this._hintChildren.changes.subscribe(() => {\n      this._processHints();\n      this._changeDetectorRef.markForCheck();\n    });\n\n    // Update the aria-described by when the number of errors changes.\n    this._errorChildren.changes.subscribe(() => {\n      this._syncDescribedByIds();\n      this._changeDetectorRef.markForCheck();\n    });\n\n    // Initial mat-hint validation and subscript describedByIds sync.\n    this._validateHints();\n    this._syncDescribedByIds();\n  }\n\n  /** Throws an error if the form field's control is missing. */\n  private _assertFormFieldControl() {\n    if (!this._control && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatFormFieldMissingControlError();\n    }\n  }\n\n  private _updateFocusState() {\n    const controlFocused = this._control.focused;\n\n    // Usually the MDC foundation would call \"activateFocus\" and \"deactivateFocus\" whenever\n    // certain DOM events are emitted. This is not possible in our implementation of the\n    // form field because we support abstract form field controls which are not necessarily\n    // of type input, nor do we have a reference to a native form field control element. Instead\n    // we handle the focus by checking if the abstract form field control focused state changes.\n    if (controlFocused && !this._isFocused) {\n      this._isFocused = true;\n      this._lineRipple?.activate();\n    } else if (!controlFocused && (this._isFocused || this._isFocused === null)) {\n      this._isFocused = false;\n      this._lineRipple?.deactivate();\n    }\n\n    this._elementRef.nativeElement.classList.toggle('mat-focused', controlFocused);\n    this._textField?.nativeElement.classList.toggle('mdc-text-field--focused', controlFocused);\n  }\n\n  /**\n   * The floating label in the docked state needs to account for prefixes. The horizontal offset\n   * is calculated whenever the appearance changes to `outline`, the prefixes change, or when the\n   * form field is added to the DOM. This method sets up all subscriptions which are needed to\n   * trigger the label offset update.\n   */\n  private _syncOutlineLabelOffset() {\n    afterRenderEffect({\n      earlyRead: () => {\n        if (this._appearanceSignal() !== 'outline') {\n          this._outlineLabelOffsetResizeObserver?.disconnect();\n          return null;\n        }\n\n        // Setup a resize observer to monitor changes to the size of the prefix / suffix and\n        // readjust the label offset.\n        if (globalThis.ResizeObserver) {\n          this._outlineLabelOffsetResizeObserver ||= new globalThis.ResizeObserver(() => {\n            this._writeOutlinedLabelStyles(this._getOutlinedLabelOffset());\n          });\n          for (const el of this._prefixSuffixContainers()) {\n            this._outlineLabelOffsetResizeObserver.observe(el, {box: 'border-box'});\n          }\n        }\n\n        return this._getOutlinedLabelOffset();\n      },\n      write: labelStyles => this._writeOutlinedLabelStyles(labelStyles()),\n    });\n  }\n\n  /** Whether the floating label should always float or not. */\n  _shouldAlwaysFloat() {\n    return this.floatLabel === 'always';\n  }\n\n  _hasOutline() {\n    return this.appearance === 'outline';\n  }\n\n  /**\n   * Whether the label should display in the infix. Labels in the outline appearance are\n   * displayed as part of the notched-outline and are horizontally offset to account for\n   * form field prefix content. This won't work in server side rendering since we cannot\n   * measure the width of the prefix container. To make the docked label appear as if the\n   * right offset has been calculated, we forcibly render the label inside the infix. Since\n   * the label is part of the infix, the label cannot overflow the prefix content.\n   */\n  _forceDisplayInfixLabel() {\n    return !this._platform.isBrowser && this._prefixChildren.length && !this._shouldLabelFloat();\n  }\n\n  _hasFloatingLabel = computed(() => !!this._labelChild());\n\n  _shouldLabelFloat(): boolean {\n    if (!this._hasFloatingLabel()) {\n      return false;\n    }\n    return this._control.shouldLabelFloat || this._shouldAlwaysFloat();\n  }\n\n  /**\n   * Determines whether a class from the AbstractControlDirective\n   * should be forwarded to the host element.\n   */\n  _shouldForward(prop: keyof AbstractControlDirective): boolean {\n    const control = this._control ? this._control.ngControl : null;\n    return control && control[prop];\n  }\n\n  /** Gets the type of subscript message to render (error or hint). */\n  _getSubscriptMessageType(): 'error' | 'hint' {\n    return this._errorChildren && this._errorChildren.length > 0 && this._control.errorState\n      ? 'error'\n      : 'hint';\n  }\n\n  /** Handle label resize events. */\n  _handleLabelResized() {\n    this._refreshOutlineNotchWidth();\n  }\n\n  /** Refreshes the width of the outline-notch, if present. */\n  _refreshOutlineNotchWidth() {\n    if (!this._hasOutline() || !this._floatingLabel || !this._shouldLabelFloat()) {\n      this._notchedOutline?._setNotchWidth(0);\n    } else {\n      this._notchedOutline?._setNotchWidth(this._floatingLabel.getWidth());\n    }\n  }\n\n  /** Does any extra processing that is required when handling the hints. */\n  private _processHints() {\n    this._validateHints();\n    this._syncDescribedByIds();\n  }\n\n  /**\n   * Ensure that there is a maximum of one of each \"mat-hint\" alignment specified. The hint\n   * label specified set through the input is being considered as \"start\" aligned.\n   *\n   * This method is a noop if Angular runs in production mode.\n   */\n  private _validateHints() {\n    if (this._hintChildren && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      let startHint: MatHint;\n      let endHint: MatHint;\n      this._hintChildren.forEach((hint: MatHint) => {\n        if (hint.align === 'start') {\n          if (startHint || this.hintLabel) {\n            throw getMatFormFieldDuplicatedHintError('start');\n          }\n          startHint = hint;\n        } else if (hint.align === 'end') {\n          if (endHint) {\n            throw getMatFormFieldDuplicatedHintError('end');\n          }\n          endHint = hint;\n        }\n      });\n    }\n  }\n\n  /**\n   * Sets the list of element IDs that describe the child control. This allows the control to update\n   * its `aria-describedby` attribute accordingly.\n   */\n  private _syncDescribedByIds() {\n    if (this._control) {\n      let ids: string[] = [];\n\n      // TODO(wagnermaciel): Remove the type check when we find the root cause of this bug.\n      if (\n        this._control.userAriaDescribedBy &&\n        typeof this._control.userAriaDescribedBy === 'string'\n      ) {\n        ids.push(...this._control.userAriaDescribedBy.split(' '));\n      }\n\n      if (this._getSubscriptMessageType() === 'hint') {\n        const startHint = this._hintChildren\n          ? this._hintChildren.find(hint => hint.align === 'start')\n          : null;\n        const endHint = this._hintChildren\n          ? this._hintChildren.find(hint => hint.align === 'end')\n          : null;\n\n        if (startHint) {\n          ids.push(startHint.id);\n        } else if (this._hintLabel) {\n          ids.push(this._hintLabelId);\n        }\n\n        if (endHint) {\n          ids.push(endHint.id);\n        }\n      } else if (this._errorChildren) {\n        ids.push(...this._errorChildren.map(error => error.id));\n      }\n\n      const existingDescribedBy = this._control.describedByIds;\n      let toAssign: string[];\n\n      // In some cases there might be some `aria-describedby` IDs that were assigned directly,\n      // like by the `AriaDescriber` (see #30011). Attempt to preserve them by taking the previous\n      // attribute value and filtering out the IDs that came from the previous `setDescribedByIds`\n      // call. Note the `|| ids` here allows us to avoid duplicating IDs on the first render.\n      if (existingDescribedBy) {\n        const exclude = this._describedByIds || ids;\n        toAssign = ids.concat(existingDescribedBy.filter(id => id && !exclude.includes(id)));\n      } else {\n        toAssign = ids;\n      }\n\n      this._control.setDescribedByIds(toAssign);\n      this._describedByIds = ids;\n    }\n  }\n\n  /**\n   * Calculates the horizontal offset of the label in the outline appearance. In the outline\n   * appearance, the notched-outline and label are not relative to the infix container because\n   * the outline intends to surround prefixes, suffixes and the infix. This means that the\n   * floating label by default overlaps prefixes in the docked state. To avoid this, we need to\n   * horizontally offset the label by the width of the prefix container. The MDC text-field does\n   * not need to do this because they use a fixed width for prefixes. Hence, they can simply\n   * incorporate the horizontal offset into their default text-field styles.\n   */\n  private _getOutlinedLabelOffset(): OutlinedLabelStyles {\n    if (!this._hasOutline() || !this._floatingLabel) {\n      return null;\n    }\n    // If no prefix is displayed, reset the outline label offset from potential\n    // previous label offset updates.\n    if (!this._iconPrefixContainer && !this._textPrefixContainer) {\n      return ['', null];\n    }\n    // If the form field is not attached to the DOM yet (e.g. in a tab), we defer\n    // the label offset update until the zone stabilizes.\n    if (!this._isAttachedToDom()) {\n      return null;\n    }\n    const iconPrefixContainer = this._iconPrefixContainer?.nativeElement;\n    const textPrefixContainer = this._textPrefixContainer?.nativeElement;\n    const iconSuffixContainer = this._iconSuffixContainer?.nativeElement;\n    const textSuffixContainer = this._textSuffixContainer?.nativeElement;\n    const iconPrefixContainerWidth = iconPrefixContainer?.getBoundingClientRect().width ?? 0;\n    const textPrefixContainerWidth = textPrefixContainer?.getBoundingClientRect().width ?? 0;\n    const iconSuffixContainerWidth = iconSuffixContainer?.getBoundingClientRect().width ?? 0;\n    const textSuffixContainerWidth = textSuffixContainer?.getBoundingClientRect().width ?? 0;\n    // If the directionality is RTL, the x-axis transform needs to be inverted. This\n    // is because `transformX` does not change based on the page directionality.\n    const negate = this._currentDirection === 'rtl' ? '-1' : '1';\n    const prefixWidth = `${iconPrefixContainerWidth + textPrefixContainerWidth}px`;\n    const labelOffset = `var(--mat-mdc-form-field-label-offset-x, 0px)`;\n    const labelHorizontalOffset = `calc(${negate} * (${prefixWidth} + ${labelOffset}))`;\n\n    // Update the translateX of the floating label to account for the prefix container,\n    // but allow the CSS to override this setting via a CSS variable when the label is\n    // floating.\n    const floatingLabelTransform =\n      'var(--mat-mdc-form-field-label-transform, ' +\n      `${FLOATING_LABEL_DEFAULT_DOCKED_TRANSFORM} translateX(${labelHorizontalOffset}))`;\n\n    // Prevent the label from overlapping the suffix when in resting position.\n    const notchedOutlineWidth =\n      iconPrefixContainerWidth +\n      textPrefixContainerWidth +\n      iconSuffixContainerWidth +\n      textSuffixContainerWidth;\n\n    return [floatingLabelTransform, notchedOutlineWidth];\n  }\n\n  /** Writes the styles produced by `_getOutlineLabelOffset` synchronously to the DOM. */\n  private _writeOutlinedLabelStyles(styles: OutlinedLabelStyles): void {\n    if (styles !== null) {\n      const [floatingLabelTransform, notchedOutlineWidth] = styles;\n\n      if (this._floatingLabel) {\n        this._floatingLabel.element.style.transform = floatingLabelTransform;\n      }\n\n      if (notchedOutlineWidth !== null) {\n        this._notchedOutline?._setMaxWidth(notchedOutlineWidth);\n      }\n    }\n  }\n\n  /** Checks whether the form field is attached to the DOM. */\n  private _isAttachedToDom(): boolean {\n    const element: HTMLElement = this._elementRef.nativeElement;\n    if (element.getRootNode) {\n      const rootNode = element.getRootNode();\n      // If the element is inside the DOM the root node will be either the document\n      // or the closest shadow root, otherwise it'll be the element itself.\n      return rootNode && rootNode !== element;\n    }\n    // Otherwise fall back to checking if it's in the document. This doesn't account for\n    // shadow DOM, however browser that support shadow DOM should support `getRootNode` as well.\n    return document.documentElement!.contains(element);\n  }\n}\n"],"names":["minVersion","version","ngImport","i0","type","MatLabel","decorators","args","MAT_ERROR","InjectionToken","ngDeclareClassMetadata","MatError","providers","provide","useExisting","ctorParameters","propDecorators","id","Input","MatHint","Directive","selector","align","MAT_PREFIX","MatPrefix","MAT_SUFFIX","MatSuffix","_floating","value","monitorResize","_handleResize","_monitorResize","_subscribeToResize","NgZone","constructor","ngOnDestroy","_resizeSubscription","unsubscribe","element","_elementRef","nativeElement","setTimeout","_parent","_handleLabelResized","_ngZone","runOutsideAngular","observe","box","fac","ngDeclareFactory","MatFormFieldFloatingLabel","deps","target","FactoryTarget","dir","ngDeclareDirective","isStandalone","inputs","floating","host","properties","classAttribute","estimateScrollWidth","_cleanupTransitionEnd","renderer","listen","_handleTransitionEnd","activate","classList","remove","DEACTIVATING_CLASS","add","ACTIVATE_CLASS","event","isDeactivating","contains","inject","ElementRef","label","querySelector","None","template","MatFormFieldControl","stateChanges","placeholder","focused","shouldLabelFloat","required","errorState","Error","getMatFormFieldMissingControlError","MAT_FORM_FIELD","DEFAULT_APPEARANCE","DEFAULT_FLOAT_LABEL","DEFAULT_SUBSCRIPT_SIZING","_idGenerator","_IdGenerator","_defaults","MAT_FORM_FIELD_DEFAULT_OPTIONS","_currentDirection","_textField","_iconPrefixContainer","_textPrefixContainer","_iconSuffixContainer","_notchedOutline","_lineRipple","_iconPrefixContainerSignal","viewChild","ngDevMode","debugName","_textPrefixContainerSignal","_iconSuffixContainerSignal","_textSuffixContainerSignal","_prefixSuffixContainers","computed","map","container","e","undefined","contentChild","hideRequiredMarker","_hideRequiredMarker","coerceBooleanProperty","color","_floatLabel","_changeDetectorRef","markForCheck","newAppearance","_appearanceSignal","set","signal","subscriptSizing","_subscriptSizing","hintLabel","_processHints","_hasIconSuffix","getId","_explicitFormFieldControl","_formFieldControl","_control","_previousControlValidatorFn","_outlineLabelOffsetResizeObserver","_animationsDisabled","defaults","dir","Directionality","appearance","valueSignal","ngAfterViewInit","_updateFocusState","detectChanges","_initializeSubscript","_assertFormFieldControl","_previousControl","ngControl","control","validator","validatorFn","_describedByChanges","_hasFloatingLabel","_labelId","previousControl","classPrefix","controlType","subscribe","pipe","startWith","userAriaDescribedBy","pairwise","filter","prevErrorState","prevDescribedBy","currentErrorState","currentDescribedBy","_valueChanges","valueChanges","takeUntil","_destroyed","_prefixChildren","find","p","_isText","_hasTextPrefix","_suffixChildren","s","_initializePrefixAndSuffix","_checkPrefixAndSuffixTypes","_hintChildren","changes","_syncDescribedByIds","controlFocused","_isFocused","deactivate","toggle","afterRenderEffect","ResizeObserver","globalThis","_writeOutlinedLabelStyles","_getOutlinedLabelOffset","el","labelStyles","_shouldAlwaysFloat","floatLabel","_hasOutline","_shouldForward","prop","startHint","getMatFormFieldDuplicatedHintError","hint","endHint","ViewEncapsulation","changeDetection","ChangeDetectionStrategy","OnPush","MatFormField","FLOATING_LABEL_PARENT","MatFormFieldNotchedOutline","NgTemplateOutlet","MatFormFieldLineRipple","styles","ViewChild","ContentChild","ContentChildren","descendants"],"mappings":"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"}