{"version":3,"file":"input-testing.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/input/testing/native-option-harness.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/input/testing/native-select-harness.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ComponentHarness, HarnessPredicate} from '@angular/cdk/testing';\nimport {NativeOptionHarnessFilters} from './native-select-harness-filters';\n\n/** Harness for interacting with a native `option` in tests. */\nexport class MatNativeOptionHarness extends ComponentHarness {\n  /** Selector used to locate option instances. */\n  static hostSelector = 'select[matNativeControl] option';\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a `MatNativeOptionHarness` that meets\n   * certain criteria.\n   * @param options Options for filtering which option instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with(options: NativeOptionHarnessFilters = {}) {\n    return new HarnessPredicate(MatNativeOptionHarness, options)\n      .addOption('text', options.text, async (harness, title) =>\n        HarnessPredicate.stringMatches(await harness.getText(), title),\n      )\n      .addOption(\n        'index',\n        options.index,\n        async (harness, index) => (await harness.getIndex()) === index,\n      )\n      .addOption(\n        'isSelected',\n        options.isSelected,\n        async (harness, isSelected) => (await harness.isSelected()) === isSelected,\n      );\n  }\n\n  /** Gets the option's label text. */\n  async getText(): Promise<string> {\n    return (await this.host()).getProperty<string>('label');\n  }\n\n  /** Index of the option within the native `select` element. */\n  async getIndex(): Promise<number> {\n    return (await this.host()).getProperty<number>('index');\n  }\n\n  /** Gets whether the option is disabled. */\n  async isDisabled(): Promise<boolean> {\n    return (await this.host()).getProperty<boolean>('disabled');\n  }\n\n  /** Gets whether the option is selected. */\n  async isSelected(): Promise<boolean> {\n    return (await this.host()).getProperty<boolean>('selected');\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {HarnessPredicate, parallel} from '@angular/cdk/testing';\nimport {MatFormFieldControlHarnessBase} from '../../form-field/testing/control';\nimport {MatNativeOptionHarness} from './native-option-harness';\nimport {\n  NativeOptionHarnessFilters,\n  NativeSelectHarnessFilters,\n} from './native-select-harness-filters';\n\n/** Harness for interacting with a native `select` in tests. */\nexport class MatNativeSelectHarness extends MatFormFieldControlHarnessBase {\n  static hostSelector = 'select[matNativeControl]';\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a `MatNativeSelectHarness` that meets\n   * certain criteria.\n   * @param options Options for filtering which select instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with(options: NativeSelectHarnessFilters = {}): HarnessPredicate<MatNativeSelectHarness> {\n    return new HarnessPredicate(MatNativeSelectHarness, options).addOption(\n      'label',\n      options.label,\n      (harness, label) => {\n        return HarnessPredicate.stringMatches(harness.getLabel(), label);\n      },\n    );\n  }\n\n  /** Gets a boolean promise indicating if the select is disabled. */\n  async isDisabled(): Promise<boolean> {\n    return (await this.host()).getProperty<boolean>('disabled');\n  }\n\n  /** Gets a boolean promise indicating if the select is required. */\n  async isRequired(): Promise<boolean> {\n    return (await this.host()).getProperty<boolean>('required');\n  }\n\n  /** Gets a boolean promise indicating if the select is in multi-selection mode. */\n  async isMultiple(): Promise<boolean> {\n    return (await this.host()).getProperty<boolean>('multiple');\n  }\n\n  /** Gets the name of the select. */\n  async getName(): Promise<string> {\n    // The \"name\" property of the native select is never undefined.\n    return await (await this.host()).getProperty<string>('name');\n  }\n\n  /** Gets the id of the select. */\n  async getId(): Promise<string> {\n    // We're guaranteed to have an id, because the `matNativeControl` always assigns one.\n    return await (await this.host()).getProperty<string>('id');\n  }\n\n  /** Focuses the select and returns a void promise that indicates when the action is complete. */\n  async focus(): Promise<void> {\n    return (await this.host()).focus();\n  }\n\n  /** Blurs the select and returns a void promise that indicates when the action is complete. */\n  async blur(): Promise<void> {\n    return (await this.host()).blur();\n  }\n\n  /** Whether the select is focused. */\n  async isFocused(): Promise<boolean> {\n    return (await this.host()).isFocused();\n  }\n\n  /** Gets the options inside the select panel. */\n  async getOptions(filter: NativeOptionHarnessFilters = {}): Promise<MatNativeOptionHarness[]> {\n    return this.locatorForAll(MatNativeOptionHarness.with(filter))();\n  }\n\n  /**\n   * Selects the options that match the passed-in filter. If the select is in multi-selection\n   * mode all options will be clicked, otherwise the harness will pick the first matching option.\n   */\n  async selectOptions(filter: NativeOptionHarnessFilters = {}): Promise<void> {\n    const [isMultiple, options] = await parallel(() => {\n      return [this.isMultiple(), this.getOptions(filter)];\n    });\n\n    if (options.length === 0) {\n      throw Error('Select does not have options matching the specified filter');\n    }\n\n    const [host, optionIndexes] = await parallel(() => [\n      this.host(),\n      parallel(() => options.slice(0, isMultiple ? undefined : 1).map(option => option.getIndex())),\n    ]);\n\n    await host.selectOptions(...optionIndexes);\n  }\n}\n"],"names":["MatNativeOptionHarness","ComponentHarness","hostSelector","with","options","HarnessPredicate","addOption","text","harness","title","stringMatches","getText","index","getIndex","isSelected","host","getProperty","isDisabled","MatNativeSelectHarness","MatFormFieldControlHarnessBase","label","getLabel","isRequired","isMultiple","getName","getId","focus","blur","isFocused","getOptions","filter","locatorForAll","selectOptions","parallel","length","Error","optionIndexes","slice","undefined","map","option"],"mappings":"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"}