{"version":3,"file":"timepicker-testing.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/timepicker/testing/timepicker-harness.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/timepicker/testing/timepicker-input-harness.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/timepicker/testing/timepicker-toggle-harness.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ComponentHarness,\n  ComponentHarnessConstructor,\n  HarnessPredicate,\n} from '@angular/cdk/testing';\nimport {MatOptionHarness, OptionHarnessFilters} from '../../core/testing';\nimport {TimepickerHarnessFilters} from './timepicker-harness-filters';\n\nexport class MatTimepickerHarness extends ComponentHarness {\n  private _documentRootLocator = this.documentRootLocatorFactory();\n  static hostSelector = 'mat-timepicker';\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a timepicker with specific\n   * attributes.\n   * @param options Options for filtering which timepicker instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with<T extends MatTimepickerHarness>(\n    this: ComponentHarnessConstructor<T>,\n    options: TimepickerHarnessFilters = {},\n  ): HarnessPredicate<T> {\n    return new HarnessPredicate(this, options);\n  }\n\n  /** Whether the timepicker is open. */\n  async isOpen(): Promise<boolean> {\n    const selector = await this._getPanelSelector();\n    const panel = await this._documentRootLocator.locatorForOptional(selector)();\n    return panel !== null;\n  }\n\n  /** Gets the options inside the timepicker panel. */\n  async getOptions(filters?: Omit<OptionHarnessFilters, 'ancestor'>): Promise<MatOptionHarness[]> {\n    if (!(await this.isOpen())) {\n      throw new Error('Unable to retrieve options for timepicker. Timepicker panel is closed.');\n    }\n\n    return this._documentRootLocator.locatorForAll(\n      MatOptionHarness.with({\n        ...(filters || {}),\n        ancestor: await this._getPanelSelector(),\n      } as OptionHarnessFilters),\n    )();\n  }\n\n  /** Selects the first option matching the given filters. */\n  async selectOption(filters: OptionHarnessFilters): Promise<void> {\n    const options = await this.getOptions(filters);\n    if (!options.length) {\n      throw Error(`Could not find a mat-option matching ${JSON.stringify(filters)}`);\n    }\n    await options[0].click();\n  }\n\n  /** Gets the selector that can be used to find the timepicker's panel. */\n  protected async _getPanelSelector(): Promise<string> {\n    return `#${await (await this.host()).getAttribute('mat-timepicker-panel-id')}`;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ComponentHarness,\n  ComponentHarnessConstructor,\n  HarnessPredicate,\n  TestKey,\n} from '@angular/cdk/testing';\nimport {MatTimepickerHarness} from './timepicker-harness';\nimport {\n  TimepickerHarnessFilters,\n  TimepickerInputHarnessFilters,\n} from './timepicker-harness-filters';\n\n/** Harness for interacting with a standard Material timepicker inputs in tests. */\nexport class MatTimepickerInputHarness extends ComponentHarness {\n  private _documentRootLocator = this.documentRootLocatorFactory();\n  static hostSelector = '.mat-timepicker-input';\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a `MatTimepickerInputHarness`\n   * that meets certain criteria.\n   * @param options Options for filtering which input instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with<T extends MatTimepickerInputHarness>(\n    this: ComponentHarnessConstructor<T>,\n    options: TimepickerInputHarnessFilters = {},\n  ): HarnessPredicate<T> {\n    return new HarnessPredicate(this, options)\n      .addOption('value', options.value, (harness, value) => {\n        return HarnessPredicate.stringMatches(harness.getValue(), value);\n      })\n      .addOption('placeholder', options.placeholder, (harness, placeholder) => {\n        return HarnessPredicate.stringMatches(harness.getPlaceholder(), placeholder);\n      });\n  }\n\n  /** Gets whether the timepicker associated with the input is open. */\n  async isTimepickerOpen(): Promise<boolean> {\n    const host = await this.host();\n    return (await host.getAttribute('aria-expanded')) === 'true';\n  }\n\n  /** Opens the timepicker associated with the input and returns the timepicker instance. */\n  async openTimepicker(): Promise<MatTimepickerHarness> {\n    if (!(await this.isDisabled())) {\n      const host = await this.host();\n      await host.sendKeys(TestKey.DOWN_ARROW);\n    }\n\n    return this.getTimepicker();\n  }\n\n  /** Closes the timepicker associated with the input. */\n  async closeTimepicker(): Promise<void> {\n    await this._documentRootLocator.rootElement.click();\n\n    // This is necessary so that we wait for the closing animation.\n    await this.forceStabilize();\n  }\n\n  /**\n   * Gets the `MatTimepickerHarness` that is associated with the input.\n   * @param filter Optionally filters which timepicker is included.\n   */\n  async getTimepicker(filter: TimepickerHarnessFilters = {}): Promise<MatTimepickerHarness> {\n    const host = await this.host();\n    const timepickerId = await host.getAttribute('mat-timepicker-id');\n\n    if (!timepickerId) {\n      throw Error('Element is not associated with a timepicker');\n    }\n\n    return this._documentRootLocator.locatorFor(\n      MatTimepickerHarness.with({\n        ...filter,\n        selector: `[mat-timepicker-panel-id=\"${timepickerId}\"]`,\n      }),\n    )();\n  }\n\n  /** Whether the input is disabled. */\n  async isDisabled(): Promise<boolean> {\n    return (await this.host()).getProperty<boolean>('disabled');\n  }\n\n  /** Whether the input is required. */\n  async isRequired(): Promise<boolean> {\n    return (await this.host()).getProperty<boolean>('required');\n  }\n\n  /** Gets the value of the input. */\n  async getValue(): Promise<string> {\n    // The \"value\" property of the native input is always defined.\n    return await (await this.host()).getProperty<string>('value');\n  }\n\n  /**\n   * Sets the value of the input. The value will be set by simulating\n   * keypresses that correspond to the given value.\n   */\n  async setValue(newValue: string): Promise<void> {\n    const inputEl = await this.host();\n    await inputEl.clear();\n\n    // We don't want to send keys for the value if the value is an empty\n    // string in order to clear the value. Sending keys with an empty string\n    // still results in unnecessary focus events.\n    if (newValue) {\n      await inputEl.sendKeys(newValue);\n    }\n  }\n\n  /** Gets the placeholder of the input. */\n  async getPlaceholder(): Promise<string> {\n    return await (await this.host()).getProperty<string>('placeholder');\n  }\n\n  /**\n   * Focuses the input and returns a promise that indicates when the\n   * action is complete.\n   */\n  async focus(): Promise<void> {\n    return (await this.host()).focus();\n  }\n\n  /**\n   * Blurs the input and returns a promise that indicates when the\n   * action is complete.\n   */\n  async blur(): Promise<void> {\n    return (await this.host()).blur();\n  }\n\n  /** Whether the input is focused. */\n  async isFocused(): Promise<boolean> {\n    return (await this.host()).isFocused();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ComponentHarness, HarnessPredicate} from '@angular/cdk/testing';\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {TimepickerToggleHarnessFilters} from './timepicker-harness-filters';\n\n/** Harness for interacting with a standard Material timepicker toggle in tests. */\nexport class MatTimepickerToggleHarness extends ComponentHarness {\n  static hostSelector = '.mat-timepicker-toggle';\n\n  /** The clickable button inside the toggle. */\n  private _button = this.locatorFor('button');\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a `MatTimepickerToggleHarness` that\n   * meets certain criteria.\n   * @param options Options for filtering which timepicker toggle instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with(\n    options: TimepickerToggleHarnessFilters = {},\n  ): HarnessPredicate<MatTimepickerToggleHarness> {\n    return new HarnessPredicate(MatTimepickerToggleHarness, options);\n  }\n\n  /** Opens the timepicker associated with the toggle. */\n  async openTimepicker(): Promise<void> {\n    const isOpen = await this.isTimepickerOpen();\n\n    if (!isOpen) {\n      const button = await this._button();\n      await button.click();\n    }\n  }\n\n  /** Gets whether the timepicker associated with the toggle is open. */\n  async isTimepickerOpen(): Promise<boolean> {\n    const button = await this._button();\n    const ariaExpanded = await button.getAttribute('aria-expanded');\n    return ariaExpanded === 'true';\n  }\n\n  /** Whether the toggle is disabled. */\n  async isDisabled(): Promise<boolean> {\n    const button = await this._button();\n    return coerceBooleanProperty(await button.getAttribute('disabled'));\n  }\n}\n"],"names":["with","options","panel","getOptions","filters","isOpen","Error","_documentRootLocator","locatorForAll","MatOptionHarness","ancestor","_getPanelSelector","isTimepickerOpen","host","getAttribute","isDisabled","sendKeys","DOWN_ARROW","getTimepicker","closeTimepicker","rootElement","click","forceStabilize","filter","timepickerId","locatorFor","MatTimepickerHarness","selector","getProperty","isRequired","getValue","setValue","newValue","inputEl","_button","button"],"mappings":";;;;;;;SAqCWA,IAAAA,CAAAC,OAAU,GAAA,EAAA,EAAA;;;;;;AAWb,IAAA,OAAAC,UAGD,IAAA;;AAMH,EAAA,MAAAC,WAAAC,OAAA,EAAA;gBACQ,KAAAC,MAAA,EAAA,CAAA,EAAA;YACR,IAAAC,KAAA,CAAA,wEAAA,CAAA;AACA;AACF,IAAA,OAAA,KAAAC,oBAAA,CAAAC,aAAA,CAAAC,gBAAA,CAAAT,IAAA,CAAA;;AAIEU,MAAAA,QAAA,aAAAC,iBAAA;KACF,CAAA,CAAA,EAAA;;;;;;;;;;;;;;;;;ECpBE,OAAAX,IAAAA,CAAAC,OAAa,GAAA,EAAA,EAAA;;;;;KASb,CAAA;;wBAS+DW,GAAA;IAC/D,MAAAC,IAAA,cAAAA,IAAA,EAAA;AACF,IAAA,OAAA,CAAA,MAAAA,IAAA,CAAAC,YAAA,CAAA,eAAA,OAAA,MAAA;;;AAMA,IAAA,IAAA,EAAA,MAAA,IAAA,CAAAC,UAAA,EAAA,CAAA,EAAA;MACE,MAAAF,IAAA,GAAa,MAAA,IAAA,CAAAA,IAAA,EAAA;YACPA,IAAA,CAAAG,gBAAqB,CAAAC,UAAA,CAAA;;AAGzB,IAAA,OAAA,IAAA,CAAAC,aAAA,EAAA;;uBAMUC,GAAA;mCAET,CAAAC,WAAA,CAAAC,KAAA,EAAA;AAGL,IAAA,MAAqC,KAAAC,cAAA,EAAA;;AAWrCJ,EAAAA,MAAAA,aAAAA,CAAAK,MAAA,GAAA,EAAA,EAAA;UACgEV,IAAA,GAAA,MAAA,IAAA,CAAAA,IAAA,EAAA;AAC9D,IAAA,MAAAW,YAAA,GAAA,MAAAX,IAAA,CAAAC,YAAA,CAAA,mBAAA,CAAA;AAGF,IAAA,IAAA,CAAAU,YAAA,EAAA;;;AAGG,IAAA,OAAA,IAAA,CAAAjB,oBAAA,CAAAkB,UAAA,CAAAC,oBAAA,CAAA1B,IAAA,CAAA;AACE,MAAA,GAAAuB,MAAA;MACHI,QAAM,+BAAqBH,YAAA,CAAA,EAAA;AAC3B,KAAA,CAAA,CAAA,EAAA;;;WAOA,CAAA,MAAA,IAAA,CAAAX,IAAA,EAAA,EAAAe,WAAA,CACF,UAAA,CAAA;;AAIEC,EAAAA,MAAAA,UACFA,GAAA;IAEA,OAAAhB,CAAAA,MAAAA,IAAAA,CAAAA,IAAA,IAAAe,WAAA,CAAA,UAAA,CAAA;;AAIAE,EAAAA,MAAAA,QAAWA,GAAA;IAIX,OAAAjB,MAAAA,CAAAA,MAAAA,IAAAA,CAAAA,IAAA,IAAAe,WAAA,CAAA,OAAA,CAAA;;AAQAG,EAAAA,MAAAA,QAAAA,CAAAC,QAAA,EAAA;AACA,IAAA,MAAAC,OAAe,GAAA,MAAA,IAAA,CAAApB,IAAA,EAAA;;;;;;;;;;;;;;;;;;;;;;AC7HPqB,EAAAA,OAAA,QAAAT,UAAA,CAAA,QAAA,CAAA;EAeF,OAAczB,IAAAA,CAAAC,OAAA,GAAA,EAAA,EAAA;;;;;AASkD,IAAA,IAAA,CAAAI,MAAA,EAAA;AACjE,MAAA,MACH8B,MAAA,GAAmC,MAAA,IAAA,CAAAD,OAAA,EAAA;YAE5BC,MAAA,CAAAd,KAAA,EAAA;;AAIT;wBAEST,GAAA;;;;;;;;;;;;;"}