{"version":3,"file":"sidenav.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/sidenav/drawer.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/sidenav/sidenav.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/sidenav/sidenav-module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {\n  FocusMonitor,\n  FocusOrigin,\n  FocusTrap,\n  FocusTrapFactory,\n  InteractivityChecker,\n} from '@angular/cdk/a11y';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {BooleanInput, coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {ESCAPE, hasModifierKey} from '@angular/cdk/keycodes';\nimport {Platform} from '@angular/cdk/platform';\nimport {CdkScrollable, ScrollDispatcher, ViewportRuler} from '@angular/cdk/scrolling';\n\nimport {\n  AfterContentInit,\n  afterNextRender,\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChild,\n  ContentChildren,\n  DoCheck,\n  ElementRef,\n  EventEmitter,\n  inject,\n  InjectionToken,\n  Injector,\n  Input,\n  NgZone,\n  OnDestroy,\n  Output,\n  QueryList,\n  Renderer2,\n  ViewChild,\n  ViewEncapsulation,\n  DOCUMENT,\n  signal,\n} from '@angular/core';\nimport {fromEvent, merge, Observable, Subject} from 'rxjs';\nimport {debounceTime, filter, map, mapTo, startWith, take, takeUntil} from 'rxjs/operators';\nimport {_animationsDisabled} from '../core';\n\n/**\n * Throws an exception when two MatDrawer are matching the same position.\n * @docs-private\n */\nexport function throwMatDuplicatedDrawerError(position: string) {\n  throw Error(`A drawer was already declared for 'position=\"${position}\"'`);\n}\n\n/** Options for where to set focus to automatically on dialog open */\nexport type AutoFocusTarget = 'dialog' | 'first-tabbable' | 'first-heading';\n\n/** Result of the toggle promise that indicates the state of the drawer. */\nexport type MatDrawerToggleResult = 'open' | 'close';\n\n/** Drawer and SideNav display modes. */\nexport type MatDrawerMode = 'over' | 'push' | 'side';\n\n/** Configures whether drawers should use auto sizing by default. */\nexport const MAT_DRAWER_DEFAULT_AUTOSIZE = new InjectionToken<boolean>(\n  'MAT_DRAWER_DEFAULT_AUTOSIZE',\n  {\n    providedIn: 'root',\n    factory: () => false,\n  },\n);\n\n/**\n * Used to provide a drawer container to a drawer while avoiding circular references.\n * @docs-private\n */\nexport const MAT_DRAWER_CONTAINER = new InjectionToken('MAT_DRAWER_CONTAINER');\n\n@Component({\n  selector: 'mat-drawer-content',\n  template: '<ng-content></ng-content>',\n  host: {\n    'class': 'mat-drawer-content',\n    '[style.margin-left.px]': '_container._contentMargins.left',\n    '[style.margin-right.px]': '_container._contentMargins.right',\n    '[class.mat-drawer-content-hidden]': '_shouldBeHidden()',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  providers: [\n    {\n      provide: CdkScrollable,\n      useExisting: MatDrawerContent,\n    },\n  ],\n})\nexport class MatDrawerContent extends CdkScrollable implements AfterContentInit {\n  private _platform = inject(Platform);\n  private _changeDetectorRef = inject(ChangeDetectorRef);\n  _container = inject(MatDrawerContainer);\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n    const scrollDispatcher = inject(ScrollDispatcher);\n    const ngZone = inject(NgZone);\n\n    super(elementRef, scrollDispatcher, ngZone);\n  }\n\n  ngAfterContentInit() {\n    this._container._contentMarginChanges.subscribe(() => {\n      this._changeDetectorRef.markForCheck();\n    });\n  }\n\n  /** Determines whether the content element should be hidden from the user. */\n  protected _shouldBeHidden(): boolean {\n    // In some modes the content is pushed based on the width of the opened sidenavs, however on\n    // the server we can't measure the sidenav so the margin is always zero. This can cause the\n    // content to jump around when it's rendered on the server and hydrated on the client. We\n    // avoid it by hiding the content on the initial render and then showing it once the sidenav\n    // has been measured on the client.\n    if (this._platform.isBrowser) {\n      return false;\n    }\n\n    const {start, end} = this._container;\n    return (\n      (start != null && start.mode !== 'over' && start.opened) ||\n      (end != null && end.mode !== 'over' && end.opened)\n    );\n  }\n}\n\n/**\n * This component corresponds to a drawer that can be opened on the drawer container.\n */\n@Component({\n  selector: 'mat-drawer',\n  exportAs: 'matDrawer',\n  templateUrl: 'drawer.html',\n  host: {\n    'class': 'mat-drawer',\n    // must prevent the browser from aligning text based on value\n    '[attr.align]': 'null',\n    '[class.mat-drawer-end]': 'position === \"end\"',\n    '[class.mat-drawer-over]': 'mode === \"over\"',\n    '[class.mat-drawer-push]': 'mode === \"push\"',\n    '[class.mat-drawer-side]': 'mode === \"side\"',\n    // The styles that render the sidenav off-screen come from the drawer container. Prior to #30235\n    // this was also done by the animations module which some internal tests seem to depend on.\n    // Simulate it by toggling the `hidden` attribute instead.\n    '[style.visibility]': '(!_container && !opened) ? \"hidden\" : null',\n    // The sidenav container should not be focused on when used in side mode. See b/286459024 for\n    // reference. Updates tabIndex of drawer/container to default to null if in side mode.\n    '[attr.tabIndex]': '(mode !== \"side\") ? \"-1\" : null',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  imports: [CdkScrollable],\n})\nexport class MatDrawer implements AfterViewInit, OnDestroy {\n  private _elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n  private _focusTrapFactory = inject(FocusTrapFactory);\n  private _focusMonitor = inject(FocusMonitor);\n  private _platform = inject(Platform);\n  private _ngZone = inject(NgZone);\n  private _renderer = inject(Renderer2);\n  private readonly _interactivityChecker = inject(InteractivityChecker);\n  private _doc = inject(DOCUMENT);\n  _container? = inject<MatDrawerContainer>(MAT_DRAWER_CONTAINER, {optional: true});\n\n  private _focusTrap: FocusTrap | null = null;\n  private _elementFocusedBeforeDrawerWasOpened: HTMLElement | null = null;\n  private _eventCleanups: (() => void)[];\n\n  /** Whether the view of the component has been attached. */\n  private _isAttached: boolean;\n\n  /** Anchor node used to restore the drawer to its initial position. */\n  private _anchor: Comment | null;\n\n  /** The side that the drawer is attached to. */\n  @Input()\n  get position(): 'start' | 'end' {\n    return this._position;\n  }\n  set position(value: 'start' | 'end') {\n    // Make sure we have a valid value.\n    value = value === 'end' ? 'end' : 'start';\n    if (value !== this._position) {\n      // Static inputs in Ivy are set before the element is in the DOM.\n      if (this._isAttached) {\n        this._updatePositionInParent(value);\n      }\n\n      this._position = value;\n      this.onPositionChanged.emit();\n    }\n  }\n  private _position: 'start' | 'end' = 'start';\n\n  /** Mode of the drawer; one of 'over', 'push' or 'side'. */\n  @Input()\n  get mode(): MatDrawerMode {\n    return this._mode;\n  }\n  set mode(value: MatDrawerMode) {\n    this._mode = value;\n    this._updateFocusTrapState();\n    this._modeChanged.next();\n  }\n  private _mode: MatDrawerMode = 'over';\n\n  /** Whether the drawer can be closed with the escape key or by clicking on the backdrop. */\n  @Input()\n  get disableClose(): boolean {\n    return this._disableClose;\n  }\n  set disableClose(value: BooleanInput) {\n    this._disableClose = coerceBooleanProperty(value);\n  }\n  private _disableClose: boolean = false;\n\n  /**\n   * Whether the drawer should focus the first focusable element automatically when opened.\n   * Defaults to false in when `mode` is set to `side`, otherwise defaults to `true`. If explicitly\n   * enabled, focus will be moved into the sidenav in `side` mode as well.\n   * @breaking-change 14.0.0 Remove boolean option from autoFocus. Use string or AutoFocusTarget\n   * instead.\n   */\n  @Input()\n  get autoFocus(): AutoFocusTarget | string | boolean {\n    const value = this._autoFocus;\n\n    // Note that usually we don't allow autoFocus to be set to `first-tabbable` in `side` mode,\n    // because we don't know how the sidenav is being used, but in some cases it still makes\n    // sense to do it. The consumer can explicitly set `autoFocus`.\n    if (value == null) {\n      if (this.mode === 'side') {\n        return 'dialog';\n      } else {\n        return 'first-tabbable';\n      }\n    }\n    return value;\n  }\n  set autoFocus(value: AutoFocusTarget | string | BooleanInput) {\n    if (value === 'true' || value === 'false' || value == null) {\n      value = coerceBooleanProperty(value);\n    }\n    this._autoFocus = value;\n  }\n  private _autoFocus: AutoFocusTarget | string | boolean | undefined;\n\n  /**\n   * Whether the drawer is opened. We overload this because we trigger an event when it\n   * starts or end.\n   */\n  @Input()\n  get opened(): boolean {\n    return this._opened();\n  }\n  set opened(value: BooleanInput) {\n    this.toggle(coerceBooleanProperty(value));\n  }\n  private _opened = signal(false);\n\n  /** How the sidenav was opened (keypress, mouse click etc.) */\n  private _openedVia: FocusOrigin | null;\n\n  /** Emits whenever the drawer has started animating. */\n  readonly _animationStarted = new Subject();\n\n  /** Emits whenever the drawer is done animating. */\n  readonly _animationEnd = new Subject();\n\n  /** Event emitted when the drawer open state is changed. */\n  @Output() readonly openedChange: EventEmitter<boolean> =\n    // Note this has to be async in order to avoid some issues with two-bindings (see #8872).\n    new EventEmitter<boolean>(/* isAsync */ true);\n\n  /** Event emitted when the drawer has been opened. */\n  @Output('opened')\n  readonly _openedStream = this.openedChange.pipe(\n    filter(o => o),\n    map(() => {}),\n  );\n\n  /** Event emitted when the drawer has started opening. */\n  @Output()\n  readonly openedStart: Observable<void> = this._animationStarted.pipe(\n    filter(() => this.opened),\n    mapTo(undefined),\n  );\n\n  /** Event emitted when the drawer has been closed. */\n  @Output('closed')\n  readonly _closedStream = this.openedChange.pipe(\n    filter(o => !o),\n    map(() => {}),\n  );\n\n  /** Event emitted when the drawer has started closing. */\n  @Output()\n  readonly closedStart: Observable<void> = this._animationStarted.pipe(\n    filter(() => !this.opened),\n    mapTo(undefined),\n  );\n\n  /** Emits when the component is destroyed. */\n  private readonly _destroyed = new Subject<void>();\n\n  /** Event emitted when the drawer's position changes. */\n  // tslint:disable-next-line:no-output-on-prefix\n  @Output('positionChanged') readonly onPositionChanged = new EventEmitter<void>();\n\n  /** Reference to the inner element that contains all the content. */\n  @ViewChild('content') _content: ElementRef<HTMLElement>;\n\n  /**\n   * An observable that emits when the drawer mode changes. This is used by the drawer container to\n   * to know when to when the mode changes so it can adapt the margins on the content.\n   */\n  readonly _modeChanged = new Subject<void>();\n\n  private _injector = inject(Injector);\n  private _changeDetectorRef = inject(ChangeDetectorRef);\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    this.openedChange.pipe(takeUntil(this._destroyed)).subscribe((opened: boolean) => {\n      if (opened) {\n        this._elementFocusedBeforeDrawerWasOpened = this._doc.activeElement as HTMLElement;\n        this._takeFocus();\n      } else if (this._isFocusWithinDrawer()) {\n        this._restoreFocus(this._openedVia || 'program');\n      }\n    });\n\n    /**\n     * Listen to `keydown` events outside the zone so that change detection is not run every\n     * time a key is pressed. Instead we re-enter the zone only if the `ESC` key is pressed\n     * and we don't have close disabled.\n     */\n    this._ngZone.runOutsideAngular(() => {\n      const element = this._elementRef.nativeElement;\n      (fromEvent(element, 'keydown') as Observable<KeyboardEvent>)\n        .pipe(\n          filter(event => {\n            return event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event);\n          }),\n          takeUntil(this._destroyed),\n        )\n        .subscribe(event =>\n          this._ngZone.run(() => {\n            this.close();\n            event.stopPropagation();\n            event.preventDefault();\n          }),\n        );\n\n      this._eventCleanups = [\n        this._renderer.listen(element, 'transitionrun', this._handleTransitionEvent),\n        this._renderer.listen(element, 'transitionend', this._handleTransitionEvent),\n        this._renderer.listen(element, 'transitioncancel', this._handleTransitionEvent),\n      ];\n    });\n\n    this._animationEnd.subscribe(() => {\n      this.openedChange.emit(this.opened);\n    });\n  }\n\n  /**\n   * Focuses the provided element. If the element is not focusable, it will add a tabIndex\n   * attribute to forcefully focus it. The attribute is removed after focus is moved.\n   * @param element The element to focus.\n   */\n  private _forceFocus(element: HTMLElement, options?: FocusOptions) {\n    if (!this._interactivityChecker.isFocusable(element)) {\n      element.tabIndex = -1;\n      // The tabindex attribute should be removed to avoid navigating to that element again\n      this._ngZone.runOutsideAngular(() => {\n        const callback = () => {\n          cleanupBlur();\n          cleanupMousedown();\n          element.removeAttribute('tabindex');\n        };\n\n        const cleanupBlur = this._renderer.listen(element, 'blur', callback);\n        const cleanupMousedown = this._renderer.listen(element, 'mousedown', callback);\n      });\n    }\n    element.focus(options);\n  }\n\n  /**\n   * Focuses the first element that matches the given selector within the focus trap.\n   * @param selector The CSS selector for the element to set focus to.\n   */\n  private _focusByCssSelector(selector: string, options?: FocusOptions) {\n    let elementToFocus = this._elementRef.nativeElement.querySelector(\n      selector,\n    ) as HTMLElement | null;\n    if (elementToFocus) {\n      this._forceFocus(elementToFocus, options);\n    }\n  }\n\n  /**\n   * Moves focus into the drawer. Note that this works even if\n   * the focus trap is disabled in `side` mode.\n   */\n  private _takeFocus() {\n    if (!this._focusTrap) {\n      return;\n    }\n\n    const element = this._elementRef.nativeElement;\n\n    // When autoFocus is not on the sidenav, if the element cannot be focused or does\n    // not exist, focus the sidenav itself so the keyboard navigation still works.\n    // We need to check that `focus` is a function due to Universal.\n    switch (this.autoFocus) {\n      case false:\n      case 'dialog':\n        return;\n      case true:\n      case 'first-tabbable':\n        afterNextRender(\n          () => {\n            const hasMovedFocus = this._focusTrap!.focusInitialElement();\n            if (!hasMovedFocus && typeof element.focus === 'function') {\n              element.focus();\n            }\n          },\n          {injector: this._injector},\n        );\n        break;\n      case 'first-heading':\n        this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role=\"heading\"]');\n        break;\n      default:\n        this._focusByCssSelector(this.autoFocus!);\n        break;\n    }\n  }\n\n  /**\n   * Restores focus to the element that was originally focused when the drawer opened.\n   * If no element was focused at that time, the focus will be restored to the drawer.\n   */\n  private _restoreFocus(focusOrigin: Exclude<FocusOrigin, null>) {\n    if (this.autoFocus === 'dialog') {\n      return;\n    }\n\n    if (this._elementFocusedBeforeDrawerWasOpened) {\n      this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened, focusOrigin);\n    } else {\n      this._elementRef.nativeElement.blur();\n    }\n\n    this._elementFocusedBeforeDrawerWasOpened = null;\n  }\n\n  /** Whether focus is currently within the drawer. */\n  private _isFocusWithinDrawer(): boolean {\n    const activeEl = this._doc.activeElement;\n    return !!activeEl && this._elementRef.nativeElement.contains(activeEl);\n  }\n\n  ngAfterViewInit() {\n    this._isAttached = true;\n\n    // Only update the DOM position when the sidenav is positioned at\n    // the end since we project the sidenav before the content by default.\n    if (this._position === 'end') {\n      this._updatePositionInParent('end');\n    }\n\n    // Needs to happen after the position is updated\n    // so the focus trap anchors are in the right place.\n    if (this._platform.isBrowser) {\n      this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\n      this._updateFocusTrapState();\n    }\n  }\n\n  ngOnDestroy() {\n    this._eventCleanups.forEach(cleanup => cleanup());\n    this._focusTrap?.destroy();\n    this._anchor?.remove();\n    this._anchor = null;\n    this._animationStarted.complete();\n    this._animationEnd.complete();\n    this._modeChanged.complete();\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n\n  /**\n   * Open the drawer.\n   * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n   * Used for focus management after the sidenav is closed.\n   */\n  open(openedVia?: FocusOrigin): Promise<MatDrawerToggleResult> {\n    return this.toggle(true, openedVia);\n  }\n\n  /** Close the drawer. */\n  close(): Promise<MatDrawerToggleResult> {\n    return this.toggle(false);\n  }\n\n  /** Closes the drawer with context that the backdrop was clicked. */\n  _closeViaBackdropClick(): Promise<MatDrawerToggleResult> {\n    // If the drawer is closed upon a backdrop click, we always want to restore focus. We\n    // don't need to check whether focus is currently in the drawer, as clicking on the\n    // backdrop causes blurs the active element.\n    return this._setOpen(/* isOpen */ false, /* restoreFocus */ true, 'mouse');\n  }\n\n  /**\n   * Toggle this drawer.\n   * @param isOpen Whether the drawer should be open.\n   * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n   * Used for focus management after the sidenav is closed.\n   */\n  toggle(isOpen: boolean = !this.opened, openedVia?: FocusOrigin): Promise<MatDrawerToggleResult> {\n    // If the focus is currently inside the drawer content and we are closing the drawer,\n    // restore the focus to the initially focused element (when the drawer opened).\n    if (isOpen && openedVia) {\n      this._openedVia = openedVia;\n    }\n\n    const result = this._setOpen(\n      isOpen,\n      /* restoreFocus */ !isOpen && this._isFocusWithinDrawer(),\n      this._openedVia || 'program',\n    );\n\n    if (!isOpen) {\n      this._openedVia = null;\n    }\n\n    return result;\n  }\n\n  /**\n   * Toggles the opened state of the drawer.\n   * @param isOpen Whether the drawer should open or close.\n   * @param restoreFocus Whether focus should be restored on close.\n   * @param focusOrigin Origin to use when restoring focus.\n   */\n  private _setOpen(\n    isOpen: boolean,\n    restoreFocus: boolean,\n    focusOrigin: Exclude<FocusOrigin, null>,\n  ): Promise<MatDrawerToggleResult> {\n    if (isOpen === this.opened) {\n      return Promise.resolve(isOpen ? 'open' : 'close');\n    }\n\n    this._opened.set(isOpen);\n\n    if (this._container?._transitionsEnabled) {\n      // Note: it's importatnt to set this as early as possible,\n      // otherwise the animation can look glitchy in some cases.\n      this._setIsAnimating(true);\n    } else {\n      // Simulate the animation events if animations are disabled.\n      setTimeout(() => {\n        this._animationStarted.next();\n        this._animationEnd.next();\n      });\n    }\n\n    this._elementRef.nativeElement.classList.toggle('mat-drawer-opened', isOpen);\n\n    if (!isOpen && restoreFocus) {\n      this._restoreFocus(focusOrigin);\n    }\n\n    // Needed to ensure that the closing sequence fires off correctly.\n    this._changeDetectorRef.markForCheck();\n    this._updateFocusTrapState();\n\n    return new Promise<MatDrawerToggleResult>(resolve => {\n      this.openedChange.pipe(take(1)).subscribe(open => resolve(open ? 'open' : 'close'));\n    });\n  }\n\n  /** Toggles whether the drawer is currently animating. */\n  private _setIsAnimating(isAnimating: boolean) {\n    this._elementRef.nativeElement.classList.toggle('mat-drawer-animating', isAnimating);\n  }\n\n  _getWidth(): number {\n    return this._elementRef.nativeElement.offsetWidth || 0;\n  }\n\n  /** Updates the enabled state of the focus trap. */\n  private _updateFocusTrapState() {\n    if (this._focusTrap) {\n      // Trap focus only if the backdrop is enabled. Otherwise, allow end user to interact with the\n      // sidenav content.\n      this._focusTrap.enabled = !!this._container?.hasBackdrop && this.opened;\n    }\n  }\n\n  /**\n   * Updates the position of the drawer in the DOM. We need to move the element around ourselves\n   * when it's in the `end` position so that it comes after the content and the visual order\n   * matches the tab order. We also need to be able to move it back to `start` if the sidenav\n   * started off as `end` and was changed to `start`.\n   */\n  private _updatePositionInParent(newPosition: 'start' | 'end'): void {\n    // Don't move the DOM node around on the server, because it can throw off hydration.\n    if (!this._platform.isBrowser) {\n      return;\n    }\n\n    const element = this._elementRef.nativeElement;\n    const parent = element.parentNode!;\n\n    if (newPosition === 'end') {\n      if (!this._anchor) {\n        this._anchor = this._doc.createComment('mat-drawer-anchor')!;\n        parent.insertBefore(this._anchor!, element);\n      }\n\n      parent.appendChild(element);\n    } else if (this._anchor) {\n      this._anchor.parentNode!.insertBefore(element, this._anchor);\n    }\n  }\n\n  /** Event handler for animation events. */\n  private _handleTransitionEvent = (event: TransitionEvent) => {\n    const element = this._elementRef.nativeElement;\n\n    if (event.target === element) {\n      this._ngZone.run(() => {\n        if (event.type === 'transitionrun') {\n          this._animationStarted.next(event);\n        } else {\n          // Don't toggle the animating state on `transitioncancel` since another animation should\n          // start afterwards. This prevents the drawer from blinking if an animation is interrupted.\n          if (event.type === 'transitionend') {\n            this._setIsAnimating(false);\n          }\n\n          this._animationEnd.next(event);\n        }\n      });\n    }\n  };\n}\n\n/**\n * `<mat-drawer-container>` component.\n *\n * This is the parent component to one or two `<mat-drawer>`s that validates the state internally\n * and coordinates the backdrop and content styling.\n */\n@Component({\n  selector: 'mat-drawer-container',\n  exportAs: 'matDrawerContainer',\n  templateUrl: 'drawer-container.html',\n  styleUrl: 'drawer.css',\n  host: {\n    'class': 'mat-drawer-container',\n    '[class.mat-drawer-container-explicit-backdrop]': '_backdropOverride',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  providers: [\n    {\n      provide: MAT_DRAWER_CONTAINER,\n      useExisting: MatDrawerContainer,\n    },\n  ],\n  imports: [MatDrawerContent],\n})\nexport class MatDrawerContainer implements AfterContentInit, DoCheck, OnDestroy {\n  private _dir = inject(Directionality, {optional: true});\n  private _element = inject<ElementRef<HTMLElement>>(ElementRef);\n  private _ngZone = inject(NgZone);\n  private _changeDetectorRef = inject(ChangeDetectorRef);\n  private _animationDisabled = _animationsDisabled();\n  _transitionsEnabled = false;\n\n  /** All drawers in the container. Includes drawers from inside nested containers. */\n  @ContentChildren(MatDrawer, {\n    // We need to use `descendants: true`, because Ivy will no longer match\n    // indirect descendants if it's left as false.\n    descendants: true,\n  })\n  _allDrawers: QueryList<MatDrawer>;\n\n  /** Drawers that belong to this container. */\n  _drawers = new QueryList<MatDrawer>();\n\n  @ContentChild(MatDrawerContent) _content: MatDrawerContent;\n  @ViewChild(MatDrawerContent) _userContent: MatDrawerContent;\n\n  /** The drawer child with the `start` position. */\n  get start(): MatDrawer | null {\n    return this._start;\n  }\n\n  /** The drawer child with the `end` position. */\n  get end(): MatDrawer | null {\n    return this._end;\n  }\n\n  /**\n   * Whether to automatically resize the container whenever\n   * the size of any of its drawers changes.\n   *\n   * **Use at your own risk!** Enabling this option can cause layout thrashing by measuring\n   * the drawers on every change detection cycle. Can be configured globally via the\n   * `MAT_DRAWER_DEFAULT_AUTOSIZE` token.\n   */\n  @Input()\n  get autosize(): boolean {\n    return this._autosize;\n  }\n  set autosize(value: BooleanInput) {\n    this._autosize = coerceBooleanProperty(value);\n  }\n  private _autosize = inject(MAT_DRAWER_DEFAULT_AUTOSIZE);\n\n  /**\n   * Whether the drawer container should have a backdrop while one of the sidenavs is open.\n   * If explicitly set to `true`, the backdrop will be enabled for drawers in the `side`\n   * mode as well.\n   */\n  @Input()\n  get hasBackdrop(): boolean {\n    return this._drawerHasBackdrop(this._start) || this._drawerHasBackdrop(this._end);\n  }\n  set hasBackdrop(value: BooleanInput) {\n    this._backdropOverride = value == null ? null : coerceBooleanProperty(value);\n  }\n  _backdropOverride: boolean | null;\n\n  /** Event emitted when the drawer backdrop is clicked. */\n  @Output() readonly backdropClick: EventEmitter<void> = new EventEmitter<void>();\n\n  /** The drawer at the start/end position, independent of direction. */\n  private _start: MatDrawer | null;\n  private _end: MatDrawer | null;\n\n  /**\n   * The drawer at the left/right. When direction changes, these will change as well.\n   * They're used as aliases for the above to set the left/right style properly.\n   * In LTR, _left == _start and _right == _end.\n   * In RTL, _left == _end and _right == _start.\n   */\n  private _left: MatDrawer | null;\n  private _right: MatDrawer | null;\n\n  /** Emits when the component is destroyed. */\n  private readonly _destroyed = new Subject<void>();\n\n  /** Emits on every ngDoCheck. Used for debouncing reflows. */\n  private readonly _doCheckSubject = new Subject<void>();\n\n  /**\n   * Margins to be applied to the content. These are used to push / shrink the drawer content when a\n   * drawer is open. We use margin rather than transform even for push mode because transform breaks\n   * fixed position elements inside of the transformed element.\n   */\n  _contentMargins: {left: number | null; right: number | null} = {left: null, right: null};\n\n  readonly _contentMarginChanges = new Subject<{left: number | null; right: number | null}>();\n\n  /** Reference to the CdkScrollable instance that wraps the scrollable content. */\n  get scrollable(): CdkScrollable {\n    return this._userContent || this._content;\n  }\n\n  private _injector = inject(Injector);\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const platform = inject(Platform);\n    const viewportRuler = inject(ViewportRuler);\n\n    // If a `Dir` directive exists up the tree, listen direction changes\n    // and update the left/right properties to point to the proper start/end.\n    this._dir?.change.pipe(takeUntil(this._destroyed)).subscribe(() => {\n      this._validateDrawers();\n      this.updateContentMargins();\n    });\n\n    // Since the minimum width of the sidenav depends on the viewport width,\n    // we need to recompute the margins if the viewport changes.\n    viewportRuler\n      .change()\n      .pipe(takeUntil(this._destroyed))\n      .subscribe(() => this.updateContentMargins());\n\n    if (!this._animationDisabled && platform.isBrowser) {\n      this._ngZone.runOutsideAngular(() => {\n        // Enable the animations after a delay in order to skip\n        // the initial transition if a drawer is open by default.\n        setTimeout(() => {\n          this._element.nativeElement.classList.add('mat-drawer-transition');\n          this._transitionsEnabled = true;\n        }, 200);\n      });\n    }\n  }\n\n  ngAfterContentInit() {\n    this._allDrawers.changes\n      .pipe(startWith(this._allDrawers), takeUntil(this._destroyed))\n      .subscribe((drawer: QueryList<MatDrawer>) => {\n        this._drawers.reset(drawer.filter(item => !item._container || item._container === this));\n        this._drawers.notifyOnChanges();\n      });\n\n    this._drawers.changes.pipe(startWith(null)).subscribe(() => {\n      this._validateDrawers();\n\n      this._drawers.forEach((drawer: MatDrawer) => {\n        this._watchDrawerToggle(drawer);\n        this._watchDrawerPosition(drawer);\n        this._watchDrawerMode(drawer);\n      });\n\n      if (\n        !this._drawers.length ||\n        this._isDrawerOpen(this._start) ||\n        this._isDrawerOpen(this._end)\n      ) {\n        this.updateContentMargins();\n      }\n\n      this._changeDetectorRef.markForCheck();\n    });\n\n    // Avoid hitting the NgZone through the debounce timeout.\n    this._ngZone.runOutsideAngular(() => {\n      this._doCheckSubject\n        .pipe(\n          debounceTime(10), // Arbitrary debounce time, less than a frame at 60fps\n          takeUntil(this._destroyed),\n        )\n        .subscribe(() => this.updateContentMargins());\n    });\n  }\n\n  ngOnDestroy() {\n    this._contentMarginChanges.complete();\n    this._doCheckSubject.complete();\n    this._drawers.destroy();\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n\n  /** Calls `open` of both start and end drawers */\n  open(): void {\n    this._drawers.forEach(drawer => drawer.open());\n  }\n\n  /** Calls `close` of both start and end drawers */\n  close(): void {\n    this._drawers.forEach(drawer => drawer.close());\n  }\n\n  /**\n   * Recalculates and updates the inline styles for the content. Note that this should be used\n   * sparingly, because it causes a reflow.\n   */\n  updateContentMargins() {\n    // 1. For drawers in `over` mode, they don't affect the content.\n    // 2. For drawers in `side` mode they should shrink the content. We do this by adding to the\n    //    left margin (for left drawer) or right margin (for right the drawer).\n    // 3. For drawers in `push` mode the should shift the content without resizing it. We do this by\n    //    adding to the left or right margin and simultaneously subtracting the same amount of\n    //    margin from the other side.\n    let left = 0;\n    let right = 0;\n\n    if (this._left && this._left.opened) {\n      if (this._left.mode == 'side') {\n        left += this._left._getWidth();\n      } else if (this._left.mode == 'push') {\n        const width = this._left._getWidth();\n        left += width;\n        right -= width;\n      }\n    }\n\n    if (this._right && this._right.opened) {\n      if (this._right.mode == 'side') {\n        right += this._right._getWidth();\n      } else if (this._right.mode == 'push') {\n        const width = this._right._getWidth();\n        right += width;\n        left -= width;\n      }\n    }\n\n    // If either `right` or `left` is zero, don't set a style to the element. This\n    // allows users to specify a custom size via CSS class in SSR scenarios where the\n    // measured widths will always be zero. Note that we reset to `null` here, rather\n    // than below, in order to ensure that the types in the `if` below are consistent.\n    left = left || null!;\n    right = right || null!;\n\n    if (left !== this._contentMargins.left || right !== this._contentMargins.right) {\n      this._contentMargins = {left, right};\n\n      // Pull back into the NgZone since in some cases we could be outside. We need to be careful\n      // to do it only when something changed, otherwise we can end up hitting the zone too often.\n      this._ngZone.run(() => this._contentMarginChanges.next(this._contentMargins));\n    }\n  }\n\n  ngDoCheck() {\n    // If users opted into autosizing, do a check every change detection cycle.\n    if (this._autosize && this._isPushed()) {\n      // Run outside the NgZone, otherwise the debouncer will throw us into an infinite loop.\n      this._ngZone.runOutsideAngular(() => this._doCheckSubject.next());\n    }\n  }\n\n  /**\n   * Subscribes to drawer events in order to set a class on the main container element when the\n   * drawer is open and the backdrop is visible. This ensures any overflow on the container element\n   * is properly hidden.\n   */\n  private _watchDrawerToggle(drawer: MatDrawer): void {\n    drawer._animationStarted.pipe(takeUntil(this._drawers.changes)).subscribe(() => {\n      this.updateContentMargins();\n      this._changeDetectorRef.markForCheck();\n    });\n\n    if (drawer.mode !== 'side') {\n      drawer.openedChange\n        .pipe(takeUntil(this._drawers.changes))\n        .subscribe(() => this._setContainerClass(drawer.opened));\n    }\n  }\n\n  /**\n   * Subscribes to drawer onPositionChanged event in order to\n   * re-validate drawers when the position changes.\n   */\n  private _watchDrawerPosition(drawer: MatDrawer): void {\n    // NOTE: We need to wait for the microtask queue to be empty before validating,\n    // since both drawers may be swapping positions at the same time.\n    drawer.onPositionChanged.pipe(takeUntil(this._drawers.changes)).subscribe(() => {\n      afterNextRender({read: () => this._validateDrawers()}, {injector: this._injector});\n    });\n  }\n\n  /** Subscribes to changes in drawer mode so we can run change detection. */\n  private _watchDrawerMode(drawer: MatDrawer): void {\n    drawer._modeChanged\n      .pipe(takeUntil(merge(this._drawers.changes, this._destroyed)))\n      .subscribe(() => {\n        this.updateContentMargins();\n        this._changeDetectorRef.markForCheck();\n      });\n  }\n\n  /** Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element. */\n  private _setContainerClass(isAdd: boolean): void {\n    const classList = this._element.nativeElement.classList;\n    const className = 'mat-drawer-container-has-open';\n\n    if (isAdd) {\n      classList.add(className);\n    } else {\n      classList.remove(className);\n    }\n  }\n\n  /** Validate the state of the drawer children components. */\n  private _validateDrawers() {\n    this._start = this._end = null;\n\n    // Ensure that we have at most one start and one end drawer.\n    this._drawers.forEach(drawer => {\n      if (drawer.position == 'end') {\n        if (this._end != null && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n          throwMatDuplicatedDrawerError('end');\n        }\n        this._end = drawer;\n      } else {\n        if (this._start != null && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n          throwMatDuplicatedDrawerError('start');\n        }\n        this._start = drawer;\n      }\n    });\n\n    this._right = this._left = null;\n\n    // Detect if we're LTR or RTL.\n    if (this._dir && this._dir.value === 'rtl') {\n      this._left = this._end;\n      this._right = this._start;\n    } else {\n      this._left = this._start;\n      this._right = this._end;\n    }\n  }\n\n  /** Whether the container is being pushed to the side by one of the drawers. */\n  private _isPushed() {\n    return (\n      (this._isDrawerOpen(this._start) && this._start.mode != 'over') ||\n      (this._isDrawerOpen(this._end) && this._end.mode != 'over')\n    );\n  }\n\n  _onBackdropClicked() {\n    this.backdropClick.emit();\n    this._closeModalDrawersViaBackdrop();\n  }\n\n  _closeModalDrawersViaBackdrop() {\n    // Close all open drawers where closing is not disabled and the mode is not `side`.\n    [this._start, this._end]\n      .filter(drawer => drawer && !drawer.disableClose && this._drawerHasBackdrop(drawer))\n      .forEach(drawer => drawer!._closeViaBackdropClick());\n  }\n\n  _isShowingBackdrop(): boolean {\n    return (\n      (this._isDrawerOpen(this._start) && this._drawerHasBackdrop(this._start)) ||\n      (this._isDrawerOpen(this._end) && this._drawerHasBackdrop(this._end))\n    );\n  }\n\n  private _isDrawerOpen(drawer: MatDrawer | null): drawer is MatDrawer {\n    return drawer != null && drawer.opened;\n  }\n\n  // Whether argument drawer should have a backdrop when it opens\n  private _drawerHasBackdrop(drawer: MatDrawer | null) {\n    if (this._backdropOverride == null) {\n      return !!drawer && drawer.mode !== 'side';\n    }\n\n    return this._backdropOverride;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  ContentChild,\n  ContentChildren,\n  Input,\n  ViewEncapsulation,\n  QueryList,\n} from '@angular/core';\nimport {MatDrawer, MatDrawerContainer, MatDrawerContent, MAT_DRAWER_CONTAINER} from './drawer';\nimport {\n  BooleanInput,\n  coerceBooleanProperty,\n  coerceNumberProperty,\n  NumberInput,\n} from '@angular/cdk/coercion';\nimport {CdkScrollable} from '@angular/cdk/scrolling';\n\n@Component({\n  selector: 'mat-sidenav-content',\n  template: '<ng-content></ng-content>',\n  host: {\n    'class': 'mat-drawer-content mat-sidenav-content',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  providers: [\n    {\n      provide: CdkScrollable,\n      useExisting: MatSidenavContent,\n    },\n  ],\n})\nexport class MatSidenavContent extends MatDrawerContent {}\n\n@Component({\n  selector: 'mat-sidenav',\n  exportAs: 'matSidenav',\n  templateUrl: 'drawer.html',\n  host: {\n    'class': 'mat-drawer mat-sidenav',\n    // The sidenav container should not be focused on when used in side mode. See b/286459024 for\n    // reference. Updates tabIndex of drawer/container to default to null if in side mode.\n    '[attr.tabIndex]': '(mode !== \"side\") ? \"-1\" : null',\n    // must prevent the browser from aligning text based on value\n    '[attr.align]': 'null',\n    '[class.mat-drawer-end]': 'position === \"end\"',\n    '[class.mat-drawer-over]': 'mode === \"over\"',\n    '[class.mat-drawer-push]': 'mode === \"push\"',\n    '[class.mat-drawer-side]': 'mode === \"side\"',\n    '[class.mat-sidenav-fixed]': 'fixedInViewport',\n    '[style.top.px]': 'fixedInViewport ? fixedTopGap : null',\n    '[style.bottom.px]': 'fixedInViewport ? fixedBottomGap : null',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  imports: [CdkScrollable],\n  providers: [{provide: MatDrawer, useExisting: MatSidenav}],\n})\nexport class MatSidenav extends MatDrawer {\n  /** Whether the sidenav is fixed in the viewport. */\n  @Input()\n  get fixedInViewport(): boolean {\n    return this._fixedInViewport;\n  }\n  set fixedInViewport(value: BooleanInput) {\n    this._fixedInViewport = coerceBooleanProperty(value);\n  }\n  private _fixedInViewport = false;\n\n  /**\n   * The gap between the top of the sidenav and the top of the viewport when the sidenav is in fixed\n   * mode.\n   */\n  @Input()\n  get fixedTopGap(): number {\n    return this._fixedTopGap;\n  }\n  set fixedTopGap(value: NumberInput) {\n    this._fixedTopGap = coerceNumberProperty(value);\n  }\n  private _fixedTopGap = 0;\n\n  /**\n   * The gap between the bottom of the sidenav and the bottom of the viewport when the sidenav is in\n   * fixed mode.\n   */\n  @Input()\n  get fixedBottomGap(): number {\n    return this._fixedBottomGap;\n  }\n  set fixedBottomGap(value: NumberInput) {\n    this._fixedBottomGap = coerceNumberProperty(value);\n  }\n  private _fixedBottomGap = 0;\n}\n\n@Component({\n  selector: 'mat-sidenav-container',\n  exportAs: 'matSidenavContainer',\n  templateUrl: 'sidenav-container.html',\n  styleUrl: 'drawer.css',\n  host: {\n    'class': 'mat-drawer-container mat-sidenav-container',\n    '[class.mat-drawer-container-explicit-backdrop]': '_backdropOverride',\n  },\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  providers: [\n    {\n      provide: MAT_DRAWER_CONTAINER,\n      useExisting: MatSidenavContainer,\n    },\n    {\n      provide: MatDrawerContainer,\n      useExisting: MatSidenavContainer,\n    },\n  ],\n  imports: [MatSidenavContent],\n})\nexport class MatSidenavContainer extends MatDrawerContainer {\n  @ContentChildren(MatSidenav, {\n    // We need to use `descendants: true`, because Ivy will no longer match\n    // indirect descendants if it's left as false.\n    descendants: true,\n  })\n  // We need an initializer here to avoid a TS error.\n  override _allDrawers: QueryList<MatSidenav> = undefined!;\n\n  // We need an initializer here to avoid a TS error.\n  @ContentChild(MatSidenavContent) override _content: MatSidenavContent = undefined!;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {BidiModule} from '@angular/cdk/bidi';\nimport {CdkScrollableModule} from '@angular/cdk/scrolling';\nimport {NgModule} from '@angular/core';\nimport {MatDrawer, MatDrawerContainer, MatDrawerContent} from './drawer';\nimport {MatSidenav, MatSidenavContainer, MatSidenavContent} from './sidenav';\n\n@NgModule({\n  imports: [\n    CdkScrollableModule,\n    MatDrawer,\n    MatDrawerContainer,\n    MatDrawerContent,\n    MatSidenav,\n    MatSidenavContainer,\n    MatSidenavContent,\n  ],\n  exports: [\n    BidiModule,\n    CdkScrollableModule,\n    MatDrawer,\n    MatDrawerContainer,\n    MatDrawerContent,\n    MatSidenav,\n    MatSidenavContainer,\n    MatSidenavContent,\n  ],\n})\nexport class MatSidenavModule {}\n"],"names":["throwMatDuplicatedDrawerError","position","Error","MAT_DRAWER_CONTAINER","InjectionToken","MatDrawerContent","CdkScrollable","_platform","inject","Platform","elementRef","ElementRef","scrollDispatcher","ScrollDispatcher","ngZone","NgZone","ngAfterContentInit","_container","_contentMarginChanges","subscribe","_changeDetectorRef","markForCheck","_shouldBeHidden","start","end","mode","opened","ɵfac","i0","ɵɵngDeclareFactory","minVersion","version","ngImport","type","deps","target","ɵɵFactoryTarget","Component","ɵɵngDeclareComponent","isStandalone","selector","host","properties","classAttribute","providers","provide","useExisting","decorators","template","changeDetection","ChangeDetectionStrategy","OnPush","ctorParameters","_interactivityChecker","InteractivityChecker","_doc","DOCUMENT","optional","_focusTrap","_isAttached","value","_position","onPositionChanged","emit","_mode","_updateFocusTrapState","disableClose","_disableClose","autoFocus","coerceBooleanProperty","_opened","signal","ngDevMode","debugName","Subject","EventEmitter","_openedStream","openedChange","pipe","filter","o","map","openedStart","_animationStarted","mapTo","undefined","_closedStream","closedStart","_content","_modeChanged","ChangeDetectorRef","_elementFocusedBeforeDrawerWasOpened","activeElement","_takeFocus","_isFocusWithinDrawer","_ngZone","runOutsideAngular","fromEvent","element","event","run","close","stopPropagation","preventDefault","_eventCleanups","_renderer","listen","_handleTransitionEvent","_animationEnd","_forceFocus","options","cleanupMousedown","removeAttribute","callback","elementToFocus","afterNextRender","hasMovedFocus","focusInitialElement","focus","injector","_injector","_focusByCssSelector","_restoreFocus","focusOrigin","nativeElement","blur","activeEl","_elementRef","contains","ngAfterViewInit","_focusTrapFactory","create","complete","_destroyed","next","_closeViaBackdropClick","_setOpen","isOpen","_openedVia","restoreFocus","setTimeout","classList","toggle","Promise","resolve","take","open","_setIsAnimating","isAnimating","_getWidth","offsetWidth","enabled","hasBackdrop","parent","parentNode","newPosition","_anchor","createComment","insertBefore","appendChild","MatDrawer","inputs","outputs","viewQueries","propertyName","first","predicate","descendants","exportAs","dependencies","kind","encapsulation","ViewEncapsulation","None","imports","Input","Output","args","_dir","Directionality","_transitionsEnabled","_drawers","QueryList","_userContent","_start","_end","_drawerHasBackdrop","_left","_contentMargins","left","right","Injector","platform","_validateDrawers","updateContentMargins","viewportRuler","_element","add","changes","_allDrawers","takeUntil","drawer","reset","item","notifyOnChanges","startWith","forEach","_watchDrawerToggle","_watchDrawerPosition","_watchDrawerMode","length","_isDrawerOpen","debounceTime","ngOnDestroy","destroy","styles","propDecorators","ContentChildren","backdropClick","ɵcmp","MatSidenavContent","usesInheritance","isInline","fixedTopGap","_fixedTopGap","MatSidenav","fixedInViewport","fixedBottomGap","MatSidenavContainer","MatDrawerContainer","MatSidenavModule","ɵmod","ɵɵngDeclareNgModule","CdkScrollableModule"],"mappings":"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"}