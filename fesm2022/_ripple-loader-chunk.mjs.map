{"version":3,"file":"_ripple-loader-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/core/private/ripple-loader.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Injectable,\n  Injector,\n  NgZone,\n  OnDestroy,\n  RendererFactory2,\n  inject,\n  DOCUMENT,\n} from '@angular/core';\nimport {\n  MAT_RIPPLE_GLOBAL_OPTIONS,\n  RippleRenderer,\n  RippleTarget,\n  defaultRippleAnimationConfig,\n} from '../ripple';\nimport {Platform, _getEventTarget} from '@angular/cdk/platform';\nimport {_CdkPrivateStyleLoader} from '@angular/cdk/private';\nimport {_animationsDisabled} from '../animation/animation';\n\n/** The options for the MatRippleLoader's event listeners. */\nconst eventListenerOptions = {capture: true};\n\n/**\n * The events that should trigger the initialization of the ripple.\n * Note that we use `mousedown`, rather than `click`, for mouse devices because\n * we can't rely on `mouseenter` in the shadow DOM and `click` happens too late.\n */\nconst rippleInteractionEvents = ['focus', 'mousedown', 'mouseenter', 'touchstart'];\n\n/** The attribute attached to a component whose ripple has not yet been initialized. */\nconst matRippleUninitialized = 'mat-ripple-loader-uninitialized';\n\n/** Additional classes that should be added to the ripple when it is rendered. */\nconst matRippleClassName = 'mat-ripple-loader-class-name';\n\n/** Whether the ripple should be centered. */\nconst matRippleCentered = 'mat-ripple-loader-centered';\n\n/** Whether the ripple should be disabled. */\nconst matRippleDisabled = 'mat-ripple-loader-disabled';\n\n/**\n * Handles attaching ripples on demand.\n *\n * This service allows us to avoid eagerly creating & attaching MatRipples.\n * It works by creating & attaching a ripple only when a component is first interacted with.\n *\n * @docs-private\n */\n@Injectable({providedIn: 'root'})\nexport class MatRippleLoader implements OnDestroy {\n  private _document = inject(DOCUMENT);\n  private _animationsDisabled = _animationsDisabled();\n  private _globalRippleOptions = inject(MAT_RIPPLE_GLOBAL_OPTIONS, {optional: true});\n  private _platform = inject(Platform);\n  private _ngZone = inject(NgZone);\n  private _injector = inject(Injector);\n  private _eventCleanups: (() => void)[];\n  private _hosts = new Map<\n    HTMLElement,\n    {renderer: RippleRenderer; target: RippleTarget; hasSetUpEvents: boolean}\n  >();\n\n  constructor() {\n    const renderer = inject(RendererFactory2).createRenderer(null, null);\n\n    this._eventCleanups = this._ngZone.runOutsideAngular(() =>\n      rippleInteractionEvents.map(name =>\n        renderer.listen(this._document, name, this._onInteraction, eventListenerOptions),\n      ),\n    );\n  }\n\n  ngOnDestroy(): void {\n    const hosts = this._hosts.keys();\n\n    for (const host of hosts) {\n      this.destroyRipple(host);\n    }\n\n    this._eventCleanups.forEach(cleanup => cleanup());\n  }\n\n  /**\n   * Configures the ripple that will be rendered by the ripple loader.\n   *\n   * Stores the given information about how the ripple should be configured on the host\n   * element so that it can later be retrived & used when the ripple is actually created.\n   */\n  configureRipple(\n    host: HTMLElement,\n    config: {\n      className?: string;\n      centered?: boolean;\n      disabled?: boolean;\n    },\n  ): void {\n    // Indicates that the ripple has not yet been rendered for this component.\n    host.setAttribute(matRippleUninitialized, this._globalRippleOptions?.namespace ?? '');\n\n    // Store the additional class name(s) that should be added to the ripple element.\n    if (config.className || !host.hasAttribute(matRippleClassName)) {\n      host.setAttribute(matRippleClassName, config.className || '');\n    }\n\n    // Store whether the ripple should be centered.\n    if (config.centered) {\n      host.setAttribute(matRippleCentered, '');\n    }\n\n    if (config.disabled) {\n      host.setAttribute(matRippleDisabled, '');\n    }\n  }\n\n  /** Sets the disabled state on the ripple instance corresponding to the given host element. */\n  setDisabled(host: HTMLElement, disabled: boolean): void {\n    const ripple = this._hosts.get(host);\n\n    // If the ripple has already been instantiated, just disable it.\n    if (ripple) {\n      ripple.target.rippleDisabled = disabled;\n\n      if (!disabled && !ripple.hasSetUpEvents) {\n        ripple.hasSetUpEvents = true;\n        ripple.renderer.setupTriggerEvents(host);\n      }\n    } else if (disabled) {\n      // Otherwise, set an attribute so we know what the\n      // disabled state should be when the ripple is initialized.\n      host.setAttribute(matRippleDisabled, '');\n    } else {\n      host.removeAttribute(matRippleDisabled);\n    }\n  }\n\n  /**\n   * Handles creating and attaching component internals\n   * when a component is initially interacted with.\n   */\n  private _onInteraction = (event: Event) => {\n    const eventTarget = _getEventTarget(event);\n\n    if (eventTarget instanceof HTMLElement) {\n      // TODO(wagnermaciel): Consider batching these events to improve runtime performance.\n      const element = eventTarget.closest(\n        `[${matRippleUninitialized}=\"${this._globalRippleOptions?.namespace ?? ''}\"]`,\n      );\n\n      if (element) {\n        this._createRipple(element as HTMLElement);\n      }\n    }\n  };\n\n  /** Creates a MatRipple and appends it to the given element. */\n  private _createRipple(host: HTMLElement): void {\n    if (!this._document || this._hosts.has(host)) {\n      return;\n    }\n\n    // Create the ripple element.\n    host.querySelector('.mat-ripple')?.remove();\n    const rippleEl = this._document.createElement('span');\n    rippleEl.classList.add('mat-ripple', host.getAttribute(matRippleClassName)!);\n    host.append(rippleEl);\n\n    const globalOptions = this._globalRippleOptions;\n    const enterDuration = this._animationsDisabled\n      ? 0\n      : (globalOptions?.animation?.enterDuration ?? defaultRippleAnimationConfig.enterDuration);\n    const exitDuration = this._animationsDisabled\n      ? 0\n      : (globalOptions?.animation?.exitDuration ?? defaultRippleAnimationConfig.exitDuration);\n    const target: RippleTarget = {\n      rippleDisabled:\n        this._animationsDisabled || globalOptions?.disabled || host.hasAttribute(matRippleDisabled),\n      rippleConfig: {\n        centered: host.hasAttribute(matRippleCentered),\n        terminateOnPointerUp: globalOptions?.terminateOnPointerUp,\n        animation: {\n          enterDuration,\n          exitDuration,\n        },\n      },\n    };\n\n    const renderer = new RippleRenderer(\n      target,\n      this._ngZone,\n      rippleEl,\n      this._platform,\n      this._injector,\n    );\n    const hasSetUpEvents = !target.rippleDisabled;\n\n    if (hasSetUpEvents) {\n      renderer.setupTriggerEvents(host);\n    }\n\n    this._hosts.set(host, {\n      target,\n      renderer,\n      hasSetUpEvents,\n    });\n\n    host.removeAttribute(matRippleUninitialized);\n  }\n\n  destroyRipple(host: HTMLElement): void {\n    const ripple = this._hosts.get(host);\n\n    if (ripple) {\n      ripple.renderer._removeTriggerEvents();\n      this._hosts.delete(host);\n    }\n  }\n}\n"],"names":["eventListenerOptions","capture","matRippleUninitialized","matRippleCentered","matRippleDisabled","_hosts","Map","renderer","inject","RendererFactory2","createRenderer","_eventCleanups","_ngZone","runOutsideAngular","rippleInteractionEvents","map","name","listen","_document","_onInteraction","ngOnDestroy","hosts","keys","host","forEach","cleanup","config","centered","setAttribute","disabled","setDisabled","ripple","get","target","rippleDisabled","hasSetUpEvents","removeAttribute","eventTarget","_getEventTarget","event","HTMLElement","_createRipple","element"],"mappings":";;;;;;MA4BAA,oBAAA,GAAA;EAAAC,OAAA,EAAA;AAAA,CAAA;;AA+BU,MAAAC,sBAAA,GAAA,iCAAA;;MAIAC,iBAAA,GAAA,4BAAA;AAGA,MAAAC,iBAAA,GAAA,4BAAA;;;;;;;;;;gBA0C2E;EACjFC,MAAA,GAAW,IAASC,GAAA,EAAA;;IAEpB,MAAAC,QAAA,GAAAC,MAAA,CAAAC,gBAAA,CAAAC,CAAAA,cAAA,OAAA,IAAA,CAAA;IAE+C,IAAAC,CAAAA,cAAA,OAAA,CAAAC,OAAA,CAAAC,iBAAA,CAAA,MAAAC,uBAAA,CAAAC,GAAA,CAAAC,IAAA,IAAAT,QAAA,CAAAU,MAAA,CAAAC,IAAAA,CAAAA,SAAA,EAAAF,IAAA,EAAA,IAAA,CAAAG,cAAA,EAAAnB,oBAAA,CAAA,CAAA,CAAA;AAC/C;AACEoB,EAAAA,WAAiBA,GAAA;AACnB,IAAA,MAAAC,KAAA,GAAA,IAAA,CAAAhB,MAAA,CAAAiB,IAAA,EAAA;IAEA,KAAW,MAAQC,IAGrB,IAAAF,KAAA,EAAA;;;QAOE,CAAIV,cAAQ,CAAAa,OAAA,CAAAC,OAAA,IAAAA,OAAA,EAAA,CAAA;;;;;;AAuBZ;IAaM,IAAAC,MAAA,CAAAC,QAAA,EAAA;AACNJ,MAAAA,IAAA,CAAAK,YAAU,CAAAzB,iBAAA,EAA4B,EAAA,CAAA;;QAItCuB,MAA6B,CAAAG,QAAA,EAAA;UACzB,CAAAD,gCAA+B,EAAA,CAAA;;;aAMnCE,CAAAP,IAAA,EAAAM,QAAmB,EAAA;AACjB,IAAA,MAAAE,MAAA,GAAA1B,IAAAA,CAAAA,MAAA,CAAA2B,GAAA,CAAAT,IAAA,CAAA;QAGAQ,MAAA,EAAA;AACAA,MAAAA,MAAA,CAAAE,MAAA,CAAAC,cAAA,GAAAL,QAAA;AACF,MAAA,IAAA,CAAAA,QAAA,IAAA,CAAAE,MAAA,CAAAI,cAAA,EAAA;AAGEJ,QAAAA,MAAA,CAAAI,cAAA,GAAA,IAAA;AACEJ,QAAAA,MAA2B,CAAAxB;;;UAS/B,CAAAqB,YAAM,CAAAxB,iBAAe,EAAA,EAAA,CAAA;;MAUnBmB,IAAA,CAAAa,eAAA,CAAAhC,iBAAA,CAAA;;;4BAMc;AACf,IAAA,MAAAiC,WAAA,GAAAC,eAAA,CAAAC,KAAA,CAAA;IAED,IAAAF,WAAA,YAAAG,WAAA,EAAA;;;QAOE,IAAAC,CAAAA,aAAA,CAAAC,OAAA,CAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}