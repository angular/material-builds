{"version":3,"file":"tree-testing.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/tree/testing/node-harness.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/tree/testing/tree-harness.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ComponentHarnessConstructor,\n  ContentContainerComponentHarness,\n  HarnessPredicate,\n} from '@angular/cdk/testing';\nimport {TreeNodeHarnessFilters} from './tree-harness-filters';\nimport {coerceBooleanProperty, coerceNumberProperty} from '@angular/cdk/coercion';\n\n/** Harness for interacting with a standard Angular Material tree node. */\nexport class MatTreeNodeHarness extends ContentContainerComponentHarness<string> {\n  /** The selector of the host element of a `MatTreeNode` instance. */\n  static hostSelector = '.mat-tree-node, .mat-nested-tree-node';\n\n  _toggle = this.locatorForOptional('[matTreeNodeToggle]');\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a tree node with specific attributes.\n   * @param options Options for narrowing the search\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with(options: TreeNodeHarnessFilters = {}): HarnessPredicate<MatTreeNodeHarness> {\n    return getNodePredicate(MatTreeNodeHarness, options);\n  }\n\n  /** Whether the tree node is expanded. */\n  async isExpanded(): Promise<boolean> {\n    return coerceBooleanProperty(await (await this.host()).getAttribute('aria-expanded'));\n  }\n\n  /** Whether the tree node is expandable. */\n  async isExpandable(): Promise<boolean> {\n    return (await (await this.host()).getAttribute('aria-expanded')) !== null;\n  }\n\n  /** Whether the tree node is disabled. */\n  async isDisabled(): Promise<boolean> {\n    return coerceBooleanProperty(await (await this.host()).getProperty('aria-disabled'));\n  }\n\n  /** Gets the level of the tree node. Note that this gets the aria-level and is 1 indexed. */\n  async getLevel(): Promise<number> {\n    return coerceNumberProperty(await (await this.host()).getAttribute('aria-level'));\n  }\n\n  /** Gets the tree node's text. */\n  async getText(): Promise<string> {\n    return (await this.host()).text({exclude: '.mat-tree-node, .mat-nested-tree-node, button'});\n  }\n\n  /** Toggles node between expanded/collapsed. Only works when node is not disabled. */\n  async toggle(): Promise<void> {\n    const toggle = await this._toggle();\n    if (toggle) {\n      return toggle.click();\n    }\n  }\n\n  /** Expands the node if it is collapsed. Only works when node is not disabled. */\n  async expand(): Promise<void> {\n    if (!(await this.isExpanded())) {\n      await this.toggle();\n    }\n  }\n\n  /** Collapses the node if it is expanded. Only works when node is not disabled. */\n  async collapse(): Promise<void> {\n    if (await this.isExpanded()) {\n      await this.toggle();\n    }\n  }\n}\n\nfunction getNodePredicate<T extends MatTreeNodeHarness>(\n  type: ComponentHarnessConstructor<T>,\n  options: TreeNodeHarnessFilters,\n): HarnessPredicate<T> {\n  return new HarnessPredicate(type, options)\n    .addOption('text', options.text, (harness, text) =>\n      HarnessPredicate.stringMatches(harness.getText(), text),\n    )\n    .addOption(\n      'disabled',\n      options.disabled,\n      async (harness, disabled) => (await harness.isDisabled()) === disabled,\n    )\n    .addOption(\n      'expanded',\n      options.expanded,\n      async (harness, expanded) => (await harness.isExpanded()) === expanded,\n    )\n    .addOption(\n      'level',\n      options.level,\n      async (harness, level) => (await harness.getLevel()) === level,\n    );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ComponentHarness, HarnessPredicate, parallel} from '@angular/cdk/testing';\nimport {MatTreeNodeHarness} from './node-harness';\nimport {TreeHarnessFilters, TreeNodeHarnessFilters} from './tree-harness-filters';\n\nexport type TextTree = {\n  text?: string;\n  children?: TextTree[];\n};\n\n/** Harness for interacting with a standard mat-tree in tests. */\nexport class MatTreeHarness extends ComponentHarness {\n  /** The selector for the host element of a `MatTableHarness` instance. */\n  static hostSelector = '.mat-tree';\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a tree with specific attributes.\n   * @param options Options for narrowing the search\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with(options: TreeHarnessFilters = {}): HarnessPredicate<MatTreeHarness> {\n    return new HarnessPredicate(MatTreeHarness, options);\n  }\n\n  /** Gets all of the nodes in the tree. */\n  async getNodes(filter: TreeNodeHarnessFilters = {}): Promise<MatTreeNodeHarness[]> {\n    return this.locatorForAll(MatTreeNodeHarness.with(filter))();\n  }\n\n  /**\n   * Gets an object representation for the visible tree structure\n   * If a node is under an unexpanded node it will not be included.\n   * Eg.\n   * Tree (all nodes expanded):\n   * `\n   * <mat-tree>\n   *   <mat-tree-node>Node 1<mat-tree-node>\n   *   <mat-nested-tree-node>\n   *     Node 2\n   *     <mat-nested-tree-node>\n   *       Node 2.1\n   *       <mat-tree-node>\n   *         Node 2.1.1\n   *       <mat-tree-node>\n   *     <mat-nested-tree-node>\n   *     <mat-tree-node>\n   *       Node 2.2\n   *     <mat-tree-node>\n   *   <mat-nested-tree-node>\n   * </mat-tree>`\n   *\n   * Tree structure:\n   * {\n   *  children: [\n   *    {\n   *      text: 'Node 1',\n   *      children: [\n   *        {\n   *          text: 'Node 2',\n   *          children: [\n   *            {\n   *              text: 'Node 2.1',\n   *              children: [{text: 'Node 2.1.1'}]\n   *            },\n   *            {text: 'Node 2.2'}\n   *          ]\n   *        }\n   *      ]\n   *    }\n   *  ]\n   * };\n   */\n  async getTreeStructure(): Promise<TextTree> {\n    const nodes = await this.getNodes();\n    const nodeInformation = await parallel(() =>\n      nodes.map(node => {\n        return parallel(() => [node.getLevel(), node.getText(), node.isExpanded()]);\n      }),\n    );\n    return this._getTreeStructure(nodeInformation, 1, true);\n  }\n\n  /**\n   * Recursively collect the structured text of the tree nodes.\n   * @param nodes A list of tree nodes\n   * @param level The level of nodes that are being accounted for during this iteration\n   * @param parentExpanded Whether the parent of the first node in param nodes is expanded\n   */\n  private _getTreeStructure(\n    nodes: [number, string, boolean][],\n    level: number,\n    parentExpanded: boolean,\n  ): TextTree {\n    const result: TextTree = {};\n    for (let i = 0; i < nodes.length; i++) {\n      const [nodeLevel, text, expanded] = nodes[i];\n      const nextNodeLevel = nodes[i + 1]?.[0] ?? -1;\n\n      // Return the accumulated value for the current level once we reach a shallower level node\n      if (nodeLevel < level) {\n        return result;\n      }\n      // Skip deeper level nodes during this iteration, they will be picked up in a later iteration\n      if (nodeLevel > level) {\n        continue;\n      }\n      // Only add to representation if it is visible (parent is expanded)\n      if (parentExpanded) {\n        // Collect the data under this node according to the following rules:\n        // 1. If the next node in the list is a sibling of the current node add it to the child list\n        // 2. If the next node is a child of the current node, get the sub-tree structure for the\n        //    child and add it under this node\n        // 3. If the next node has a shallower level, we've reached the end of the child nodes for\n        //    the current parent.\n        if (nextNodeLevel === level) {\n          this._addChildToNode(result, {text});\n        } else if (nextNodeLevel > level) {\n          let children = this._getTreeStructure(\n            nodes.slice(i + 1),\n            nextNodeLevel,\n            expanded,\n          )?.children;\n          let child = children ? {text, children} : {text};\n          this._addChildToNode(result, child);\n        } else {\n          this._addChildToNode(result, {text});\n          return result;\n        }\n      }\n    }\n    return result;\n  }\n\n  private _addChildToNode(result: TextTree, child: TextTree) {\n    result.children ? result.children.push(child) : (result.children = [child]);\n  }\n}\n"],"names":["_toggle","locatorForOptional","with","options","getNodePredicate","MatTreeNodeHarness","isExpandable","isDisabled","getLevel","getText","host","text","exclude","toggle","click","expand","isExpanded","level"],"mappings":";;;;;AAqBEA,EAAAA,OAAA,QAAAC,kBAAA,CAAA,qBAAA,CAAA;SAgB2CC,IAAAA,CAAAC,OAAA,GAAA,EAAA,EAAA;AAEzC,IAAA,OAAAC,gBAAc,CAAAC,kBAAgB,EAAAF,OAAiB,CAAA;;;;;AAU/CG,EAAAA,MAAAA,YAAAA,GAAA;;AAIF;AAEAC,EAAAA,MAAAA,UAAAA,GAAA;;AAIE;AAEEC,EAAAA,MAAAA,QAAAA,GAAA;;;eAMEC,GAAA;IACF,OAAAC,CAAAA,MAAAA,IAAAA,CAAAA,IAAA,IAAAC,IAAA,CAAA;MAAAC,OAAA,EAAA;AAAA,KAAA,CAAA;;AAKJC,EAAAA,MAAAA,MAAcA,GAAA;IACZ,MAAAA,MAAA,cAAAb,OAAA,EAAA;;MAGF,OAAAa,MAAA,CAAAC,KAAA,EAAA;;AAGF;cAQcC,GAAA;QAKA,EAAA,MAAA,IACR,CAAAC,UAAU,EAAA,CAAA,EAAA;YAIF,IAAA,CAAAH,MAAA,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACuBN,QAAA;AAQE;sBAEFI,KAAA,EAAA;;AAEE;wBAEJ,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}