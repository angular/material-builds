{"version":3,"file":"tree-testing.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/tree/testing/node-harness.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/tree/testing/tree-harness.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ComponentHarnessConstructor,\n  ContentContainerComponentHarness,\n  HarnessPredicate,\n} from '@angular/cdk/testing';\nimport {TreeNodeHarnessFilters} from './tree-harness-filters';\nimport {coerceBooleanProperty, coerceNumberProperty} from '@angular/cdk/coercion';\n\n/** Harness for interacting with a standard Angular Material tree node. */\nexport class MatTreeNodeHarness extends ContentContainerComponentHarness<string> {\n  /** The selector of the host element of a `MatTreeNode` instance. */\n  static hostSelector = '.mat-tree-node, .mat-nested-tree-node';\n\n  _toggle = this.locatorForOptional('[matTreeNodeToggle]');\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a tree node with specific attributes.\n   * @param options Options for narrowing the search\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with(options: TreeNodeHarnessFilters = {}): HarnessPredicate<MatTreeNodeHarness> {\n    return getNodePredicate(MatTreeNodeHarness, options);\n  }\n\n  /** Whether the tree node is expanded. */\n  async isExpanded(): Promise<boolean> {\n    return coerceBooleanProperty(await (await this.host()).getAttribute('aria-expanded'));\n  }\n\n  /** Whether the tree node is expandable. */\n  async isExpandable(): Promise<boolean> {\n    return (await (await this.host()).getAttribute('aria-expanded')) !== null;\n  }\n\n  /** Whether the tree node is disabled. */\n  async isDisabled(): Promise<boolean> {\n    return coerceBooleanProperty(await (await this.host()).getProperty('aria-disabled'));\n  }\n\n  /** Gets the level of the tree node. Note that this gets the aria-level and is 1 indexed. */\n  async getLevel(): Promise<number> {\n    return coerceNumberProperty(await (await this.host()).getAttribute('aria-level'));\n  }\n\n  /** Gets the tree node's text. */\n  async getText(): Promise<string> {\n    return (await this.host()).text({exclude: '.mat-tree-node, .mat-nested-tree-node, button'});\n  }\n\n  /** Toggles node between expanded/collapsed. Only works when node is not disabled. */\n  async toggle(): Promise<void> {\n    const toggle = await this._toggle();\n    if (toggle) {\n      return toggle.click();\n    }\n  }\n\n  /** Expands the node if it is collapsed. Only works when node is not disabled. */\n  async expand(): Promise<void> {\n    if (!(await this.isExpanded())) {\n      await this.toggle();\n    }\n  }\n\n  /** Collapses the node if it is expanded. Only works when node is not disabled. */\n  async collapse(): Promise<void> {\n    if (await this.isExpanded()) {\n      await this.toggle();\n    }\n  }\n}\n\nfunction getNodePredicate<T extends MatTreeNodeHarness>(\n  type: ComponentHarnessConstructor<T>,\n  options: TreeNodeHarnessFilters,\n): HarnessPredicate<T> {\n  return new HarnessPredicate(type, options)\n    .addOption('text', options.text, (harness, text) =>\n      HarnessPredicate.stringMatches(harness.getText(), text),\n    )\n    .addOption(\n      'disabled',\n      options.disabled,\n      async (harness, disabled) => (await harness.isDisabled()) === disabled,\n    )\n    .addOption(\n      'expanded',\n      options.expanded,\n      async (harness, expanded) => (await harness.isExpanded()) === expanded,\n    )\n    .addOption(\n      'level',\n      options.level,\n      async (harness, level) => (await harness.getLevel()) === level,\n    );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ComponentHarness, HarnessPredicate, parallel} from '@angular/cdk/testing';\nimport {MatTreeNodeHarness} from './node-harness';\nimport {TreeHarnessFilters, TreeNodeHarnessFilters} from './tree-harness-filters';\n\nexport type TextTree = {\n  text?: string;\n  children?: TextTree[];\n};\n\n/** Harness for interacting with a standard mat-tree in tests. */\nexport class MatTreeHarness extends ComponentHarness {\n  /** The selector for the host element of a `MatTableHarness` instance. */\n  static hostSelector = '.mat-tree';\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a tree with specific attributes.\n   * @param options Options for narrowing the search\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with(options: TreeHarnessFilters = {}): HarnessPredicate<MatTreeHarness> {\n    return new HarnessPredicate(MatTreeHarness, options);\n  }\n\n  /** Gets all of the nodes in the tree. */\n  async getNodes(filter: TreeNodeHarnessFilters = {}): Promise<MatTreeNodeHarness[]> {\n    return this.locatorForAll(MatTreeNodeHarness.with(filter))();\n  }\n\n  /**\n   * Gets an object representation for the visible tree structure\n   * If a node is under an unexpanded node it will not be included.\n   * Eg.\n   * Tree (all nodes expanded):\n   * `\n   * <mat-tree>\n   *   <mat-tree-node>Node 1<mat-tree-node>\n   *   <mat-nested-tree-node>\n   *     Node 2\n   *     <mat-nested-tree-node>\n   *       Node 2.1\n   *       <mat-tree-node>\n   *         Node 2.1.1\n   *       <mat-tree-node>\n   *     <mat-nested-tree-node>\n   *     <mat-tree-node>\n   *       Node 2.2\n   *     <mat-tree-node>\n   *   <mat-nested-tree-node>\n   * </mat-tree>`\n   *\n   * Tree structure:\n   * {\n   *  children: [\n   *    {\n   *      text: 'Node 1',\n   *      children: [\n   *        {\n   *          text: 'Node 2',\n   *          children: [\n   *            {\n   *              text: 'Node 2.1',\n   *              children: [{text: 'Node 2.1.1'}]\n   *            },\n   *            {text: 'Node 2.2'}\n   *          ]\n   *        }\n   *      ]\n   *    }\n   *  ]\n   * };\n   */\n  async getTreeStructure(): Promise<TextTree> {\n    const nodes = await this.getNodes();\n    const nodeInformation = await parallel(() =>\n      nodes.map(node => {\n        return parallel(() => [node.getLevel(), node.getText(), node.isExpanded()]);\n      }),\n    );\n    return this._getTreeStructure(nodeInformation, 1, true);\n  }\n\n  /**\n   * Recursively collect the structured text of the tree nodes.\n   * @param nodes A list of tree nodes\n   * @param level The level of nodes that are being accounted for during this iteration\n   * @param parentExpanded Whether the parent of the first node in param nodes is expanded\n   */\n  private _getTreeStructure(\n    nodes: [number, string, boolean][],\n    level: number,\n    parentExpanded: boolean,\n  ): TextTree {\n    const result: TextTree = {};\n    for (let i = 0; i < nodes.length; i++) {\n      const [nodeLevel, text, expanded] = nodes[i];\n      const nextNodeLevel = nodes[i + 1]?.[0] ?? -1;\n\n      // Return the accumulated value for the current level once we reach a shallower level node\n      if (nodeLevel < level) {\n        return result;\n      }\n      // Skip deeper level nodes during this iteration, they will be picked up in a later iteration\n      if (nodeLevel > level) {\n        continue;\n      }\n      // Only add to representation if it is visible (parent is expanded)\n      if (parentExpanded) {\n        // Collect the data under this node according to the following rules:\n        // 1. If the next node in the list is a sibling of the current node add it to the child list\n        // 2. If the next node is a child of the current node, get the sub-tree structure for the\n        //    child and add it under this node\n        // 3. If the next node has a shallower level, we've reached the end of the child nodes for\n        //    the current parent.\n        if (nextNodeLevel === level) {\n          this._addChildToNode(result, {text});\n        } else if (nextNodeLevel > level) {\n          let children = this._getTreeStructure(\n            nodes.slice(i + 1),\n            nextNodeLevel,\n            expanded,\n          )?.children;\n          let child = children ? {text, children} : {text};\n          this._addChildToNode(result, child);\n        } else {\n          this._addChildToNode(result, {text});\n          return result;\n        }\n      }\n    }\n    return result;\n  }\n\n  private _addChildToNode(result: TextTree, child: TextTree) {\n    result.children ? result.children.push(child) : (result.children = [child]);\n  }\n}\n"],"names":["MatTreeNodeHarness","ContentContainerComponentHarness","hostSelector","_toggle","locatorForOptional","with","options","getNodePredicate","isExpanded","coerceBooleanProperty","host","getAttribute","isExpandable","isDisabled","getProperty","getLevel","coerceNumberProperty","getText","text","exclude","toggle","click","expand","collapse","type","HarnessPredicate","addOption","harness","stringMatches","disabled","expanded","level","MatTreeHarness","ComponentHarness","getNodes","filter","locatorForAll","getTreeStructure","nodes","nodeInformation","parallel","map","node","_getTreeStructure","parentExpanded","result","i","length","nodeLevel","nextNodeLevel","_addChildToNode","children","slice","child","push"],"mappings":"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"}