{"version":3,"file":"radio.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/radio/radio.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/radio/radio-module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {_IdGenerator, FocusMonitor, FocusOrigin} from '@angular/cdk/a11y';\nimport {UniqueSelectionDispatcher} from '@angular/cdk/collections';\nimport {\n  AfterContentInit,\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  Directive,\n  DoCheck,\n  ElementRef,\n  EventEmitter,\n  InjectionToken,\n  Injector,\n  Input,\n  NgZone,\n  OnDestroy,\n  OnInit,\n  Output,\n  QueryList,\n  ViewChild,\n  ViewEncapsulation,\n  afterNextRender,\n  booleanAttribute,\n  forwardRef,\n  inject,\n  numberAttribute,\n  HostAttributeToken,\n  Renderer2,\n} from '@angular/core';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '@angular/forms';\nimport {\n  MatRipple,\n  ThemePalette,\n  _MatInternalFormField,\n  _StructuralStylesLoader,\n  _animationsDisabled,\n} from '../core';\nimport {Subscription} from 'rxjs';\nimport {_CdkPrivateStyleLoader} from '@angular/cdk/private';\n\n/** Change event object emitted by radio button and radio group. */\nexport class MatRadioChange<T = any> {\n  constructor(\n    /** The radio button that emits the change event. */\n    public source: MatRadioButton,\n    /** The value of the radio button. */\n    public value: T,\n  ) {}\n}\n\n/**\n * Provider Expression that allows mat-radio-group to register as a ControlValueAccessor. This\n * allows it to support [(ngModel)] and ngControl.\n * @docs-private\n */\nexport const MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatRadioGroup),\n  multi: true,\n};\n\n/**\n * Injection token that can be used to inject instances of `MatRadioGroup`. It serves as\n * alternative token to the actual `MatRadioGroup` class which could cause unnecessary\n * retention of the class and its component metadata.\n */\nexport const MAT_RADIO_GROUP = new InjectionToken<MatRadioGroup>('MatRadioGroup');\n\nexport interface MatRadioDefaultOptions {\n  /**\n   * Theme color of the radio button. This API is supported in M2 themes only, it\n   * has no effect in M3 themes. For color customization in M3, see https://material.angular.dev/components/radio/styling.\n   *\n   * For information on applying color variants in M3, see\n   * https://material.angular.dev/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n   */\n  color: ThemePalette;\n\n  /** Whether disabled radio buttons should be interactive. */\n  disabledInteractive?: boolean;\n}\n\nexport const MAT_RADIO_DEFAULT_OPTIONS = new InjectionToken<MatRadioDefaultOptions>(\n  'mat-radio-default-options',\n  {\n    providedIn: 'root',\n    factory: () => ({\n      color: 'accent',\n      disabledInteractive: false,\n    }),\n  },\n);\n\n/**\n * A group of radio buttons. May contain one or more `<mat-radio-button>` elements.\n */\n@Directive({\n  selector: 'mat-radio-group',\n  exportAs: 'matRadioGroup',\n  providers: [\n    MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR,\n    {provide: MAT_RADIO_GROUP, useExisting: MatRadioGroup},\n  ],\n  host: {\n    'role': 'radiogroup',\n    'class': 'mat-mdc-radio-group',\n  },\n})\nexport class MatRadioGroup implements AfterContentInit, OnDestroy, ControlValueAccessor {\n  private _changeDetector = inject(ChangeDetectorRef);\n\n  /** Selected value for the radio group. */\n  private _value: any = null;\n\n  /** The HTML name attribute applied to radio buttons in this group. */\n  private _name: string = inject(_IdGenerator).getId('mat-radio-group-');\n\n  /** The currently selected radio button. Should match value. */\n  private _selected: MatRadioButton | null = null;\n\n  /** Whether the `value` has been set to its initial value. */\n  private _isInitialized: boolean = false;\n\n  /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n  private _labelPosition: 'before' | 'after' = 'after';\n\n  /** Whether the radio group is disabled. */\n  private _disabled: boolean = false;\n\n  /** Whether the radio group is required. */\n  private _required: boolean = false;\n\n  /** Subscription to changes in amount of radio buttons. */\n  private _buttonChanges: Subscription;\n\n  /** The method to be called in order to update ngModel */\n  _controlValueAccessorChangeFn: (value: any) => void = () => {};\n\n  /**\n   * onTouch function registered via registerOnTouch (ControlValueAccessor).\n   * @docs-private\n   */\n  onTouched: () => any = () => {};\n\n  /**\n   * Event emitted when the group value changes.\n   * Change events are only emitted when the value changes due to user interaction with\n   * a radio button (the same behavior as `<input type-\"radio\">`).\n   */\n  @Output() readonly change: EventEmitter<MatRadioChange> = new EventEmitter<MatRadioChange>();\n\n  /** Child radio buttons. */\n  @ContentChildren(forwardRef(() => MatRadioButton), {descendants: true})\n  _radios: QueryList<MatRadioButton>;\n\n  /**\n   * Theme color of the radio buttons in the group. This API is supported in M2\n   * themes only, it has no effect in M3 themes. For color customization in M3, see https://material.angular.dev/components/radio/styling.\n   *\n   * For information on applying color variants in M3, see\n   * https://material.angular.dev/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n   */\n  @Input() color: ThemePalette;\n\n  /** Name of the radio button group. All radio buttons inside this group will use this name. */\n  @Input()\n  get name(): string {\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    this._updateRadioButtonNames();\n  }\n\n  /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n  @Input()\n  get labelPosition(): 'before' | 'after' {\n    return this._labelPosition;\n  }\n  set labelPosition(v) {\n    this._labelPosition = v === 'before' ? 'before' : 'after';\n    this._markRadiosForCheck();\n  }\n\n  /**\n   * Value for the radio-group. Should equal the value of the selected radio button if there is\n   * a corresponding radio button with a matching value. If there is not such a corresponding\n   * radio button, this value persists to be applied in case a new radio button is added with a\n   * matching value.\n   */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(newValue: any) {\n    if (this._value !== newValue) {\n      // Set this before proceeding to ensure no circular loop occurs with selection.\n      this._value = newValue;\n\n      this._updateSelectedRadioFromValue();\n      this._checkSelectedRadioButton();\n    }\n  }\n\n  _checkSelectedRadioButton() {\n    if (this._selected && !this._selected.checked) {\n      this._selected.checked = true;\n    }\n  }\n\n  /**\n   * The currently selected radio button. If set to a new radio button, the radio group value\n   * will be updated to match the new selected button.\n   */\n  @Input()\n  get selected() {\n    return this._selected;\n  }\n  set selected(selected: MatRadioButton | null) {\n    this._selected = selected;\n    this.value = selected ? selected.value : null;\n    this._checkSelectedRadioButton();\n  }\n\n  /** Whether the radio group is disabled */\n  @Input({transform: booleanAttribute})\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(value: boolean) {\n    this._disabled = value;\n    this._markRadiosForCheck();\n  }\n\n  /** Whether the radio group is required */\n  @Input({transform: booleanAttribute})\n  get required(): boolean {\n    return this._required;\n  }\n  set required(value: boolean) {\n    this._required = value;\n    this._markRadiosForCheck();\n  }\n\n  /** Whether buttons in the group should be interactive while they're disabled. */\n  @Input({transform: booleanAttribute})\n  get disabledInteractive(): boolean {\n    return this._disabledInteractive;\n  }\n  set disabledInteractive(value: boolean) {\n    this._disabledInteractive = value;\n    this._markRadiosForCheck();\n  }\n  private _disabledInteractive = false;\n\n  constructor(...args: unknown[]);\n\n  constructor() {}\n\n  /**\n   * Initialize properties once content children are available.\n   * This allows us to propagate relevant attributes to associated buttons.\n   */\n  ngAfterContentInit() {\n    // Mark this component as initialized in AfterContentInit because the initial value can\n    // possibly be set by NgModel on MatRadioGroup, and it is possible that the OnInit of the\n    // NgModel occurs *after* the OnInit of the MatRadioGroup.\n    this._isInitialized = true;\n\n    // Clear the `selected` button when it's destroyed since the tabindex of the rest of the\n    // buttons depends on it. Note that we don't clear the `value`, because the radio button\n    // may be swapped out with a similar one and there are some internal apps that depend on\n    // that behavior.\n    this._buttonChanges = this._radios.changes.subscribe(() => {\n      if (this.selected && !this._radios.find(radio => radio === this.selected)) {\n        this._selected = null;\n      }\n    });\n  }\n\n  ngOnDestroy() {\n    this._buttonChanges?.unsubscribe();\n  }\n\n  /**\n   * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\n   * radio buttons upon their blur.\n   */\n  _touch() {\n    if (this.onTouched) {\n      this.onTouched();\n    }\n  }\n\n  private _updateRadioButtonNames(): void {\n    if (this._radios) {\n      this._radios.forEach(radio => {\n        radio.name = this.name;\n        radio._markForCheck();\n      });\n    }\n  }\n\n  /** Updates the `selected` radio button from the internal _value state. */\n  private _updateSelectedRadioFromValue(): void {\n    // If the value already matches the selected radio, do nothing.\n    const isAlreadySelected = this._selected !== null && this._selected.value === this._value;\n\n    if (this._radios && !isAlreadySelected) {\n      this._selected = null;\n      this._radios.forEach(radio => {\n        radio.checked = this.value === radio.value;\n        if (radio.checked) {\n          this._selected = radio;\n        }\n      });\n    }\n  }\n\n  /** Dispatch change event with current selection and group value. */\n  _emitChangeEvent(): void {\n    if (this._isInitialized) {\n      this.change.emit(new MatRadioChange(this._selected!, this._value));\n    }\n  }\n\n  _markRadiosForCheck() {\n    if (this._radios) {\n      this._radios.forEach(radio => radio._markForCheck());\n    }\n  }\n\n  /**\n   * Sets the model value. Implemented as part of ControlValueAccessor.\n   * @param value\n   */\n  writeValue(value: any) {\n    this.value = value;\n    this._changeDetector.markForCheck();\n  }\n\n  /**\n   * Registers a callback to be triggered when the model value changes.\n   * Implemented as part of ControlValueAccessor.\n   * @param fn Callback to be registered.\n   */\n  registerOnChange(fn: (value: any) => void) {\n    this._controlValueAccessorChangeFn = fn;\n  }\n\n  /**\n   * Registers a callback to be triggered when the control is touched.\n   * Implemented as part of ControlValueAccessor.\n   * @param fn Callback to be registered.\n   */\n  registerOnTouched(fn: any) {\n    this.onTouched = fn;\n  }\n\n  /**\n   * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\n   * @param isDisabled Whether the control should be disabled.\n   */\n  setDisabledState(isDisabled: boolean) {\n    this.disabled = isDisabled;\n    this._changeDetector.markForCheck();\n  }\n}\n\n@Component({\n  selector: 'mat-radio-button',\n  templateUrl: 'radio.html',\n  styleUrl: 'radio.css',\n  host: {\n    'class': 'mat-mdc-radio-button',\n    '[attr.id]': 'id',\n    '[class.mat-primary]': 'color === \"primary\"',\n    '[class.mat-accent]': 'color === \"accent\"',\n    '[class.mat-warn]': 'color === \"warn\"',\n    '[class.mat-mdc-radio-checked]': 'checked',\n    '[class.mat-mdc-radio-disabled]': 'disabled',\n    '[class.mat-mdc-radio-disabled-interactive]': 'disabledInteractive',\n    '[class._mat-animation-noopable]': '_noopAnimations',\n    // Needs to be removed since it causes some a11y issues (see #21266).\n    '[attr.tabindex]': 'null',\n    '[attr.aria-label]': 'null',\n    '[attr.aria-labelledby]': 'null',\n    '[attr.aria-describedby]': 'null',\n    // Note: under normal conditions focus shouldn't land on this element, however it may be\n    // programmatically set, for example inside of a focus trap, in this case we want to forward\n    // the focus to the native element.\n    '(focus)': '_inputElement.nativeElement.focus()',\n  },\n  exportAs: 'matRadioButton',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [MatRipple, _MatInternalFormField],\n})\nexport class MatRadioButton implements OnInit, AfterViewInit, DoCheck, OnDestroy {\n  protected _elementRef = inject(ElementRef);\n  private _changeDetector = inject(ChangeDetectorRef);\n  private _focusMonitor = inject(FocusMonitor);\n  private _radioDispatcher = inject(UniqueSelectionDispatcher);\n  private _defaultOptions = inject<MatRadioDefaultOptions>(MAT_RADIO_DEFAULT_OPTIONS, {\n    optional: true,\n  });\n\n  private _ngZone = inject(NgZone);\n  private _renderer = inject(Renderer2);\n  private _uniqueId = inject(_IdGenerator).getId('mat-radio-');\n  private _cleanupClick: (() => void) | undefined;\n\n  /** The unique ID for the radio button. */\n  @Input() id: string = this._uniqueId;\n\n  /** Analog to HTML 'name' attribute used to group radios for unique selection. */\n  @Input() name: string;\n\n  /** Used to set the 'aria-label' attribute on the underlying input element. */\n  @Input('aria-label') ariaLabel: string;\n\n  /** The 'aria-labelledby' attribute takes precedence as the element's text alternative. */\n  @Input('aria-labelledby') ariaLabelledby: string;\n\n  /** The 'aria-describedby' attribute is read after the element's label and field type. */\n  @Input('aria-describedby') ariaDescribedby: string;\n\n  /** Whether ripples are disabled inside the radio button */\n  @Input({transform: booleanAttribute})\n  disableRipple: boolean = false;\n\n  /** Tabindex of the radio button. */\n  @Input({\n    transform: (value: unknown) => (value == null ? 0 : numberAttribute(value)),\n  })\n  tabIndex: number = 0;\n\n  /** Whether this radio button is checked. */\n  @Input({transform: booleanAttribute})\n  get checked(): boolean {\n    return this._checked;\n  }\n  set checked(value: boolean) {\n    if (this._checked !== value) {\n      this._checked = value;\n      if (value && this.radioGroup && this.radioGroup.value !== this.value) {\n        this.radioGroup.selected = this;\n      } else if (!value && this.radioGroup && this.radioGroup.value === this.value) {\n        // When unchecking the selected radio button, update the selected radio\n        // property on the group.\n        this.radioGroup.selected = null;\n      }\n\n      if (value) {\n        // Notify all radio buttons with the same name to un-check.\n        this._radioDispatcher.notify(this.id, this.name);\n      }\n      this._changeDetector.markForCheck();\n    }\n  }\n\n  /** The value of this radio button. */\n  @Input()\n  get value(): any {\n    return this._value;\n  }\n  set value(value: any) {\n    if (this._value !== value) {\n      this._value = value;\n      if (this.radioGroup !== null) {\n        if (!this.checked) {\n          // Update checked when the value changed to match the radio group's value\n          this.checked = this.radioGroup.value === value;\n        }\n        if (this.checked) {\n          this.radioGroup.selected = this;\n        }\n      }\n    }\n  }\n\n  /** Whether the label should appear after or before the radio button. Defaults to 'after' */\n  @Input()\n  get labelPosition(): 'before' | 'after' {\n    return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || 'after';\n  }\n  set labelPosition(value) {\n    this._labelPosition = value;\n  }\n  private _labelPosition: 'before' | 'after';\n\n  /** Whether the radio button is disabled. */\n  @Input({transform: booleanAttribute})\n  get disabled(): boolean {\n    return this._disabled || (this.radioGroup !== null && this.radioGroup.disabled);\n  }\n  set disabled(value: boolean) {\n    this._setDisabled(value);\n  }\n\n  /** Whether the radio button is required. */\n  @Input({transform: booleanAttribute})\n  get required(): boolean {\n    return this._required || (this.radioGroup && this.radioGroup.required);\n  }\n  set required(value: boolean) {\n    if (value !== this._required) {\n      this._changeDetector.markForCheck();\n    }\n    this._required = value;\n  }\n\n  /**\n   * Theme color of the radio button. This API is supported in M2 themes only, it\n   * has no effect in M3 themes. For color customization in M3, see https://material.angular.dev/components/radio/styling.\n   *\n   * For information on applying color variants in M3, see\n   * https://material.angular.dev/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n   */\n  @Input()\n  get color(): ThemePalette {\n    // As per M2 design specifications the selection control radio should use the accent color\n    // palette by default. https://m2.material.io/components/radio-buttons#specs\n    return (\n      this._color ||\n      (this.radioGroup && this.radioGroup.color) ||\n      (this._defaultOptions && this._defaultOptions.color) ||\n      'accent'\n    );\n  }\n  set color(newValue: ThemePalette) {\n    this._color = newValue;\n  }\n  private _color: ThemePalette;\n\n  /** Whether the radio button should remain interactive when it is disabled. */\n  @Input({transform: booleanAttribute})\n  get disabledInteractive(): boolean {\n    return (\n      this._disabledInteractive || (this.radioGroup !== null && this.radioGroup.disabledInteractive)\n    );\n  }\n  set disabledInteractive(value: boolean) {\n    this._disabledInteractive = value;\n  }\n  private _disabledInteractive: boolean;\n\n  /**\n   * Event emitted when the checked state of this radio button changes.\n   * Change events are only emitted when the value changes due to user interaction with\n   * the radio button (the same behavior as `<input type-\"radio\">`).\n   */\n  @Output() readonly change: EventEmitter<MatRadioChange> = new EventEmitter<MatRadioChange>();\n\n  /** The parent radio group. May or may not be present. */\n  radioGroup: MatRadioGroup;\n\n  /** ID of the native input element inside `<mat-radio-button>` */\n  get inputId(): string {\n    return `${this.id || this._uniqueId}-input`;\n  }\n\n  /** Whether this radio is checked. */\n  private _checked: boolean = false;\n\n  /** Whether this radio is disabled. */\n  private _disabled: boolean;\n\n  /** Whether this radio is required. */\n  private _required: boolean;\n\n  /** Value assigned to this radio. */\n  private _value: any = null;\n\n  /** Unregister function for _radioDispatcher */\n  private _removeUniqueSelectionListener: () => void = () => {};\n\n  /** Previous value of the input's tabindex. */\n  private _previousTabIndex: number | undefined;\n\n  /** The native `<input type=radio>` element */\n  @ViewChild('input') _inputElement: ElementRef<HTMLInputElement>;\n\n  /** Trigger elements for the ripple events. */\n  @ViewChild('formField', {read: ElementRef, static: true})\n  _rippleTrigger: ElementRef<HTMLElement>;\n\n  /** Whether animations are disabled. */\n  _noopAnimations = _animationsDisabled();\n\n  private _injector = inject(Injector);\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    inject(_CdkPrivateStyleLoader).load(_StructuralStylesLoader);\n    const radioGroup = inject<MatRadioGroup>(MAT_RADIO_GROUP, {optional: true})!;\n    const tabIndex = inject(new HostAttributeToken('tabindex'), {optional: true});\n\n    // Assertions. Ideally these should be stripped out by the compiler.\n    // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.\n    this.radioGroup = radioGroup;\n    this._disabledInteractive = this._defaultOptions?.disabledInteractive ?? false;\n\n    if (tabIndex) {\n      this.tabIndex = numberAttribute(tabIndex, 0);\n    }\n  }\n\n  /** Focuses the radio button. */\n  focus(options?: FocusOptions, origin?: FocusOrigin): void {\n    if (origin) {\n      this._focusMonitor.focusVia(this._inputElement, origin, options);\n    } else {\n      this._inputElement.nativeElement.focus(options);\n    }\n  }\n\n  /**\n   * Marks the radio button as needing checking for change detection.\n   * This method is exposed because the parent radio group will directly\n   * update bound properties of the radio button.\n   */\n  _markForCheck() {\n    // When group value changes, the button will not be notified. Use `markForCheck` to explicit\n    // update radio button's status\n    this._changeDetector.markForCheck();\n  }\n\n  ngOnInit() {\n    if (this.radioGroup) {\n      // If the radio is inside a radio group, determine if it should be checked\n      this.checked = this.radioGroup.value === this._value;\n\n      if (this.checked) {\n        this.radioGroup.selected = this;\n      }\n\n      // Copy name from parent radio group\n      this.name = this.radioGroup.name;\n    }\n\n    this._removeUniqueSelectionListener = this._radioDispatcher.listen((id, name) => {\n      if (id !== this.id && name === this.name) {\n        this.checked = false;\n      }\n    });\n  }\n\n  ngDoCheck(): void {\n    this._updateTabIndex();\n  }\n\n  ngAfterViewInit() {\n    this._updateTabIndex();\n    this._focusMonitor.monitor(this._elementRef, true).subscribe(focusOrigin => {\n      if (!focusOrigin && this.radioGroup) {\n        this.radioGroup._touch();\n      }\n    });\n\n    // We bind this outside of the zone, because:\n    // 1. Its logic is completely DOM-related so we can avoid some change detections.\n    // 2. There appear to be some internal tests that break when this triggers a change detection.\n    this._ngZone.runOutsideAngular(() => {\n      this._cleanupClick = this._renderer.listen(\n        this._inputElement.nativeElement,\n        'click',\n        this._onInputClick,\n      );\n    });\n  }\n\n  ngOnDestroy() {\n    this._cleanupClick?.();\n    this._focusMonitor.stopMonitoring(this._elementRef);\n    this._removeUniqueSelectionListener();\n  }\n\n  /** Dispatch change event with current value. */\n  private _emitChangeEvent(): void {\n    this.change.emit(new MatRadioChange(this, this._value));\n  }\n\n  _isRippleDisabled() {\n    return this.disableRipple || this.disabled;\n  }\n\n  /** Triggered when the radio button receives an interaction from the user. */\n  _onInputInteraction(event: Event) {\n    // We always have to stop propagation on the change event.\n    // Otherwise the change event, from the input element, will bubble up and\n    // emit its event object to the `change` output.\n    event.stopPropagation();\n\n    if (!this.checked && !this.disabled) {\n      const groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;\n      this.checked = true;\n      this._emitChangeEvent();\n\n      if (this.radioGroup) {\n        this.radioGroup._controlValueAccessorChangeFn(this.value);\n        if (groupValueChanged) {\n          this.radioGroup._emitChangeEvent();\n        }\n      }\n    }\n  }\n\n  /** Triggered when the user clicks on the touch target. */\n  _onTouchTargetClick(event: Event) {\n    this._onInputInteraction(event);\n\n    if (!this.disabled || this.disabledInteractive) {\n      // Normally the input should be focused already, but if the click\n      // comes from the touch target, then we might have to focus it ourselves.\n      this._inputElement?.nativeElement.focus();\n    }\n  }\n\n  /** Sets the disabled state and marks for check if a change occurred. */\n  protected _setDisabled(value: boolean) {\n    if (this._disabled !== value) {\n      this._disabled = value;\n      this._changeDetector.markForCheck();\n    }\n  }\n\n  /** Called when the input is clicked. */\n  private _onInputClick = (event: Event) => {\n    // If the input is disabled while interactive, we need to prevent the\n    // selection from happening in this event handler. Note that even though\n    // this happens on `click` events, the logic applies when the user is\n    // navigating with the keyboard as well. An alternative way of doing\n    // this is by resetting the `checked` state in the `change` callback but\n    // it isn't optimal, because it can allow a pre-checked disabled button\n    // to be un-checked. This approach seems to cover everything.\n    if (this.disabled && this.disabledInteractive) {\n      event.preventDefault();\n    }\n  };\n\n  /** Gets the tabindex for the underlying input element. */\n  private _updateTabIndex() {\n    const group = this.radioGroup;\n    let value: number;\n\n    // Implement a roving tabindex if the button is inside a group. For most cases this isn't\n    // necessary, because the browser handles the tab order for inputs inside a group automatically,\n    // but we need an explicitly higher tabindex for the selected button in order for things like\n    // the focus trap to pick it up correctly.\n    if (!group || !group.selected || this.disabled) {\n      value = this.tabIndex;\n    } else {\n      value = group.selected === this ? this.tabIndex : -1;\n    }\n\n    if (value !== this._previousTabIndex) {\n      // We have to set the tabindex directly on the DOM node, because it depends on\n      // the selected state which is prone to \"changed after checked errors\".\n      const input: HTMLInputElement | undefined = this._inputElement?.nativeElement;\n\n      if (input) {\n        input.setAttribute('tabindex', value + '');\n        this._previousTabIndex = value;\n        // Wait for any pending tabindex changes to be applied\n        afterNextRender(\n          () => {\n            queueMicrotask(() => {\n              // The radio group uses a \"selection follows focus\" pattern for tab management, so if this\n              // radio button is currently focused and another radio button in the group becomes\n              // selected, we should move focus to the newly selected radio button to maintain\n              // consistency between the focused and selected states.\n              if (\n                group &&\n                group.selected &&\n                group.selected !== this &&\n                document.activeElement === input\n              ) {\n                group.selected?._inputElement.nativeElement.focus();\n                // If this radio button still has focus, the selected one must be disabled. In this\n                // case the radio group as a whole should lose focus.\n                if (document.activeElement === input) {\n                  this._inputElement.nativeElement.blur();\n                }\n              }\n            });\n          },\n          {injector: this._injector},\n        );\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {BidiModule} from '@angular/cdk/bidi';\nimport {NgModule} from '@angular/core';\nimport {MatRippleModule} from '../core';\nimport {MatRadioButton, MatRadioGroup} from './radio';\n\n@NgModule({\n  imports: [MatRippleModule, MatRadioGroup, MatRadioButton],\n  exports: [BidiModule, MatRadioGroup, MatRadioButton],\n})\nexport class MatRadioModule {}\n"],"names":["MatRadioChange","source","value","constructor","MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR","MAT_RADIO_DEFAULT_OPTIONS","InjectionToken","providedIn","MatRadioGroup","inject","ChangeDetectorRef","_buttonChanges","onTouched","_radios","_name","_updateRadioButtonNames","labelPosition","_labelPosition","v","_value","newValue","_updateSelectedRadioFromValue","_checkSelectedRadioButton","_selected","checked","selected","disabled","_disabled","_markRadiosForCheck","required","_required","disabledInteractive","_disabledInteractive","ngAfterContentInit","changes","subscribe","find","radio","unsubscribe","name","isAlreadySelected","forEach","_emitChangeEvent","change","emit","_markForCheck","writeValue","_changeDetector","markForCheck","_controlValueAccessorChangeFn","fn","registerOnTouched","setDisabledState","isDisabled","MAT_RADIO_GROUP","useExisting","queries","propertyName","predicate","i0","forwardRef","MatRadioButton","descendants","exportAs","ngImport","ctorParameters","propDecorators","Input","type","transform","booleanAttribute","FocusMonitor","UniqueSelectionDispatcher","_ngZone","NgZone","_renderer","Renderer2","_uniqueId","_IdGenerator","getId","_cleanupClick","ariaLabel","ariaLabelledby","tabIndex","_checked","radioGroup","_radioDispatcher","notify","id","_setDisabled","_removeUniqueSelectionListener","_previousTabIndex","_rippleTrigger","_injector","Injector","_CdkPrivateStyleLoader","load","_StructuralStylesLoader","HostAttributeToken","optional","_defaultOptions","focus","options","origin","listen","_inputElement","nativeElement","_onInputClick","_onInputInteraction","event","encapsulation","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","imports","MatRipple","_MatInternalFormField","template","styles","args","numberAttribute","read","ElementRef","static","ɵmod","ɵɵngDeclareNgModule","minVersion","version","MatRadioModule","MatRippleModule","exports","BidiModule","decorators"],"mappings":"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"}