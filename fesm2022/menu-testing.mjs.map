{"version":3,"file":"menu-testing.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/menu/testing/menu-harness.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/menu/testing/context-menu-harness.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ComponentHarnessConstructor,\n  ContentContainerComponentHarness,\n  HarnessLoader,\n  HarnessPredicate,\n  TestElement,\n} from '@angular/cdk/testing';\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {MatIconHarness} from '@angular/material/icon/testing';\nimport {MenuHarnessFilters, MenuItemHarnessFilters} from './menu-harness-filters';\n\n/** Harness for interacting with a mat-menu in tests. */\nexport class MatMenuHarness extends ContentContainerComponentHarness<string> {\n  private _documentRootLocator = this.documentRootLocatorFactory();\n\n  /** The selector for the host element of a `MatMenu` instance. */\n  static hostSelector = '.mat-mdc-menu-trigger';\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a menu with specific attributes.\n   * @param options Options for filtering which menu instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with<T extends MatMenuHarness>(\n    this: ComponentHarnessConstructor<T>,\n    options: MenuHarnessFilters = {},\n  ): HarnessPredicate<T> {\n    return new HarnessPredicate(this, options)\n      .addOption('triggerText', options.triggerText, (harness, text) =>\n        HarnessPredicate.stringMatches(harness.getTriggerText(), text),\n      )\n      .addOption('triggerIconName', options.triggerIconName, async (harness, triggerIconName) => {\n        const result = await harness.locatorForOptional(\n          MatIconHarness.with({name: triggerIconName}),\n        )();\n        return result !== null;\n      });\n  }\n\n  /** Whether the menu is disabled. */\n  async isDisabled(): Promise<boolean> {\n    const disabled = (await this.host()).getAttribute('disabled');\n    return coerceBooleanProperty(await disabled);\n  }\n\n  /** Whether the menu is open. */\n  async isOpen(): Promise<boolean> {\n    return !!(await this._getMenuPanel());\n  }\n\n  /** Gets the text of the menu's trigger element. */\n  async getTriggerText(): Promise<string> {\n    return (await this.host()).text();\n  }\n\n  /** Focuses the menu. */\n  async focus(): Promise<void> {\n    return (await this.host()).focus();\n  }\n\n  /** Blurs the menu. */\n  async blur(): Promise<void> {\n    return (await this.host()).blur();\n  }\n\n  /** Whether the menu is focused. */\n  async isFocused(): Promise<boolean> {\n    return (await this.host()).isFocused();\n  }\n\n  /** Opens the menu. */\n  async open(): Promise<void> {\n    if (!(await this.isOpen())) {\n      return (await this.host()).click();\n    }\n  }\n\n  /** Closes the menu. */\n  async close(): Promise<void> {\n    const panel = await this._getMenuPanel();\n    if (panel) {\n      return panel.click();\n    }\n  }\n\n  /**\n   * Gets a list of `MatMenuItemHarness` representing the items in the menu.\n   * @param filters Optionally filters which menu items are included.\n   */\n  async getItems(\n    filters?: Omit<MenuItemHarnessFilters, 'ancestor'>,\n  ): Promise<MatMenuItemHarness[]> {\n    const panelId = await this._getPanelId();\n    if (panelId) {\n      return this._documentRootLocator.locatorForAll(\n        MatMenuItemHarness.with({\n          ...(filters || {}),\n          ancestor: `#${panelId}`,\n        } as MenuItemHarnessFilters),\n      )();\n    }\n    return [];\n  }\n\n  /**\n   * Clicks an item in the menu, and optionally continues clicking items in subsequent sub-menus.\n   * @param itemFilter A filter used to represent which item in the menu should be clicked. The\n   *     first matching menu item will be clicked.\n   * @param subItemFilters A list of filters representing the items to click in any subsequent\n   *     sub-menus. The first item in the sub-menu matching the corresponding filter in\n   *     `subItemFilters` will be clicked.\n   */\n  async clickItem(\n    itemFilter: Omit<MenuItemHarnessFilters, 'ancestor'>,\n    ...subItemFilters: Omit<MenuItemHarnessFilters, 'ancestor'>[]\n  ): Promise<void> {\n    await this.open();\n    return clickItemImplementation(await this.getItems(itemFilter), itemFilter, subItemFilters);\n  }\n\n  protected override async getRootHarnessLoader(): Promise<HarnessLoader> {\n    const panelId = await this._getPanelId();\n    return this.documentRootLocatorFactory().harnessLoaderFor(`#${panelId}`);\n  }\n\n  /** Gets the menu panel associated with this menu. */\n  private async _getMenuPanel(): Promise<TestElement | null> {\n    const panelId = await this._getPanelId();\n    return panelId ? this._documentRootLocator.locatorForOptional(`#${panelId}`)() : null;\n  }\n\n  /** Gets the id of the menu panel associated with this menu. */\n  private async _getPanelId(): Promise<string | null> {\n    const panelId = await (await this.host()).getAttribute('aria-controls');\n    return panelId || null;\n  }\n}\n\nexport class MatMenuItemHarness extends ContentContainerComponentHarness<string> {\n  /** The selector for the host element of a `MatMenuItem` instance. */\n  static hostSelector = '.mat-mdc-menu-item';\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a menu item with specific attributes.\n   * @param options Options for filtering which menu item instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with<T extends MatMenuItemHarness>(\n    this: ComponentHarnessConstructor<T>,\n    options: MenuItemHarnessFilters = {},\n  ): HarnessPredicate<T> {\n    return new HarnessPredicate(this, options)\n      .addOption('text', options.text, (harness, text) =>\n        HarnessPredicate.stringMatches(harness.getText(), text),\n      )\n      .addOption(\n        'hasSubmenu',\n        options.hasSubmenu,\n        async (harness, hasSubmenu) => (await harness.hasSubmenu()) === hasSubmenu,\n      );\n  }\n\n  /** Whether the menu is disabled. */\n  async isDisabled(): Promise<boolean> {\n    const disabled = (await this.host()).getAttribute('disabled');\n    return coerceBooleanProperty(await disabled);\n  }\n\n  /** Gets the text of the menu item. */\n  async getText(): Promise<string> {\n    return (await this.host()).text();\n  }\n\n  /** Focuses the menu item. */\n  async focus(): Promise<void> {\n    return (await this.host()).focus();\n  }\n\n  /** Blurs the menu item. */\n  async blur(): Promise<void> {\n    return (await this.host()).blur();\n  }\n\n  /** Whether the menu item is focused. */\n  async isFocused(): Promise<boolean> {\n    return (await this.host()).isFocused();\n  }\n\n  /** Clicks the menu item. */\n  async click(): Promise<void> {\n    return (await this.host()).click();\n  }\n\n  /** Whether this item has a submenu. */\n  async hasSubmenu(): Promise<boolean> {\n    return (await this.host()).matchesSelector(MatMenuHarness.hostSelector);\n  }\n\n  /** Gets the submenu associated with this menu item, or null if none. */\n  async getSubmenu(): Promise<MatMenuHarness | null> {\n    if (await this.hasSubmenu()) {\n      return new MatMenuHarness(this.locatorFactory);\n    }\n    return null;\n  }\n}\n\nexport async function clickItemImplementation(\n  items: MatMenuItemHarness[],\n  itemFilter: Omit<MenuItemHarnessFilters, 'ancestor'>,\n  subItemFilters: Omit<MenuItemHarnessFilters, 'ancestor'>[],\n): Promise<void> {\n  if (!items.length) {\n    throw Error(`Could not find item matching ${JSON.stringify(itemFilter)}`);\n  }\n\n  if (!subItemFilters.length) {\n    return await items[0].click();\n  }\n\n  const menu = await items[0].getSubmenu();\n  if (!menu) {\n    throw Error(`Item matching ${JSON.stringify(itemFilter)} does not have a submenu`);\n  }\n  return menu.clickItem(...(subItemFilters as [Omit<MenuItemHarnessFilters, 'ancestor'>]));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ComponentHarnessConstructor,\n  ContentContainerComponentHarness,\n  HarnessLoader,\n  HarnessPredicate,\n  TestElement,\n} from '@angular/cdk/testing';\nimport {ContextMenuHarnessFilters, MenuItemHarnessFilters} from './menu-harness-filters';\nimport {clickItemImplementation, MatMenuItemHarness} from './menu-harness';\n\n/** Harness for interacting with context menus in tests. */\nexport class MatContextMenuHarness extends ContentContainerComponentHarness<string> {\n  private _documentRootLocator = this.documentRootLocatorFactory();\n\n  /** The selector for the host element of a `MatContextMenu` instance. */\n  static hostSelector = '.mat-context-menu-trigger';\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a context menu with specific\n   * attributes.\n   * @param options Options for filtering which menu instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with<T extends MatContextMenuHarness>(\n    this: ComponentHarnessConstructor<T>,\n    options: ContextMenuHarnessFilters = {},\n  ): HarnessPredicate<T> {\n    return new HarnessPredicate(this, options);\n  }\n\n  /** Whether the menu is open. */\n  async isOpen(): Promise<boolean> {\n    return !!(await this._getMenuPanel());\n  }\n\n  /**\n   * Opens the menu.\n   * @param relativeX X coordinate, relative to the element, to dispatch the opening click at.\n   * @param relativeY Y coordinate, relative to the element, to dispatch the opening click at.\n   */\n  async open(relativeX = 0, relativeY = 0): Promise<void> {\n    if (!(await this.isOpen())) {\n      return (await this.host()).rightClick(relativeX, relativeY);\n    }\n  }\n\n  /** Closes the menu. */\n  async close(): Promise<void> {\n    const panel = await this._getMenuPanel();\n    if (panel) {\n      return panel.click();\n    }\n  }\n\n  /** Gets whether the context menu trigger is disabled. */\n  async isDisabled(): Promise<boolean> {\n    const host = await this.host();\n    return host.hasClass('mat-context-menu-trigger-disabled');\n  }\n\n  /**\n   * Gets a list of `MatMenuItemHarness` representing the items in the menu.\n   * @param filters Optionally filters which menu items are included.\n   */\n  async getItems(\n    filters?: Omit<MenuItemHarnessFilters, 'ancestor'>,\n  ): Promise<MatMenuItemHarness[]> {\n    const panelId = await this._getPanelId();\n    if (panelId) {\n      return this._documentRootLocator.locatorForAll(\n        MatMenuItemHarness.with({\n          ...(filters || {}),\n          ancestor: `#${panelId}`,\n        } as MenuItemHarnessFilters),\n      )();\n    }\n    return [];\n  }\n\n  /**\n   * Clicks an item in the menu, and optionally continues clicking items in subsequent sub-menus.\n   * @param itemFilter A filter used to represent which item in the menu should be clicked. The\n   *     first matching menu item will be clicked.\n   * @param subItemFilters A list of filters representing the items to click in any subsequent\n   *     sub-menus. The first item in the sub-menu matching the corresponding filter in\n   *     `subItemFilters` will be clicked.\n   */\n  async clickItem(\n    itemFilter: Omit<MenuItemHarnessFilters, 'ancestor'>,\n    ...subItemFilters: Omit<MenuItemHarnessFilters, 'ancestor'>[]\n  ): Promise<void> {\n    await this.open();\n    return clickItemImplementation(await this.getItems(itemFilter), itemFilter, subItemFilters);\n  }\n\n  protected override async getRootHarnessLoader(): Promise<HarnessLoader> {\n    const panelId = await this._getPanelId();\n    return this.documentRootLocatorFactory().harnessLoaderFor(`#${panelId}`);\n  }\n\n  /** Gets the menu panel associated with this menu. */\n  private async _getMenuPanel(): Promise<TestElement | null> {\n    const panelId = await this._getPanelId();\n    return panelId ? this._documentRootLocator.locatorForOptional(`#${panelId}`)() : null;\n  }\n\n  /** Gets the id of the menu panel associated with this menu. */\n  private async _getPanelId(): Promise<string | null> {\n    const panelId = await (await this.host()).getAttribute('aria-controls');\n    return panelId || null;\n  }\n}\n"],"names":["with","options","HarnessPredicate","disabled","host","getAttribute","coerceBooleanProperty","_getMenuPanel","getTriggerText","focus","isFocused","isOpen","click","panel","getItems","filters","panelId","_getPanelId","documentRootLocatorFactory","harnessLoaderFor","_documentRootLocator","locatorForOptional","hostSelector","addOption","text","harness","stringMatches","getText","isDisabled","open","relativeX","relativeY","close","locatorForAll","MatMenuItemHarness"],"mappings":"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"}