{"version":3,"file":"input.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/input/input.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/material/input/input-module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {BooleanInput, coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {getSupportedInputTypes, Platform} from '@angular/cdk/platform';\nimport {AutofillMonitor} from '@angular/cdk/text-field';\nimport {\n  AfterViewInit,\n  booleanAttribute,\n  Directive,\n  DoCheck,\n  effect,\n  ElementRef,\n  inject,\n  InjectionToken,\n  Input,\n  isSignal,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Renderer2,\n  WritableSignal,\n} from '@angular/core';\nimport {_IdGenerator} from '@angular/cdk/a11y';\nimport {FormGroupDirective, NgControl, NgForm, Validators} from '@angular/forms';\nimport {ErrorStateMatcher, _ErrorStateTracker} from '../core';\nimport {MatFormFieldControl, MatFormField, MAT_FORM_FIELD} from '../form-field';\nimport {Subject} from 'rxjs';\nimport {getMatInputUnsupportedTypeError} from './input-errors';\nimport {MAT_INPUT_VALUE_ACCESSOR} from './input-value-accessor';\n\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\nconst MAT_INPUT_INVALID_TYPES = [\n  'button',\n  'checkbox',\n  'file',\n  'hidden',\n  'image',\n  'radio',\n  'range',\n  'reset',\n  'submit',\n];\n\n/** Object that can be used to configure the default options for the input. */\nexport interface MatInputConfig {\n  /** Whether disabled inputs should be interactive. */\n  disabledInteractive?: boolean;\n}\n\n/** Injection token that can be used to provide the default options for the input. */\nexport const MAT_INPUT_CONFIG = new InjectionToken<MatInputConfig>('MAT_INPUT_CONFIG');\n\n@Directive({\n  selector: `input[matInput], textarea[matInput], select[matNativeControl],\n      input[matNativeControl], textarea[matNativeControl]`,\n  exportAs: 'matInput',\n  host: {\n    'class': 'mat-mdc-input-element',\n    // The BaseMatInput parent class adds `mat-input-element`, `mat-form-field-control` and\n    // `mat-form-field-autofill-control` to the CSS class list, but this should not be added for\n    // this MDC equivalent input.\n    '[class.mat-input-server]': '_isServer',\n    '[class.mat-mdc-form-field-textarea-control]': '_isInFormField && _isTextarea',\n    '[class.mat-mdc-form-field-input-control]': '_isInFormField',\n    '[class.mat-mdc-input-disabled-interactive]': 'disabledInteractive',\n    '[class.mdc-text-field__input]': '_isInFormField',\n    '[class.mat-mdc-native-select-inline]': '_isInlineSelect()',\n    // Native input properties that are overwritten by Angular inputs need to be synced with\n    // the native input element. Otherwise property bindings for those don't work.\n    '[id]': 'id',\n    '[disabled]': 'disabled && !disabledInteractive',\n    '[required]': 'required',\n    '[attr.name]': 'name || null',\n    '[attr.readonly]': '_getReadonlyAttribute()',\n    '[attr.aria-disabled]': 'disabled && disabledInteractive ? \"true\" : null',\n    // Only mark the input as invalid for assistive technology if it has a value since the\n    // state usually overlaps with `aria-required` when the input is empty and can be redundant.\n    '[attr.aria-invalid]': '(empty && required) ? null : errorState',\n    '[attr.aria-required]': 'required',\n    // Native input properties that are overwritten by Angular inputs need to be synced with\n    // the native input element. Otherwise property bindings for those don't work.\n    '[attr.id]': 'id',\n    '(focus)': '_focusChanged(true)',\n    '(blur)': '_focusChanged(false)',\n    '(input)': '_onInput()',\n  },\n  providers: [{provide: MatFormFieldControl, useExisting: MatInput}],\n})\nexport class MatInput\n  implements MatFormFieldControl<any>, OnChanges, OnDestroy, AfterViewInit, DoCheck\n{\n  protected _elementRef =\n    inject<ElementRef<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>>(ElementRef);\n  protected _platform = inject(Platform);\n  ngControl = inject(NgControl, {optional: true, self: true})!;\n  private _autofillMonitor = inject(AutofillMonitor);\n  private _ngZone = inject(NgZone);\n  protected _formField? = inject<MatFormField>(MAT_FORM_FIELD, {optional: true});\n  private _renderer = inject(Renderer2);\n\n  protected _uid = inject(_IdGenerator).getId('mat-input-');\n  protected _previousNativeValue: any;\n  private _inputValueAccessor: {value: any};\n  private _signalBasedValueAccessor?: {value: WritableSignal<any>};\n  private _previousPlaceholder: string | null;\n  private _errorStateTracker: _ErrorStateTracker;\n  private _config = inject(MAT_INPUT_CONFIG, {optional: true});\n  private _cleanupIosKeyup: (() => void) | undefined;\n  private _cleanupWebkitWheel: (() => void) | undefined;\n\n  /** Whether the component is being rendered on the server. */\n  readonly _isServer: boolean;\n\n  /** Whether the component is a native html select. */\n  readonly _isNativeSelect: boolean;\n\n  /** Whether the component is a textarea. */\n  readonly _isTextarea: boolean;\n\n  /** Whether the input is inside of a form field. */\n  readonly _isInFormField: boolean;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  focused: boolean = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  readonly stateChanges: Subject<void> = new Subject<void>();\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  controlType: string = 'mat-input';\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  autofilled = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get disabled(): boolean {\n    return this._disabled;\n  }\n  set disabled(value: BooleanInput) {\n    this._disabled = coerceBooleanProperty(value);\n\n    // Browsers may not fire the blur event if the input is disabled too quickly.\n    // Reset from here to ensure that the element doesn't become stuck.\n    if (this.focused) {\n      this.focused = false;\n      this.stateChanges.next();\n    }\n  }\n  protected _disabled = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get id(): string {\n    return this._id;\n  }\n  set id(value: string) {\n    this._id = value || this._uid;\n  }\n  protected _id: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input() placeholder: string;\n\n  /**\n   * Name of the input.\n   * @docs-private\n   */\n  @Input() name: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get required(): boolean {\n    return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;\n  }\n  set required(value: BooleanInput) {\n    this._required = coerceBooleanProperty(value);\n  }\n  protected _required: boolean | undefined;\n\n  /** Input type of the element. */\n  @Input()\n  get type(): string {\n    return this._type;\n  }\n  set type(value: string) {\n    this._type = value || 'text';\n    this._validateType();\n\n    // When using Angular inputs, developers are no longer able to set the properties on the native\n    // input element. To ensure that bindings for `type` work, we need to sync the setter\n    // with the native property. Textarea elements don't support the type property or attribute.\n    if (!this._isTextarea && getSupportedInputTypes().has(this._type)) {\n      (this._elementRef.nativeElement as HTMLInputElement).type = this._type;\n    }\n  }\n  protected _type = 'text';\n\n  /** An object used to control when error messages are shown. */\n  @Input()\n  get errorStateMatcher() {\n    return this._errorStateTracker.matcher;\n  }\n  set errorStateMatcher(value: ErrorStateMatcher) {\n    this._errorStateTracker.matcher = value;\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input('aria-describedby') userAriaDescribedBy: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get value(): string {\n    return this._signalBasedValueAccessor\n      ? this._signalBasedValueAccessor.value()\n      : this._inputValueAccessor.value;\n  }\n  set value(value: any) {\n    if (value !== this.value) {\n      if (this._signalBasedValueAccessor) {\n        this._signalBasedValueAccessor.value.set(value);\n      } else {\n        this._inputValueAccessor.value = value;\n      }\n\n      this.stateChanges.next();\n    }\n  }\n\n  /** Whether the element is readonly. */\n  @Input()\n  get readonly(): boolean {\n    return this._readonly;\n  }\n  set readonly(value: BooleanInput) {\n    this._readonly = coerceBooleanProperty(value);\n  }\n  private _readonly = false;\n\n  /** Whether the input should remain interactive when it is disabled. */\n  @Input({transform: booleanAttribute})\n  disabledInteractive: boolean;\n\n  /** Whether the input is in an error state. */\n  get errorState() {\n    return this._errorStateTracker.errorState;\n  }\n  set errorState(value: boolean) {\n    this._errorStateTracker.errorState = value;\n  }\n\n  protected _neverEmptyInputTypes = [\n    'date',\n    'datetime',\n    'datetime-local',\n    'month',\n    'time',\n    'week',\n  ].filter(t => getSupportedInputTypes().has(t));\n\n  constructor(...args: unknown[]);\n\n  constructor() {\n    const parentForm = inject(NgForm, {optional: true});\n    const parentFormGroup = inject(FormGroupDirective, {optional: true});\n    const defaultErrorStateMatcher = inject(ErrorStateMatcher);\n    const accessor = inject(MAT_INPUT_VALUE_ACCESSOR, {optional: true, self: true});\n\n    const element = this._elementRef.nativeElement;\n    const nodeName = element.nodeName.toLowerCase();\n\n    if (accessor) {\n      if (isSignal(accessor.value)) {\n        this._signalBasedValueAccessor = accessor;\n      } else {\n        this._inputValueAccessor = accessor;\n      }\n    } else {\n      // If no input value accessor was explicitly specified, use the element as the input value\n      // accessor.\n      this._inputValueAccessor = element;\n    }\n\n    this._previousNativeValue = this.value;\n\n    // Force setter to be called in case id was not specified.\n    this.id = this.id;\n\n    // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n    // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n    // exists on iOS, we only bother to install the listener on iOS.\n    if (this._platform.IOS) {\n      this._ngZone.runOutsideAngular(() => {\n        this._cleanupIosKeyup = this._renderer.listen(element, 'keyup', this._iOSKeyupListener);\n      });\n    }\n\n    this._errorStateTracker = new _ErrorStateTracker(\n      defaultErrorStateMatcher,\n      this.ngControl,\n      parentFormGroup,\n      parentForm,\n      this.stateChanges,\n    );\n    this._isServer = !this._platform.isBrowser;\n    this._isNativeSelect = nodeName === 'select';\n    this._isTextarea = nodeName === 'textarea';\n    this._isInFormField = !!this._formField;\n    this.disabledInteractive = this._config?.disabledInteractive || false;\n\n    if (this._isNativeSelect) {\n      this.controlType = (element as HTMLSelectElement).multiple\n        ? 'mat-native-select-multiple'\n        : 'mat-native-select';\n    }\n\n    if (this._signalBasedValueAccessor) {\n      effect(() => {\n        // Read the value so the effect can register the dependency.\n        this._signalBasedValueAccessor!.value();\n        this.stateChanges.next();\n      });\n    }\n  }\n\n  ngAfterViewInit() {\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(event => {\n        this.autofilled = event.isAutofilled;\n        this.stateChanges.next();\n      });\n    }\n  }\n\n  ngOnChanges() {\n    this.stateChanges.next();\n  }\n\n  ngOnDestroy() {\n    this.stateChanges.complete();\n\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n    }\n\n    this._cleanupIosKeyup?.();\n    this._cleanupWebkitWheel?.();\n  }\n\n  ngDoCheck() {\n    if (this.ngControl) {\n      // We need to re-evaluate this on every change detection cycle, because there are some\n      // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n      // that whatever logic is in here has to be super lean or we risk destroying the performance.\n      this.updateErrorState();\n\n      // Since the input isn't a `ControlValueAccessor`, we don't have a good way of knowing when\n      // the disabled state has changed. We can't use the `ngControl.statusChanges`, because it\n      // won't fire if the input is disabled with `emitEvents = false`, despite the input becoming\n      // disabled.\n      if (this.ngControl.disabled !== null && this.ngControl.disabled !== this.disabled) {\n        this.disabled = this.ngControl.disabled;\n        this.stateChanges.next();\n      }\n    }\n\n    // We need to dirty-check the native element's value, because there are some cases where\n    // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n    // updating the value using `emitEvent: false`).\n    this._dirtyCheckNativeValue();\n\n    // We need to dirty-check and set the placeholder attribute ourselves, because whether it's\n    // present or not depends on a query which is prone to \"changed after checked\" errors.\n    this._dirtyCheckPlaceholder();\n  }\n\n  /** Focuses the input. */\n  focus(options?: FocusOptions): void {\n    this._elementRef.nativeElement.focus(options);\n  }\n\n  /** Refreshes the error state of the input. */\n  updateErrorState() {\n    this._errorStateTracker.updateErrorState();\n  }\n\n  /** Callback for the cases where the focused state of the input changes. */\n  _focusChanged(isFocused: boolean) {\n    if (isFocused === this.focused) {\n      return;\n    }\n\n    if (!this._isNativeSelect && isFocused && this.disabled && this.disabledInteractive) {\n      const element = this._elementRef.nativeElement as HTMLInputElement;\n\n      // Focusing an input that has text will cause all the text to be selected. Clear it since\n      // the user won't be able to change it. This is based on the internal implementation.\n      if (element.type === 'number') {\n        // setSelectionRange doesn't work on number inputs so it needs to be set briefly to text.\n        element.type = 'text';\n        element.setSelectionRange(0, 0);\n        element.type = 'number';\n      } else {\n        element.setSelectionRange(0, 0);\n      }\n    }\n\n    this.focused = isFocused;\n    this.stateChanges.next();\n  }\n\n  _onInput() {\n    // This is a noop function and is used to let Angular know whenever the value changes.\n    // Angular will run a new change detection each time the `input` event has been dispatched.\n    // It's necessary that Angular recognizes the value change, because when floatingLabel\n    // is set to false and Angular forms aren't used, the placeholder won't recognize the\n    // value changes and will not disappear.\n    // Listening to the input event wouldn't be necessary when the input is using the\n    // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n  }\n\n  /** Does some manual dirty checking on the native input `value` property. */\n  protected _dirtyCheckNativeValue() {\n    const newValue = this._elementRef.nativeElement.value;\n\n    if (this._previousNativeValue !== newValue) {\n      this._previousNativeValue = newValue;\n      this.stateChanges.next();\n    }\n  }\n\n  /** Does some manual dirty checking on the native input `placeholder` attribute. */\n  private _dirtyCheckPlaceholder() {\n    const placeholder = this._getPlaceholder();\n    if (placeholder !== this._previousPlaceholder) {\n      const element = this._elementRef.nativeElement;\n      this._previousPlaceholder = placeholder;\n      placeholder\n        ? element.setAttribute('placeholder', placeholder)\n        : element.removeAttribute('placeholder');\n    }\n  }\n\n  /** Gets the current placeholder of the form field. */\n  protected _getPlaceholder(): string | null {\n    return this.placeholder || null;\n  }\n\n  /** Make sure the input is a supported type. */\n  protected _validateType() {\n    if (\n      MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1 &&\n      (typeof ngDevMode === 'undefined' || ngDevMode)\n    ) {\n      throw getMatInputUnsupportedTypeError(this._type);\n    }\n  }\n\n  /** Checks whether the input type is one of the types that are never empty. */\n  protected _isNeverEmpty() {\n    return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n  }\n\n  /** Checks whether the input is invalid based on the native validation. */\n  protected _isBadInput() {\n    // The `validity` property won't be present on platform-server.\n    let validity = (this._elementRef.nativeElement as HTMLInputElement).validity;\n    return validity && validity.badInput;\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get empty(): boolean {\n    return (\n      !this._isNeverEmpty() &&\n      !this._elementRef.nativeElement.value &&\n      !this._isBadInput() &&\n      !this.autofilled\n    );\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get shouldLabelFloat(): boolean {\n    if (this._isNativeSelect) {\n      // For a single-selection `<select>`, the label should float when the selected option has\n      // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n      // overlapping the label with the options.\n      const selectElement = this._elementRef.nativeElement as HTMLSelectElement;\n      const firstOption: HTMLOptionElement | undefined = selectElement.options[0];\n\n      // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n      // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n      return (\n        this.focused ||\n        selectElement.multiple ||\n        !this.empty ||\n        !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label)\n      );\n    } else {\n      return (this.focused && !this.disabled) || !this.empty;\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get describedByIds(): string[] {\n    const element = this._elementRef.nativeElement;\n    const existingDescribedBy = element.getAttribute('aria-describedby');\n\n    return existingDescribedBy?.split(' ') || [];\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  setDescribedByIds(ids: string[]) {\n    const element = this._elementRef.nativeElement;\n\n    if (ids.length) {\n      element.setAttribute('aria-describedby', ids.join(' '));\n    } else {\n      element.removeAttribute('aria-describedby');\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  onContainerClick() {\n    // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n    // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n    // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n    if (!this.focused) {\n      this.focus();\n    }\n  }\n\n  /** Whether the form control is a native select that is displayed inline. */\n  _isInlineSelect(): boolean {\n    const element = this._elementRef.nativeElement as HTMLSelectElement;\n    return this._isNativeSelect && (element.multiple || element.size > 1);\n  }\n\n  private _iOSKeyupListener = (event: Event): void => {\n    const el = event.target as HTMLInputElement;\n\n    // Note: We specifically check for 0, rather than `!el.selectionStart`, because the two\n    // indicate different things. If the value is 0, it means that the caret is at the start\n    // of the input, whereas a value of `null` means that the input doesn't support\n    // manipulating the selection range. Inputs that don't support setting the selection range\n    // will throw an error so we want to avoid calling `setSelectionRange` on them. See:\n    // https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n    if (!el.value && el.selectionStart === 0 && el.selectionEnd === 0) {\n      // Note: Just setting `0, 0` doesn't fix the issue. Setting\n      // `1, 1` fixes it for the first time that you type text and\n      // then hold delete. Toggling to `1, 1` and then back to\n      // `0, 0` seems to completely fix it.\n      el.setSelectionRange(1, 1);\n      el.setSelectionRange(0, 0);\n    }\n  };\n\n  /** Gets the value to set on the `readonly` attribute. */\n  protected _getReadonlyAttribute(): string | null {\n    if (this._isNativeSelect) {\n      return null;\n    }\n\n    if (this.readonly || (this.disabled && this.disabledInteractive)) {\n      return 'true';\n    }\n\n    return null;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {BidiModule} from '@angular/cdk/bidi';\nimport {TextFieldModule} from '@angular/cdk/text-field';\nimport {NgModule} from '@angular/core';\nimport {MatFormFieldModule} from '../form-field';\nimport {MatInput} from './input';\n\n@NgModule({\n  imports: [MatFormFieldModule, MatInput],\n  exports: [MatInput, MatFormFieldModule, TextFieldModule, BidiModule],\n})\nexport class MatInputModule {}\n"],"names":["MAT_INPUT_INVALID_TYPES","MAT_INPUT_CONFIG","InjectionToken","MatInput","_elementRef","inject","ElementRef","Platform","ngControl","NgControl","optional","self","_formField","MAT_FORM_FIELD","Renderer2","_uid","_IdGenerator","getId","_previousNativeValue","_previousPlaceholder","_errorStateTracker","_config","_cleanupWebkitWheel","_isServer","_isTextarea","focused","id","value","_required","control","hasValidator","Validators","required","_type","type","_validateType","getSupportedInputTypes","has","nativeElement","errorStateMatcher","matcher","_signalBasedValueAccessor","_inputValueAccessor","set","stateChanges","next","_readonly","readonly","coerceBooleanProperty","errorState","filter","t","constructor","parentForm","NgForm","parentFormGroup","FormGroupDirective","defaultErrorStateMatcher","ErrorStateMatcher","accessor","MAT_INPUT_VALUE_ACCESSOR","element","nodeName","toLowerCase","_ngZone","runOutsideAngular","_iOSKeyupListener","_platform","isBrowser","_isNativeSelect","disabledInteractive","controlType","multiple","effect","ngAfterViewInit","_autofillMonitor","monitor","subscribe","event","autofilled","isAutofilled","ngOnChanges","complete","stopMonitoring","_cleanupIosKeyup","updateErrorState","disabled","_dirtyCheckPlaceholder","focus","options","_focusChanged","isFocused","setSelectionRange","_dirtyCheckNativeValue","newValue","placeholder","setAttribute","removeAttribute","indexOf","ngDevMode","getMatInputUnsupportedTypeError","_isNeverEmpty","_neverEmptyInputTypes","_isBadInput","validity","badInput","ctorParameters","Input","transform","booleanAttribute","MatInputModule","ɵmod","i0","ɵɵngDeclareNgModule","minVersion","version","ngImport","imports","MatFormFieldModule","exports","TextFieldModule","BidiModule","decorators"],"mappings":"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"}