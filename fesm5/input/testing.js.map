{"version":3,"file":"input__testing.js","sources":["../../../../../../../src/material/input/testing/input-harness.ts","../../../../../../../src/material/input/testing/public-api.ts","../../../../../../../src/material/input/testing/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {HarnessPredicate} from '@angular/cdk/testing';\nimport {MatFormFieldControlHarness} from '@angular/material/form-field/testing/control';\nimport {InputHarnessFilters} from './input-harness-filters';\n\n/** Harness for interacting with a standard Material inputs in tests. */\nexport class MatInputHarness extends MatFormFieldControlHarness {\n  // TODO: We do not want to handle `select` elements with `matNativeControl` because\n  // not all methods of this harness work reasonably for native select elements.\n  // For more details. See: https://github.com/angular/components/pull/18221.\n  static hostSelector = '[matInput], input[matNativeControl], textarea[matNativeControl]';\n\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a `MatInputHarness` that meets\n   * certain criteria.\n   * @param options Options for filtering which input instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with(options: InputHarnessFilters = {}): HarnessPredicate<MatInputHarness> {\n    return new HarnessPredicate(MatInputHarness, options)\n        .addOption('value', options.value, async (harness, value) => {\n          return (await harness.getValue()) === value;\n        })\n        .addOption('placeholder', options.placeholder, async (harness, placeholder) => {\n          return (await harness.getPlaceholder()) === placeholder;\n        });\n  }\n\n  /** Whether the input is disabled. */\n  async isDisabled(): Promise<boolean> {\n    return (await this.host()).getProperty('disabled')!;\n  }\n\n  /** Whether the input is required. */\n  async isRequired(): Promise<boolean> {\n    return (await this.host()).getProperty('required')!;\n  }\n\n  /** Whether the input is readonly. */\n  async isReadonly(): Promise<boolean> {\n    return (await this.host()).getProperty('readOnly')!;\n  }\n\n  /** Gets the value of the input. */\n  async getValue(): Promise<string> {\n    // The \"value\" property of the native input is never undefined.\n    return (await (await this.host()).getProperty('value'))!;\n  }\n\n  /** Gets the name of the input. */\n  async getName(): Promise<string> {\n    // The \"name\" property of the native input is never undefined.\n    return (await (await this.host()).getProperty('name'))!;\n  }\n\n  /**\n   * Gets the type of the input. Returns \"textarea\" if the input is\n   * a textarea.\n   */\n  async getType(): Promise<string> {\n    // The \"type\" property of the native input is never undefined.\n    return (await (await this.host()).getProperty('type'))!;\n  }\n\n  /** Gets the placeholder of the input. */\n  async getPlaceholder(): Promise<string> {\n    // The \"placeholder\" property of the native input is never undefined.\n    return (await (await this.host()).getProperty('placeholder'))!;\n  }\n\n  /** Gets the id of the input. */\n  async getId(): Promise<string> {\n    // The input directive always assigns a unique id to the input in\n    // case no id has been explicitly specified.\n    return (await (await this.host()).getProperty('id'))!;\n  }\n\n  /**\n   * Focuses the input and returns a promise that indicates when the\n   * action is complete.\n   */\n  async focus(): Promise<void> {\n    return (await this.host()).focus();\n  }\n\n  /**\n   * Blurs the input and returns a promise that indicates when the\n   * action is complete.\n   */\n  async blur(): Promise<void> {\n    return (await this.host()).blur();\n  }\n\n  /**\n   * Sets the value of the input. The value will be set by simulating\n   * keypresses that correspond to the given value.\n   */\n  async setValue(newValue: string): Promise<void> {\n    const inputEl = await this.host();\n    await inputEl.clear();\n    // We don't want to send keys for the value if the value is an empty\n    // string in order to clear the value. Sending keys with an empty string\n    // still results in unnecessary focus events.\n    if (newValue) {\n      await inputEl.sendKeys(newValue);\n    }\n\n    // Some input types won't respond to key presses (e.g. `color`) so to be sure that the\n    // value is set, we also set the property after the keyboard sequence. Note that we don't\n    // want to do it before, because it can cause the value to be entered twice.\n    // @breaking-change 11.0.0 Remove non-null assertion once `setInputValue` is required.\n    if (inputEl.setInputValue) {\n      await inputEl.setInputValue(newValue);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport * from './input-harness';\nexport * from './input-harness-filters';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":"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"}