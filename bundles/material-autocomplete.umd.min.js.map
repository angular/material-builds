{"version":3,"sources":["src/material/material-autocomplete.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","material","autocomplete","cdk","a11y","coercion","core","rxjs","common","overlay","bidi","keycodes","platform","portal","scrolling","forms","formField","operators","this","core$1","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","_uniqueAutocompleteIdCounter","MatAutocompleteSelectedEvent","source","option","_MatAutocompleteMixinBase","mixinDisableRipple","MatAutocompleteBase","MAT_AUTOCOMPLETE_DEFAULT_OPTIONS","InjectionToken","providedIn","MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY","autoActiveFirstOption","MatAutocomplete","_super","_changeDetectorRef","_elementRef","defaults","_this","_activeOptionChanges","Subscription","EMPTY","showPanel","_isOpen","displayWith","optionSelected","EventEmitter","opened","closed","optionActivated","_classList","id","_autoActiveFirstOption","__extends","__","constructor","prototype","create","defineProperty","get","enumerable","configurable","set","coerceBooleanProperty","length","split","reduce","classList","className","trim","_setVisibilityClasses","nativeElement","ngAfterContentInit","_keyManager","ActiveDescendantKeyManager","options","withWrap","change","subscribe","index","emit","toArray","_setVisibility","ngOnDestroy","unsubscribe","_setScrollTop","scrollTop","panel","_getScrollTop","markForCheck","_emitSelectEvent","event","decorators","type","Component","args","selector","template","encapsulation","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","exportAs","inputs","host","class","providers","provide","MAT_OPTION_PARENT_COMPONENT","useExisting","styles","ctorParameters","ChangeDetectorRef","ElementRef","undefined","Inject","propDecorators","ViewChild","TemplateRef","static","ContentChildren","MatOption","descendants","optionGroups","MatOptgroup","Input","panelWidth","Output","MatAutocompleteOrigin","elementRef","Directive","MAT_AUTOCOMPLETE_SCROLL_STRATEGY","MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY","scrollStrategies","reposition","MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER","deps","Overlay","useFactory","MAT_AUTOCOMPLETE_VALUE_ACCESSOR","NG_VALUE_ACCESSOR","forwardRef","MatAutocompleteTrigger","multi","getMatAutocompleteMissingPanelError","Error","_element","_overlay","_viewContainerRef","_zone","scrollStrategy","_dir","_formField","_document","_viewportRuler","_componentDestroyed","_autocompleteDisabled","_manuallyFloatingLabel","_viewportSubscription","_canOpenOnNextFocus","_closeKeyEventStream","Subject","_windowBlurHandler","activeElement","panelOpen","_onChange","_onTouched","position","autocompleteAttribute","_overlayAttached","optionSelections","defer","merge","apply","__spread","arguments","concat","map","onSelectionChange","onStable","asObservable","pipe","take","switchMap","_scrollStrategy","ngAfterViewInit","window","runOutsideAngular","addEventListener","_supportsShadowDom","element","rootNode","getRootNode","_isInsideShadowRoot","ShadowRoot","ngOnChanges","changes","_positionStrategy","_setStrategyPositions","_overlayRef","updatePosition","removeEventListener","_destroyPanel","complete","openPanel","_attachOverlay","_floatLabel","closePanel","_resetLabel","hasAttached","detach","_closingActionsSubscription","detectChanges","tabOut","filter","_getOutsideClickStream","detachments","of","MatOptionSelectionChange","activeItem","fromEvent","clickTarget","composedPath","target","contains","overlayElement","writeValue","Promise","resolve","then","_setTriggerValue","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","disabled","_handleKeydown","keyCode","ESCAPE","preventDefault","activeOption","ENTER","_selectViaInteraction","_resetActiveItem","prevActiveItem","isArrowKey","UP_ARROW","DOWN_ARROW","TAB","onKeydown","_canOpen","_scrollToOption","_handleInput","parseFloat","_previousValue","_handleFocus","shouldAnimate","floatLabel","_animateAndLockLabel","activeItemIndex","labelCount","_countGroupLabelsBeforeOption","newScrollPosition","_getOptionScrollPosition","_subscribeToClosingActions","firstStable","optionChanges","tap","reapplyLastPosition","delay","wasOpen","panelClosingActions","_setValueAndClose","dispose","toDisplay","inputValue","_control","_clearPreviousSelectedOption","focus","skip","forEach","selected","deselect","overlayRef","setOrigin","_getConnectedElement","updateSize","width","_getPanelWidth","_portal","TemplatePortal","_getOverlayConfig","keydownEvents","altKey","stopPropagation","attach","OverlayConfig","positionStrategy","_getOverlayPosition","direction","strategy","flexibleConnectedTo","withFlexibleDimensions","withPush","belowPosition","originX","originY","overlayX","overlayY","abovePosition","panelClass","withPositions","connectedTo","getConnectedOverlayOrigin","_getHostWidth","getBoundingClientRect","setActiveItem","readOnly","[attr.autocomplete]","[attr.role]","[attr.aria-autocomplete]","[attr.aria-activedescendant]","[attr.aria-expanded]","[attr.aria-owns]","[attr.aria-haspopup]","(focusin)","(blur)","(input)","(keydown)","ViewContainerRef","NgZone","Directionality","Optional","MatFormField","Host","DOCUMENT","ViewportRuler","autocompleteDisabled","MatAutocompleteModule","NgModule","imports","MatOptionModule","OverlayModule","MatCommonModule","CommonModule","declarations","AUTOCOMPLETE_OPTION_HEIGHT","AUTOCOMPLETE_PANEL_HEIGHT"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/cdk/a11y'), require('@angular/cdk/coercion'), require('@angular/core'), require('@angular/material/core'), require('rxjs'), require('@angular/common'), require('@angular/cdk/overlay'), require('@angular/cdk/bidi'), require('@angular/cdk/keycodes'), require('@angular/cdk/platform'), require('@angular/cdk/portal'), require('@angular/cdk/scrolling'), require('@angular/forms'), require('@angular/material/form-field'), require('rxjs/operators')) :\n    typeof define === 'function' && define.amd ? define('@angular/material/autocomplete', ['exports', '@angular/cdk/a11y', '@angular/cdk/coercion', '@angular/core', '@angular/material/core', 'rxjs', '@angular/common', '@angular/cdk/overlay', '@angular/cdk/bidi', '@angular/cdk/keycodes', '@angular/cdk/platform', '@angular/cdk/portal', '@angular/cdk/scrolling', '@angular/forms', '@angular/material/form-field', 'rxjs/operators'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.autocomplete = {}), global.ng.cdk.a11y, global.ng.cdk.coercion, global.ng.core, global.ng.material.core, global.rxjs, global.ng.common, global.ng.cdk.overlay, global.ng.cdk.bidi, global.ng.cdk.keycodes, global.ng.cdk.platform, global.ng.cdk.portal, global.ng.cdk.scrolling, global.ng.forms, global.ng.material.formField, global.rxjs.operators));\n}(this, (function (exports, a11y, coercion, core, core$1, rxjs, common, overlay, bidi, keycodes, platform, portal, scrolling, forms, formField, operators) { 'use strict';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation. All rights reserved.\r\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n    this file except in compliance with the License. You may obtain a copy of the\r\n    License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n    MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n    and limitations under the License.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = function(d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n\r\n    function __extends(d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\r\n\r\n    function __rest(s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                    t[p[i]] = s[p[i]];\r\n            }\r\n        return t;\r\n    }\r\n\r\n    function __decorate(decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    }\r\n\r\n    function __param(paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    }\r\n\r\n    function __metadata(metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    }\r\n\r\n    function __awaiter(thisArg, _arguments, P, generator) {\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    }\r\n\r\n    function __generator(thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    }\r\n\r\n    function __exportStar(m, exports) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    }\r\n\r\n    function __values(o) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n        if (m) return m.call(o);\r\n        return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n    }\r\n\r\n    function __read(o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    }\r\n\r\n    function __spread() {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    }\r\n\r\n    function __spreadArrays() {\r\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n                r[k] = a[j];\r\n        return r;\r\n    };\r\n\r\n    function __await(v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    }\r\n\r\n    function __asyncGenerator(thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n    }\r\n\r\n    function __asyncDelegator(o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n    }\r\n\r\n    function __asyncValues(o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator], i;\r\n        return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n    }\r\n\r\n    function __makeTemplateObject(cooked, raw) {\r\n        if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n        return cooked;\r\n    };\r\n\r\n    function __importStar(mod) {\r\n        if (mod && mod.__esModule) return mod;\r\n        var result = {};\r\n        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n        result.default = mod;\r\n        return result;\r\n    }\r\n\r\n    function __importDefault(mod) {\r\n        return (mod && mod.__esModule) ? mod : { default: mod };\r\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Autocomplete IDs need to be unique across components, so this counter exists outside of\n     * the component definition.\n     */\n    var _uniqueAutocompleteIdCounter = 0;\n    /** Event object that is emitted when an autocomplete option is selected. */\n    var MatAutocompleteSelectedEvent = /** @class */ (function () {\n        function MatAutocompleteSelectedEvent(\n        /** Reference to the autocomplete panel that emitted the event. */\n        source, \n        /** Option that was selected. */\n        option) {\n            this.source = source;\n            this.option = option;\n        }\n        return MatAutocompleteSelectedEvent;\n    }());\n    // Boilerplate for applying mixins to MatAutocomplete.\n    /** @docs-private */\n    var MatAutocompleteBase = /** @class */ (function () {\n        function MatAutocompleteBase() {\n        }\n        return MatAutocompleteBase;\n    }());\n    var _MatAutocompleteMixinBase = core$1.mixinDisableRipple(MatAutocompleteBase);\n    /** Injection token to be used to override the default options for `mat-autocomplete`. */\n    var MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new core.InjectionToken('mat-autocomplete-default-options', {\n        providedIn: 'root',\n        factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY,\n    });\n    /** @docs-private */\n    function MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {\n        return { autoActiveFirstOption: false };\n    }\n    var MatAutocomplete = /** @class */ (function (_super) {\n        __extends(MatAutocomplete, _super);\n        function MatAutocomplete(_changeDetectorRef, _elementRef, defaults) {\n            var _this = _super.call(this) || this;\n            _this._changeDetectorRef = _changeDetectorRef;\n            _this._elementRef = _elementRef;\n            _this._activeOptionChanges = rxjs.Subscription.EMPTY;\n            /** Whether the autocomplete panel should be visible, depending on option length. */\n            _this.showPanel = false;\n            _this._isOpen = false;\n            /** Function that maps an option's control value to its display value in the trigger. */\n            _this.displayWith = null;\n            /** Event that is emitted whenever an option from the list is selected. */\n            _this.optionSelected = new core.EventEmitter();\n            /** Event that is emitted when the autocomplete panel is opened. */\n            _this.opened = new core.EventEmitter();\n            /** Event that is emitted when the autocomplete panel is closed. */\n            _this.closed = new core.EventEmitter();\n            /** Emits whenever an option is activated using the keyboard. */\n            _this.optionActivated = new core.EventEmitter();\n            _this._classList = {};\n            /** Unique ID to be used by autocomplete trigger's \"aria-owns\" property. */\n            _this.id = \"mat-autocomplete-\" + _uniqueAutocompleteIdCounter++;\n            _this._autoActiveFirstOption = !!defaults.autoActiveFirstOption;\n            return _this;\n        }\n        Object.defineProperty(MatAutocomplete.prototype, \"isOpen\", {\n            /** Whether the autocomplete panel is open. */\n            get: function () { return this._isOpen && this.showPanel; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatAutocomplete.prototype, \"autoActiveFirstOption\", {\n            /**\n             * Whether the first option should be highlighted when the autocomplete panel is opened.\n             * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\n             */\n            get: function () { return this._autoActiveFirstOption; },\n            set: function (value) {\n                this._autoActiveFirstOption = coercion.coerceBooleanProperty(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatAutocomplete.prototype, \"classList\", {\n            /**\n             * Takes classes set on the host mat-autocomplete element and applies them to the panel\n             * inside the overlay container to allow for easy styling.\n             */\n            set: function (value) {\n                if (value && value.length) {\n                    this._classList = value.split(' ').reduce(function (classList, className) {\n                        classList[className.trim()] = true;\n                        return classList;\n                    }, {});\n                }\n                else {\n                    this._classList = {};\n                }\n                this._setVisibilityClasses(this._classList);\n                this._elementRef.nativeElement.className = '';\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MatAutocomplete.prototype.ngAfterContentInit = function () {\n            var _this = this;\n            this._keyManager = new a11y.ActiveDescendantKeyManager(this.options).withWrap();\n            this._activeOptionChanges = this._keyManager.change.subscribe(function (index) {\n                _this.optionActivated.emit({ source: _this, option: _this.options.toArray()[index] || null });\n            });\n            // Set the initial visibility state.\n            this._setVisibility();\n        };\n        MatAutocomplete.prototype.ngOnDestroy = function () {\n            this._activeOptionChanges.unsubscribe();\n        };\n        /**\n         * Sets the panel scrollTop. This allows us to manually scroll to display options\n         * above or below the fold, as they are not actually being focused when active.\n         */\n        MatAutocomplete.prototype._setScrollTop = function (scrollTop) {\n            if (this.panel) {\n                this.panel.nativeElement.scrollTop = scrollTop;\n            }\n        };\n        /** Returns the panel's scrollTop. */\n        MatAutocomplete.prototype._getScrollTop = function () {\n            return this.panel ? this.panel.nativeElement.scrollTop : 0;\n        };\n        /** Panel should hide itself when the option list is empty. */\n        MatAutocomplete.prototype._setVisibility = function () {\n            this.showPanel = !!this.options.length;\n            this._setVisibilityClasses(this._classList);\n            this._changeDetectorRef.markForCheck();\n        };\n        /** Emits the `select` event. */\n        MatAutocomplete.prototype._emitSelectEvent = function (option) {\n            var event = new MatAutocompleteSelectedEvent(this, option);\n            this.optionSelected.emit(event);\n        };\n        /** Sets the autocomplete visibility classes on a classlist based on the panel is visible. */\n        MatAutocomplete.prototype._setVisibilityClasses = function (classList) {\n            classList['mat-autocomplete-visible'] = this.showPanel;\n            classList['mat-autocomplete-hidden'] = !this.showPanel;\n        };\n        MatAutocomplete.decorators = [\n            { type: core.Component, args: [{\n                        selector: 'mat-autocomplete',\n                        template: \"<ng-template>\\n  <div class=\\\"mat-autocomplete-panel\\\" role=\\\"listbox\\\" [id]=\\\"id\\\" [ngClass]=\\\"_classList\\\" #panel>\\n    <ng-content></ng-content>\\n  </div>\\n</ng-template>\\n\",\n                        encapsulation: core.ViewEncapsulation.None,\n                        changeDetection: core.ChangeDetectionStrategy.OnPush,\n                        exportAs: 'matAutocomplete',\n                        inputs: ['disableRipple'],\n                        host: {\n                            'class': 'mat-autocomplete'\n                        },\n                        providers: [\n                            { provide: core$1.MAT_OPTION_PARENT_COMPONENT, useExisting: MatAutocomplete }\n                        ],\n                        styles: [\".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}.cdk-high-contrast-active .mat-autocomplete-panel{outline:solid 1px}\\n\"]\n                    }] }\n        ];\n        /** @nocollapse */\n        MatAutocomplete.ctorParameters = function () { return [\n            { type: core.ChangeDetectorRef },\n            { type: core.ElementRef },\n            { type: undefined, decorators: [{ type: core.Inject, args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,] }] }\n        ]; };\n        MatAutocomplete.propDecorators = {\n            template: [{ type: core.ViewChild, args: [core.TemplateRef, { static: true },] }],\n            panel: [{ type: core.ViewChild, args: ['panel',] }],\n            options: [{ type: core.ContentChildren, args: [core$1.MatOption, { descendants: true },] }],\n            optionGroups: [{ type: core.ContentChildren, args: [core$1.MatOptgroup, { descendants: true },] }],\n            displayWith: [{ type: core.Input }],\n            autoActiveFirstOption: [{ type: core.Input }],\n            panelWidth: [{ type: core.Input }],\n            optionSelected: [{ type: core.Output }],\n            opened: [{ type: core.Output }],\n            closed: [{ type: core.Output }],\n            optionActivated: [{ type: core.Output }],\n            classList: [{ type: core.Input, args: ['class',] }]\n        };\n        return MatAutocomplete;\n    }(_MatAutocompleteMixinBase));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Directive applied to an element to make it usable\n     * as a connection point for an autocomplete panel.\n     */\n    var MatAutocompleteOrigin = /** @class */ (function () {\n        function MatAutocompleteOrigin(\n        /** Reference to the element on which the directive is applied. */\n        elementRef) {\n            this.elementRef = elementRef;\n        }\n        MatAutocompleteOrigin.decorators = [\n            { type: core.Directive, args: [{\n                        selector: '[matAutocompleteOrigin]',\n                        exportAs: 'matAutocompleteOrigin',\n                    },] }\n        ];\n        /** @nocollapse */\n        MatAutocompleteOrigin.ctorParameters = function () { return [\n            { type: core.ElementRef }\n        ]; };\n        return MatAutocompleteOrigin;\n    }());\n\n    /**\n     * The following style constants are necessary to save here in order\n     * to properly calculate the scrollTop of the panel. Because we are not\n     * actually focusing the active item, scroll must be handled manually.\n     */\n    /** The height of each autocomplete option. */\n    var AUTOCOMPLETE_OPTION_HEIGHT = 48;\n    /** The total height of the autocomplete panel. */\n    var AUTOCOMPLETE_PANEL_HEIGHT = 256;\n    /** Injection token that determines the scroll handling while the autocomplete panel is open. */\n    var MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new core.InjectionToken('mat-autocomplete-scroll-strategy');\n    /** @docs-private */\n    function MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay) {\n        return function () { return overlay.scrollStrategies.reposition(); };\n    }\n    /** @docs-private */\n    var MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n        provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,\n        deps: [overlay.Overlay],\n        useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY,\n    };\n    /**\n     * Provider that allows the autocomplete to register as a ControlValueAccessor.\n     * @docs-private\n     */\n    var MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {\n        provide: forms.NG_VALUE_ACCESSOR,\n        useExisting: core.forwardRef(function () { return MatAutocompleteTrigger; }),\n        multi: true\n    };\n    /**\n     * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n     * @docs-private\n     */\n    function getMatAutocompleteMissingPanelError() {\n        return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' +\n            'Make sure that the id passed to the `matAutocomplete` is correct and that ' +\n            'you\\'re attempting to open it after the ngAfterContentInit hook.');\n    }\n    var MatAutocompleteTrigger = /** @class */ (function () {\n        function MatAutocompleteTrigger(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, \n        // @breaking-change 8.0.0 Make `_viewportRuler` required.\n        _viewportRuler) {\n            var _this = this;\n            this._element = _element;\n            this._overlay = _overlay;\n            this._viewContainerRef = _viewContainerRef;\n            this._zone = _zone;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._dir = _dir;\n            this._formField = _formField;\n            this._document = _document;\n            this._viewportRuler = _viewportRuler;\n            this._componentDestroyed = false;\n            this._autocompleteDisabled = false;\n            /** Whether or not the label state is being overridden. */\n            this._manuallyFloatingLabel = false;\n            /** Subscription to viewport size changes. */\n            this._viewportSubscription = rxjs.Subscription.EMPTY;\n            /**\n             * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n             * closed autocomplete from being reopened if the user switches to another browser tab and then\n             * comes back.\n             */\n            this._canOpenOnNextFocus = true;\n            /** Stream of keyboard events that can close the panel. */\n            this._closeKeyEventStream = new rxjs.Subject();\n            /**\n             * Event handler for when the window is blurred. Needs to be an\n             * arrow function in order to preserve the context.\n             */\n            this._windowBlurHandler = function () {\n                // If the user blurred the window while the autocomplete is focused, it means that it'll be\n                // refocused when they come back. In this case we want to skip the first focus event, if the\n                // pane was closed, in order to avoid reopening it unintentionally.\n                _this._canOpenOnNextFocus =\n                    _this._document.activeElement !== _this._element.nativeElement || _this.panelOpen;\n            };\n            /** `View -> model callback called when value changes` */\n            this._onChange = function () { };\n            /** `View -> model callback called when autocomplete has been touched` */\n            this._onTouched = function () { };\n            /**\n             * Position of the autocomplete panel relative to the trigger element. A position of `auto`\n             * will render the panel underneath the trigger if there is enough space for it to fit in\n             * the viewport, otherwise the panel will be shown above it. If the position is set to\n             * `above` or `below`, the panel will always be shown above or below the trigger. no matter\n             * whether it fits completely in the viewport.\n             */\n            this.position = 'auto';\n            /**\n             * `autocomplete` attribute to be set on the input element.\n             * @docs-private\n             */\n            this.autocompleteAttribute = 'off';\n            this._overlayAttached = false;\n            /** Stream of autocomplete option selections. */\n            this.optionSelections = rxjs.defer(function () {\n                if (_this.autocomplete && _this.autocomplete.options) {\n                    return rxjs.merge.apply(void 0, __spread(_this.autocomplete.options.map(function (option) { return option.onSelectionChange; })));\n                }\n                // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n                // Return a stream that we'll replace with the real one once everything is in place.\n                return _this._zone.onStable\n                    .asObservable()\n                    .pipe(operators.take(1), operators.switchMap(function () { return _this.optionSelections; }));\n            });\n            this._scrollStrategy = scrollStrategy;\n        }\n        Object.defineProperty(MatAutocompleteTrigger.prototype, \"autocompleteDisabled\", {\n            /**\n             * Whether the autocomplete is disabled. When disabled, the element will\n             * act as a regular input and the user won't be able to open the panel.\n             */\n            get: function () { return this._autocompleteDisabled; },\n            set: function (value) {\n                this._autocompleteDisabled = coercion.coerceBooleanProperty(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MatAutocompleteTrigger.prototype.ngAfterViewInit = function () {\n            var _this = this;\n            if (typeof window !== 'undefined') {\n                this._zone.runOutsideAngular(function () {\n                    window.addEventListener('blur', _this._windowBlurHandler);\n                });\n                if (platform._supportsShadowDom()) {\n                    var element = this._element.nativeElement;\n                    var rootNode = element.getRootNode ? element.getRootNode() : null;\n                    // We need to take the `ShadowRoot` off of `window`, because the built-in types are\n                    // incorrect. See https://github.com/Microsoft/TypeScript/issues/27929.\n                    this._isInsideShadowRoot = rootNode instanceof window.ShadowRoot;\n                }\n            }\n        };\n        MatAutocompleteTrigger.prototype.ngOnChanges = function (changes) {\n            if (changes['position'] && this._positionStrategy) {\n                this._setStrategyPositions(this._positionStrategy);\n                if (this.panelOpen) {\n                    this._overlayRef.updatePosition();\n                }\n            }\n        };\n        MatAutocompleteTrigger.prototype.ngOnDestroy = function () {\n            if (typeof window !== 'undefined') {\n                window.removeEventListener('blur', this._windowBlurHandler);\n            }\n            this._viewportSubscription.unsubscribe();\n            this._componentDestroyed = true;\n            this._destroyPanel();\n            this._closeKeyEventStream.complete();\n        };\n        Object.defineProperty(MatAutocompleteTrigger.prototype, \"panelOpen\", {\n            /** Whether or not the autocomplete panel is open. */\n            get: function () {\n                return this._overlayAttached && this.autocomplete.showPanel;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** Opens the autocomplete suggestion panel. */\n        MatAutocompleteTrigger.prototype.openPanel = function () {\n            this._attachOverlay();\n            this._floatLabel();\n        };\n        /** Closes the autocomplete suggestion panel. */\n        MatAutocompleteTrigger.prototype.closePanel = function () {\n            this._resetLabel();\n            if (!this._overlayAttached) {\n                return;\n            }\n            if (this.panelOpen) {\n                // Only emit if the panel was visible.\n                this.autocomplete.closed.emit();\n            }\n            this.autocomplete._isOpen = this._overlayAttached = false;\n            if (this._overlayRef && this._overlayRef.hasAttached()) {\n                this._overlayRef.detach();\n                this._closingActionsSubscription.unsubscribe();\n            }\n            // Note that in some cases this can end up being called after the component is destroyed.\n            // Add a check to ensure that we don't try to run change detection on a destroyed view.\n            if (!this._componentDestroyed) {\n                // We need to trigger change detection manually, because\n                // `fromEvent` doesn't seem to do it at the proper time.\n                // This ensures that the label is reset when the\n                // user clicks outside.\n                this._changeDetectorRef.detectChanges();\n            }\n        };\n        /**\n         * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n         * within the viewport.\n         */\n        MatAutocompleteTrigger.prototype.updatePosition = function () {\n            if (this._overlayAttached) {\n                this._overlayRef.updatePosition();\n            }\n        };\n        Object.defineProperty(MatAutocompleteTrigger.prototype, \"panelClosingActions\", {\n            /**\n             * A stream of actions that should close the autocomplete panel, including\n             * when an option is selected, on blur, and when TAB is pressed.\n             */\n            get: function () {\n                var _this = this;\n                return rxjs.merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(operators.filter(function () { return _this._overlayAttached; })), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ?\n                    this._overlayRef.detachments().pipe(operators.filter(function () { return _this._overlayAttached; })) :\n                    rxjs.of()).pipe(\n                // Normalize the output so we return a consistent type.\n                operators.map(function (event) { return event instanceof core$1.MatOptionSelectionChange ? event : null; }));\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatAutocompleteTrigger.prototype, \"activeOption\", {\n            /** The currently active option, coerced to MatOption type. */\n            get: function () {\n                if (this.autocomplete && this.autocomplete._keyManager) {\n                    return this.autocomplete._keyManager.activeItem;\n                }\n                return null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** Stream of clicks outside of the autocomplete panel. */\n        MatAutocompleteTrigger.prototype._getOutsideClickStream = function () {\n            var _this = this;\n            return rxjs.merge(rxjs.fromEvent(this._document, 'click'), rxjs.fromEvent(this._document, 'touchend'))\n                .pipe(operators.filter(function (event) {\n                // If we're in the Shadow DOM, the event target will be the shadow root, so we have to\n                // fall back to check the first element in the path of the click event.\n                var clickTarget = (_this._isInsideShadowRoot && event.composedPath ? event.composedPath()[0] :\n                    event.target);\n                var formField = _this._formField ? _this._formField._elementRef.nativeElement : null;\n                return _this._overlayAttached && clickTarget !== _this._element.nativeElement &&\n                    (!formField || !formField.contains(clickTarget)) &&\n                    (!!_this._overlayRef && !_this._overlayRef.overlayElement.contains(clickTarget));\n            }));\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatAutocompleteTrigger.prototype.writeValue = function (value) {\n            var _this = this;\n            Promise.resolve(null).then(function () { return _this._setTriggerValue(value); });\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatAutocompleteTrigger.prototype.registerOnChange = function (fn) {\n            this._onChange = fn;\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatAutocompleteTrigger.prototype.registerOnTouched = function (fn) {\n            this._onTouched = fn;\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatAutocompleteTrigger.prototype.setDisabledState = function (isDisabled) {\n            this._element.nativeElement.disabled = isDisabled;\n        };\n        MatAutocompleteTrigger.prototype._handleKeydown = function (event) {\n            var keyCode = event.keyCode;\n            // Prevent the default action on all escape key presses. This is here primarily to bring IE\n            // in line with other browsers. By default, pressing escape on IE will cause it to revert\n            // the input value to the one that it had on focus, however it won't dispatch any events\n            // which means that the model value will be out of sync with the view.\n            if (keyCode === keycodes.ESCAPE) {\n                event.preventDefault();\n            }\n            if (this.activeOption && keyCode === keycodes.ENTER && this.panelOpen) {\n                this.activeOption._selectViaInteraction();\n                this._resetActiveItem();\n                event.preventDefault();\n            }\n            else if (this.autocomplete) {\n                var prevActiveItem = this.autocomplete._keyManager.activeItem;\n                var isArrowKey = keyCode === keycodes.UP_ARROW || keyCode === keycodes.DOWN_ARROW;\n                if (this.panelOpen || keyCode === keycodes.TAB) {\n                    this.autocomplete._keyManager.onKeydown(event);\n                }\n                else if (isArrowKey && this._canOpen()) {\n                    this.openPanel();\n                }\n                if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {\n                    this._scrollToOption();\n                }\n            }\n        };\n        MatAutocompleteTrigger.prototype._handleInput = function (event) {\n            var target = event.target;\n            var value = target.value;\n            // Based on `NumberValueAccessor` from forms.\n            if (target.type === 'number') {\n                value = value == '' ? null : parseFloat(value);\n            }\n            // If the input has a placeholder, IE will fire the `input` event on page load,\n            // focus and blur, in addition to when the user actually changed the value. To\n            // filter out all of the extra events, we save the value on focus and between\n            // `input` events, and we check whether it changed.\n            // See: https://connect.microsoft.com/IE/feedback/details/885747/\n            if (this._previousValue !== value) {\n                this._previousValue = value;\n                this._onChange(value);\n                if (this._canOpen() && this._document.activeElement === event.target) {\n                    this.openPanel();\n                }\n            }\n        };\n        MatAutocompleteTrigger.prototype._handleFocus = function () {\n            if (!this._canOpenOnNextFocus) {\n                this._canOpenOnNextFocus = true;\n            }\n            else if (this._canOpen()) {\n                this._previousValue = this._element.nativeElement.value;\n                this._attachOverlay();\n                this._floatLabel(true);\n            }\n        };\n        /**\n         * In \"auto\" mode, the label will animate down as soon as focus is lost.\n         * This causes the value to jump when selecting an option with the mouse.\n         * This method manually floats the label until the panel can be closed.\n         * @param shouldAnimate Whether the label should be animated when it is floated.\n         */\n        MatAutocompleteTrigger.prototype._floatLabel = function (shouldAnimate) {\n            if (shouldAnimate === void 0) { shouldAnimate = false; }\n            if (this._formField && this._formField.floatLabel === 'auto') {\n                if (shouldAnimate) {\n                    this._formField._animateAndLockLabel();\n                }\n                else {\n                    this._formField.floatLabel = 'always';\n                }\n                this._manuallyFloatingLabel = true;\n            }\n        };\n        /** If the label has been manually elevated, return it to its normal state. */\n        MatAutocompleteTrigger.prototype._resetLabel = function () {\n            if (this._manuallyFloatingLabel) {\n                this._formField.floatLabel = 'auto';\n                this._manuallyFloatingLabel = false;\n            }\n        };\n        /**\n         * Given that we are not actually focusing active options, we must manually adjust scroll\n         * to reveal options below the fold. First, we find the offset of the option from the top\n         * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n         * the panel height + the option height, so the active option will be just visible at the\n         * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n         * will become the offset. If that offset is visible within the panel already, the scrollTop is\n         * not adjusted.\n         */\n        MatAutocompleteTrigger.prototype._scrollToOption = function () {\n            var index = this.autocomplete._keyManager.activeItemIndex || 0;\n            var labelCount = core$1._countGroupLabelsBeforeOption(index, this.autocomplete.options, this.autocomplete.optionGroups);\n            if (index === 0 && labelCount === 1) {\n                // If we've got one group label before the option and we're at the top option,\n                // scroll the list to the top. This is better UX than scrolling the list to the\n                // top of the option, because it allows the user to read the top group's label.\n                this.autocomplete._setScrollTop(0);\n            }\n            else {\n                var newScrollPosition = core$1._getOptionScrollPosition(index + labelCount, AUTOCOMPLETE_OPTION_HEIGHT, this.autocomplete._getScrollTop(), AUTOCOMPLETE_PANEL_HEIGHT);\n                this.autocomplete._setScrollTop(newScrollPosition);\n            }\n        };\n        /**\n         * This method listens to a stream of panel closing actions and resets the\n         * stream every time the option list changes.\n         */\n        MatAutocompleteTrigger.prototype._subscribeToClosingActions = function () {\n            var _this = this;\n            var firstStable = this._zone.onStable.asObservable().pipe(operators.take(1));\n            var optionChanges = this.autocomplete.options.changes.pipe(operators.tap(function () { return _this._positionStrategy.reapplyLastPosition(); }), \n            // Defer emitting to the stream until the next tick, because changing\n            // bindings in here will cause \"changed after checked\" errors.\n            operators.delay(0));\n            // When the zone is stable initially, and when the option list changes...\n            return rxjs.merge(firstStable, optionChanges)\n                .pipe(\n            // create a new stream of panelClosingActions, replacing any previous streams\n            // that were created, and flatten it so our stream only emits closing events...\n            operators.switchMap(function () {\n                var wasOpen = _this.panelOpen;\n                _this._resetActiveItem();\n                _this.autocomplete._setVisibility();\n                if (_this.panelOpen) {\n                    _this._overlayRef.updatePosition();\n                    // If the `panelOpen` state changed, we need to make sure to emit the `opened`\n                    // event, because we may not have emitted it when the panel was attached. This\n                    // can happen if the users opens the panel and there are no options, but the\n                    // options come in slightly later or as a result of the value changing.\n                    if (wasOpen !== _this.panelOpen) {\n                        _this.autocomplete.opened.emit();\n                    }\n                }\n                return _this.panelClosingActions;\n            }), \n            // when the first closing event occurs...\n            operators.take(1))\n                // set the value, close the panel, and complete.\n                .subscribe(function (event) { return _this._setValueAndClose(event); });\n        };\n        /** Destroys the autocomplete suggestion panel. */\n        MatAutocompleteTrigger.prototype._destroyPanel = function () {\n            if (this._overlayRef) {\n                this.closePanel();\n                this._overlayRef.dispose();\n                this._overlayRef = null;\n            }\n        };\n        MatAutocompleteTrigger.prototype._setTriggerValue = function (value) {\n            var toDisplay = this.autocomplete && this.autocomplete.displayWith ?\n                this.autocomplete.displayWith(value) :\n                value;\n            // Simply falling back to an empty string if the display value is falsy does not work properly.\n            // The display value can also be the number zero and shouldn't fall back to an empty string.\n            var inputValue = toDisplay != null ? toDisplay : '';\n            // If it's used within a `MatFormField`, we should set it through the property so it can go\n            // through change detection.\n            if (this._formField) {\n                this._formField._control.value = inputValue;\n            }\n            else {\n                this._element.nativeElement.value = inputValue;\n            }\n            this._previousValue = inputValue;\n        };\n        /**\n         * This method closes the panel, and if a value is specified, also sets the associated\n         * control to that value. It will also mark the control as dirty if this interaction\n         * stemmed from the user.\n         */\n        MatAutocompleteTrigger.prototype._setValueAndClose = function (event) {\n            if (event && event.source) {\n                this._clearPreviousSelectedOption(event.source);\n                this._setTriggerValue(event.source.value);\n                this._onChange(event.source.value);\n                this._element.nativeElement.focus();\n                this.autocomplete._emitSelectEvent(event.source);\n            }\n            this.closePanel();\n        };\n        /**\n         * Clear any previous selected option and emit a selection change event for this option\n         */\n        MatAutocompleteTrigger.prototype._clearPreviousSelectedOption = function (skip) {\n            this.autocomplete.options.forEach(function (option) {\n                if (option != skip && option.selected) {\n                    option.deselect();\n                }\n            });\n        };\n        MatAutocompleteTrigger.prototype._attachOverlay = function () {\n            var _this = this;\n            if (!this.autocomplete) {\n                throw getMatAutocompleteMissingPanelError();\n            }\n            var overlayRef = this._overlayRef;\n            if (!overlayRef) {\n                this._portal = new portal.TemplatePortal(this.autocomplete.template, this._viewContainerRef);\n                overlayRef = this._overlay.create(this._getOverlayConfig());\n                this._overlayRef = overlayRef;\n                // Use the `keydownEvents` in order to take advantage of\n                // the overlay event targeting provided by the CDK overlay.\n                overlayRef.keydownEvents().subscribe(function (event) {\n                    // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n                    // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n                    if (event.keyCode === keycodes.ESCAPE || (event.keyCode === keycodes.UP_ARROW && event.altKey)) {\n                        _this._resetActiveItem();\n                        _this._closeKeyEventStream.next();\n                        // We need to stop propagation, otherwise the event will eventually\n                        // reach the input itself and cause the overlay to be reopened.\n                        event.stopPropagation();\n                        event.preventDefault();\n                    }\n                });\n                if (this._viewportRuler) {\n                    this._viewportSubscription = this._viewportRuler.change().subscribe(function () {\n                        if (_this.panelOpen && overlayRef) {\n                            overlayRef.updateSize({ width: _this._getPanelWidth() });\n                        }\n                    });\n                }\n            }\n            else {\n                // Update the trigger, panel width and direction, in case anything has changed.\n                this._positionStrategy.setOrigin(this._getConnectedElement());\n                overlayRef.updateSize({ width: this._getPanelWidth() });\n            }\n            if (overlayRef && !overlayRef.hasAttached()) {\n                overlayRef.attach(this._portal);\n                this._closingActionsSubscription = this._subscribeToClosingActions();\n            }\n            var wasOpen = this.panelOpen;\n            this.autocomplete._setVisibility();\n            this.autocomplete._isOpen = this._overlayAttached = true;\n            // We need to do an extra `panelOpen` check in here, because the\n            // autocomplete won't be shown if there are no options.\n            if (this.panelOpen && wasOpen !== this.panelOpen) {\n                this.autocomplete.opened.emit();\n            }\n        };\n        MatAutocompleteTrigger.prototype._getOverlayConfig = function () {\n            return new overlay.OverlayConfig({\n                positionStrategy: this._getOverlayPosition(),\n                scrollStrategy: this._scrollStrategy(),\n                width: this._getPanelWidth(),\n                direction: this._dir\n            });\n        };\n        MatAutocompleteTrigger.prototype._getOverlayPosition = function () {\n            var strategy = this._overlay.position()\n                .flexibleConnectedTo(this._getConnectedElement())\n                .withFlexibleDimensions(false)\n                .withPush(false);\n            this._setStrategyPositions(strategy);\n            this._positionStrategy = strategy;\n            return strategy;\n        };\n        /** Sets the positions on a position strategy based on the directive's input state. */\n        MatAutocompleteTrigger.prototype._setStrategyPositions = function (positionStrategy) {\n            var belowPosition = {\n                originX: 'start',\n                originY: 'bottom',\n                overlayX: 'start',\n                overlayY: 'top'\n            };\n            var abovePosition = {\n                originX: 'start',\n                originY: 'top',\n                overlayX: 'start',\n                overlayY: 'bottom',\n                // The overlay edge connected to the trigger should have squared corners, while\n                // the opposite end has rounded corners. We apply a CSS class to swap the\n                // border-radius based on the overlay position.\n                panelClass: 'mat-autocomplete-panel-above'\n            };\n            var positions;\n            if (this.position === 'above') {\n                positions = [abovePosition];\n            }\n            else if (this.position === 'below') {\n                positions = [belowPosition];\n            }\n            else {\n                positions = [belowPosition, abovePosition];\n            }\n            positionStrategy.withPositions(positions);\n        };\n        MatAutocompleteTrigger.prototype._getConnectedElement = function () {\n            if (this.connectedTo) {\n                return this.connectedTo.elementRef;\n            }\n            return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;\n        };\n        MatAutocompleteTrigger.prototype._getPanelWidth = function () {\n            return this.autocomplete.panelWidth || this._getHostWidth();\n        };\n        /** Returns the width of the input element, so the panel width can match it. */\n        MatAutocompleteTrigger.prototype._getHostWidth = function () {\n            return this._getConnectedElement().nativeElement.getBoundingClientRect().width;\n        };\n        /**\n         * Resets the active item to -1 so arrow events will activate the\n         * correct options, or to 0 if the consumer opted into it.\n         */\n        MatAutocompleteTrigger.prototype._resetActiveItem = function () {\n            this.autocomplete._keyManager.setActiveItem(this.autocomplete.autoActiveFirstOption ? 0 : -1);\n        };\n        /** Determines whether the panel can be opened. */\n        MatAutocompleteTrigger.prototype._canOpen = function () {\n            var element = this._element.nativeElement;\n            return !element.readOnly && !element.disabled && !this._autocompleteDisabled;\n        };\n        MatAutocompleteTrigger.decorators = [\n            { type: core.Directive, args: [{\n                        selector: \"input[matAutocomplete], textarea[matAutocomplete]\",\n                        host: {\n                            'class': 'mat-autocomplete-trigger',\n                            '[attr.autocomplete]': 'autocompleteAttribute',\n                            '[attr.role]': 'autocompleteDisabled ? null : \"combobox\"',\n                            '[attr.aria-autocomplete]': 'autocompleteDisabled ? null : \"list\"',\n                            '[attr.aria-activedescendant]': '(panelOpen && activeOption) ? activeOption.id : null',\n                            '[attr.aria-expanded]': 'autocompleteDisabled ? null : panelOpen.toString()',\n                            '[attr.aria-owns]': '(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id',\n                            '[attr.aria-haspopup]': '!autocompleteDisabled',\n                            // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\n                            // a little earlier. This avoids issues where IE delays the focusing of the input.\n                            '(focusin)': '_handleFocus()',\n                            '(blur)': '_onTouched()',\n                            '(input)': '_handleInput($event)',\n                            '(keydown)': '_handleKeydown($event)',\n                        },\n                        exportAs: 'matAutocompleteTrigger',\n                        providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR]\n                    },] }\n        ];\n        /** @nocollapse */\n        MatAutocompleteTrigger.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: overlay.Overlay },\n            { type: core.ViewContainerRef },\n            { type: core.NgZone },\n            { type: core.ChangeDetectorRef },\n            { type: undefined, decorators: [{ type: core.Inject, args: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY,] }] },\n            { type: bidi.Directionality, decorators: [{ type: core.Optional }] },\n            { type: formField.MatFormField, decorators: [{ type: core.Optional }, { type: core.Host }] },\n            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] },\n            { type: scrolling.ViewportRuler }\n        ]; };\n        MatAutocompleteTrigger.propDecorators = {\n            autocomplete: [{ type: core.Input, args: ['matAutocomplete',] }],\n            position: [{ type: core.Input, args: ['matAutocompletePosition',] }],\n            connectedTo: [{ type: core.Input, args: ['matAutocompleteConnectedTo',] }],\n            autocompleteAttribute: [{ type: core.Input, args: ['autocomplete',] }],\n            autocompleteDisabled: [{ type: core.Input, args: ['matAutocompleteDisabled',] }]\n        };\n        return MatAutocompleteTrigger;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var MatAutocompleteModule = /** @class */ (function () {\n        function MatAutocompleteModule() {\n        }\n        MatAutocompleteModule.decorators = [\n            { type: core.NgModule, args: [{\n                        imports: [core$1.MatOptionModule, overlay.OverlayModule, core$1.MatCommonModule, common.CommonModule],\n                        exports: [\n                            MatAutocomplete,\n                            core$1.MatOptionModule,\n                            MatAutocompleteTrigger,\n                            MatAutocompleteOrigin,\n                            core$1.MatCommonModule\n                        ],\n                        declarations: [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin],\n                        providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER],\n                    },] }\n        ];\n        return MatAutocompleteModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.AUTOCOMPLETE_OPTION_HEIGHT = AUTOCOMPLETE_OPTION_HEIGHT;\n    exports.AUTOCOMPLETE_PANEL_HEIGHT = AUTOCOMPLETE_PANEL_HEIGHT;\n    exports.MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = MAT_AUTOCOMPLETE_DEFAULT_OPTIONS;\n    exports.MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY = MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY;\n    exports.MAT_AUTOCOMPLETE_SCROLL_STRATEGY = MAT_AUTOCOMPLETE_SCROLL_STRATEGY;\n    exports.MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY = MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY;\n    exports.MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER;\n    exports.MAT_AUTOCOMPLETE_VALUE_ACCESSOR = MAT_AUTOCOMPLETE_VALUE_ACCESSOR;\n    exports.MatAutocomplete = MatAutocomplete;\n    exports.MatAutocompleteModule = MatAutocompleteModule;\n    exports.MatAutocompleteOrigin = MatAutocompleteOrigin;\n    exports.MatAutocompleteSelectedEvent = MatAutocompleteSelectedEvent;\n    exports.MatAutocompleteTrigger = MatAutocompleteTrigger;\n    exports.getMatAutocompleteMissingPanelError = getMatAutocompleteMissingPanelError;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=material-autocomplete.umd.js.map\n"]}