{"version":3,"sources":["src/material/material-autocomplete-testing.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","material","autocomplete","testing","tslib","cdk","coercion","this","MatAutocompleteOptionHarness","_super","apply","arguments","__extends","with","options","HarnessPredicate","addOption","text","harness","stringMatches","getText","prototype","select","__awaiter","__generator","_a","label","host","sent","click","hostSelector","ComponentHarness","MatAutocompleteOptionGroupHarness","_this","_label","locatorFor","labelText","getLabelText","PANEL_SELECTOR","MatAutocompleteHarness","_documentRootLocator","documentRootLocatorFactory","_optionalPanel","locatorForOptional","value","getValue","getProperty","isDisabled","disabled","_b","getAttribute","coerceBooleanProperty","focus","blur","enterText","sendKeys","getOptions","filters","locatorForAll","getOptionGroups","selectOption","length","Error","JSON","stringify","isOpen","panel","hasClass","Object","defineProperty"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('@angular/cdk/coercion'), require('@angular/cdk/testing')) :\n    typeof define === 'function' && define.amd ? define('@angular/material/autocomplete/testing', ['exports', 'tslib', '@angular/cdk/coercion', '@angular/cdk/testing'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.autocomplete = global.ng.material.autocomplete || {}, global.ng.material.autocomplete.testing = {}), global.tslib, global.ng.cdk.coercion, global.ng.cdk.testing));\n}(this, function (exports, tslib, coercion, testing) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Harness for interacting with a the `mat-option` for a `mat-autocomplete` in tests.\n     * @dynamic\n     */\n    var MatAutocompleteOptionHarness = /** @class */ (function (_super) {\n        tslib.__extends(MatAutocompleteOptionHarness, _super);\n        function MatAutocompleteOptionHarness() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        MatAutocompleteOptionHarness.with = function (options) {\n            if (options === void 0) { options = {}; }\n            return new testing.HarnessPredicate(MatAutocompleteOptionHarness, options)\n                .addOption('text', options.text, function (harness, text) { return testing.HarnessPredicate.stringMatches(harness.getText(), text); });\n        };\n        /** Clicks the option. */\n        MatAutocompleteOptionHarness.prototype.select = function () {\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                return tslib.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.host()];\n                        case 1: return [2 /*return*/, (_a.sent()).click()];\n                    }\n                });\n            });\n        };\n        /** Gets a promise for the option's label text. */\n        MatAutocompleteOptionHarness.prototype.getText = function () {\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                return tslib.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.host()];\n                        case 1: return [2 /*return*/, (_a.sent()).text()];\n                    }\n                });\n            });\n        };\n        MatAutocompleteOptionHarness.hostSelector = '.mat-autocomplete-panel .mat-option';\n        return MatAutocompleteOptionHarness;\n    }(testing.ComponentHarness));\n    /**\n     * Harness for interacting with a the `mat-optgroup` for a `mat-autocomplete` in tests.\n     * @dynamic\n     */\n    var MatAutocompleteOptionGroupHarness = /** @class */ (function (_super) {\n        tslib.__extends(MatAutocompleteOptionGroupHarness, _super);\n        function MatAutocompleteOptionGroupHarness() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this._label = _this.locatorFor('.mat-optgroup-label');\n            return _this;\n        }\n        MatAutocompleteOptionGroupHarness.with = function (options) {\n            if (options === void 0) { options = {}; }\n            return new testing.HarnessPredicate(MatAutocompleteOptionGroupHarness, options)\n                .addOption('labelText', options.labelText, function (harness, label) { return testing.HarnessPredicate.stringMatches(harness.getLabelText(), label); });\n        };\n        /** Gets a promise for the option group's label text. */\n        MatAutocompleteOptionGroupHarness.prototype.getLabelText = function () {\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                return tslib.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this._label()];\n                        case 1: return [2 /*return*/, (_a.sent()).text()];\n                    }\n                });\n            });\n        };\n        MatAutocompleteOptionGroupHarness.hostSelector = '.mat-autocomplete-panel .mat-optgroup';\n        return MatAutocompleteOptionGroupHarness;\n    }(testing.ComponentHarness));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Selector for the autocomplete panel. */\n    var PANEL_SELECTOR = '.mat-autocomplete-panel';\n    /**\n     * Harness for interacting with a standard mat-autocomplete in tests.\n     * @dynamic\n     */\n    var MatAutocompleteHarness = /** @class */ (function (_super) {\n        tslib.__extends(MatAutocompleteHarness, _super);\n        function MatAutocompleteHarness() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this._documentRootLocator = _this.documentRootLocatorFactory();\n            _this._optionalPanel = _this._documentRootLocator.locatorForOptional(PANEL_SELECTOR);\n            return _this;\n        }\n        /**\n         * Gets a `HarnessPredicate` that can be used to search for an autocomplete with\n         * specific attributes.\n         * @param options Options for narrowing the search:\n         *   - `name` finds an autocomplete with a specific name.\n         * @return a `HarnessPredicate` configured with the given options.\n         */\n        MatAutocompleteHarness.with = function (options) {\n            if (options === void 0) { options = {}; }\n            return new testing.HarnessPredicate(MatAutocompleteHarness, options)\n                .addOption('value', options.value, function (harness, value) { return testing.HarnessPredicate.stringMatches(harness.getValue(), value); });\n        };\n        /** Gets the value of the autocomplete input. */\n        MatAutocompleteHarness.prototype.getValue = function () {\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                return tslib.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.host()];\n                        case 1: return [2 /*return*/, (_a.sent()).getProperty('value')];\n                    }\n                });\n            });\n        };\n        /** Gets a boolean promise indicating if the autocomplete input is disabled. */\n        MatAutocompleteHarness.prototype.isDisabled = function () {\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                var disabled, _a;\n                return tslib.__generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0: return [4 /*yield*/, this.host()];\n                        case 1:\n                            disabled = (_b.sent()).getAttribute('disabled');\n                            _a = coercion.coerceBooleanProperty;\n                            return [4 /*yield*/, disabled];\n                        case 2: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];\n                    }\n                });\n            });\n        };\n        /** Focuses the input and returns a void promise that indicates when the action is complete. */\n        MatAutocompleteHarness.prototype.focus = function () {\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                return tslib.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.host()];\n                        case 1: return [2 /*return*/, (_a.sent()).focus()];\n                    }\n                });\n            });\n        };\n        /** Blurs the input and returns a void promise that indicates when the action is complete. */\n        MatAutocompleteHarness.prototype.blur = function () {\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                return tslib.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.host()];\n                        case 1: return [2 /*return*/, (_a.sent()).blur()];\n                    }\n                });\n            });\n        };\n        /** Enters text into the autocomplete. */\n        MatAutocompleteHarness.prototype.enterText = function (value) {\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                return tslib.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.host()];\n                        case 1: return [2 /*return*/, (_a.sent()).sendKeys(value)];\n                    }\n                });\n            });\n        };\n        /** Gets the options inside the autocomplete panel. */\n        MatAutocompleteHarness.prototype.getOptions = function (filters) {\n            if (filters === void 0) { filters = {}; }\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                return tslib.__generator(this, function (_a) {\n                    return [2 /*return*/, this._documentRootLocator.locatorForAll(MatAutocompleteOptionHarness.with(filters))()];\n                });\n            });\n        };\n        /** Gets the groups of options inside the panel. */\n        MatAutocompleteHarness.prototype.getOptionGroups = function (filters) {\n            if (filters === void 0) { filters = {}; }\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                return tslib.__generator(this, function (_a) {\n                    return [2 /*return*/, this._documentRootLocator.locatorForAll(MatAutocompleteOptionGroupHarness.with(filters))()];\n                });\n            });\n        };\n        /** Selects the first option matching the given filters. */\n        MatAutocompleteHarness.prototype.selectOption = function (filters) {\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                var options;\n                return tslib.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.focus()];\n                        case 1:\n                            _a.sent(); // Focus the input to make sure the autocomplete panel is shown.\n                            return [4 /*yield*/, this.getOptions(filters)];\n                        case 2:\n                            options = _a.sent();\n                            if (!options.length) {\n                                throw Error(\"Could not find a mat-option matching \" + JSON.stringify(filters));\n                            }\n                            return [4 /*yield*/, options[0].select()];\n                        case 3:\n                            _a.sent();\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        /** Gets whether the autocomplete is open. */\n        MatAutocompleteHarness.prototype.isOpen = function () {\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                var panel, _a;\n                return tslib.__generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0: return [4 /*yield*/, this._optionalPanel()];\n                        case 1:\n                            panel = _b.sent();\n                            _a = !!panel;\n                            if (!_a) return [3 /*break*/, 3];\n                            return [4 /*yield*/, panel.hasClass('mat-autocomplete-visible')];\n                        case 2:\n                            _a = (_b.sent());\n                            _b.label = 3;\n                        case 3: return [2 /*return*/, _a];\n                    }\n                });\n            });\n        };\n        MatAutocompleteHarness.hostSelector = '.mat-autocomplete-trigger';\n        return MatAutocompleteHarness;\n    }(testing.ComponentHarness));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    exports.MatAutocompleteHarness = MatAutocompleteHarness;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=material-autocomplete-testing.umd.js.map\n"]}