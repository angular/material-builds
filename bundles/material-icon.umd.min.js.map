{"version":3,"sources":["src/material/material-icon.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","material","icon","core","cdk","coercion","common","rxjs","operators","http","platformBrowser","this","i0","i3","i1","i2","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","getMatIconNameNotFoundError","iconName","Error","getMatIconNoHttpProviderError","getMatIconFailedToSanitizeUrlError","url","getMatIconFailedToSanitizeLiteralError","literal","SvgIconConfig","data","options","nodeName","svgElement","MatIconRegistry","_httpClient","_sanitizer","document","_errorHandler","_svgIconConfigs","Map","_iconSetConfigs","_cachedIconsByUrl","_inProgressUrlFetches","_fontCssClassesByAlias","_defaultFontSetClass","_document","prototype","addSvgIcon","addSvgIconInNamespace","addSvgIconLiteral","addSvgIconLiteralInNamespace","namespace","_addSvgIconConfig","sanitizedLiteral","sanitize","SecurityContext","HTML","_createSvgElementForSingleIcon","addSvgIconSet","addSvgIconSetInNamespace","addSvgIconSetLiteral","addSvgIconSetLiteralInNamespace","_addSvgIconSetConfig","_svgElementFromString","registerFontClassAlias","alias","className","set","classNameForFontAlias","get","setDefaultFontSetClass","getDefaultFontSetClass","getSvgIconFromUrl","safeUrl","_this","RESOURCE_URL","cachedIcon","of","cloneSvg","_loadSvgIconFromConfig","pipe","tap","svg","map","getNamedSvgIcon","name","key","iconKey","config","_getSvgFromConfig","iconSetConfigs","_getSvgFromIconSetConfigs","throwError","ngOnDestroy","clear","namedIcon","_extractIconWithNameFromAnySet","iconSetFetchRequests","filter","iconSetConfig","_loadSvgIconSetFromConfig","catchError","err","errorMessage","message","handleError","console","error","forkJoin","foundIcon","i","length","_extractSvgIconFromSet","_fetchUrl","svgText","responseText","_setSvgAttributes","iconSet","iconSource","querySelector","iconElement","cloneNode","removeAttribute","toLowerCase","_toSvgElement","appendChild","str","div","createElement","innerHTML","element","attributes","_a","name_1","setAttribute","value","childNodes","nodeType","ELEMENT_NODE","viewBox","inProgressFetch","req","responseType","finalize","delete","share","configNamespace","push","decorators","type","Injectable","args","providedIn","ctorParameters","HttpClient","Optional","DomSanitizer","undefined","Inject","DOCUMENT","ErrorHandler","ɵprov","ɵɵdefineInjectable","MatIconRegistry_Factory","ɵɵinject","token","ICON_REGISTRY_PROVIDER_FACTORY","parentRegistry","httpClient","sanitizer","errorHandler","ICON_REGISTRY_PROVIDER","provide","deps","SkipSelf","useFactory","_MatIconMixinBase","mixinColor","MatIconBase","_elementRef","MAT_ICON_LOCATION","InjectionToken","MAT_ICON_LOCATION_FACTORY","inject","_location","location","getPathname","pathname","search","funcIriAttributes","ɵ0","attr","funcIriAttributeSelector","join","funcIriPattern","MatIcon","_super","elementRef","_iconRegistry","ariaHidden","call","_inline","_currentIconFetch","Subscription","EMPTY","nativeElement","__extends","__","constructor","create","defineProperty","inline","coerceBooleanProperty","enumerable","configurable","_fontSet","_cleanupFontValue","_fontIcon","_splitIconName","parts","split","ngOnChanges","changes","svgIconChanges","unsubscribe","svgIcon","__read","o","n","m","Symbol","iterator","r","e","ar","next","done","namespace_1","iconName_1","take","subscribe","_setSvgElement","previousValue","_clearSvgElement","_usingFontIcon","_updateFontIconClasses","ngOnInit","ngAfterViewChecked","cachedElements","_elementsWithExternalReferences","size","newPath","_previousPath","_prependPathToReferences","styleTags","querySelectorAll","textContent","path","_cacheChildrenWithExternalReferences","layoutElement","childCount","child","removeChild","elem","fontSetClass","fontSet","_previousFontSetClass","classList","remove","add","fontIcon","_previousFontIconClass","trim","elements","forEach","attrs","elementsWithFuncIri","_loop_1","elementWithReference","getAttribute","match","Component","template","selector","exportAs","inputs","host","role","class","[class.mat-icon-inline]","[class.mat-icon-no-color]","encapsulation","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","styles","ElementRef","String","Attribute","propDecorators","Input","MatIconModule","NgModule","imports","MatCommonModule","declarations"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/material/core'), require('@angular/cdk/coercion'), require('@angular/common'), require('rxjs'), require('rxjs/operators'), require('@angular/common/http'), require('@angular/platform-browser')) :\n    typeof define === 'function' && define.amd ? define('@angular/material/icon', ['exports', '@angular/core', '@angular/material/core', '@angular/cdk/coercion', '@angular/common', 'rxjs', 'rxjs/operators', '@angular/common/http', '@angular/platform-browser'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.icon = {}), global.ng.core, global.ng.material.core, global.ng.cdk.coercion, global.ng.common, global.rxjs, global.rxjs.operators, global.ng.common.http, global.ng.platformBrowser));\n}(this, (function (exports, i0, core, coercion, i3, rxjs, operators, i1, i2) { 'use strict';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation. All rights reserved.\r\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n    this file except in compliance with the License. You may obtain a copy of the\r\n    License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n    MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n    and limitations under the License.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = function(d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n\r\n    function __extends(d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\r\n\r\n    function __rest(s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                    t[p[i]] = s[p[i]];\r\n            }\r\n        return t;\r\n    }\r\n\r\n    function __decorate(decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    }\r\n\r\n    function __param(paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    }\r\n\r\n    function __metadata(metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    }\r\n\r\n    function __awaiter(thisArg, _arguments, P, generator) {\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    }\r\n\r\n    function __generator(thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    }\r\n\r\n    function __exportStar(m, exports) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    }\r\n\r\n    function __values(o) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n        if (m) return m.call(o);\r\n        return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n    }\r\n\r\n    function __read(o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    }\r\n\r\n    function __spread() {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    }\r\n\r\n    function __spreadArrays() {\r\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n                r[k] = a[j];\r\n        return r;\r\n    };\r\n\r\n    function __await(v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    }\r\n\r\n    function __asyncGenerator(thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n    }\r\n\r\n    function __asyncDelegator(o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n    }\r\n\r\n    function __asyncValues(o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator], i;\r\n        return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n    }\r\n\r\n    function __makeTemplateObject(cooked, raw) {\r\n        if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n        return cooked;\r\n    };\r\n\r\n    function __importStar(mod) {\r\n        if (mod && mod.__esModule) return mod;\r\n        var result = {};\r\n        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n        result.default = mod;\r\n        return result;\r\n    }\r\n\r\n    function __importDefault(mod) {\r\n        return (mod && mod.__esModule) ? mod : { default: mod };\r\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Returns an exception to be thrown in the case when attempting to\n     * load an icon with a name that cannot be found.\n     * @docs-private\n     */\n    function getMatIconNameNotFoundError(iconName) {\n        return Error(\"Unable to find icon with the name \\\"\" + iconName + \"\\\"\");\n    }\n    /**\n     * Returns an exception to be thrown when the consumer attempts to use\n     * `<mat-icon>` without including @angular/common/http.\n     * @docs-private\n     */\n    function getMatIconNoHttpProviderError() {\n        return Error('Could not find HttpClient provider for use with Angular Material icons. ' +\n            'Please include the HttpClientModule from @angular/common/http in your ' +\n            'app imports.');\n    }\n    /**\n     * Returns an exception to be thrown when a URL couldn't be sanitized.\n     * @param url URL that was attempted to be sanitized.\n     * @docs-private\n     */\n    function getMatIconFailedToSanitizeUrlError(url) {\n        return Error(\"The URL provided to MatIconRegistry was not trusted as a resource URL \" +\n            (\"via Angular's DomSanitizer. Attempted URL was \\\"\" + url + \"\\\".\"));\n    }\n    /**\n     * Returns an exception to be thrown when a HTML string couldn't be sanitized.\n     * @param literal HTML that was attempted to be sanitized.\n     * @docs-private\n     */\n    function getMatIconFailedToSanitizeLiteralError(literal) {\n        return Error(\"The literal provided to MatIconRegistry was not trusted as safe HTML by \" +\n            (\"Angular's DomSanitizer. Attempted literal was \\\"\" + literal + \"\\\".\"));\n    }\n    /**\n     * Configuration for an icon, including the URL and possibly the cached SVG element.\n     * @docs-private\n     */\n    var SvgIconConfig = /** @class */ (function () {\n        function SvgIconConfig(data, options) {\n            this.options = options;\n            // Note that we can't use `instanceof SVGElement` here,\n            // because it'll break during server-side rendering.\n            if (!!data.nodeName) {\n                this.svgElement = data;\n            }\n            else {\n                this.url = data;\n            }\n        }\n        return SvgIconConfig;\n    }());\n    /**\n     * Service to register and display icons used by the `<mat-icon>` component.\n     * - Registers icon URLs by namespace and name.\n     * - Registers icon set URLs by namespace.\n     * - Registers aliases for CSS classes, for use with icon fonts.\n     * - Loads icons from URLs and extracts individual icons from icon sets.\n     */\n    var MatIconRegistry = /** @class */ (function () {\n        function MatIconRegistry(_httpClient, _sanitizer, document, \n        // @breaking-change 9.0.0 _errorHandler parameter to be made required\n        _errorHandler) {\n            this._httpClient = _httpClient;\n            this._sanitizer = _sanitizer;\n            this._errorHandler = _errorHandler;\n            /**\n             * URLs and cached SVG elements for individual icons. Keys are of the format \"[namespace]:[icon]\".\n             */\n            this._svgIconConfigs = new Map();\n            /**\n             * SvgIconConfig objects and cached SVG elements for icon sets, keyed by namespace.\n             * Multiple icon sets can be registered under the same namespace.\n             */\n            this._iconSetConfigs = new Map();\n            /** Cache for icons loaded by direct URLs. */\n            this._cachedIconsByUrl = new Map();\n            /** In-progress icon fetches. Used to coalesce multiple requests to the same URL. */\n            this._inProgressUrlFetches = new Map();\n            /** Map from font identifiers to their CSS class names. Used for icon fonts. */\n            this._fontCssClassesByAlias = new Map();\n            /**\n             * The CSS class to apply when an `<mat-icon>` component has no icon name, url, or font specified.\n             * The default 'material-icons' value assumes that the material icon font has been loaded as\n             * described at http://google.github.io/material-design-icons/#icon-font-for-the-web\n             */\n            this._defaultFontSetClass = 'material-icons';\n            this._document = document;\n        }\n        /**\n         * Registers an icon by URL in the default namespace.\n         * @param iconName Name under which the icon should be registered.\n         * @param url\n         */\n        MatIconRegistry.prototype.addSvgIcon = function (iconName, url, options) {\n            return this.addSvgIconInNamespace('', iconName, url, options);\n        };\n        /**\n         * Registers an icon using an HTML string in the default namespace.\n         * @param iconName Name under which the icon should be registered.\n         * @param literal SVG source of the icon.\n         */\n        MatIconRegistry.prototype.addSvgIconLiteral = function (iconName, literal, options) {\n            return this.addSvgIconLiteralInNamespace('', iconName, literal, options);\n        };\n        /**\n         * Registers an icon by URL in the specified namespace.\n         * @param namespace Namespace in which the icon should be registered.\n         * @param iconName Name under which the icon should be registered.\n         * @param url\n         */\n        MatIconRegistry.prototype.addSvgIconInNamespace = function (namespace, iconName, url, options) {\n            return this._addSvgIconConfig(namespace, iconName, new SvgIconConfig(url, options));\n        };\n        /**\n         * Registers an icon using an HTML string in the specified namespace.\n         * @param namespace Namespace in which the icon should be registered.\n         * @param iconName Name under which the icon should be registered.\n         * @param literal SVG source of the icon.\n         */\n        MatIconRegistry.prototype.addSvgIconLiteralInNamespace = function (namespace, iconName, literal, options) {\n            var sanitizedLiteral = this._sanitizer.sanitize(i0.SecurityContext.HTML, literal);\n            if (!sanitizedLiteral) {\n                throw getMatIconFailedToSanitizeLiteralError(literal);\n            }\n            var svgElement = this._createSvgElementForSingleIcon(sanitizedLiteral, options);\n            return this._addSvgIconConfig(namespace, iconName, new SvgIconConfig(svgElement, options));\n        };\n        /**\n         * Registers an icon set by URL in the default namespace.\n         * @param url\n         */\n        MatIconRegistry.prototype.addSvgIconSet = function (url, options) {\n            return this.addSvgIconSetInNamespace('', url, options);\n        };\n        /**\n         * Registers an icon set using an HTML string in the default namespace.\n         * @param literal SVG source of the icon set.\n         */\n        MatIconRegistry.prototype.addSvgIconSetLiteral = function (literal, options) {\n            return this.addSvgIconSetLiteralInNamespace('', literal, options);\n        };\n        /**\n         * Registers an icon set by URL in the specified namespace.\n         * @param namespace Namespace in which to register the icon set.\n         * @param url\n         */\n        MatIconRegistry.prototype.addSvgIconSetInNamespace = function (namespace, url, options) {\n            return this._addSvgIconSetConfig(namespace, new SvgIconConfig(url, options));\n        };\n        /**\n         * Registers an icon set using an HTML string in the specified namespace.\n         * @param namespace Namespace in which to register the icon set.\n         * @param literal SVG source of the icon set.\n         */\n        MatIconRegistry.prototype.addSvgIconSetLiteralInNamespace = function (namespace, literal, options) {\n            var sanitizedLiteral = this._sanitizer.sanitize(i0.SecurityContext.HTML, literal);\n            if (!sanitizedLiteral) {\n                throw getMatIconFailedToSanitizeLiteralError(literal);\n            }\n            var svgElement = this._svgElementFromString(sanitizedLiteral);\n            return this._addSvgIconSetConfig(namespace, new SvgIconConfig(svgElement, options));\n        };\n        /**\n         * Defines an alias for a CSS class name to be used for icon fonts. Creating an matIcon\n         * component with the alias as the fontSet input will cause the class name to be applied\n         * to the `<mat-icon>` element.\n         *\n         * @param alias Alias for the font.\n         * @param className Class name override to be used instead of the alias.\n         */\n        MatIconRegistry.prototype.registerFontClassAlias = function (alias, className) {\n            if (className === void 0) { className = alias; }\n            this._fontCssClassesByAlias.set(alias, className);\n            return this;\n        };\n        /**\n         * Returns the CSS class name associated with the alias by a previous call to\n         * registerFontClassAlias. If no CSS class has been associated, returns the alias unmodified.\n         */\n        MatIconRegistry.prototype.classNameForFontAlias = function (alias) {\n            return this._fontCssClassesByAlias.get(alias) || alias;\n        };\n        /**\n         * Sets the CSS class name to be used for icon fonts when an `<mat-icon>` component does not\n         * have a fontSet input value, and is not loading an icon by name or URL.\n         *\n         * @param className\n         */\n        MatIconRegistry.prototype.setDefaultFontSetClass = function (className) {\n            this._defaultFontSetClass = className;\n            return this;\n        };\n        /**\n         * Returns the CSS class name to be used for icon fonts when an `<mat-icon>` component does not\n         * have a fontSet input value, and is not loading an icon by name or URL.\n         */\n        MatIconRegistry.prototype.getDefaultFontSetClass = function () {\n            return this._defaultFontSetClass;\n        };\n        /**\n         * Returns an Observable that produces the icon (as an `<svg>` DOM element) from the given URL.\n         * The response from the URL may be cached so this will not always cause an HTTP request, but\n         * the produced element will always be a new copy of the originally fetched icon. (That is,\n         * it will not contain any modifications made to elements previously returned).\n         *\n         * @param safeUrl URL from which to fetch the SVG icon.\n         */\n        MatIconRegistry.prototype.getSvgIconFromUrl = function (safeUrl) {\n            var _this = this;\n            var url = this._sanitizer.sanitize(i0.SecurityContext.RESOURCE_URL, safeUrl);\n            if (!url) {\n                throw getMatIconFailedToSanitizeUrlError(safeUrl);\n            }\n            var cachedIcon = this._cachedIconsByUrl.get(url);\n            if (cachedIcon) {\n                return rxjs.of(cloneSvg(cachedIcon));\n            }\n            return this._loadSvgIconFromConfig(new SvgIconConfig(safeUrl)).pipe(operators.tap(function (svg) { return _this._cachedIconsByUrl.set(url, svg); }), operators.map(function (svg) { return cloneSvg(svg); }));\n        };\n        /**\n         * Returns an Observable that produces the icon (as an `<svg>` DOM element) with the given name\n         * and namespace. The icon must have been previously registered with addIcon or addIconSet;\n         * if not, the Observable will throw an error.\n         *\n         * @param name Name of the icon to be retrieved.\n         * @param namespace Namespace in which to look for the icon.\n         */\n        MatIconRegistry.prototype.getNamedSvgIcon = function (name, namespace) {\n            if (namespace === void 0) { namespace = ''; }\n            // Return (copy of) cached icon if possible.\n            var key = iconKey(namespace, name);\n            var config = this._svgIconConfigs.get(key);\n            if (config) {\n                return this._getSvgFromConfig(config);\n            }\n            // See if we have any icon sets registered for the namespace.\n            var iconSetConfigs = this._iconSetConfigs.get(namespace);\n            if (iconSetConfigs) {\n                return this._getSvgFromIconSetConfigs(name, iconSetConfigs);\n            }\n            return rxjs.throwError(getMatIconNameNotFoundError(key));\n        };\n        MatIconRegistry.prototype.ngOnDestroy = function () {\n            this._svgIconConfigs.clear();\n            this._iconSetConfigs.clear();\n            this._cachedIconsByUrl.clear();\n        };\n        /**\n         * Returns the cached icon for a SvgIconConfig if available, or fetches it from its URL if not.\n         */\n        MatIconRegistry.prototype._getSvgFromConfig = function (config) {\n            if (config.svgElement) {\n                // We already have the SVG element for this icon, return a copy.\n                return rxjs.of(cloneSvg(config.svgElement));\n            }\n            else {\n                // Fetch the icon from the config's URL, cache it, and return a copy.\n                return this._loadSvgIconFromConfig(config).pipe(operators.tap(function (svg) { return config.svgElement = svg; }), operators.map(function (svg) { return cloneSvg(svg); }));\n            }\n        };\n        /**\n         * Attempts to find an icon with the specified name in any of the SVG icon sets.\n         * First searches the available cached icons for a nested element with a matching name, and\n         * if found copies the element to a new `<svg>` element. If not found, fetches all icon sets\n         * that have not been cached, and searches again after all fetches are completed.\n         * The returned Observable produces the SVG element if possible, and throws\n         * an error if no icon with the specified name can be found.\n         */\n        MatIconRegistry.prototype._getSvgFromIconSetConfigs = function (name, iconSetConfigs) {\n            var _this = this;\n            // For all the icon set SVG elements we've fetched, see if any contain an icon with the\n            // requested name.\n            var namedIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);\n            if (namedIcon) {\n                // We could cache namedIcon in _svgIconConfigs, but since we have to make a copy every\n                // time anyway, there's probably not much advantage compared to just always extracting\n                // it from the icon set.\n                return rxjs.of(namedIcon);\n            }\n            // Not found in any cached icon sets. If there are icon sets with URLs that we haven't\n            // fetched, fetch them now and look for iconName in the results.\n            var iconSetFetchRequests = iconSetConfigs\n                .filter(function (iconSetConfig) { return !iconSetConfig.svgElement; })\n                .map(function (iconSetConfig) {\n                return _this._loadSvgIconSetFromConfig(iconSetConfig).pipe(operators.catchError(function (err) {\n                    var url = _this._sanitizer.sanitize(i0.SecurityContext.RESOURCE_URL, iconSetConfig.url);\n                    // Swallow errors fetching individual URLs so the\n                    // combined Observable won't necessarily fail.\n                    var errorMessage = \"Loading icon set URL: \" + url + \" failed: \" + err.message;\n                    // @breaking-change 9.0.0 _errorHandler parameter to be made required\n                    if (_this._errorHandler) {\n                        _this._errorHandler.handleError(new Error(errorMessage));\n                    }\n                    else {\n                        console.error(errorMessage);\n                    }\n                    return rxjs.of(null);\n                }));\n            });\n            // Fetch all the icon set URLs. When the requests complete, every IconSet should have a\n            // cached SVG element (unless the request failed), and we can check again for the icon.\n            return rxjs.forkJoin(iconSetFetchRequests).pipe(operators.map(function () {\n                var foundIcon = _this._extractIconWithNameFromAnySet(name, iconSetConfigs);\n                if (!foundIcon) {\n                    throw getMatIconNameNotFoundError(name);\n                }\n                return foundIcon;\n            }));\n        };\n        /**\n         * Searches the cached SVG elements for the given icon sets for a nested icon element whose \"id\"\n         * tag matches the specified name. If found, copies the nested element to a new SVG element and\n         * returns it. Returns null if no matching element is found.\n         */\n        MatIconRegistry.prototype._extractIconWithNameFromAnySet = function (iconName, iconSetConfigs) {\n            // Iterate backwards, so icon sets added later have precedence.\n            for (var i = iconSetConfigs.length - 1; i >= 0; i--) {\n                var config = iconSetConfigs[i];\n                if (config.svgElement) {\n                    var foundIcon = this._extractSvgIconFromSet(config.svgElement, iconName, config.options);\n                    if (foundIcon) {\n                        return foundIcon;\n                    }\n                }\n            }\n            return null;\n        };\n        /**\n         * Loads the content of the icon URL specified in the SvgIconConfig and creates an SVG element\n         * from it.\n         */\n        MatIconRegistry.prototype._loadSvgIconFromConfig = function (config) {\n            var _this = this;\n            return this._fetchUrl(config.url)\n                .pipe(operators.map(function (svgText) { return _this._createSvgElementForSingleIcon(svgText, config.options); }));\n        };\n        /**\n         * Loads the content of the icon set URL specified in the SvgIconConfig and creates an SVG element\n         * from it.\n         */\n        MatIconRegistry.prototype._loadSvgIconSetFromConfig = function (config) {\n            var _this = this;\n            // If the SVG for this icon set has already been parsed, do nothing.\n            if (config.svgElement) {\n                return rxjs.of(config.svgElement);\n            }\n            return this._fetchUrl(config.url).pipe(operators.map(function (svgText) {\n                // It is possible that the icon set was parsed and cached by an earlier request, so parsing\n                // only needs to occur if the cache is yet unset.\n                if (!config.svgElement) {\n                    config.svgElement = _this._svgElementFromString(svgText);\n                }\n                return config.svgElement;\n            }));\n        };\n        /**\n         * Creates a DOM element from the given SVG string, and adds default attributes.\n         */\n        MatIconRegistry.prototype._createSvgElementForSingleIcon = function (responseText, options) {\n            var svg = this._svgElementFromString(responseText);\n            this._setSvgAttributes(svg, options);\n            return svg;\n        };\n        /**\n         * Searches the cached element of the given SvgIconConfig for a nested icon element whose \"id\"\n         * tag matches the specified name. If found, copies the nested element to a new SVG element and\n         * returns it. Returns null if no matching element is found.\n         */\n        MatIconRegistry.prototype._extractSvgIconFromSet = function (iconSet, iconName, options) {\n            // Use the `id=\"iconName\"` syntax in order to escape special\n            // characters in the ID (versus using the #iconName syntax).\n            var iconSource = iconSet.querySelector(\"[id=\\\"\" + iconName + \"\\\"]\");\n            if (!iconSource) {\n                return null;\n            }\n            // Clone the element and remove the ID to prevent multiple elements from being added\n            // to the page with the same ID.\n            var iconElement = iconSource.cloneNode(true);\n            iconElement.removeAttribute('id');\n            // If the icon node is itself an <svg> node, clone and return it directly. If not, set it as\n            // the content of a new <svg> node.\n            if (iconElement.nodeName.toLowerCase() === 'svg') {\n                return this._setSvgAttributes(iconElement, options);\n            }\n            // If the node is a <symbol>, it won't be rendered so we have to convert it into <svg>. Note\n            // that the same could be achieved by referring to it via <use href=\"#id\">, however the <use>\n            // tag is problematic on Firefox, because it needs to include the current page path.\n            if (iconElement.nodeName.toLowerCase() === 'symbol') {\n                return this._setSvgAttributes(this._toSvgElement(iconElement), options);\n            }\n            // createElement('SVG') doesn't work as expected; the DOM ends up with\n            // the correct nodes, but the SVG content doesn't render. Instead we\n            // have to create an empty SVG node using innerHTML and append its content.\n            // Elements created using DOMParser.parseFromString have the same problem.\n            // http://stackoverflow.com/questions/23003278/svg-innerhtml-in-firefox-can-not-display\n            var svg = this._svgElementFromString('<svg></svg>');\n            // Clone the node so we don't remove it from the parent icon set element.\n            svg.appendChild(iconElement);\n            return this._setSvgAttributes(svg, options);\n        };\n        /**\n         * Creates a DOM element from the given SVG string.\n         */\n        MatIconRegistry.prototype._svgElementFromString = function (str) {\n            var div = this._document.createElement('DIV');\n            div.innerHTML = str;\n            var svg = div.querySelector('svg');\n            if (!svg) {\n                throw Error('<svg> tag not found');\n            }\n            return svg;\n        };\n        /**\n         * Converts an element into an SVG node by cloning all of its children.\n         */\n        MatIconRegistry.prototype._toSvgElement = function (element) {\n            var svg = this._svgElementFromString('<svg></svg>');\n            var attributes = element.attributes;\n            // Copy over all the attributes from the `symbol` to the new SVG, except the id.\n            for (var i = 0; i < attributes.length; i++) {\n                var _a = attributes[i], name_1 = _a.name, value = _a.value;\n                if (name_1 !== 'id') {\n                    svg.setAttribute(name_1, value);\n                }\n            }\n            for (var i = 0; i < element.childNodes.length; i++) {\n                if (element.childNodes[i].nodeType === this._document.ELEMENT_NODE) {\n                    svg.appendChild(element.childNodes[i].cloneNode(true));\n                }\n            }\n            return svg;\n        };\n        /**\n         * Sets the default attributes for an SVG element to be used as an icon.\n         */\n        MatIconRegistry.prototype._setSvgAttributes = function (svg, options) {\n            svg.setAttribute('fit', '');\n            svg.setAttribute('height', '100%');\n            svg.setAttribute('width', '100%');\n            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n            svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.\n            if (options && options.viewBox) {\n                svg.setAttribute('viewBox', options.viewBox);\n            }\n            return svg;\n        };\n        /**\n         * Returns an Observable which produces the string contents of the given URL. Results may be\n         * cached, so future calls with the same URL may not cause another HTTP request.\n         */\n        MatIconRegistry.prototype._fetchUrl = function (safeUrl) {\n            var _this = this;\n            if (!this._httpClient) {\n                throw getMatIconNoHttpProviderError();\n            }\n            if (safeUrl == null) {\n                throw Error(\"Cannot fetch icon from URL \\\"\" + safeUrl + \"\\\".\");\n            }\n            var url = this._sanitizer.sanitize(i0.SecurityContext.RESOURCE_URL, safeUrl);\n            if (!url) {\n                throw getMatIconFailedToSanitizeUrlError(safeUrl);\n            }\n            // Store in-progress fetches to avoid sending a duplicate request for a URL when there is\n            // already a request in progress for that URL. It's necessary to call share() on the\n            // Observable returned by http.get() so that multiple subscribers don't cause multiple XHRs.\n            var inProgressFetch = this._inProgressUrlFetches.get(url);\n            if (inProgressFetch) {\n                return inProgressFetch;\n            }\n            // TODO(jelbourn): for some reason, the `finalize` operator \"loses\" the generic type on the\n            // Observable. Figure out why and fix it.\n            var req = this._httpClient.get(url, { responseType: 'text' }).pipe(operators.finalize(function () { return _this._inProgressUrlFetches.delete(url); }), operators.share());\n            this._inProgressUrlFetches.set(url, req);\n            return req;\n        };\n        /**\n         * Registers an icon config by name in the specified namespace.\n         * @param namespace Namespace in which to register the icon config.\n         * @param iconName Name under which to register the config.\n         * @param config Config to be registered.\n         */\n        MatIconRegistry.prototype._addSvgIconConfig = function (namespace, iconName, config) {\n            this._svgIconConfigs.set(iconKey(namespace, iconName), config);\n            return this;\n        };\n        /**\n         * Registers an icon set config in the specified namespace.\n         * @param namespace Namespace in which to register the icon config.\n         * @param config Config to be registered.\n         */\n        MatIconRegistry.prototype._addSvgIconSetConfig = function (namespace, config) {\n            var configNamespace = this._iconSetConfigs.get(namespace);\n            if (configNamespace) {\n                configNamespace.push(config);\n            }\n            else {\n                this._iconSetConfigs.set(namespace, [config]);\n            }\n            return this;\n        };\n        MatIconRegistry.decorators = [\n            { type: i0.Injectable, args: [{ providedIn: 'root' },] }\n        ];\n        /** @nocollapse */\n        MatIconRegistry.ctorParameters = function () { return [\n            { type: i1.HttpClient, decorators: [{ type: i0.Optional }] },\n            { type: i2.DomSanitizer },\n            { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [i3.DOCUMENT,] }] },\n            { type: i0.ErrorHandler, decorators: [{ type: i0.Optional }] }\n        ]; };\n        MatIconRegistry.ɵprov = i0.ɵɵdefineInjectable({ factory: function MatIconRegistry_Factory() { return new MatIconRegistry(i0.ɵɵinject(i1.HttpClient, 8), i0.ɵɵinject(i2.DomSanitizer), i0.ɵɵinject(i3.DOCUMENT, 8), i0.ɵɵinject(i0.ErrorHandler, 8)); }, token: MatIconRegistry, providedIn: \"root\" });\n        return MatIconRegistry;\n    }());\n    /** @docs-private */\n    function ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry, httpClient, sanitizer, document, errorHandler) {\n        return parentRegistry || new MatIconRegistry(httpClient, sanitizer, document, errorHandler);\n    }\n    /** @docs-private */\n    var ICON_REGISTRY_PROVIDER = {\n        // If there is already an MatIconRegistry available, use that. Otherwise, provide a new one.\n        provide: MatIconRegistry,\n        deps: [\n            [new i0.Optional(), new i0.SkipSelf(), MatIconRegistry],\n            [new i0.Optional(), i1.HttpClient],\n            i2.DomSanitizer,\n            [new i0.Optional(), i0.ErrorHandler],\n            [new i0.Optional(), i3.DOCUMENT],\n        ],\n        useFactory: ICON_REGISTRY_PROVIDER_FACTORY,\n    };\n    /** Clones an SVGElement while preserving type information. */\n    function cloneSvg(svg) {\n        return svg.cloneNode(true);\n    }\n    /** Returns the cache key to use for an icon namespace and name. */\n    function iconKey(namespace, name) {\n        return namespace + ':' + name;\n    }\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // Boilerplate for applying mixins to MatIcon.\n    /** @docs-private */\n    var MatIconBase = /** @class */ (function () {\n        function MatIconBase(_elementRef) {\n            this._elementRef = _elementRef;\n        }\n        return MatIconBase;\n    }());\n    var _MatIconMixinBase = core.mixinColor(MatIconBase);\n    /**\n     * Injection token used to provide the current location to `MatIcon`.\n     * Used to handle server-side rendering and to stub out during unit tests.\n     * @docs-private\n     */\n    var MAT_ICON_LOCATION = new i0.InjectionToken('mat-icon-location', {\n        providedIn: 'root',\n        factory: MAT_ICON_LOCATION_FACTORY\n    });\n    /** @docs-private */\n    function MAT_ICON_LOCATION_FACTORY() {\n        var _document = i0.inject(i3.DOCUMENT);\n        var _location = _document ? _document.location : null;\n        return {\n            // Note that this needs to be a function, rather than a property, because Angular\n            // will only resolve it once, but we want the current path on each call.\n            getPathname: function () { return _location ? (_location.pathname + _location.search) : ''; }\n        };\n    }\n    /** SVG attributes that accept a FuncIRI (e.g. `url(<something>)`). */\n    var funcIriAttributes = [\n        'clip-path',\n        'color-profile',\n        'src',\n        'cursor',\n        'fill',\n        'filter',\n        'marker',\n        'marker-start',\n        'marker-mid',\n        'marker-end',\n        'mask',\n        'stroke'\n    ];\n    var ɵ0 = function (attr) { return \"[\" + attr + \"]\"; };\n    /** Selector that can be used to find all elements that are using a `FuncIRI`. */\n    var funcIriAttributeSelector = funcIriAttributes.map(ɵ0).join(', ');\n    /** Regex that can be used to extract the id out of a FuncIRI. */\n    var funcIriPattern = /^url\\(['\"]?#(.*?)['\"]?\\)$/;\n    /**\n     * Component to display an icon. It can be used in the following ways:\n     *\n     * - Specify the svgIcon input to load an SVG icon from a URL previously registered with the\n     *   addSvgIcon, addSvgIconInNamespace, addSvgIconSet, or addSvgIconSetInNamespace methods of\n     *   MatIconRegistry. If the svgIcon value contains a colon it is assumed to be in the format\n     *   \"[namespace]:[name]\", if not the value will be the name of an icon in the default namespace.\n     *   Examples:\n     *     `<mat-icon svgIcon=\"left-arrow\"></mat-icon>\n     *     <mat-icon svgIcon=\"animals:cat\"></mat-icon>`\n     *\n     * - Use a font ligature as an icon by putting the ligature text in the content of the `<mat-icon>`\n     *   component. By default the Material icons font is used as described at\n     *   http://google.github.io/material-design-icons/#icon-font-for-the-web. You can specify an\n     *   alternate font by setting the fontSet input to either the CSS class to apply to use the\n     *   desired font, or to an alias previously registered with MatIconRegistry.registerFontClassAlias.\n     *   Examples:\n     *     `<mat-icon>home</mat-icon>\n     *     <mat-icon fontSet=\"myfont\">sun</mat-icon>`\n     *\n     * - Specify a font glyph to be included via CSS rules by setting the fontSet input to specify the\n     *   font, and the fontIcon input to specify the icon. Typically the fontIcon will specify a\n     *   CSS class which causes the glyph to be displayed via a :before selector, as in\n     *   https://fortawesome.github.io/Font-Awesome/examples/\n     *   Example:\n     *     `<mat-icon fontSet=\"fa\" fontIcon=\"alarm\"></mat-icon>`\n     */\n    var MatIcon = /** @class */ (function (_super) {\n        __extends(MatIcon, _super);\n        function MatIcon(elementRef, _iconRegistry, ariaHidden, \n        /**\n         * @deprecated `location` parameter to be made required.\n         * @breaking-change 8.0.0\n         */\n        _location, \n        // @breaking-change 9.0.0 _errorHandler parameter to be made required\n        _errorHandler) {\n            var _this = _super.call(this, elementRef) || this;\n            _this._iconRegistry = _iconRegistry;\n            _this._location = _location;\n            _this._errorHandler = _errorHandler;\n            _this._inline = false;\n            /** Subscription to the current in-progress SVG icon request. */\n            _this._currentIconFetch = rxjs.Subscription.EMPTY;\n            // If the user has not explicitly set aria-hidden, mark the icon as hidden, as this is\n            // the right thing to do for the majority of icon use-cases.\n            if (!ariaHidden) {\n                elementRef.nativeElement.setAttribute('aria-hidden', 'true');\n            }\n            return _this;\n        }\n        Object.defineProperty(MatIcon.prototype, \"inline\", {\n            /**\n             * Whether the icon should be inlined, automatically sizing the icon to match the font size of\n             * the element the icon is contained in.\n             */\n            get: function () {\n                return this._inline;\n            },\n            set: function (inline) {\n                this._inline = coercion.coerceBooleanProperty(inline);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatIcon.prototype, \"fontSet\", {\n            /** Font set that the icon is a part of. */\n            get: function () { return this._fontSet; },\n            set: function (value) {\n                this._fontSet = this._cleanupFontValue(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatIcon.prototype, \"fontIcon\", {\n            /** Name of an icon within a font set. */\n            get: function () { return this._fontIcon; },\n            set: function (value) {\n                this._fontIcon = this._cleanupFontValue(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Splits an svgIcon binding value into its icon set and icon name components.\n         * Returns a 2-element array of [(icon set), (icon name)].\n         * The separator for the two fields is ':'. If there is no separator, an empty\n         * string is returned for the icon set and the entire value is returned for\n         * the icon name. If the argument is falsy, returns an array of two empty strings.\n         * Throws an error if the name contains two or more ':' separators.\n         * Examples:\n         *   `'social:cake' -> ['social', 'cake']\n         *   'penguin' -> ['', 'penguin']\n         *   null -> ['', '']\n         *   'a:b:c' -> (throws Error)`\n         */\n        MatIcon.prototype._splitIconName = function (iconName) {\n            if (!iconName) {\n                return ['', ''];\n            }\n            var parts = iconName.split(':');\n            switch (parts.length) {\n                case 1: return ['', parts[0]]; // Use default namespace.\n                case 2: return parts;\n                default: throw Error(\"Invalid icon name: \\\"\" + iconName + \"\\\"\");\n            }\n        };\n        MatIcon.prototype.ngOnChanges = function (changes) {\n            var _this = this;\n            // Only update the inline SVG icon if the inputs changed, to avoid unnecessary DOM operations.\n            var svgIconChanges = changes['svgIcon'];\n            if (svgIconChanges) {\n                this._currentIconFetch.unsubscribe();\n                if (this.svgIcon) {\n                    var _a = __read(this._splitIconName(this.svgIcon), 2), namespace_1 = _a[0], iconName_1 = _a[1];\n                    this._currentIconFetch = this._iconRegistry.getNamedSvgIcon(iconName_1, namespace_1)\n                        .pipe(operators.take(1))\n                        .subscribe(function (svg) { return _this._setSvgElement(svg); }, function (err) {\n                        var errorMessage = \"Error retrieving icon \" + namespace_1 + \":\" + iconName_1 + \"! \" + err.message;\n                        // @breaking-change 9.0.0 _errorHandler parameter to be made required.\n                        if (_this._errorHandler) {\n                            _this._errorHandler.handleError(new Error(errorMessage));\n                        }\n                        else {\n                            console.error(errorMessage);\n                        }\n                    });\n                }\n                else if (svgIconChanges.previousValue) {\n                    this._clearSvgElement();\n                }\n            }\n            if (this._usingFontIcon()) {\n                this._updateFontIconClasses();\n            }\n        };\n        MatIcon.prototype.ngOnInit = function () {\n            // Update font classes because ngOnChanges won't be called if none of the inputs are present,\n            // e.g. <mat-icon>arrow</mat-icon> In this case we need to add a CSS class for the default font.\n            if (this._usingFontIcon()) {\n                this._updateFontIconClasses();\n            }\n        };\n        MatIcon.prototype.ngAfterViewChecked = function () {\n            var cachedElements = this._elementsWithExternalReferences;\n            if (cachedElements && this._location && cachedElements.size) {\n                var newPath = this._location.getPathname();\n                // We need to check whether the URL has changed on each change detection since\n                // the browser doesn't have an API that will let us react on link clicks and\n                // we can't depend on the Angular router. The references need to be updated,\n                // because while most browsers don't care whether the URL is correct after\n                // the first render, Safari will break if the user navigates to a different\n                // page and the SVG isn't re-rendered.\n                if (newPath !== this._previousPath) {\n                    this._previousPath = newPath;\n                    this._prependPathToReferences(newPath);\n                }\n            }\n        };\n        MatIcon.prototype.ngOnDestroy = function () {\n            this._currentIconFetch.unsubscribe();\n            if (this._elementsWithExternalReferences) {\n                this._elementsWithExternalReferences.clear();\n            }\n        };\n        MatIcon.prototype._usingFontIcon = function () {\n            return !this.svgIcon;\n        };\n        MatIcon.prototype._setSvgElement = function (svg) {\n            this._clearSvgElement();\n            // Workaround for IE11 and Edge ignoring `style` tags inside dynamically-created SVGs.\n            // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10898469/\n            // Do this before inserting the element into the DOM, in order to avoid a style recalculation.\n            var styleTags = svg.querySelectorAll('style');\n            for (var i = 0; i < styleTags.length; i++) {\n                styleTags[i].textContent += ' ';\n            }\n            // Note: we do this fix here, rather than the icon registry, because the\n            // references have to point to the URL at the time that the icon was created.\n            if (this._location) {\n                var path = this._location.getPathname();\n                this._previousPath = path;\n                this._cacheChildrenWithExternalReferences(svg);\n                this._prependPathToReferences(path);\n            }\n            this._elementRef.nativeElement.appendChild(svg);\n        };\n        MatIcon.prototype._clearSvgElement = function () {\n            var layoutElement = this._elementRef.nativeElement;\n            var childCount = layoutElement.childNodes.length;\n            if (this._elementsWithExternalReferences) {\n                this._elementsWithExternalReferences.clear();\n            }\n            // Remove existing non-element child nodes and SVGs, and add the new SVG element. Note that\n            // we can't use innerHTML, because IE will throw if the element has a data binding.\n            while (childCount--) {\n                var child = layoutElement.childNodes[childCount];\n                // 1 corresponds to Node.ELEMENT_NODE. We remove all non-element nodes in order to get rid\n                // of any loose text nodes, as well as any SVG elements in order to remove any old icons.\n                if (child.nodeType !== 1 || child.nodeName.toLowerCase() === 'svg') {\n                    layoutElement.removeChild(child);\n                }\n            }\n        };\n        MatIcon.prototype._updateFontIconClasses = function () {\n            if (!this._usingFontIcon()) {\n                return;\n            }\n            var elem = this._elementRef.nativeElement;\n            var fontSetClass = this.fontSet ?\n                this._iconRegistry.classNameForFontAlias(this.fontSet) :\n                this._iconRegistry.getDefaultFontSetClass();\n            if (fontSetClass != this._previousFontSetClass) {\n                if (this._previousFontSetClass) {\n                    elem.classList.remove(this._previousFontSetClass);\n                }\n                if (fontSetClass) {\n                    elem.classList.add(fontSetClass);\n                }\n                this._previousFontSetClass = fontSetClass;\n            }\n            if (this.fontIcon != this._previousFontIconClass) {\n                if (this._previousFontIconClass) {\n                    elem.classList.remove(this._previousFontIconClass);\n                }\n                if (this.fontIcon) {\n                    elem.classList.add(this.fontIcon);\n                }\n                this._previousFontIconClass = this.fontIcon;\n            }\n        };\n        /**\n         * Cleans up a value to be used as a fontIcon or fontSet.\n         * Since the value ends up being assigned as a CSS class, we\n         * have to trim the value and omit space-separated values.\n         */\n        MatIcon.prototype._cleanupFontValue = function (value) {\n            return typeof value === 'string' ? value.trim().split(' ')[0] : value;\n        };\n        /**\n         * Prepends the current path to all elements that have an attribute pointing to a `FuncIRI`\n         * reference. This is required because WebKit browsers require references to be prefixed with\n         * the current path, if the page has a `base` tag.\n         */\n        MatIcon.prototype._prependPathToReferences = function (path) {\n            var elements = this._elementsWithExternalReferences;\n            if (elements) {\n                elements.forEach(function (attrs, element) {\n                    attrs.forEach(function (attr) {\n                        element.setAttribute(attr.name, \"url('\" + path + \"#\" + attr.value + \"')\");\n                    });\n                });\n            }\n        };\n        /**\n         * Caches the children of an SVG element that have `url()`\n         * references that we need to prefix with the current path.\n         */\n        MatIcon.prototype._cacheChildrenWithExternalReferences = function (element) {\n            var elementsWithFuncIri = element.querySelectorAll(funcIriAttributeSelector);\n            var elements = this._elementsWithExternalReferences =\n                this._elementsWithExternalReferences || new Map();\n            var _loop_1 = function (i) {\n                funcIriAttributes.forEach(function (attr) {\n                    var elementWithReference = elementsWithFuncIri[i];\n                    var value = elementWithReference.getAttribute(attr);\n                    var match = value ? value.match(funcIriPattern) : null;\n                    if (match) {\n                        var attributes = elements.get(elementWithReference);\n                        if (!attributes) {\n                            attributes = [];\n                            elements.set(elementWithReference, attributes);\n                        }\n                        attributes.push({ name: attr, value: match[1] });\n                    }\n                });\n            };\n            for (var i = 0; i < elementsWithFuncIri.length; i++) {\n                _loop_1(i);\n            }\n        };\n        MatIcon.decorators = [\n            { type: i0.Component, args: [{\n                        template: '<ng-content></ng-content>',\n                        selector: 'mat-icon',\n                        exportAs: 'matIcon',\n                        inputs: ['color'],\n                        host: {\n                            'role': 'img',\n                            'class': 'mat-icon notranslate',\n                            '[class.mat-icon-inline]': 'inline',\n                            '[class.mat-icon-no-color]': 'color !== \"primary\" && color !== \"accent\" && color !== \"warn\"',\n                        },\n                        encapsulation: i0.ViewEncapsulation.None,\n                        changeDetection: i0.ChangeDetectionStrategy.OnPush,\n                        styles: [\".mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\\n\"]\n                    }] }\n        ];\n        /** @nocollapse */\n        MatIcon.ctorParameters = function () { return [\n            { type: i0.ElementRef },\n            { type: MatIconRegistry },\n            { type: String, decorators: [{ type: i0.Attribute, args: ['aria-hidden',] }] },\n            { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [MAT_ICON_LOCATION,] }] },\n            { type: i0.ErrorHandler, decorators: [{ type: i0.Optional }] }\n        ]; };\n        MatIcon.propDecorators = {\n            inline: [{ type: i0.Input }],\n            svgIcon: [{ type: i0.Input }],\n            fontSet: [{ type: i0.Input }],\n            fontIcon: [{ type: i0.Input }]\n        };\n        return MatIcon;\n    }(_MatIconMixinBase));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var MatIconModule = /** @class */ (function () {\n        function MatIconModule() {\n        }\n        MatIconModule.decorators = [\n            { type: i0.NgModule, args: [{\n                        imports: [core.MatCommonModule],\n                        exports: [MatIcon, core.MatCommonModule],\n                        declarations: [MatIcon],\n                    },] }\n        ];\n        return MatIconModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.ICON_REGISTRY_PROVIDER = ICON_REGISTRY_PROVIDER;\n    exports.ICON_REGISTRY_PROVIDER_FACTORY = ICON_REGISTRY_PROVIDER_FACTORY;\n    exports.MAT_ICON_LOCATION = MAT_ICON_LOCATION;\n    exports.MAT_ICON_LOCATION_FACTORY = MAT_ICON_LOCATION_FACTORY;\n    exports.MatIcon = MatIcon;\n    exports.MatIconModule = MatIconModule;\n    exports.MatIconRegistry = MatIconRegistry;\n    exports.getMatIconFailedToSanitizeLiteralError = getMatIconFailedToSanitizeLiteralError;\n    exports.getMatIconFailedToSanitizeUrlError = getMatIconFailedToSanitizeUrlError;\n    exports.getMatIconNameNotFoundError = getMatIconNameNotFoundError;\n    exports.getMatIconNoHttpProviderError = getMatIconNoHttpProviderError;\n    exports.ɵ0 = ɵ0;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=material-icon.umd.js.map\n"]}