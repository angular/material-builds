{"version":3,"sources":["src/material/material-radio.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","material","radio","common","core","tslib","cdk","a11y","coercion","collections","forms","platformBrowser","animations","this","core$1","MAT_RADIO_DEFAULT_OPTIONS","InjectionToken","providedIn","MAT_RADIO_DEFAULT_OPTIONS_FACTORY","color","nextUniqueId","MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR","provide","NG_VALUE_ACCESSOR","useExisting","forwardRef","MatRadioGroup","multi","MatRadioChange","source","value","_changeDetector","_value","_name","_selected","_isInitialized","_labelPosition","_disabled","_required","_controlValueAccessorChangeFn","onTouched","change","EventEmitter","Object","defineProperty","prototype","get","set","_updateRadioButtonNames","enumerable","configurable","v","_markRadiosForCheck","newValue","_updateSelectedRadioFromValue","_checkSelectedRadioButton","checked","selected","coerceBooleanProperty","ngAfterContentInit","_touch","_this","_radios","forEach","name","_markForCheck","_emitChangeEvent","emit","writeValue","markForCheck","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","disabled","decorators","type","Directive","args","selector","exportAs","providers","host","role","class","ctorParameters","ChangeDetectorRef","propDecorators","Output","ContentChildren","MatRadioButton","descendants","Input","labelPosition","required","_super","radioGroup","elementRef","_focusMonitor","_radioDispatcher","_animationMode","_providerOverride","call","_uniqueId","id","_checked","_removeUniqueSelectionListener","listen","__extends","newCheckedState","notify","newDisabledState","_color","focus","options","focusVia","_inputElement","ngOnInit","ngAfterViewInit","monitor","_elementRef","subscribe","focusOrigin","ngOnDestroy","stopMonitoring","_isRippleDisabled","disableRipple","_onInputClick","event","stopPropagation","_onInputChange","groupValueChanged","Component","template","inputs","encapsulation","ViewEncapsulation","None","[class.mat-radio-checked]","[class.mat-radio-disabled]","[class._mat-animation-noopable]","[class.mat-primary]","[class.mat-accent]","[class.mat-warn]","[attr.tabindex]","[attr.id]","[attr.aria-label]","[attr.aria-labelledby]","[attr.aria-describedby]","(focus)","changeDetection","ChangeDetectionStrategy","OnPush","styles","Optional","ElementRef","FocusMonitor","UniqueSelectionDispatcher","String","Inject","ANIMATION_MODULE_TYPE","undefined","ariaLabel","ariaLabelledby","ariaDescribedby","ViewChild","mixinDisableRipple","mixinTabIndex","MatRadioButtonBase","MatRadioModule","NgModule","imports","CommonModule","MatRippleModule","MatCommonModule","declarations"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('@angular/material/core'), require('tslib'), require('@angular/cdk/a11y'), require('@angular/cdk/coercion'), require('@angular/cdk/collections'), require('@angular/forms'), require('@angular/platform-browser/animations')) :\n    typeof define === 'function' && define.amd ? define('@angular/material/radio', ['exports', '@angular/common', '@angular/core', '@angular/material/core', 'tslib', '@angular/cdk/a11y', '@angular/cdk/coercion', '@angular/cdk/collections', '@angular/forms', '@angular/platform-browser/animations'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.radio = {}), global.ng.common, global.ng.core, global.ng.material.core, global.tslib, global.ng.cdk.a11y, global.ng.cdk.coercion, global.ng.cdk.collections, global.ng.forms, global.ng.platformBrowser.animations));\n}(this, (function (exports, common, core, core$1, tslib, a11y, coercion, collections, forms, animations) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var MAT_RADIO_DEFAULT_OPTIONS = new core.InjectionToken('mat-radio-default-options', {\n        providedIn: 'root',\n        factory: MAT_RADIO_DEFAULT_OPTIONS_FACTORY\n    });\n    function MAT_RADIO_DEFAULT_OPTIONS_FACTORY() {\n        return {\n            color: 'accent'\n        };\n    }\n    // Increasing integer for generating unique ids for radio components.\n    var nextUniqueId = 0;\n    /**\n     * Provider Expression that allows mat-radio-group to register as a ControlValueAccessor. This\n     * allows it to support [(ngModel)] and ngControl.\n     * @docs-private\n     */\n    var MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {\n        provide: forms.NG_VALUE_ACCESSOR,\n        useExisting: core.forwardRef(function () { return MatRadioGroup; }),\n        multi: true\n    };\n    /** Change event object emitted by MatRadio and MatRadioGroup. */\n    var MatRadioChange = /** @class */ (function () {\n        function MatRadioChange(\n        /** The MatRadioButton that emits the change event. */\n        source, \n        /** The value of the MatRadioButton. */\n        value) {\n            this.source = source;\n            this.value = value;\n        }\n        return MatRadioChange;\n    }());\n    /**\n     * A group of radio buttons. May contain one or more `<mat-radio-button>` elements.\n     */\n    var MatRadioGroup = /** @class */ (function () {\n        function MatRadioGroup(_changeDetector) {\n            this._changeDetector = _changeDetector;\n            /** Selected value for the radio group. */\n            this._value = null;\n            /** The HTML name attribute applied to radio buttons in this group. */\n            this._name = \"mat-radio-group-\" + nextUniqueId++;\n            /** The currently selected radio button. Should match value. */\n            this._selected = null;\n            /** Whether the `value` has been set to its initial value. */\n            this._isInitialized = false;\n            /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n            this._labelPosition = 'after';\n            /** Whether the radio group is disabled. */\n            this._disabled = false;\n            /** Whether the radio group is required. */\n            this._required = false;\n            /** The method to be called in order to update ngModel */\n            this._controlValueAccessorChangeFn = function () { };\n            /**\n             * onTouch function registered via registerOnTouch (ControlValueAccessor).\n             * @docs-private\n             */\n            this.onTouched = function () { };\n            /**\n             * Event emitted when the group value changes.\n             * Change events are only emitted when the value changes due to user interaction with\n             * a radio button (the same behavior as `<input type-\"radio\">`).\n             */\n            this.change = new core.EventEmitter();\n        }\n        Object.defineProperty(MatRadioGroup.prototype, \"name\", {\n            /** Name of the radio button group. All radio buttons inside this group will use this name. */\n            get: function () { return this._name; },\n            set: function (value) {\n                this._name = value;\n                this._updateRadioButtonNames();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatRadioGroup.prototype, \"labelPosition\", {\n            /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n            get: function () {\n                return this._labelPosition;\n            },\n            set: function (v) {\n                this._labelPosition = v === 'before' ? 'before' : 'after';\n                this._markRadiosForCheck();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatRadioGroup.prototype, \"value\", {\n            /**\n             * Value for the radio-group. Should equal the value of the selected radio button if there is\n             * a corresponding radio button with a matching value. If there is not such a corresponding\n             * radio button, this value persists to be applied in case a new radio button is added with a\n             * matching value.\n             */\n            get: function () { return this._value; },\n            set: function (newValue) {\n                if (this._value !== newValue) {\n                    // Set this before proceeding to ensure no circular loop occurs with selection.\n                    this._value = newValue;\n                    this._updateSelectedRadioFromValue();\n                    this._checkSelectedRadioButton();\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MatRadioGroup.prototype._checkSelectedRadioButton = function () {\n            if (this._selected && !this._selected.checked) {\n                this._selected.checked = true;\n            }\n        };\n        Object.defineProperty(MatRadioGroup.prototype, \"selected\", {\n            /**\n             * The currently selected radio button. If set to a new radio button, the radio group value\n             * will be updated to match the new selected button.\n             */\n            get: function () { return this._selected; },\n            set: function (selected) {\n                this._selected = selected;\n                this.value = selected ? selected.value : null;\n                this._checkSelectedRadioButton();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatRadioGroup.prototype, \"disabled\", {\n            /** Whether the radio group is disabled */\n            get: function () { return this._disabled; },\n            set: function (value) {\n                this._disabled = coercion.coerceBooleanProperty(value);\n                this._markRadiosForCheck();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatRadioGroup.prototype, \"required\", {\n            /** Whether the radio group is required */\n            get: function () { return this._required; },\n            set: function (value) {\n                this._required = coercion.coerceBooleanProperty(value);\n                this._markRadiosForCheck();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Initialize properties once content children are available.\n         * This allows us to propagate relevant attributes to associated buttons.\n         */\n        MatRadioGroup.prototype.ngAfterContentInit = function () {\n            // Mark this component as initialized in AfterContentInit because the initial value can\n            // possibly be set by NgModel on MatRadioGroup, and it is possible that the OnInit of the\n            // NgModel occurs *after* the OnInit of the MatRadioGroup.\n            this._isInitialized = true;\n        };\n        /**\n         * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\n         * radio buttons upon their blur.\n         */\n        MatRadioGroup.prototype._touch = function () {\n            if (this.onTouched) {\n                this.onTouched();\n            }\n        };\n        MatRadioGroup.prototype._updateRadioButtonNames = function () {\n            var _this = this;\n            if (this._radios) {\n                this._radios.forEach(function (radio) {\n                    radio.name = _this.name;\n                    radio._markForCheck();\n                });\n            }\n        };\n        /** Updates the `selected` radio button from the internal _value state. */\n        MatRadioGroup.prototype._updateSelectedRadioFromValue = function () {\n            var _this = this;\n            // If the value already matches the selected radio, do nothing.\n            var isAlreadySelected = this._selected !== null && this._selected.value === this._value;\n            if (this._radios && !isAlreadySelected) {\n                this._selected = null;\n                this._radios.forEach(function (radio) {\n                    radio.checked = _this.value === radio.value;\n                    if (radio.checked) {\n                        _this._selected = radio;\n                    }\n                });\n            }\n        };\n        /** Dispatch change event with current selection and group value. */\n        MatRadioGroup.prototype._emitChangeEvent = function () {\n            if (this._isInitialized) {\n                this.change.emit(new MatRadioChange(this._selected, this._value));\n            }\n        };\n        MatRadioGroup.prototype._markRadiosForCheck = function () {\n            if (this._radios) {\n                this._radios.forEach(function (radio) { return radio._markForCheck(); });\n            }\n        };\n        /**\n         * Sets the model value. Implemented as part of ControlValueAccessor.\n         * @param value\n         */\n        MatRadioGroup.prototype.writeValue = function (value) {\n            this.value = value;\n            this._changeDetector.markForCheck();\n        };\n        /**\n         * Registers a callback to be triggered when the model value changes.\n         * Implemented as part of ControlValueAccessor.\n         * @param fn Callback to be registered.\n         */\n        MatRadioGroup.prototype.registerOnChange = function (fn) {\n            this._controlValueAccessorChangeFn = fn;\n        };\n        /**\n         * Registers a callback to be triggered when the control is touched.\n         * Implemented as part of ControlValueAccessor.\n         * @param fn Callback to be registered.\n         */\n        MatRadioGroup.prototype.registerOnTouched = function (fn) {\n            this.onTouched = fn;\n        };\n        /**\n         * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\n         * @param isDisabled Whether the control should be disabled.\n         */\n        MatRadioGroup.prototype.setDisabledState = function (isDisabled) {\n            this.disabled = isDisabled;\n            this._changeDetector.markForCheck();\n        };\n        MatRadioGroup.decorators = [\n            { type: core.Directive, args: [{\n                        selector: 'mat-radio-group',\n                        exportAs: 'matRadioGroup',\n                        providers: [MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR],\n                        host: {\n                            'role': 'radiogroup',\n                            'class': 'mat-radio-group',\n                        },\n                    },] }\n        ];\n        /** @nocollapse */\n        MatRadioGroup.ctorParameters = function () { return [\n            { type: core.ChangeDetectorRef }\n        ]; };\n        MatRadioGroup.propDecorators = {\n            change: [{ type: core.Output }],\n            _radios: [{ type: core.ContentChildren, args: [core.forwardRef(function () { return MatRadioButton; }), { descendants: true },] }],\n            color: [{ type: core.Input }],\n            name: [{ type: core.Input }],\n            labelPosition: [{ type: core.Input }],\n            value: [{ type: core.Input }],\n            selected: [{ type: core.Input }],\n            disabled: [{ type: core.Input }],\n            required: [{ type: core.Input }]\n        };\n        return MatRadioGroup;\n    }());\n    // Boilerplate for applying mixins to MatRadioButton.\n    /** @docs-private */\n    var MatRadioButtonBase = /** @class */ (function () {\n        function MatRadioButtonBase(_elementRef) {\n            this._elementRef = _elementRef;\n        }\n        return MatRadioButtonBase;\n    }());\n    // As per Material design specifications the selection control radio should use the accent color\n    // palette by default. https://material.io/guidelines/components/selection-controls.html\n    var _MatRadioButtonMixinBase = core$1.mixinDisableRipple(core$1.mixinTabIndex(MatRadioButtonBase));\n    /**\n     * A Material design radio-button. Typically placed inside of `<mat-radio-group>` elements.\n     */\n    var MatRadioButton = /** @class */ (function (_super) {\n        tslib.__extends(MatRadioButton, _super);\n        function MatRadioButton(radioGroup, elementRef, _changeDetector, _focusMonitor, _radioDispatcher, _animationMode, _providerOverride) {\n            var _this = _super.call(this, elementRef) || this;\n            _this._changeDetector = _changeDetector;\n            _this._focusMonitor = _focusMonitor;\n            _this._radioDispatcher = _radioDispatcher;\n            _this._animationMode = _animationMode;\n            _this._providerOverride = _providerOverride;\n            _this._uniqueId = \"mat-radio-\" + ++nextUniqueId;\n            /** The unique ID for the radio button. */\n            _this.id = _this._uniqueId;\n            /**\n             * Event emitted when the checked state of this radio button changes.\n             * Change events are only emitted when the value changes due to user interaction with\n             * the radio button (the same behavior as `<input type-\"radio\">`).\n             */\n            _this.change = new core.EventEmitter();\n            /** Whether this radio is checked. */\n            _this._checked = false;\n            /** Value assigned to this radio. */\n            _this._value = null;\n            /** Unregister function for _radioDispatcher */\n            _this._removeUniqueSelectionListener = function () { };\n            // Assertions. Ideally these should be stripped out by the compiler.\n            // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.\n            _this.radioGroup = radioGroup;\n            _this._removeUniqueSelectionListener =\n                _radioDispatcher.listen(function (id, name) {\n                    if (id !== _this.id && name === _this.name) {\n                        _this.checked = false;\n                    }\n                });\n            return _this;\n        }\n        Object.defineProperty(MatRadioButton.prototype, \"checked\", {\n            /** Whether this radio button is checked. */\n            get: function () { return this._checked; },\n            set: function (value) {\n                var newCheckedState = coercion.coerceBooleanProperty(value);\n                if (this._checked !== newCheckedState) {\n                    this._checked = newCheckedState;\n                    if (newCheckedState && this.radioGroup && this.radioGroup.value !== this.value) {\n                        this.radioGroup.selected = this;\n                    }\n                    else if (!newCheckedState && this.radioGroup && this.radioGroup.value === this.value) {\n                        // When unchecking the selected radio button, update the selected radio\n                        // property on the group.\n                        this.radioGroup.selected = null;\n                    }\n                    if (newCheckedState) {\n                        // Notify all radio buttons with the same name to un-check.\n                        this._radioDispatcher.notify(this.id, this.name);\n                    }\n                    this._changeDetector.markForCheck();\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatRadioButton.prototype, \"value\", {\n            /** The value of this radio button. */\n            get: function () { return this._value; },\n            set: function (value) {\n                if (this._value !== value) {\n                    this._value = value;\n                    if (this.radioGroup !== null) {\n                        if (!this.checked) {\n                            // Update checked when the value changed to match the radio group's value\n                            this.checked = this.radioGroup.value === value;\n                        }\n                        if (this.checked) {\n                            this.radioGroup.selected = this;\n                        }\n                    }\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatRadioButton.prototype, \"labelPosition\", {\n            /** Whether the label should appear after or before the radio button. Defaults to 'after' */\n            get: function () {\n                return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || 'after';\n            },\n            set: function (value) {\n                this._labelPosition = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatRadioButton.prototype, \"disabled\", {\n            /** Whether the radio button is disabled. */\n            get: function () {\n                return this._disabled || (this.radioGroup !== null && this.radioGroup.disabled);\n            },\n            set: function (value) {\n                var newDisabledState = coercion.coerceBooleanProperty(value);\n                if (this._disabled !== newDisabledState) {\n                    this._disabled = newDisabledState;\n                    this._changeDetector.markForCheck();\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatRadioButton.prototype, \"required\", {\n            /** Whether the radio button is required. */\n            get: function () {\n                return this._required || (this.radioGroup && this.radioGroup.required);\n            },\n            set: function (value) {\n                this._required = coercion.coerceBooleanProperty(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatRadioButton.prototype, \"color\", {\n            /** Theme color of the radio button. */\n            get: function () {\n                return this._color ||\n                    (this.radioGroup && this.radioGroup.color) ||\n                    this._providerOverride && this._providerOverride.color || 'accent';\n            },\n            set: function (newValue) { this._color = newValue; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatRadioButton.prototype, \"inputId\", {\n            /** ID of the native input element inside `<mat-radio-button>` */\n            get: function () { return (this.id || this._uniqueId) + \"-input\"; },\n            enumerable: true,\n            configurable: true\n        });\n        /** Focuses the radio button. */\n        MatRadioButton.prototype.focus = function (options) {\n            this._focusMonitor.focusVia(this._inputElement, 'keyboard', options);\n        };\n        /**\n         * Marks the radio button as needing checking for change detection.\n         * This method is exposed because the parent radio group will directly\n         * update bound properties of the radio button.\n         */\n        MatRadioButton.prototype._markForCheck = function () {\n            // When group value changes, the button will not be notified. Use `markForCheck` to explicit\n            // update radio button's status\n            this._changeDetector.markForCheck();\n        };\n        MatRadioButton.prototype.ngOnInit = function () {\n            if (this.radioGroup) {\n                // If the radio is inside a radio group, determine if it should be checked\n                this.checked = this.radioGroup.value === this._value;\n                // Copy name from parent radio group\n                this.name = this.radioGroup.name;\n            }\n        };\n        MatRadioButton.prototype.ngAfterViewInit = function () {\n            var _this = this;\n            this._focusMonitor\n                .monitor(this._elementRef, true)\n                .subscribe(function (focusOrigin) {\n                if (!focusOrigin && _this.radioGroup) {\n                    _this.radioGroup._touch();\n                }\n            });\n        };\n        MatRadioButton.prototype.ngOnDestroy = function () {\n            this._focusMonitor.stopMonitoring(this._elementRef);\n            this._removeUniqueSelectionListener();\n        };\n        /** Dispatch change event with current value. */\n        MatRadioButton.prototype._emitChangeEvent = function () {\n            this.change.emit(new MatRadioChange(this, this._value));\n        };\n        MatRadioButton.prototype._isRippleDisabled = function () {\n            return this.disableRipple || this.disabled;\n        };\n        MatRadioButton.prototype._onInputClick = function (event) {\n            // We have to stop propagation for click events on the visual hidden input element.\n            // By default, when a user clicks on a label element, a generated click event will be\n            // dispatched on the associated input element. Since we are using a label element as our\n            // root container, the click event on the `radio-button` will be executed twice.\n            // The real click event will bubble up, and the generated click event also tries to bubble up.\n            // This will lead to multiple click events.\n            // Preventing bubbling for the second event will solve that issue.\n            event.stopPropagation();\n        };\n        /**\n         * Triggered when the radio button received a click or the input recognized any change.\n         * Clicking on a label element, will trigger a change event on the associated input.\n         */\n        MatRadioButton.prototype._onInputChange = function (event) {\n            // We always have to stop propagation on the change event.\n            // Otherwise the change event, from the input element, will bubble up and\n            // emit its event object to the `change` output.\n            event.stopPropagation();\n            var groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;\n            this.checked = true;\n            this._emitChangeEvent();\n            if (this.radioGroup) {\n                this.radioGroup._controlValueAccessorChangeFn(this.value);\n                if (groupValueChanged) {\n                    this.radioGroup._emitChangeEvent();\n                }\n            }\n        };\n        MatRadioButton.decorators = [\n            { type: core.Component, args: [{\n                        selector: 'mat-radio-button',\n                        template: \"<!-- TODO(jelbourn): render the radio on either side of the content -->\\n<!-- TODO(mtlin): Evaluate trade-offs of using native radio vs. cost of additional bindings. -->\\n<label [attr.for]=\\\"inputId\\\" class=\\\"mat-radio-label\\\" #label>\\n  <!-- The actual 'radio' part of the control. -->\\n  <div class=\\\"mat-radio-container\\\">\\n    <div class=\\\"mat-radio-outer-circle\\\"></div>\\n    <div class=\\\"mat-radio-inner-circle\\\"></div>\\n    <div mat-ripple class=\\\"mat-radio-ripple\\\"\\n         [matRippleTrigger]=\\\"label\\\"\\n         [matRippleDisabled]=\\\"_isRippleDisabled()\\\"\\n         [matRippleCentered]=\\\"true\\\"\\n         [matRippleRadius]=\\\"20\\\"\\n         [matRippleAnimation]=\\\"{enterDuration: 150}\\\">\\n\\n      <div class=\\\"mat-ripple-element mat-radio-persistent-ripple\\\"></div>\\n    </div>\\n\\n    <input #input class=\\\"mat-radio-input cdk-visually-hidden\\\" type=\\\"radio\\\"\\n        [id]=\\\"inputId\\\"\\n        [checked]=\\\"checked\\\"\\n        [disabled]=\\\"disabled\\\"\\n        [tabIndex]=\\\"tabIndex\\\"\\n        [attr.name]=\\\"name\\\"\\n        [attr.value]=\\\"value\\\"\\n        [required]=\\\"required\\\"\\n        [attr.aria-label]=\\\"ariaLabel\\\"\\n        [attr.aria-labelledby]=\\\"ariaLabelledby\\\"\\n        [attr.aria-describedby]=\\\"ariaDescribedby\\\"\\n        (change)=\\\"_onInputChange($event)\\\"\\n        (click)=\\\"_onInputClick($event)\\\">\\n  </div>\\n\\n  <!-- The label content for radio control. -->\\n  <div class=\\\"mat-radio-label-content\\\" [class.mat-radio-label-before]=\\\"labelPosition == 'before'\\\">\\n    <!-- Add an invisible span so JAWS can read the label -->\\n    <span style=\\\"display:none\\\">&nbsp;</span>\\n    <ng-content></ng-content>\\n  </div>\\n</label>\\n\",\n                        inputs: ['disableRipple', 'tabIndex'],\n                        encapsulation: core.ViewEncapsulation.None,\n                        exportAs: 'matRadioButton',\n                        host: {\n                            'class': 'mat-radio-button',\n                            '[class.mat-radio-checked]': 'checked',\n                            '[class.mat-radio-disabled]': 'disabled',\n                            '[class._mat-animation-noopable]': '_animationMode === \"NoopAnimations\"',\n                            '[class.mat-primary]': 'color === \"primary\"',\n                            '[class.mat-accent]': 'color === \"accent\"',\n                            '[class.mat-warn]': 'color === \"warn\"',\n                            // Needs to be -1 so the `focus` event still fires.\n                            '[attr.tabindex]': '-1',\n                            '[attr.id]': 'id',\n                            '[attr.aria-label]': 'null',\n                            '[attr.aria-labelledby]': 'null',\n                            '[attr.aria-describedby]': 'null',\n                            // Note: under normal conditions focus shouldn't land on this element, however it may be\n                            // programmatically set, for example inside of a focus trap, in this case we want to forward\n                            // the focus to the native element.\n                            '(focus)': '_inputElement.nativeElement.focus()',\n                        },\n                        changeDetection: core.ChangeDetectionStrategy.OnPush,\n                        styles: [\".mat-radio-button{display:inline-block;-webkit-tap-highlight-color:transparent;outline:0}.mat-radio-label{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;vertical-align:middle;width:100%}.mat-radio-container{box-sizing:border-box;display:inline-block;position:relative;width:20px;height:20px;flex-shrink:0}.mat-radio-outer-circle{box-sizing:border-box;height:20px;left:0;position:absolute;top:0;transition:border-color ease 280ms;width:20px;border-width:2px;border-style:solid;border-radius:50%}._mat-animation-noopable .mat-radio-outer-circle{transition:none}.mat-radio-inner-circle{border-radius:50%;box-sizing:border-box;height:20px;left:0;position:absolute;top:0;transition:transform ease 280ms,background-color ease 280ms;width:20px;transform:scale(0.001)}._mat-animation-noopable .mat-radio-inner-circle{transition:none}.mat-radio-checked .mat-radio-inner-circle{transform:scale(0.5)}.cdk-high-contrast-active .mat-radio-checked .mat-radio-inner-circle{border:solid 10px}.mat-radio-label-content{-webkit-user-select:auto;-moz-user-select:auto;-ms-user-select:auto;user-select:auto;display:inline-block;order:0;line-height:inherit;padding-left:8px;padding-right:0}[dir=rtl] .mat-radio-label-content{padding-right:8px;padding-left:0}.mat-radio-label-content.mat-radio-label-before{order:-1;padding-left:0;padding-right:8px}[dir=rtl] .mat-radio-label-content.mat-radio-label-before{padding-right:0;padding-left:8px}.mat-radio-disabled,.mat-radio-disabled .mat-radio-label{cursor:default}.mat-radio-button .mat-radio-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-radio-button .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple){opacity:.16}.mat-radio-persistent-ripple{width:100%;height:100%;transform:none}.mat-radio-container:hover .mat-radio-persistent-ripple{opacity:.04}.mat-radio-button:not(.mat-radio-disabled).cdk-keyboard-focused .mat-radio-persistent-ripple,.mat-radio-button:not(.mat-radio-disabled).cdk-program-focused .mat-radio-persistent-ripple{opacity:.12}.mat-radio-persistent-ripple,.mat-radio-disabled .mat-radio-container:hover .mat-radio-persistent-ripple{opacity:0}@media(hover: none){.mat-radio-container:hover .mat-radio-persistent-ripple{display:none}}.mat-radio-input{bottom:0;left:50%}.cdk-high-contrast-active .mat-radio-disabled{opacity:.5}\\n\"]\n                    }] }\n        ];\n        /** @nocollapse */\n        MatRadioButton.ctorParameters = function () { return [\n            { type: MatRadioGroup, decorators: [{ type: core.Optional }] },\n            { type: core.ElementRef },\n            { type: core.ChangeDetectorRef },\n            { type: a11y.FocusMonitor },\n            { type: collections.UniqueSelectionDispatcher },\n            { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] },\n            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_RADIO_DEFAULT_OPTIONS,] }] }\n        ]; };\n        MatRadioButton.propDecorators = {\n            id: [{ type: core.Input }],\n            name: [{ type: core.Input }],\n            ariaLabel: [{ type: core.Input, args: ['aria-label',] }],\n            ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],\n            ariaDescribedby: [{ type: core.Input, args: ['aria-describedby',] }],\n            checked: [{ type: core.Input }],\n            value: [{ type: core.Input }],\n            labelPosition: [{ type: core.Input }],\n            disabled: [{ type: core.Input }],\n            required: [{ type: core.Input }],\n            color: [{ type: core.Input }],\n            change: [{ type: core.Output }],\n            _inputElement: [{ type: core.ViewChild, args: ['input',] }]\n        };\n        return MatRadioButton;\n    }(_MatRadioButtonMixinBase));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var MatRadioModule = /** @class */ (function () {\n        function MatRadioModule() {\n        }\n        MatRadioModule.decorators = [\n            { type: core.NgModule, args: [{\n                        imports: [common.CommonModule, core$1.MatRippleModule, core$1.MatCommonModule],\n                        exports: [MatRadioGroup, MatRadioButton, core$1.MatCommonModule],\n                        declarations: [MatRadioGroup, MatRadioButton],\n                    },] }\n        ];\n        return MatRadioModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.MAT_RADIO_DEFAULT_OPTIONS = MAT_RADIO_DEFAULT_OPTIONS;\n    exports.MAT_RADIO_DEFAULT_OPTIONS_FACTORY = MAT_RADIO_DEFAULT_OPTIONS_FACTORY;\n    exports.MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR;\n    exports.MatRadioButton = MatRadioButton;\n    exports.MatRadioChange = MatRadioChange;\n    exports.MatRadioGroup = MatRadioGroup;\n    exports.MatRadioModule = MatRadioModule;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=material-radio.umd.js.map\n"]}