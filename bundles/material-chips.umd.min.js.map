{"version":3,"sources":["src/material/material-chips.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","material","chips","cdk","keycodes","core","tslib","coercion","platform","rxjs","operators","platformBrowser","animations","a11y","bidi","collections","forms","formField","this","core$1","tslib_1","MatChipSelectionChange","source","selected","isUserInput","_MatChipMixinBase","mixinColor","mixinDisableRipple","mixinDisabled","MatChipBase","_elementRef","MatChipAvatar","decorators","type","Directive","args","selector","host","class","MatChipTrailingIcon","MatChip","_super","_ngZone","globalRippleOptions","animationMode","_changeDetectorRef","_this","call","_hasFocus","chipListSelectable","_chipListMultiple","_selected","_selectable","_removable","_onFocus","Subject","_onBlur","selectionChange","EventEmitter","destroyed","removed","_addHostClassName","_chipRipple","RippleRenderer","setupTriggerEvents","rippleConfig","_animationsDisabled","__extends","Object","defineProperty","prototype","get","disabled","disableRipple","enumerable","configurable","set","value","coercedValue","coerceBooleanProperty","_dispatchSelectionChange","undefined","_value","nativeElement","textContent","selectable","toString","element","hasAttribute","tagName","toLowerCase","classList","add","ngOnDestroy","emit","chip","_removeTriggerEvents","select","_markForCheck","deselect","selectViaInteraction","toggleSelected","focus","next","remove","removable","_handleClick","event","preventDefault","stopPropagation","_handleKeydown","keyCode","DELETE","BACKSPACE","SPACE","_blur","onStable","asObservable","pipe","take","subscribe","run","markForCheck","inputs","exportAs","[attr.tabindex]","role","[class.mat-chip-selected]","[class.mat-chip-with-avatar]","[class.mat-chip-with-trailing-icon]","[class.mat-chip-disabled]","[class._mat-animation-noopable]","[attr.disabled]","[attr.aria-disabled]","[attr.aria-selected]","(click)","(keydown)","(focus)","(blur)","ctorParameters","ElementRef","NgZone","Platform","Optional","Inject","MAT_RIPPLE_GLOBAL_OPTIONS","String","ANIMATION_MODULE_TYPE","ChangeDetectorRef","propDecorators","avatar","ContentChild","static","trailingIcon","removeIcon","forwardRef","MatChipRemove","Input","Output","_parentChip","parentChip","MAT_CHIPS_DEFAULT_OPTIONS","InjectionToken","_MatChipListMixinBase","mixinErrorState","MatChipListBase","_defaultErrorStateMatcher","_parentForm","_parentFormGroup","ngControl","nextUniqueId","MatChipListChange","MatChipList","_dir","controlType","_lastDestroyedChipIndex","_destroyed","_uid","_tabIndex","_userTabIndex","_onTouched","_onChange","_multiple","_compareWith","o1","o2","_required","_disabled","ariaOrientation","change","valueChange","valueAccessor","multiple","_selectionModel","empty","_syncChipsState","fn","_initializeSelection","writeValue","_chipInput","id","stateChanges","placeholder","_placeholder","focused","_hasFocusedChip","length","forEach","merge","apply","__spread","map","ngAfterContentInit","_keyManager","FocusKeyManager","withWrap","withVerticalOrientation","withHorizontalOrientation","takeUntil","dir","tabOut","_allowFocusEscape","changes","startWith","Promise","resolve","then","_resetChips","_updateTabIndex","_updateFocusForDestroyedChips","ngOnInit","SelectionModel","ngDoCheck","updateErrorState","complete","_dropSubscriptions","registerInput","inputElement","setDescribedByIds","ids","_ariaDescribedby","join","_setSelectionByValue","registerOnChange","registerOnTouched","setDisabledState","isDisabled","onContainerClick","_originatesFromChip","options","setFirstItemActive","_focusInput","_keydown","target","_isInputEmpty","setLastItemActive","contains","HOME","END","onKeydown","newChipIndex","Math","min","setActiveItem","_isValidIndex","index","nodeName","_clearSelection","Array","isArray","currentValue","_selectValue","_sortValues","correspondingChip","find","skip","clear","_propagateChanges","fallbackValue","valueToEmit","setTimeout","_markAsTouched","_listenToChipsFocus","_listenToChipsSelection","_listenToChipsRemoved","_chipFocusSubscription","unsubscribe","_chipBlurSubscription","_chipSelectionSubscription","_chipRemoveSubscription","chipSelectionChanges","isSelected","chipFocusChanges","chipIndex","toArray","indexOf","updateActiveItem","chipBlurChanges","chipRemoveChanges","currentElement","parentElement","some","Component","moduleId","template","[attr.aria-describedby]","[attr.aria-required]","[attr.aria-invalid]","[attr.aria-multiselectable]","[attr.role]","[class.mat-chip-list-disabled]","[class.mat-chip-list-invalid]","[class.mat-chip-list-required]","[attr.aria-orientation]","[id]","providers","provide","MatFormFieldControl","useExisting","encapsulation","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","styles","Directionality","NgForm","FormGroupDirective","ErrorStateMatcher","NgControl","Self","errorStateMatcher","compareWith","required","tabIndex","ContentChildren","descendants","nextUniqueId$1","MatChipInput","_defaultOptions","_addOnBlur","separatorKeyCodes","chipEnd","_inputElement","_chipList","ngOnChanges","TAB","hasModifierKey","_emitChipEnd","addOnBlur","_focus","_isSeparatorKey","input","_onInput","separators","has","(input)","[attr.placeholder]","chipList","CHIP_DECLARATIONS","Éµ0","ENTER","MatChipsModule","NgModule","declarations","useValue"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/cdk/keycodes'), require('@angular/core'), require('@angular/material/core'), require('tslib'), require('@angular/cdk/coercion'), require('@angular/cdk/platform'), require('rxjs'), require('rxjs/operators'), require('@angular/platform-browser/animations'), require('@angular/cdk/a11y'), require('@angular/cdk/bidi'), require('@angular/cdk/collections'), require('@angular/forms'), require('@angular/material/form-field')) :\n    typeof define === 'function' && define.amd ? define('@angular/material/chips', ['exports', '@angular/cdk/keycodes', '@angular/core', '@angular/material/core', 'tslib', '@angular/cdk/coercion', '@angular/cdk/platform', 'rxjs', 'rxjs/operators', '@angular/platform-browser/animations', '@angular/cdk/a11y', '@angular/cdk/bidi', '@angular/cdk/collections', '@angular/forms', '@angular/material/form-field'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.chips = {}), global.ng.cdk.keycodes, global.ng.core, global.ng.material.core, global.tslib, global.ng.cdk.coercion, global.ng.cdk.platform, global.rxjs, global.rxjs.operators, global.ng.platformBrowser.animations, global.ng.cdk.a11y, global.ng.cdk.bidi, global.ng.cdk.collections, global.ng.forms, global.ng.material.formField));\n}(this, function (exports, keycodes, core, core$1, tslib_1, coercion, platform, rxjs, operators, animations, a11y, bidi, collections, forms, formField) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Event object emitted by MatChip when selected or deselected. */\n    var MatChipSelectionChange = /** @class */ (function () {\n        function MatChipSelectionChange(\n        /** Reference to the chip that emitted the event. */\n        source, \n        /** Whether the chip that emitted the event is selected. */\n        selected, \n        /** Whether the selection change was a result of a user interaction. */\n        isUserInput) {\n            if (isUserInput === void 0) { isUserInput = false; }\n            this.source = source;\n            this.selected = selected;\n            this.isUserInput = isUserInput;\n        }\n        return MatChipSelectionChange;\n    }());\n    // Boilerplate for applying mixins to MatChip.\n    /** @docs-private */\n    var MatChipBase = /** @class */ (function () {\n        function MatChipBase(_elementRef) {\n            this._elementRef = _elementRef;\n        }\n        return MatChipBase;\n    }());\n    var _MatChipMixinBase = core$1.mixinColor(core$1.mixinDisableRipple(core$1.mixinDisabled(MatChipBase)), 'primary');\n    /**\n     * Dummy directive to add CSS class to chip avatar.\n     * @docs-private\n     */\n    var MatChipAvatar = /** @class */ (function () {\n        function MatChipAvatar() {\n        }\n        MatChipAvatar.decorators = [\n            { type: core.Directive, args: [{\n                        selector: 'mat-chip-avatar, [matChipAvatar]',\n                        host: { 'class': 'mat-chip-avatar' }\n                    },] }\n        ];\n        return MatChipAvatar;\n    }());\n    /**\n     * Dummy directive to add CSS class to chip trailing icon.\n     * @docs-private\n     */\n    var MatChipTrailingIcon = /** @class */ (function () {\n        function MatChipTrailingIcon() {\n        }\n        MatChipTrailingIcon.decorators = [\n            { type: core.Directive, args: [{\n                        selector: 'mat-chip-trailing-icon, [matChipTrailingIcon]',\n                        host: { 'class': 'mat-chip-trailing-icon' }\n                    },] }\n        ];\n        return MatChipTrailingIcon;\n    }());\n    /**\n     * Material design styled Chip component. Used inside the MatChipList component.\n     */\n    var MatChip = /** @class */ (function (_super) {\n        tslib_1.__extends(MatChip, _super);\n        function MatChip(_elementRef, _ngZone, platform, globalRippleOptions, \n        // @breaking-change 8.0.0 `animationMode` parameter to become required.\n        animationMode, \n        // @breaking-change 9.0.0 `_changeDetectorRef` parameter to become required.\n        _changeDetectorRef) {\n            var _this = _super.call(this, _elementRef) || this;\n            _this._elementRef = _elementRef;\n            _this._ngZone = _ngZone;\n            _this._changeDetectorRef = _changeDetectorRef;\n            /** Whether the chip has focus. */\n            _this._hasFocus = false;\n            /** Whether the chip list is selectable */\n            _this.chipListSelectable = true;\n            /** Whether the chip list is in multi-selection mode. */\n            _this._chipListMultiple = false;\n            _this._selected = false;\n            _this._selectable = true;\n            _this._removable = true;\n            /** Emits when the chip is focused. */\n            _this._onFocus = new rxjs.Subject();\n            /** Emits when the chip is blured. */\n            _this._onBlur = new rxjs.Subject();\n            /** Emitted when the chip is selected or deselected. */\n            _this.selectionChange = new core.EventEmitter();\n            /** Emitted when the chip is destroyed. */\n            _this.destroyed = new core.EventEmitter();\n            /** Emitted when a chip is to be removed. */\n            _this.removed = new core.EventEmitter();\n            _this._addHostClassName();\n            _this._chipRipple = new core$1.RippleRenderer(_this, _ngZone, _elementRef, platform);\n            _this._chipRipple.setupTriggerEvents(_elementRef);\n            _this.rippleConfig = globalRippleOptions || {};\n            _this._animationsDisabled = animationMode === 'NoopAnimations';\n            return _this;\n        }\n        Object.defineProperty(MatChip.prototype, \"rippleDisabled\", {\n            /**\n             * Whether ripples are disabled on interaction\n             * @docs-private\n             */\n            get: function () {\n                return this.disabled || this.disableRipple || !!this.rippleConfig.disabled;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChip.prototype, \"selected\", {\n            /** Whether the chip is selected. */\n            get: function () { return this._selected; },\n            set: function (value) {\n                var coercedValue = coercion.coerceBooleanProperty(value);\n                if (coercedValue !== this._selected) {\n                    this._selected = coercedValue;\n                    this._dispatchSelectionChange();\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChip.prototype, \"value\", {\n            /** The value of the chip. Defaults to the content inside `<mat-chip>` tags. */\n            get: function () {\n                return this._value !== undefined\n                    ? this._value\n                    : this._elementRef.nativeElement.textContent;\n            },\n            set: function (value) { this._value = value; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChip.prototype, \"selectable\", {\n            /**\n             * Whether or not the chip is selectable. When a chip is not selectable,\n             * changes to its selected state are always ignored. By default a chip is\n             * selectable, and it becomes non-selectable if its parent chip list is\n             * not selectable.\n             */\n            get: function () { return this._selectable && this.chipListSelectable; },\n            set: function (value) {\n                this._selectable = coercion.coerceBooleanProperty(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChip.prototype, \"removable\", {\n            /**\n             * Determines whether or not the chip displays the remove styling and emits (removed) events.\n             */\n            get: function () { return this._removable; },\n            set: function (value) {\n                this._removable = coercion.coerceBooleanProperty(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChip.prototype, \"ariaSelected\", {\n            /** The ARIA selected applied to the chip. */\n            get: function () {\n                // Remove the `aria-selected` when the chip is deselected in single-selection mode, because\n                // it adds noise to NVDA users where \"not selected\" will be read out for each chip.\n                return this.selectable && (this._chipListMultiple || this.selected) ?\n                    this.selected.toString() : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MatChip.prototype._addHostClassName = function () {\n            var basicChipAttrName = 'mat-basic-chip';\n            var element = this._elementRef.nativeElement;\n            if (element.hasAttribute(basicChipAttrName) ||\n                element.tagName.toLowerCase() === basicChipAttrName) {\n                element.classList.add(basicChipAttrName);\n                return;\n            }\n            else {\n                element.classList.add('mat-standard-chip');\n            }\n        };\n        MatChip.prototype.ngOnDestroy = function () {\n            this.destroyed.emit({ chip: this });\n            this._chipRipple._removeTriggerEvents();\n        };\n        /** Selects the chip. */\n        MatChip.prototype.select = function () {\n            if (!this._selected) {\n                this._selected = true;\n                this._dispatchSelectionChange();\n                this._markForCheck();\n            }\n        };\n        /** Deselects the chip. */\n        MatChip.prototype.deselect = function () {\n            if (this._selected) {\n                this._selected = false;\n                this._dispatchSelectionChange();\n                this._markForCheck();\n            }\n        };\n        /** Select this chip and emit selected event */\n        MatChip.prototype.selectViaInteraction = function () {\n            if (!this._selected) {\n                this._selected = true;\n                this._dispatchSelectionChange(true);\n                this._markForCheck();\n            }\n        };\n        /** Toggles the current selected state of this chip. */\n        MatChip.prototype.toggleSelected = function (isUserInput) {\n            if (isUserInput === void 0) { isUserInput = false; }\n            this._selected = !this.selected;\n            this._dispatchSelectionChange(isUserInput);\n            this._markForCheck();\n            return this.selected;\n        };\n        /** Allows for programmatic focusing of the chip. */\n        MatChip.prototype.focus = function () {\n            if (!this._hasFocus) {\n                this._elementRef.nativeElement.focus();\n                this._onFocus.next({ chip: this });\n            }\n            this._hasFocus = true;\n        };\n        /**\n         * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or\n         * BACKSPACE keys are pressed.\n         *\n         * Informs any listeners of the removal request. Does not remove the chip from the DOM.\n         */\n        MatChip.prototype.remove = function () {\n            if (this.removable) {\n                this.removed.emit({ chip: this });\n            }\n        };\n        /** Handles click events on the chip. */\n        MatChip.prototype._handleClick = function (event) {\n            if (this.disabled) {\n                event.preventDefault();\n            }\n            else {\n                event.stopPropagation();\n            }\n        };\n        /** Handle custom key presses. */\n        MatChip.prototype._handleKeydown = function (event) {\n            if (this.disabled) {\n                return;\n            }\n            switch (event.keyCode) {\n                case keycodes.DELETE:\n                case keycodes.BACKSPACE:\n                    // If we are removable, remove the focused chip\n                    this.remove();\n                    // Always prevent so page navigation does not occur\n                    event.preventDefault();\n                    break;\n                case keycodes.SPACE:\n                    // If we are selectable, toggle the focused chip\n                    if (this.selectable) {\n                        this.toggleSelected(true);\n                    }\n                    // Always prevent space from scrolling the page since the list has focus\n                    event.preventDefault();\n                    break;\n            }\n        };\n        MatChip.prototype._blur = function () {\n            var _this = this;\n            // When animations are enabled, Angular may end up removing the chip from the DOM a little\n            // earlier than usual, causing it to be blurred and throwing off the logic in the chip list\n            // that moves focus not the next item. To work around the issue, we defer marking the chip\n            // as not focused until the next time the zone stabilizes.\n            this._ngZone.onStable\n                .asObservable()\n                .pipe(operators.take(1))\n                .subscribe(function () {\n                _this._ngZone.run(function () {\n                    _this._hasFocus = false;\n                    _this._onBlur.next({ chip: _this });\n                });\n            });\n        };\n        MatChip.prototype._dispatchSelectionChange = function (isUserInput) {\n            if (isUserInput === void 0) { isUserInput = false; }\n            this.selectionChange.emit({\n                source: this,\n                isUserInput: isUserInput,\n                selected: this._selected\n            });\n        };\n        MatChip.prototype._markForCheck = function () {\n            // @breaking-change 9.0.0 Remove this method once the _changeDetectorRef is a required param.\n            if (this._changeDetectorRef) {\n                this._changeDetectorRef.markForCheck();\n            }\n        };\n        MatChip.decorators = [\n            { type: core.Directive, args: [{\n                        selector: \"mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]\",\n                        inputs: ['color', 'disabled', 'disableRipple'],\n                        exportAs: 'matChip',\n                        host: {\n                            'class': 'mat-chip',\n                            '[attr.tabindex]': 'disabled ? null : -1',\n                            'role': 'option',\n                            '[class.mat-chip-selected]': 'selected',\n                            '[class.mat-chip-with-avatar]': 'avatar',\n                            '[class.mat-chip-with-trailing-icon]': 'trailingIcon || removeIcon',\n                            '[class.mat-chip-disabled]': 'disabled',\n                            '[class._mat-animation-noopable]': '_animationsDisabled',\n                            '[attr.disabled]': 'disabled || null',\n                            '[attr.aria-disabled]': 'disabled.toString()',\n                            '[attr.aria-selected]': 'ariaSelected',\n                            '(click)': '_handleClick($event)',\n                            '(keydown)': '_handleKeydown($event)',\n                            '(focus)': 'focus()',\n                            '(blur)': '_blur()',\n                        },\n                    },] }\n        ];\n        /** @nocollapse */\n        MatChip.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: core.NgZone },\n            { type: platform.Platform },\n            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core$1.MAT_RIPPLE_GLOBAL_OPTIONS,] }] },\n            { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] },\n            { type: core.ChangeDetectorRef }\n        ]; };\n        MatChip.propDecorators = {\n            avatar: [{ type: core.ContentChild, args: [MatChipAvatar, { static: false },] }],\n            trailingIcon: [{ type: core.ContentChild, args: [MatChipTrailingIcon, { static: false },] }],\n            removeIcon: [{ type: core.ContentChild, args: [core.forwardRef(function () { return MatChipRemove; }), { static: false },] }],\n            selected: [{ type: core.Input }],\n            value: [{ type: core.Input }],\n            selectable: [{ type: core.Input }],\n            removable: [{ type: core.Input }],\n            selectionChange: [{ type: core.Output }],\n            destroyed: [{ type: core.Output }],\n            removed: [{ type: core.Output }]\n        };\n        return MatChip;\n    }(_MatChipMixinBase));\n    /**\n     * Applies proper (click) support and adds styling for use with the Material Design \"cancel\" icon\n     * available at https://material.io/icons/#ic_cancel.\n     *\n     * Example:\n     *\n     *     `<mat-chip>\n     *       <mat-icon matChipRemove>cancel</mat-icon>\n     *     </mat-chip>`\n     *\n     * You *may* use a custom icon, but you may need to override the `mat-chip-remove` positioning\n     * styles to properly center the icon within the chip.\n     */\n    var MatChipRemove = /** @class */ (function () {\n        function MatChipRemove(_parentChip) {\n            this._parentChip = _parentChip;\n        }\n        /** Calls the parent chip's public `remove()` method if applicable. */\n        MatChipRemove.prototype._handleClick = function (event) {\n            var parentChip = this._parentChip;\n            if (parentChip.removable && !parentChip.disabled) {\n                parentChip.remove();\n            }\n            // We need to stop event propagation because otherwise the event will bubble up to the\n            // form field and cause the `onContainerClick` method to be invoked. This method would then\n            // reset the focused chip that has been focused after chip removal. Usually the parent\n            // the parent click listener of the `MatChip` would prevent propagation, but it can happen\n            // that the chip is being removed before the event bubbles up.\n            event.stopPropagation();\n        };\n        MatChipRemove.decorators = [\n            { type: core.Directive, args: [{\n                        selector: '[matChipRemove]',\n                        host: {\n                            'class': 'mat-chip-remove mat-chip-trailing-icon',\n                            '(click)': '_handleClick($event)',\n                        }\n                    },] }\n        ];\n        /** @nocollapse */\n        MatChipRemove.ctorParameters = function () { return [\n            { type: MatChip }\n        ]; };\n        return MatChipRemove;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Injection token to be used to override the default options for the chips module. */\n    var MAT_CHIPS_DEFAULT_OPTIONS = new core.InjectionToken('mat-chips-default-options');\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // Boilerplate for applying mixins to MatChipList.\n    /** @docs-private */\n    var MatChipListBase = /** @class */ (function () {\n        function MatChipListBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, \n        /** @docs-private */\n        ngControl) {\n            this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n            this._parentForm = _parentForm;\n            this._parentFormGroup = _parentFormGroup;\n            this.ngControl = ngControl;\n        }\n        return MatChipListBase;\n    }());\n    var _MatChipListMixinBase = core$1.mixinErrorState(MatChipListBase);\n    // Increasing integer for generating unique ids for chip-list components.\n    var nextUniqueId = 0;\n    /** Change event object that is emitted when the chip list value has changed. */\n    var MatChipListChange = /** @class */ (function () {\n        function MatChipListChange(\n        /** Chip list that emitted the event. */\n        source, \n        /** Value of the chip list when the event was emitted. */\n        value) {\n            this.source = source;\n            this.value = value;\n        }\n        return MatChipListChange;\n    }());\n    /**\n     * A material design chips component (named ChipList for its similarity to the List component).\n     */\n    var MatChipList = /** @class */ (function (_super) {\n        tslib_1.__extends(MatChipList, _super);\n        function MatChipList(_elementRef, _changeDetectorRef, _dir, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, \n        /** @docs-private */\n        ngControl) {\n            var _this = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;\n            _this._elementRef = _elementRef;\n            _this._changeDetectorRef = _changeDetectorRef;\n            _this._dir = _dir;\n            _this.ngControl = ngControl;\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            _this.controlType = 'mat-chip-list';\n            /**\n             * When a chip is destroyed, we store the index of the destroyed chip until the chips\n             * query list notifies about the update. This is necessary because we cannot determine an\n             * appropriate chip that should receive focus until the array of chips updated completely.\n             */\n            _this._lastDestroyedChipIndex = null;\n            /** Subject that emits when the component has been destroyed. */\n            _this._destroyed = new rxjs.Subject();\n            /** Uid of the chip list */\n            _this._uid = \"mat-chip-list-\" + nextUniqueId++;\n            /** Tab index for the chip list. */\n            _this._tabIndex = 0;\n            /**\n             * User defined tab index.\n             * When it is not null, use user defined tab index. Otherwise use _tabIndex\n             */\n            _this._userTabIndex = null;\n            /** Function when touched */\n            _this._onTouched = function () { };\n            /** Function when changed */\n            _this._onChange = function () { };\n            _this._multiple = false;\n            _this._compareWith = function (o1, o2) { return o1 === o2; };\n            _this._required = false;\n            _this._disabled = false;\n            /** Orientation of the chip list. */\n            _this.ariaOrientation = 'horizontal';\n            _this._selectable = true;\n            /** Event emitted when the selected chip list value has been changed by the user. */\n            _this.change = new core.EventEmitter();\n            /**\n             * Event that emits whenever the raw value of the chip-list changes. This is here primarily\n             * to facilitate the two-way binding for the `value` input.\n             * @docs-private\n             */\n            _this.valueChange = new core.EventEmitter();\n            if (_this.ngControl) {\n                _this.ngControl.valueAccessor = _this;\n            }\n            return _this;\n        }\n        Object.defineProperty(MatChipList.prototype, \"selected\", {\n            /** The array of selected chips inside chip list. */\n            get: function () {\n                return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0];\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"role\", {\n            /** The ARIA role applied to the chip list. */\n            get: function () { return this.empty ? null : 'listbox'; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"multiple\", {\n            /** Whether the user should be allowed to select multiple chips. */\n            get: function () { return this._multiple; },\n            set: function (value) {\n                this._multiple = coercion.coerceBooleanProperty(value);\n                this._syncChipsState();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"compareWith\", {\n            /**\n             * A function to compare the option values with the selected values. The first argument\n             * is a value from an option. The second is a value from the selection. A boolean\n             * should be returned.\n             */\n            get: function () { return this._compareWith; },\n            set: function (fn) {\n                this._compareWith = fn;\n                if (this._selectionModel) {\n                    // A different comparator means the selection could change.\n                    this._initializeSelection();\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"value\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () { return this._value; },\n            set: function (value) {\n                this.writeValue(value);\n                this._value = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"id\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () {\n                return this._chipInput ? this._chipInput.id : this._uid;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"required\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () { return this._required; },\n            set: function (value) {\n                this._required = coercion.coerceBooleanProperty(value);\n                this.stateChanges.next();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"placeholder\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () {\n                return this._chipInput ? this._chipInput.placeholder : this._placeholder;\n            },\n            set: function (value) {\n                this._placeholder = value;\n                this.stateChanges.next();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"focused\", {\n            /** Whether any chips or the matChipInput inside of this chip-list has focus. */\n            get: function () {\n                return (this._chipInput && this._chipInput.focused) || this._hasFocusedChip();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"empty\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () {\n                return (!this._chipInput || this._chipInput.empty) && this.chips.length === 0;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"shouldLabelFloat\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () { return !this.empty || this.focused; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"disabled\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () { return this.ngControl ? !!this.ngControl.disabled : this._disabled; },\n            set: function (value) {\n                this._disabled = coercion.coerceBooleanProperty(value);\n                this._syncChipsState();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"selectable\", {\n            /**\n             * Whether or not this chip list is selectable. When a chip list is not selectable,\n             * the selected states for all the chips inside the chip list are always ignored.\n             */\n            get: function () { return this._selectable; },\n            set: function (value) {\n                var _this = this;\n                this._selectable = coercion.coerceBooleanProperty(value);\n                if (this.chips) {\n                    this.chips.forEach(function (chip) { return chip.chipListSelectable = _this._selectable; });\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"tabIndex\", {\n            set: function (value) {\n                this._userTabIndex = value;\n                this._tabIndex = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"chipSelectionChanges\", {\n            /** Combined stream of all of the child chips' selection change events. */\n            get: function () {\n                return rxjs.merge.apply(void 0, tslib_1.__spread(this.chips.map(function (chip) { return chip.selectionChange; })));\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"chipFocusChanges\", {\n            /** Combined stream of all of the child chips' focus change events. */\n            get: function () {\n                return rxjs.merge.apply(void 0, tslib_1.__spread(this.chips.map(function (chip) { return chip._onFocus; })));\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"chipBlurChanges\", {\n            /** Combined stream of all of the child chips' blur change events. */\n            get: function () {\n                return rxjs.merge.apply(void 0, tslib_1.__spread(this.chips.map(function (chip) { return chip._onBlur; })));\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"chipRemoveChanges\", {\n            /** Combined stream of all of the child chips' remove change events. */\n            get: function () {\n                return rxjs.merge.apply(void 0, tslib_1.__spread(this.chips.map(function (chip) { return chip.destroyed; })));\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MatChipList.prototype.ngAfterContentInit = function () {\n            var _this = this;\n            this._keyManager = new a11y.FocusKeyManager(this.chips)\n                .withWrap()\n                .withVerticalOrientation()\n                .withHorizontalOrientation(this._dir ? this._dir.value : 'ltr');\n            if (this._dir) {\n                this._dir.change\n                    .pipe(operators.takeUntil(this._destroyed))\n                    .subscribe(function (dir) { return _this._keyManager.withHorizontalOrientation(dir); });\n            }\n            this._keyManager.tabOut.pipe(operators.takeUntil(this._destroyed)).subscribe(function () {\n                _this._allowFocusEscape();\n            });\n            // When the list changes, re-subscribe\n            this.chips.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroyed)).subscribe(function () {\n                if (_this.disabled) {\n                    // Since this happens after the content has been\n                    // checked, we need to defer it to the next tick.\n                    Promise.resolve().then(function () {\n                        _this._syncChipsState();\n                    });\n                }\n                _this._resetChips();\n                // Reset chips selected/deselected status\n                _this._initializeSelection();\n                // Check to see if we need to update our tab index\n                _this._updateTabIndex();\n                // Check to see if we have a destroyed chip and need to refocus\n                _this._updateFocusForDestroyedChips();\n                _this.stateChanges.next();\n            });\n        };\n        MatChipList.prototype.ngOnInit = function () {\n            this._selectionModel = new collections.SelectionModel(this.multiple, undefined, false);\n            this.stateChanges.next();\n        };\n        MatChipList.prototype.ngDoCheck = function () {\n            if (this.ngControl) {\n                // We need to re-evaluate this on every change detection cycle, because there are some\n                // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n                // that whatever logic is in here has to be super lean or we risk destroying the performance.\n                this.updateErrorState();\n            }\n        };\n        MatChipList.prototype.ngOnDestroy = function () {\n            this._destroyed.next();\n            this._destroyed.complete();\n            this.stateChanges.complete();\n            this._dropSubscriptions();\n        };\n        /** Associates an HTML input element with this chip list. */\n        MatChipList.prototype.registerInput = function (inputElement) {\n            this._chipInput = inputElement;\n        };\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        MatChipList.prototype.setDescribedByIds = function (ids) { this._ariaDescribedby = ids.join(' '); };\n        // Implemented as part of ControlValueAccessor.\n        MatChipList.prototype.writeValue = function (value) {\n            if (this.chips) {\n                this._setSelectionByValue(value, false);\n            }\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatChipList.prototype.registerOnChange = function (fn) {\n            this._onChange = fn;\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatChipList.prototype.registerOnTouched = function (fn) {\n            this._onTouched = fn;\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatChipList.prototype.setDisabledState = function (isDisabled) {\n            this.disabled = isDisabled;\n            this.stateChanges.next();\n        };\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        MatChipList.prototype.onContainerClick = function (event) {\n            if (!this._originatesFromChip(event)) {\n                this.focus();\n            }\n        };\n        /**\n         * Focuses the first non-disabled chip in this chip list, or the associated input when there\n         * are no eligible chips.\n         */\n        MatChipList.prototype.focus = function (options) {\n            if (this.disabled) {\n                return;\n            }\n            // TODO: ARIA says this should focus the first `selected` chip if any are selected.\n            // Focus on first element if there's no chipInput inside chip-list\n            if (this._chipInput && this._chipInput.focused) {\n                // do nothing\n            }\n            else if (this.chips.length > 0) {\n                this._keyManager.setFirstItemActive();\n                this.stateChanges.next();\n            }\n            else {\n                this._focusInput(options);\n                this.stateChanges.next();\n            }\n        };\n        /** Attempt to focus an input if we have one. */\n        MatChipList.prototype._focusInput = function (options) {\n            if (this._chipInput) {\n                this._chipInput.focus(options);\n            }\n        };\n        /**\n         * Pass events to the keyboard manager. Available here for tests.\n         */\n        MatChipList.prototype._keydown = function (event) {\n            var target = event.target;\n            // If they are on an empty input and hit backspace, focus the last chip\n            if (event.keyCode === keycodes.BACKSPACE && this._isInputEmpty(target)) {\n                this._keyManager.setLastItemActive();\n                event.preventDefault();\n            }\n            else if (target && target.classList.contains('mat-chip')) {\n                if (event.keyCode === keycodes.HOME) {\n                    this._keyManager.setFirstItemActive();\n                    event.preventDefault();\n                }\n                else if (event.keyCode === keycodes.END) {\n                    this._keyManager.setLastItemActive();\n                    event.preventDefault();\n                }\n                else {\n                    this._keyManager.onKeydown(event);\n                }\n                this.stateChanges.next();\n            }\n        };\n        /**\n         * Check the tab index as you should not be allowed to focus an empty list.\n         */\n        MatChipList.prototype._updateTabIndex = function () {\n            // If we have 0 chips, we should not allow keyboard focus\n            this._tabIndex = this._userTabIndex || (this.chips.length === 0 ? -1 : 0);\n        };\n        /**\n         * If the amount of chips changed, we need to update the\n         * key manager state and focus the next closest chip.\n         */\n        MatChipList.prototype._updateFocusForDestroyedChips = function () {\n            // Move focus to the closest chip. If no other chips remain, focus the chip-list itself.\n            if (this._lastDestroyedChipIndex != null) {\n                if (this.chips.length) {\n                    var newChipIndex = Math.min(this._lastDestroyedChipIndex, this.chips.length - 1);\n                    this._keyManager.setActiveItem(newChipIndex);\n                }\n                else {\n                    this.focus();\n                }\n            }\n            this._lastDestroyedChipIndex = null;\n        };\n        /**\n         * Utility to ensure all indexes are valid.\n         *\n         * @param index The index to be checked.\n         * @returns True if the index is valid for our list of chips.\n         */\n        MatChipList.prototype._isValidIndex = function (index) {\n            return index >= 0 && index < this.chips.length;\n        };\n        MatChipList.prototype._isInputEmpty = function (element) {\n            if (element && element.nodeName.toLowerCase() === 'input') {\n                var input = element;\n                return !input.value;\n            }\n            return false;\n        };\n        MatChipList.prototype._setSelectionByValue = function (value, isUserInput) {\n            var _this = this;\n            if (isUserInput === void 0) { isUserInput = true; }\n            this._clearSelection();\n            this.chips.forEach(function (chip) { return chip.deselect(); });\n            if (Array.isArray(value)) {\n                value.forEach(function (currentValue) { return _this._selectValue(currentValue, isUserInput); });\n                this._sortValues();\n            }\n            else {\n                var correspondingChip = this._selectValue(value, isUserInput);\n                // Shift focus to the active item. Note that we shouldn't do this in multiple\n                // mode, because we don't know what chip the user interacted with last.\n                if (correspondingChip) {\n                    if (isUserInput) {\n                        this._keyManager.setActiveItem(correspondingChip);\n                    }\n                }\n            }\n        };\n        /**\n         * Finds and selects the chip based on its value.\n         * @returns Chip that has the corresponding value.\n         */\n        MatChipList.prototype._selectValue = function (value, isUserInput) {\n            var _this = this;\n            if (isUserInput === void 0) { isUserInput = true; }\n            var correspondingChip = this.chips.find(function (chip) {\n                return chip.value != null && _this._compareWith(chip.value, value);\n            });\n            if (correspondingChip) {\n                isUserInput ? correspondingChip.selectViaInteraction() : correspondingChip.select();\n                this._selectionModel.select(correspondingChip);\n            }\n            return correspondingChip;\n        };\n        MatChipList.prototype._initializeSelection = function () {\n            var _this = this;\n            // Defer setting the value in order to avoid the \"Expression\n            // has changed after it was checked\" errors from Angular.\n            Promise.resolve().then(function () {\n                if (_this.ngControl || _this._value) {\n                    _this._setSelectionByValue(_this.ngControl ? _this.ngControl.value : _this._value, false);\n                    _this.stateChanges.next();\n                }\n            });\n        };\n        /**\n         * Deselects every chip in the list.\n         * @param skip Chip that should not be deselected.\n         */\n        MatChipList.prototype._clearSelection = function (skip) {\n            this._selectionModel.clear();\n            this.chips.forEach(function (chip) {\n                if (chip !== skip) {\n                    chip.deselect();\n                }\n            });\n            this.stateChanges.next();\n        };\n        /**\n         * Sorts the model values, ensuring that they keep the same\n         * order that they have in the panel.\n         */\n        MatChipList.prototype._sortValues = function () {\n            var _this = this;\n            if (this._multiple) {\n                this._selectionModel.clear();\n                this.chips.forEach(function (chip) {\n                    if (chip.selected) {\n                        _this._selectionModel.select(chip);\n                    }\n                });\n                this.stateChanges.next();\n            }\n        };\n        /** Emits change event to set the model value. */\n        MatChipList.prototype._propagateChanges = function (fallbackValue) {\n            var valueToEmit = null;\n            if (Array.isArray(this.selected)) {\n                valueToEmit = this.selected.map(function (chip) { return chip.value; });\n            }\n            else {\n                valueToEmit = this.selected ? this.selected.value : fallbackValue;\n            }\n            this._value = valueToEmit;\n            this.change.emit(new MatChipListChange(this, valueToEmit));\n            this.valueChange.emit(valueToEmit);\n            this._onChange(valueToEmit);\n            this._changeDetectorRef.markForCheck();\n        };\n        /** When blurred, mark the field as touched when focus moved outside the chip list. */\n        MatChipList.prototype._blur = function () {\n            var _this = this;\n            if (!this._hasFocusedChip()) {\n                this._keyManager.setActiveItem(-1);\n            }\n            if (!this.disabled) {\n                if (this._chipInput) {\n                    // If there's a chip input, we should check whether the focus moved to chip input.\n                    // If the focus is not moved to chip input, mark the field as touched. If the focus moved\n                    // to chip input, do nothing.\n                    // Timeout is needed to wait for the focus() event trigger on chip input.\n                    setTimeout(function () {\n                        if (!_this.focused) {\n                            _this._markAsTouched();\n                        }\n                    });\n                }\n                else {\n                    // If there's no chip input, then mark the field as touched.\n                    this._markAsTouched();\n                }\n            }\n        };\n        /** Mark the field as touched */\n        MatChipList.prototype._markAsTouched = function () {\n            this._onTouched();\n            this._changeDetectorRef.markForCheck();\n            this.stateChanges.next();\n        };\n        /**\n         * Removes the `tabindex` from the chip list and resets it back afterwards, allowing the\n         * user to tab out of it. This prevents the list from capturing focus and redirecting\n         * it back to the first chip, creating a focus trap, if it user tries to tab away.\n         */\n        MatChipList.prototype._allowFocusEscape = function () {\n            var _this = this;\n            if (this._tabIndex !== -1) {\n                this._tabIndex = -1;\n                setTimeout(function () {\n                    _this._tabIndex = _this._userTabIndex || 0;\n                    _this._changeDetectorRef.markForCheck();\n                });\n            }\n        };\n        MatChipList.prototype._resetChips = function () {\n            this._dropSubscriptions();\n            this._listenToChipsFocus();\n            this._listenToChipsSelection();\n            this._listenToChipsRemoved();\n        };\n        MatChipList.prototype._dropSubscriptions = function () {\n            if (this._chipFocusSubscription) {\n                this._chipFocusSubscription.unsubscribe();\n                this._chipFocusSubscription = null;\n            }\n            if (this._chipBlurSubscription) {\n                this._chipBlurSubscription.unsubscribe();\n                this._chipBlurSubscription = null;\n            }\n            if (this._chipSelectionSubscription) {\n                this._chipSelectionSubscription.unsubscribe();\n                this._chipSelectionSubscription = null;\n            }\n            if (this._chipRemoveSubscription) {\n                this._chipRemoveSubscription.unsubscribe();\n                this._chipRemoveSubscription = null;\n            }\n        };\n        /** Listens to user-generated selection events on each chip. */\n        MatChipList.prototype._listenToChipsSelection = function () {\n            var _this = this;\n            this._chipSelectionSubscription = this.chipSelectionChanges.subscribe(function (event) {\n                event.source.selected\n                    ? _this._selectionModel.select(event.source)\n                    : _this._selectionModel.deselect(event.source);\n                // For single selection chip list, make sure the deselected value is unselected.\n                if (!_this.multiple) {\n                    _this.chips.forEach(function (chip) {\n                        if (!_this._selectionModel.isSelected(chip) && chip.selected) {\n                            chip.deselect();\n                        }\n                    });\n                }\n                if (event.isUserInput) {\n                    _this._propagateChanges();\n                }\n            });\n        };\n        /** Listens to user-generated selection events on each chip. */\n        MatChipList.prototype._listenToChipsFocus = function () {\n            var _this = this;\n            this._chipFocusSubscription = this.chipFocusChanges.subscribe(function (event) {\n                var chipIndex = _this.chips.toArray().indexOf(event.chip);\n                if (_this._isValidIndex(chipIndex)) {\n                    _this._keyManager.updateActiveItem(chipIndex);\n                }\n                _this.stateChanges.next();\n            });\n            this._chipBlurSubscription = this.chipBlurChanges.subscribe(function () {\n                _this._blur();\n                _this.stateChanges.next();\n            });\n        };\n        MatChipList.prototype._listenToChipsRemoved = function () {\n            var _this = this;\n            this._chipRemoveSubscription = this.chipRemoveChanges.subscribe(function (event) {\n                var chip = event.chip;\n                var chipIndex = _this.chips.toArray().indexOf(event.chip);\n                // In case the chip that will be removed is currently focused, we temporarily store\n                // the index in order to be able to determine an appropriate sibling chip that will\n                // receive focus.\n                if (_this._isValidIndex(chipIndex) && chip._hasFocus) {\n                    _this._lastDestroyedChipIndex = chipIndex;\n                }\n            });\n        };\n        /** Checks whether an event comes from inside a chip element. */\n        MatChipList.prototype._originatesFromChip = function (event) {\n            var currentElement = event.target;\n            while (currentElement && currentElement !== this._elementRef.nativeElement) {\n                if (currentElement.classList.contains('mat-chip')) {\n                    return true;\n                }\n                currentElement = currentElement.parentElement;\n            }\n            return false;\n        };\n        /** Checks whether any of the chips is focused. */\n        MatChipList.prototype._hasFocusedChip = function () {\n            return this.chips.some(function (chip) { return chip._hasFocus; });\n        };\n        /** Syncs the list's state with the individual chips. */\n        MatChipList.prototype._syncChipsState = function () {\n            var _this = this;\n            if (this.chips) {\n                this.chips.forEach(function (chip) {\n                    chip.disabled = _this._disabled;\n                    chip._chipListMultiple = _this.multiple;\n                });\n            }\n        };\n        MatChipList.decorators = [\n            { type: core.Component, args: [{\n                        moduleId: module.id,\n                        selector: 'mat-chip-list',\n                        template: \"<div class=\\\"mat-chip-list-wrapper\\\"><ng-content></ng-content></div>\",\n                        exportAs: 'matChipList',\n                        host: {\n                            '[attr.tabindex]': 'disabled ? null : _tabIndex',\n                            '[attr.aria-describedby]': '_ariaDescribedby || null',\n                            '[attr.aria-required]': 'required.toString()',\n                            '[attr.aria-disabled]': 'disabled.toString()',\n                            '[attr.aria-invalid]': 'errorState',\n                            '[attr.aria-multiselectable]': 'multiple',\n                            '[attr.role]': 'role',\n                            '[class.mat-chip-list-disabled]': 'disabled',\n                            '[class.mat-chip-list-invalid]': 'errorState',\n                            '[class.mat-chip-list-required]': 'required',\n                            '[attr.aria-orientation]': 'ariaOrientation',\n                            'class': 'mat-chip-list',\n                            '(focus)': 'focus()',\n                            '(blur)': '_blur()',\n                            '(keydown)': '_keydown($event)',\n                            '[id]': '_uid',\n                        },\n                        providers: [{ provide: formField.MatFormFieldControl, useExisting: MatChipList }],\n                        encapsulation: core.ViewEncapsulation.None,\n                        changeDetection: core.ChangeDetectionStrategy.OnPush,\n                        styles: [\".mat-chip{position:relative;overflow:hidden;box-sizing:border-box;-webkit-tap-highlight-color:transparent;transform:translateZ(0)}.mat-standard-chip{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:inline-flex;padding:7px 12px;border-radius:16px;align-items:center;cursor:default;min-height:32px;height:1px}._mat-animation-noopable.mat-standard-chip{transition:none;animation:none}.mat-standard-chip .mat-chip-remove.mat-icon{width:18px;height:18px}.mat-standard-chip::after{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit;opacity:0;content:\\\"\\\";pointer-events:none;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-standard-chip:hover::after{opacity:.12}.mat-standard-chip:focus{outline:none}.mat-standard-chip:focus::after{opacity:.16}@media(-ms-high-contrast: active){.mat-standard-chip{outline:solid 1px}.mat-standard-chip:focus{outline:dotted 2px}}.mat-standard-chip.mat-chip-disabled::after{opacity:0}.mat-standard-chip.mat-chip-disabled .mat-chip-remove,.mat-standard-chip.mat-chip-disabled .mat-chip-trailing-icon{cursor:default}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar,.mat-standard-chip.mat-chip-with-avatar{padding-top:0;padding-bottom:0}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-right:8px;padding-left:0}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-left:8px;padding-right:0}.mat-standard-chip.mat-chip-with-trailing-icon{padding-top:7px;padding-bottom:7px;padding-right:8px;padding-left:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon{padding-left:8px;padding-right:12px}.mat-standard-chip.mat-chip-with-avatar{padding-left:0;padding-right:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-avatar{padding-right:0;padding-left:12px}.mat-standard-chip .mat-chip-avatar{width:24px;height:24px;margin-right:8px;margin-left:4px}[dir=rtl] .mat-standard-chip .mat-chip-avatar{margin-left:8px;margin-right:4px}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{width:18px;height:18px;cursor:pointer}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-standard-chip .mat-chip-remove,[dir=rtl] .mat-standard-chip .mat-chip-trailing-icon{margin-right:8px;margin-left:0}.mat-chip-list-wrapper{display:flex;flex-direction:row;flex-wrap:wrap;align-items:center;margin:-4px}.mat-chip-list-wrapper input.mat-input-element,.mat-chip-list-wrapper .mat-standard-chip{margin:4px}.mat-chip-list-stacked .mat-chip-list-wrapper{flex-direction:column;align-items:flex-start}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-standard-chip{width:100%}.mat-chip-avatar{border-radius:50%;justify-content:center;align-items:center;display:flex;overflow:hidden;object-fit:cover}input.mat-chip-input{width:150px;margin:4px;flex:1 0 150px}\\n\"]\n                    }] }\n        ];\n        /** @nocollapse */\n        MatChipList.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: core.ChangeDetectorRef },\n            { type: bidi.Directionality, decorators: [{ type: core.Optional }] },\n            { type: forms.NgForm, decorators: [{ type: core.Optional }] },\n            { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] },\n            { type: core$1.ErrorStateMatcher },\n            { type: forms.NgControl, decorators: [{ type: core.Optional }, { type: core.Self }] }\n        ]; };\n        MatChipList.propDecorators = {\n            errorStateMatcher: [{ type: core.Input }],\n            multiple: [{ type: core.Input }],\n            compareWith: [{ type: core.Input }],\n            value: [{ type: core.Input }],\n            required: [{ type: core.Input }],\n            placeholder: [{ type: core.Input }],\n            disabled: [{ type: core.Input }],\n            ariaOrientation: [{ type: core.Input, args: ['aria-orientation',] }],\n            selectable: [{ type: core.Input }],\n            tabIndex: [{ type: core.Input }],\n            change: [{ type: core.Output }],\n            valueChange: [{ type: core.Output }],\n            chips: [{ type: core.ContentChildren, args: [MatChip, {\n                            // We need to use `descendants: true`, because Ivy will no longer match\n                            // indirect descendants if it's left as false.\n                            descendants: true\n                        },] }]\n        };\n        return MatChipList;\n    }(_MatChipListMixinBase));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // Increasing integer for generating unique ids.\n    var nextUniqueId$1 = 0;\n    /**\n     * Directive that adds chip-specific behaviors to an input element inside `<mat-form-field>`.\n     * May be placed inside or outside of an `<mat-chip-list>`.\n     */\n    var MatChipInput = /** @class */ (function () {\n        function MatChipInput(_elementRef, _defaultOptions) {\n            this._elementRef = _elementRef;\n            this._defaultOptions = _defaultOptions;\n            /** Whether the control is focused. */\n            this.focused = false;\n            this._addOnBlur = false;\n            /**\n             * The list of key codes that will trigger a chipEnd event.\n             *\n             * Defaults to `[ENTER]`.\n             */\n            this.separatorKeyCodes = this._defaultOptions.separatorKeyCodes;\n            /** Emitted when a chip is to be added. */\n            this.chipEnd = new core.EventEmitter();\n            /** The input's placeholder text. */\n            this.placeholder = '';\n            /** Unique id for the input. */\n            this.id = \"mat-chip-list-input-\" + nextUniqueId$1++;\n            this._disabled = false;\n            this._inputElement = this._elementRef.nativeElement;\n        }\n        Object.defineProperty(MatChipInput.prototype, \"chipList\", {\n            /** Register input for chip list */\n            set: function (value) {\n                if (value) {\n                    this._chipList = value;\n                    this._chipList.registerInput(this);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipInput.prototype, \"addOnBlur\", {\n            /**\n             * Whether or not the chipEnd event will be emitted when the input is blurred.\n             */\n            get: function () { return this._addOnBlur; },\n            set: function (value) { this._addOnBlur = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipInput.prototype, \"disabled\", {\n            /** Whether the input is disabled. */\n            get: function () { return this._disabled || (this._chipList && this._chipList.disabled); },\n            set: function (value) { this._disabled = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipInput.prototype, \"empty\", {\n            /** Whether the input is empty. */\n            get: function () { return !this._inputElement.value; },\n            enumerable: true,\n            configurable: true\n        });\n        MatChipInput.prototype.ngOnChanges = function () {\n            this._chipList.stateChanges.next();\n        };\n        /** Utility method to make host definition/tests more clear. */\n        MatChipInput.prototype._keydown = function (event) {\n            // Allow the user's focus to escape when they're tabbing forward. Note that we don't\n            // want to do this when going backwards, because focus should go back to the first chip.\n            if (event && event.keyCode === keycodes.TAB && !keycodes.hasModifierKey(event, 'shiftKey')) {\n                this._chipList._allowFocusEscape();\n            }\n            this._emitChipEnd(event);\n        };\n        /** Checks to see if the blur should emit the (chipEnd) event. */\n        MatChipInput.prototype._blur = function () {\n            if (this.addOnBlur) {\n                this._emitChipEnd();\n            }\n            this.focused = false;\n            // Blur the chip list if it is not focused\n            if (!this._chipList.focused) {\n                this._chipList._blur();\n            }\n            this._chipList.stateChanges.next();\n        };\n        MatChipInput.prototype._focus = function () {\n            this.focused = true;\n            this._chipList.stateChanges.next();\n        };\n        /** Checks to see if the (chipEnd) event needs to be emitted. */\n        MatChipInput.prototype._emitChipEnd = function (event) {\n            if (!this._inputElement.value && !!event) {\n                this._chipList._keydown(event);\n            }\n            if (!event || this._isSeparatorKey(event)) {\n                this.chipEnd.emit({ input: this._inputElement, value: this._inputElement.value });\n                if (event) {\n                    event.preventDefault();\n                }\n            }\n        };\n        MatChipInput.prototype._onInput = function () {\n            // Let chip list know whenever the value changes.\n            this._chipList.stateChanges.next();\n        };\n        /** Focuses the input. */\n        MatChipInput.prototype.focus = function (options) {\n            this._inputElement.focus(options);\n        };\n        /** Checks whether a keycode is one of the configured separators. */\n        MatChipInput.prototype._isSeparatorKey = function (event) {\n            if (keycodes.hasModifierKey(event)) {\n                return false;\n            }\n            var separators = this.separatorKeyCodes;\n            var keyCode = event.keyCode;\n            return Array.isArray(separators) ? separators.indexOf(keyCode) > -1 : separators.has(keyCode);\n        };\n        MatChipInput.decorators = [\n            { type: core.Directive, args: [{\n                        selector: 'input[matChipInputFor]',\n                        exportAs: 'matChipInput, matChipInputFor',\n                        host: {\n                            'class': 'mat-chip-input mat-input-element',\n                            '(keydown)': '_keydown($event)',\n                            '(blur)': '_blur()',\n                            '(focus)': '_focus()',\n                            '(input)': '_onInput()',\n                            '[id]': 'id',\n                            '[attr.disabled]': 'disabled || null',\n                            '[attr.placeholder]': 'placeholder || null',\n                            '[attr.aria-invalid]': '_chipList && _chipList.ngControl ? _chipList.ngControl.invalid : null',\n                        }\n                    },] }\n        ];\n        /** @nocollapse */\n        MatChipInput.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: undefined, decorators: [{ type: core.Inject, args: [MAT_CHIPS_DEFAULT_OPTIONS,] }] }\n        ]; };\n        MatChipInput.propDecorators = {\n            chipList: [{ type: core.Input, args: ['matChipInputFor',] }],\n            addOnBlur: [{ type: core.Input, args: ['matChipInputAddOnBlur',] }],\n            separatorKeyCodes: [{ type: core.Input, args: ['matChipInputSeparatorKeyCodes',] }],\n            chipEnd: [{ type: core.Output, args: ['matChipInputTokenEnd',] }],\n            placeholder: [{ type: core.Input }],\n            id: [{ type: core.Input }],\n            disabled: [{ type: core.Input }]\n        };\n        return MatChipInput;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var CHIP_DECLARATIONS = [\n        MatChipList,\n        MatChip,\n        MatChipInput,\n        MatChipRemove,\n        MatChipAvatar,\n        MatChipTrailingIcon,\n    ];\n    var Éµ0 = {\n        separatorKeyCodes: [keycodes.ENTER]\n    };\n    var MatChipsModule = /** @class */ (function () {\n        function MatChipsModule() {\n        }\n        MatChipsModule.decorators = [\n            { type: core.NgModule, args: [{\n                        exports: CHIP_DECLARATIONS,\n                        declarations: CHIP_DECLARATIONS,\n                        providers: [\n                            core$1.ErrorStateMatcher,\n                            {\n                                provide: MAT_CHIPS_DEFAULT_OPTIONS,\n                                useValue: Éµ0\n                            }\n                        ]\n                    },] }\n        ];\n        return MatChipsModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.MatChipsModule = MatChipsModule;\n    exports.Éµ0 = Éµ0;\n    exports.MatChipListChange = MatChipListChange;\n    exports.MatChipList = MatChipList;\n    exports.MatChipSelectionChange = MatChipSelectionChange;\n    exports.MatChipAvatar = MatChipAvatar;\n    exports.MatChipTrailingIcon = MatChipTrailingIcon;\n    exports.MatChip = MatChip;\n    exports.MatChipRemove = MatChipRemove;\n    exports.MatChipInput = MatChipInput;\n    exports.MAT_CHIPS_DEFAULT_OPTIONS = MAT_CHIPS_DEFAULT_OPTIONS;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=material-chips.umd.js.map\n"]}