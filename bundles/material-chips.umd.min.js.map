{"version":3,"sources":["src/material/material-chips.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","material","chips","cdk","keycodes","core","tslib","coercion","platform","rxjs","operators","platformBrowser","animations","a11y","bidi","collections","forms","formField","this","core$1","MatChipSelectionChange","source","selected","isUserInput","_MatChipMixinBase","mixinTabIndex","mixinColor","mixinDisableRipple","mixinDisabled","MatChipBase","_elementRef","MatChipAvatar","decorators","type","Directive","args","selector","host","class","MatChipTrailingIcon","MatChip","_super","_ngZone","globalRippleOptions","animationMode","_changeDetectorRef","tabIndex","_this","call","_hasFocus","chipListSelectable","_chipListMultiple","_selected","_selectable","_removable","_onFocus","Subject","_onBlur","selectionChange","EventEmitter","destroyed","removed","_addHostClassName","_chipRipple","RippleRenderer","setupTriggerEvents","rippleConfig","_animationsDisabled","parseInt","__extends","Object","defineProperty","prototype","get","disabled","disableRipple","enumerable","configurable","set","value","coercedValue","coerceBooleanProperty","_dispatchSelectionChange","undefined","_value","nativeElement","textContent","selectable","toString","element","hasAttribute","tagName","toLowerCase","classList","add","ngOnDestroy","emit","chip","_removeTriggerEvents","select","_markForCheck","deselect","selectViaInteraction","toggleSelected","focus","next","remove","removable","_handleClick","event","preventDefault","stopPropagation","_handleKeydown","keyCode","DELETE","BACKSPACE","SPACE","_blur","onStable","asObservable","pipe","take","subscribe","run","markForCheck","inputs","exportAs","[attr.tabindex]","role","[class.mat-chip-selected]","[class.mat-chip-with-avatar]","[class.mat-chip-with-trailing-icon]","[class.mat-chip-disabled]","[class._mat-animation-noopable]","[attr.disabled]","[attr.aria-disabled]","[attr.aria-selected]","(click)","(keydown)","(focus)","(blur)","ctorParameters","ElementRef","NgZone","Platform","Optional","Inject","MAT_RIPPLE_GLOBAL_OPTIONS","String","ANIMATION_MODULE_TYPE","ChangeDetectorRef","Attribute","propDecorators","avatar","ContentChild","trailingIcon","removeIcon","forwardRef","MatChipRemove","Input","Output","_parentChip","parentChip","MAT_CHIPS_DEFAULT_OPTIONS","InjectionToken","_MatChipListMixinBase","mixinErrorState","MatChipListBase","_defaultErrorStateMatcher","_parentForm","_parentFormGroup","ngControl","nextUniqueId","MatChipListChange","MatChipList","_dir","controlType","_lastDestroyedChipIndex","_destroyed","_uid","_tabIndex","_userTabIndex","_onTouched","_onChange","_multiple","_compareWith","o1","o2","_required","_disabled","ariaOrientation","change","valueChange","valueAccessor","multiple","_selectionModel","empty","_syncChipsState","fn","_initializeSelection","writeValue","_chipInput","id","stateChanges","placeholder","_placeholder","focused","_hasFocusedChip","length","forEach","merge","apply","__spread","map","ngAfterContentInit","_keyManager","FocusKeyManager","withWrap","withVerticalOrientation","withHorizontalOrientation","takeUntil","dir","tabOut","_allowFocusEscape","changes","startWith","Promise","resolve","then","_resetChips","_updateTabIndex","_updateFocusForDestroyedChips","ngOnInit","SelectionModel","ngDoCheck","updateErrorState","complete","_dropSubscriptions","registerInput","inputElement","setDescribedByIds","ids","_ariaDescribedby","join","_setSelectionByValue","registerOnChange","registerOnTouched","setDisabledState","isDisabled","onContainerClick","_originatesFromChip","options","setFirstItemActive","_focusInput","_keydown","target","_isInputEmpty","setLastItemActive","contains","HOME","END","onKeydown","newChipIndex","Math","min","setActiveItem","_isValidIndex","index","nodeName","_clearSelection","Array","isArray","currentValue","_selectValue","_sortValues","correspondingChip","find","skip","clear","_propagateChanges","fallbackValue","valueToEmit","setTimeout","_markAsTouched","_listenToChipsFocus","_listenToChipsSelection","_listenToChipsRemoved","_chipFocusSubscription","unsubscribe","_chipBlurSubscription","_chipSelectionSubscription","_chipRemoveSubscription","chipSelectionChanges","isSelected","chipFocusChanges","chipIndex","toArray","indexOf","updateActiveItem","chipBlurChanges","chipRemoveChanges","currentElement","parentElement","some","Component","template","[attr.aria-describedby]","[attr.aria-required]","[attr.aria-invalid]","[attr.aria-multiselectable]","[attr.role]","[class.mat-chip-list-disabled]","[class.mat-chip-list-invalid]","[class.mat-chip-list-required]","[attr.aria-orientation]","[id]","providers","provide","MatFormFieldControl","useExisting","encapsulation","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","styles","Directionality","NgForm","FormGroupDirective","ErrorStateMatcher","NgControl","Self","errorStateMatcher","compareWith","required","ContentChildren","descendants","nextUniqueId$1","MatChipInput","_defaultOptions","_addOnBlur","separatorKeyCodes","chipEnd","_inputElement","_chipList","ngOnChanges","TAB","hasModifierKey","_emitChipEnd","addOnBlur","_focus","_isSeparatorKey","input","_onInput","separators","has","(input)","[attr.placeholder]","chipList","CHIP_DECLARATIONS","Éµ0","ENTER","MatChipsModule","NgModule","declarations","useValue"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/cdk/keycodes'), require('@angular/core'), require('@angular/material/core'), require('tslib'), require('@angular/cdk/coercion'), require('@angular/cdk/platform'), require('rxjs'), require('rxjs/operators'), require('@angular/platform-browser/animations'), require('@angular/cdk/a11y'), require('@angular/cdk/bidi'), require('@angular/cdk/collections'), require('@angular/forms'), require('@angular/material/form-field')) :\n    typeof define === 'function' && define.amd ? define('@angular/material/chips', ['exports', '@angular/cdk/keycodes', '@angular/core', '@angular/material/core', 'tslib', '@angular/cdk/coercion', '@angular/cdk/platform', 'rxjs', 'rxjs/operators', '@angular/platform-browser/animations', '@angular/cdk/a11y', '@angular/cdk/bidi', '@angular/cdk/collections', '@angular/forms', '@angular/material/form-field'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.chips = {}), global.ng.cdk.keycodes, global.ng.core, global.ng.material.core, global.tslib, global.ng.cdk.coercion, global.ng.cdk.platform, global.rxjs, global.rxjs.operators, global.ng.platformBrowser.animations, global.ng.cdk.a11y, global.ng.cdk.bidi, global.ng.cdk.collections, global.ng.forms, global.ng.material.formField));\n}(this, (function (exports, keycodes, core, core$1, tslib, coercion, platform, rxjs, operators, animations, a11y, bidi, collections, forms, formField) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Event object emitted by MatChip when selected or deselected. */\n    var MatChipSelectionChange = /** @class */ (function () {\n        function MatChipSelectionChange(\n        /** Reference to the chip that emitted the event. */\n        source, \n        /** Whether the chip that emitted the event is selected. */\n        selected, \n        /** Whether the selection change was a result of a user interaction. */\n        isUserInput) {\n            if (isUserInput === void 0) { isUserInput = false; }\n            this.source = source;\n            this.selected = selected;\n            this.isUserInput = isUserInput;\n        }\n        return MatChipSelectionChange;\n    }());\n    // Boilerplate for applying mixins to MatChip.\n    /** @docs-private */\n    var MatChipBase = /** @class */ (function () {\n        function MatChipBase(_elementRef) {\n            this._elementRef = _elementRef;\n        }\n        return MatChipBase;\n    }());\n    var _MatChipMixinBase = core$1.mixinTabIndex(core$1.mixinColor(core$1.mixinDisableRipple(core$1.mixinDisabled(MatChipBase)), 'primary'), -1);\n    /**\n     * Dummy directive to add CSS class to chip avatar.\n     * @docs-private\n     */\n    var MatChipAvatar = /** @class */ (function () {\n        function MatChipAvatar() {\n        }\n        MatChipAvatar.decorators = [\n            { type: core.Directive, args: [{\n                        selector: 'mat-chip-avatar, [matChipAvatar]',\n                        host: { 'class': 'mat-chip-avatar' }\n                    },] }\n        ];\n        return MatChipAvatar;\n    }());\n    /**\n     * Dummy directive to add CSS class to chip trailing icon.\n     * @docs-private\n     */\n    var MatChipTrailingIcon = /** @class */ (function () {\n        function MatChipTrailingIcon() {\n        }\n        MatChipTrailingIcon.decorators = [\n            { type: core.Directive, args: [{\n                        selector: 'mat-chip-trailing-icon, [matChipTrailingIcon]',\n                        host: { 'class': 'mat-chip-trailing-icon' }\n                    },] }\n        ];\n        return MatChipTrailingIcon;\n    }());\n    /**\n     * Material design styled Chip component. Used inside the MatChipList component.\n     */\n    var MatChip = /** @class */ (function (_super) {\n        tslib.__extends(MatChip, _super);\n        function MatChip(_elementRef, _ngZone, platform, globalRippleOptions, \n        // @breaking-change 8.0.0 `animationMode` parameter to become required.\n        animationMode, \n        // @breaking-change 9.0.0 `_changeDetectorRef` parameter to become required.\n        _changeDetectorRef, tabIndex) {\n            var _this = _super.call(this, _elementRef) || this;\n            _this._elementRef = _elementRef;\n            _this._ngZone = _ngZone;\n            _this._changeDetectorRef = _changeDetectorRef;\n            /** Whether the chip has focus. */\n            _this._hasFocus = false;\n            /** Whether the chip list is selectable */\n            _this.chipListSelectable = true;\n            /** Whether the chip list is in multi-selection mode. */\n            _this._chipListMultiple = false;\n            _this._selected = false;\n            _this._selectable = true;\n            _this._removable = true;\n            /** Emits when the chip is focused. */\n            _this._onFocus = new rxjs.Subject();\n            /** Emits when the chip is blured. */\n            _this._onBlur = new rxjs.Subject();\n            /** Emitted when the chip is selected or deselected. */\n            _this.selectionChange = new core.EventEmitter();\n            /** Emitted when the chip is destroyed. */\n            _this.destroyed = new core.EventEmitter();\n            /** Emitted when a chip is to be removed. */\n            _this.removed = new core.EventEmitter();\n            _this._addHostClassName();\n            _this._chipRipple = new core$1.RippleRenderer(_this, _ngZone, _elementRef, platform);\n            _this._chipRipple.setupTriggerEvents(_elementRef);\n            _this.rippleConfig = globalRippleOptions || {};\n            _this._animationsDisabled = animationMode === 'NoopAnimations';\n            _this.tabIndex = tabIndex != null ? (parseInt(tabIndex) || -1) : -1;\n            return _this;\n        }\n        Object.defineProperty(MatChip.prototype, \"rippleDisabled\", {\n            /**\n             * Whether ripples are disabled on interaction\n             * @docs-private\n             */\n            get: function () {\n                return this.disabled || this.disableRipple || !!this.rippleConfig.disabled;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChip.prototype, \"selected\", {\n            /** Whether the chip is selected. */\n            get: function () { return this._selected; },\n            set: function (value) {\n                var coercedValue = coercion.coerceBooleanProperty(value);\n                if (coercedValue !== this._selected) {\n                    this._selected = coercedValue;\n                    this._dispatchSelectionChange();\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChip.prototype, \"value\", {\n            /** The value of the chip. Defaults to the content inside `<mat-chip>` tags. */\n            get: function () {\n                return this._value !== undefined\n                    ? this._value\n                    : this._elementRef.nativeElement.textContent;\n            },\n            set: function (value) { this._value = value; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChip.prototype, \"selectable\", {\n            /**\n             * Whether or not the chip is selectable. When a chip is not selectable,\n             * changes to its selected state are always ignored. By default a chip is\n             * selectable, and it becomes non-selectable if its parent chip list is\n             * not selectable.\n             */\n            get: function () { return this._selectable && this.chipListSelectable; },\n            set: function (value) {\n                this._selectable = coercion.coerceBooleanProperty(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChip.prototype, \"removable\", {\n            /**\n             * Determines whether or not the chip displays the remove styling and emits (removed) events.\n             */\n            get: function () { return this._removable; },\n            set: function (value) {\n                this._removable = coercion.coerceBooleanProperty(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChip.prototype, \"ariaSelected\", {\n            /** The ARIA selected applied to the chip. */\n            get: function () {\n                // Remove the `aria-selected` when the chip is deselected in single-selection mode, because\n                // it adds noise to NVDA users where \"not selected\" will be read out for each chip.\n                return this.selectable && (this._chipListMultiple || this.selected) ?\n                    this.selected.toString() : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MatChip.prototype._addHostClassName = function () {\n            var basicChipAttrName = 'mat-basic-chip';\n            var element = this._elementRef.nativeElement;\n            if (element.hasAttribute(basicChipAttrName) ||\n                element.tagName.toLowerCase() === basicChipAttrName) {\n                element.classList.add(basicChipAttrName);\n                return;\n            }\n            else {\n                element.classList.add('mat-standard-chip');\n            }\n        };\n        MatChip.prototype.ngOnDestroy = function () {\n            this.destroyed.emit({ chip: this });\n            this._chipRipple._removeTriggerEvents();\n        };\n        /** Selects the chip. */\n        MatChip.prototype.select = function () {\n            if (!this._selected) {\n                this._selected = true;\n                this._dispatchSelectionChange();\n                this._markForCheck();\n            }\n        };\n        /** Deselects the chip. */\n        MatChip.prototype.deselect = function () {\n            if (this._selected) {\n                this._selected = false;\n                this._dispatchSelectionChange();\n                this._markForCheck();\n            }\n        };\n        /** Select this chip and emit selected event */\n        MatChip.prototype.selectViaInteraction = function () {\n            if (!this._selected) {\n                this._selected = true;\n                this._dispatchSelectionChange(true);\n                this._markForCheck();\n            }\n        };\n        /** Toggles the current selected state of this chip. */\n        MatChip.prototype.toggleSelected = function (isUserInput) {\n            if (isUserInput === void 0) { isUserInput = false; }\n            this._selected = !this.selected;\n            this._dispatchSelectionChange(isUserInput);\n            this._markForCheck();\n            return this.selected;\n        };\n        /** Allows for programmatic focusing of the chip. */\n        MatChip.prototype.focus = function () {\n            if (!this._hasFocus) {\n                this._elementRef.nativeElement.focus();\n                this._onFocus.next({ chip: this });\n            }\n            this._hasFocus = true;\n        };\n        /**\n         * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or\n         * BACKSPACE keys are pressed.\n         *\n         * Informs any listeners of the removal request. Does not remove the chip from the DOM.\n         */\n        MatChip.prototype.remove = function () {\n            if (this.removable) {\n                this.removed.emit({ chip: this });\n            }\n        };\n        /** Handles click events on the chip. */\n        MatChip.prototype._handleClick = function (event) {\n            if (this.disabled) {\n                event.preventDefault();\n            }\n            else {\n                event.stopPropagation();\n            }\n        };\n        /** Handle custom key presses. */\n        MatChip.prototype._handleKeydown = function (event) {\n            if (this.disabled) {\n                return;\n            }\n            switch (event.keyCode) {\n                case keycodes.DELETE:\n                case keycodes.BACKSPACE:\n                    // If we are removable, remove the focused chip\n                    this.remove();\n                    // Always prevent so page navigation does not occur\n                    event.preventDefault();\n                    break;\n                case keycodes.SPACE:\n                    // If we are selectable, toggle the focused chip\n                    if (this.selectable) {\n                        this.toggleSelected(true);\n                    }\n                    // Always prevent space from scrolling the page since the list has focus\n                    event.preventDefault();\n                    break;\n            }\n        };\n        MatChip.prototype._blur = function () {\n            var _this = this;\n            // When animations are enabled, Angular may end up removing the chip from the DOM a little\n            // earlier than usual, causing it to be blurred and throwing off the logic in the chip list\n            // that moves focus not the next item. To work around the issue, we defer marking the chip\n            // as not focused until the next time the zone stabilizes.\n            this._ngZone.onStable\n                .asObservable()\n                .pipe(operators.take(1))\n                .subscribe(function () {\n                _this._ngZone.run(function () {\n                    _this._hasFocus = false;\n                    _this._onBlur.next({ chip: _this });\n                });\n            });\n        };\n        MatChip.prototype._dispatchSelectionChange = function (isUserInput) {\n            if (isUserInput === void 0) { isUserInput = false; }\n            this.selectionChange.emit({\n                source: this,\n                isUserInput: isUserInput,\n                selected: this._selected\n            });\n        };\n        MatChip.prototype._markForCheck = function () {\n            // @breaking-change 9.0.0 Remove this method once the _changeDetectorRef is a required param.\n            if (this._changeDetectorRef) {\n                this._changeDetectorRef.markForCheck();\n            }\n        };\n        MatChip.decorators = [\n            { type: core.Directive, args: [{\n                        selector: \"mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]\",\n                        inputs: ['color', 'disabled', 'disableRipple', 'tabIndex'],\n                        exportAs: 'matChip',\n                        host: {\n                            'class': 'mat-chip',\n                            '[attr.tabindex]': 'disabled ? null : tabIndex',\n                            'role': 'option',\n                            '[class.mat-chip-selected]': 'selected',\n                            '[class.mat-chip-with-avatar]': 'avatar',\n                            '[class.mat-chip-with-trailing-icon]': 'trailingIcon || removeIcon',\n                            '[class.mat-chip-disabled]': 'disabled',\n                            '[class._mat-animation-noopable]': '_animationsDisabled',\n                            '[attr.disabled]': 'disabled || null',\n                            '[attr.aria-disabled]': 'disabled.toString()',\n                            '[attr.aria-selected]': 'ariaSelected',\n                            '(click)': '_handleClick($event)',\n                            '(keydown)': '_handleKeydown($event)',\n                            '(focus)': 'focus()',\n                            '(blur)': '_blur()',\n                        },\n                    },] }\n        ];\n        /** @nocollapse */\n        MatChip.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: core.NgZone },\n            { type: platform.Platform },\n            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core$1.MAT_RIPPLE_GLOBAL_OPTIONS,] }] },\n            { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] },\n            { type: core.ChangeDetectorRef },\n            { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] }\n        ]; };\n        MatChip.propDecorators = {\n            avatar: [{ type: core.ContentChild, args: [MatChipAvatar,] }],\n            trailingIcon: [{ type: core.ContentChild, args: [MatChipTrailingIcon,] }],\n            removeIcon: [{ type: core.ContentChild, args: [core.forwardRef(function () { return MatChipRemove; }),] }],\n            selected: [{ type: core.Input }],\n            value: [{ type: core.Input }],\n            selectable: [{ type: core.Input }],\n            removable: [{ type: core.Input }],\n            selectionChange: [{ type: core.Output }],\n            destroyed: [{ type: core.Output }],\n            removed: [{ type: core.Output }]\n        };\n        return MatChip;\n    }(_MatChipMixinBase));\n    /**\n     * Applies proper (click) support and adds styling for use with the Material Design \"cancel\" icon\n     * available at https://material.io/icons/#ic_cancel.\n     *\n     * Example:\n     *\n     *     `<mat-chip>\n     *       <mat-icon matChipRemove>cancel</mat-icon>\n     *     </mat-chip>`\n     *\n     * You *may* use a custom icon, but you may need to override the `mat-chip-remove` positioning\n     * styles to properly center the icon within the chip.\n     */\n    var MatChipRemove = /** @class */ (function () {\n        function MatChipRemove(_parentChip) {\n            this._parentChip = _parentChip;\n        }\n        /** Calls the parent chip's public `remove()` method if applicable. */\n        MatChipRemove.prototype._handleClick = function (event) {\n            var parentChip = this._parentChip;\n            if (parentChip.removable && !parentChip.disabled) {\n                parentChip.remove();\n            }\n            // We need to stop event propagation because otherwise the event will bubble up to the\n            // form field and cause the `onContainerClick` method to be invoked. This method would then\n            // reset the focused chip that has been focused after chip removal. Usually the parent\n            // the parent click listener of the `MatChip` would prevent propagation, but it can happen\n            // that the chip is being removed before the event bubbles up.\n            event.stopPropagation();\n        };\n        MatChipRemove.decorators = [\n            { type: core.Directive, args: [{\n                        selector: '[matChipRemove]',\n                        host: {\n                            'class': 'mat-chip-remove mat-chip-trailing-icon',\n                            '(click)': '_handleClick($event)',\n                            // Prevent accidental form submissions.\n                            'type': 'button',\n                        }\n                    },] }\n        ];\n        /** @nocollapse */\n        MatChipRemove.ctorParameters = function () { return [\n            { type: MatChip }\n        ]; };\n        return MatChipRemove;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Injection token to be used to override the default options for the chips module. */\n    var MAT_CHIPS_DEFAULT_OPTIONS = new core.InjectionToken('mat-chips-default-options');\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // Boilerplate for applying mixins to MatChipList.\n    /** @docs-private */\n    var MatChipListBase = /** @class */ (function () {\n        function MatChipListBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, \n        /** @docs-private */\n        ngControl) {\n            this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n            this._parentForm = _parentForm;\n            this._parentFormGroup = _parentFormGroup;\n            this.ngControl = ngControl;\n        }\n        return MatChipListBase;\n    }());\n    var _MatChipListMixinBase = core$1.mixinErrorState(MatChipListBase);\n    // Increasing integer for generating unique ids for chip-list components.\n    var nextUniqueId = 0;\n    /** Change event object that is emitted when the chip list value has changed. */\n    var MatChipListChange = /** @class */ (function () {\n        function MatChipListChange(\n        /** Chip list that emitted the event. */\n        source, \n        /** Value of the chip list when the event was emitted. */\n        value) {\n            this.source = source;\n            this.value = value;\n        }\n        return MatChipListChange;\n    }());\n    /**\n     * A material design chips component (named ChipList for its similarity to the List component).\n     */\n    var MatChipList = /** @class */ (function (_super) {\n        tslib.__extends(MatChipList, _super);\n        function MatChipList(_elementRef, _changeDetectorRef, _dir, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, \n        /** @docs-private */\n        ngControl) {\n            var _this = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;\n            _this._elementRef = _elementRef;\n            _this._changeDetectorRef = _changeDetectorRef;\n            _this._dir = _dir;\n            _this.ngControl = ngControl;\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            _this.controlType = 'mat-chip-list';\n            /**\n             * When a chip is destroyed, we store the index of the destroyed chip until the chips\n             * query list notifies about the update. This is necessary because we cannot determine an\n             * appropriate chip that should receive focus until the array of chips updated completely.\n             */\n            _this._lastDestroyedChipIndex = null;\n            /** Subject that emits when the component has been destroyed. */\n            _this._destroyed = new rxjs.Subject();\n            /** Uid of the chip list */\n            _this._uid = \"mat-chip-list-\" + nextUniqueId++;\n            /** Tab index for the chip list. */\n            _this._tabIndex = 0;\n            /**\n             * User defined tab index.\n             * When it is not null, use user defined tab index. Otherwise use _tabIndex\n             */\n            _this._userTabIndex = null;\n            /** Function when touched */\n            _this._onTouched = function () { };\n            /** Function when changed */\n            _this._onChange = function () { };\n            _this._multiple = false;\n            _this._compareWith = function (o1, o2) { return o1 === o2; };\n            _this._required = false;\n            _this._disabled = false;\n            /** Orientation of the chip list. */\n            _this.ariaOrientation = 'horizontal';\n            _this._selectable = true;\n            /** Event emitted when the selected chip list value has been changed by the user. */\n            _this.change = new core.EventEmitter();\n            /**\n             * Event that emits whenever the raw value of the chip-list changes. This is here primarily\n             * to facilitate the two-way binding for the `value` input.\n             * @docs-private\n             */\n            _this.valueChange = new core.EventEmitter();\n            if (_this.ngControl) {\n                _this.ngControl.valueAccessor = _this;\n            }\n            return _this;\n        }\n        Object.defineProperty(MatChipList.prototype, \"selected\", {\n            /** The array of selected chips inside chip list. */\n            get: function () {\n                return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0];\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"role\", {\n            /** The ARIA role applied to the chip list. */\n            get: function () { return this.empty ? null : 'listbox'; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"multiple\", {\n            /** Whether the user should be allowed to select multiple chips. */\n            get: function () { return this._multiple; },\n            set: function (value) {\n                this._multiple = coercion.coerceBooleanProperty(value);\n                this._syncChipsState();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"compareWith\", {\n            /**\n             * A function to compare the option values with the selected values. The first argument\n             * is a value from an option. The second is a value from the selection. A boolean\n             * should be returned.\n             */\n            get: function () { return this._compareWith; },\n            set: function (fn) {\n                this._compareWith = fn;\n                if (this._selectionModel) {\n                    // A different comparator means the selection could change.\n                    this._initializeSelection();\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"value\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () { return this._value; },\n            set: function (value) {\n                this.writeValue(value);\n                this._value = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"id\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () {\n                return this._chipInput ? this._chipInput.id : this._uid;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"required\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () { return this._required; },\n            set: function (value) {\n                this._required = coercion.coerceBooleanProperty(value);\n                this.stateChanges.next();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"placeholder\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () {\n                return this._chipInput ? this._chipInput.placeholder : this._placeholder;\n            },\n            set: function (value) {\n                this._placeholder = value;\n                this.stateChanges.next();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"focused\", {\n            /** Whether any chips or the matChipInput inside of this chip-list has focus. */\n            get: function () {\n                return (this._chipInput && this._chipInput.focused) || this._hasFocusedChip();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"empty\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () {\n                return (!this._chipInput || this._chipInput.empty) && this.chips.length === 0;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"shouldLabelFloat\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () { return !this.empty || this.focused; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"disabled\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () { return this.ngControl ? !!this.ngControl.disabled : this._disabled; },\n            set: function (value) {\n                this._disabled = coercion.coerceBooleanProperty(value);\n                this._syncChipsState();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"selectable\", {\n            /**\n             * Whether or not this chip list is selectable. When a chip list is not selectable,\n             * the selected states for all the chips inside the chip list are always ignored.\n             */\n            get: function () { return this._selectable; },\n            set: function (value) {\n                var _this = this;\n                this._selectable = coercion.coerceBooleanProperty(value);\n                if (this.chips) {\n                    this.chips.forEach(function (chip) { return chip.chipListSelectable = _this._selectable; });\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"tabIndex\", {\n            set: function (value) {\n                this._userTabIndex = value;\n                this._tabIndex = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"chipSelectionChanges\", {\n            /** Combined stream of all of the child chips' selection change events. */\n            get: function () {\n                return rxjs.merge.apply(void 0, tslib.__spread(this.chips.map(function (chip) { return chip.selectionChange; })));\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"chipFocusChanges\", {\n            /** Combined stream of all of the child chips' focus change events. */\n            get: function () {\n                return rxjs.merge.apply(void 0, tslib.__spread(this.chips.map(function (chip) { return chip._onFocus; })));\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"chipBlurChanges\", {\n            /** Combined stream of all of the child chips' blur change events. */\n            get: function () {\n                return rxjs.merge.apply(void 0, tslib.__spread(this.chips.map(function (chip) { return chip._onBlur; })));\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"chipRemoveChanges\", {\n            /** Combined stream of all of the child chips' remove change events. */\n            get: function () {\n                return rxjs.merge.apply(void 0, tslib.__spread(this.chips.map(function (chip) { return chip.destroyed; })));\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MatChipList.prototype.ngAfterContentInit = function () {\n            var _this = this;\n            this._keyManager = new a11y.FocusKeyManager(this.chips)\n                .withWrap()\n                .withVerticalOrientation()\n                .withHorizontalOrientation(this._dir ? this._dir.value : 'ltr');\n            if (this._dir) {\n                this._dir.change\n                    .pipe(operators.takeUntil(this._destroyed))\n                    .subscribe(function (dir) { return _this._keyManager.withHorizontalOrientation(dir); });\n            }\n            this._keyManager.tabOut.pipe(operators.takeUntil(this._destroyed)).subscribe(function () {\n                _this._allowFocusEscape();\n            });\n            // When the list changes, re-subscribe\n            this.chips.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroyed)).subscribe(function () {\n                if (_this.disabled) {\n                    // Since this happens after the content has been\n                    // checked, we need to defer it to the next tick.\n                    Promise.resolve().then(function () {\n                        _this._syncChipsState();\n                    });\n                }\n                _this._resetChips();\n                // Reset chips selected/deselected status\n                _this._initializeSelection();\n                // Check to see if we need to update our tab index\n                _this._updateTabIndex();\n                // Check to see if we have a destroyed chip and need to refocus\n                _this._updateFocusForDestroyedChips();\n                _this.stateChanges.next();\n            });\n        };\n        MatChipList.prototype.ngOnInit = function () {\n            this._selectionModel = new collections.SelectionModel(this.multiple, undefined, false);\n            this.stateChanges.next();\n        };\n        MatChipList.prototype.ngDoCheck = function () {\n            if (this.ngControl) {\n                // We need to re-evaluate this on every change detection cycle, because there are some\n                // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n                // that whatever logic is in here has to be super lean or we risk destroying the performance.\n                this.updateErrorState();\n            }\n        };\n        MatChipList.prototype.ngOnDestroy = function () {\n            this._destroyed.next();\n            this._destroyed.complete();\n            this.stateChanges.complete();\n            this._dropSubscriptions();\n        };\n        /** Associates an HTML input element with this chip list. */\n        MatChipList.prototype.registerInput = function (inputElement) {\n            this._chipInput = inputElement;\n        };\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        MatChipList.prototype.setDescribedByIds = function (ids) { this._ariaDescribedby = ids.join(' '); };\n        // Implemented as part of ControlValueAccessor.\n        MatChipList.prototype.writeValue = function (value) {\n            if (this.chips) {\n                this._setSelectionByValue(value, false);\n            }\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatChipList.prototype.registerOnChange = function (fn) {\n            this._onChange = fn;\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatChipList.prototype.registerOnTouched = function (fn) {\n            this._onTouched = fn;\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatChipList.prototype.setDisabledState = function (isDisabled) {\n            this.disabled = isDisabled;\n            this.stateChanges.next();\n        };\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        MatChipList.prototype.onContainerClick = function (event) {\n            if (!this._originatesFromChip(event)) {\n                this.focus();\n            }\n        };\n        /**\n         * Focuses the first non-disabled chip in this chip list, or the associated input when there\n         * are no eligible chips.\n         */\n        MatChipList.prototype.focus = function (options) {\n            if (this.disabled) {\n                return;\n            }\n            // TODO: ARIA says this should focus the first `selected` chip if any are selected.\n            // Focus on first element if there's no chipInput inside chip-list\n            if (this._chipInput && this._chipInput.focused) {\n                // do nothing\n            }\n            else if (this.chips.length > 0) {\n                this._keyManager.setFirstItemActive();\n                this.stateChanges.next();\n            }\n            else {\n                this._focusInput(options);\n                this.stateChanges.next();\n            }\n        };\n        /** Attempt to focus an input if we have one. */\n        MatChipList.prototype._focusInput = function (options) {\n            if (this._chipInput) {\n                this._chipInput.focus(options);\n            }\n        };\n        /**\n         * Pass events to the keyboard manager. Available here for tests.\n         */\n        MatChipList.prototype._keydown = function (event) {\n            var target = event.target;\n            // If they are on an empty input and hit backspace, focus the last chip\n            if (event.keyCode === keycodes.BACKSPACE && this._isInputEmpty(target)) {\n                this._keyManager.setLastItemActive();\n                event.preventDefault();\n            }\n            else if (target && target.classList.contains('mat-chip')) {\n                if (event.keyCode === keycodes.HOME) {\n                    this._keyManager.setFirstItemActive();\n                    event.preventDefault();\n                }\n                else if (event.keyCode === keycodes.END) {\n                    this._keyManager.setLastItemActive();\n                    event.preventDefault();\n                }\n                else {\n                    this._keyManager.onKeydown(event);\n                }\n                this.stateChanges.next();\n            }\n        };\n        /**\n         * Check the tab index as you should not be allowed to focus an empty list.\n         */\n        MatChipList.prototype._updateTabIndex = function () {\n            // If we have 0 chips, we should not allow keyboard focus\n            this._tabIndex = this._userTabIndex || (this.chips.length === 0 ? -1 : 0);\n        };\n        /**\n         * If the amount of chips changed, we need to update the\n         * key manager state and focus the next closest chip.\n         */\n        MatChipList.prototype._updateFocusForDestroyedChips = function () {\n            // Move focus to the closest chip. If no other chips remain, focus the chip-list itself.\n            if (this._lastDestroyedChipIndex != null) {\n                if (this.chips.length) {\n                    var newChipIndex = Math.min(this._lastDestroyedChipIndex, this.chips.length - 1);\n                    this._keyManager.setActiveItem(newChipIndex);\n                }\n                else {\n                    this.focus();\n                }\n            }\n            this._lastDestroyedChipIndex = null;\n        };\n        /**\n         * Utility to ensure all indexes are valid.\n         *\n         * @param index The index to be checked.\n         * @returns True if the index is valid for our list of chips.\n         */\n        MatChipList.prototype._isValidIndex = function (index) {\n            return index >= 0 && index < this.chips.length;\n        };\n        MatChipList.prototype._isInputEmpty = function (element) {\n            if (element && element.nodeName.toLowerCase() === 'input') {\n                var input = element;\n                return !input.value;\n            }\n            return false;\n        };\n        MatChipList.prototype._setSelectionByValue = function (value, isUserInput) {\n            var _this = this;\n            if (isUserInput === void 0) { isUserInput = true; }\n            this._clearSelection();\n            this.chips.forEach(function (chip) { return chip.deselect(); });\n            if (Array.isArray(value)) {\n                value.forEach(function (currentValue) { return _this._selectValue(currentValue, isUserInput); });\n                this._sortValues();\n            }\n            else {\n                var correspondingChip = this._selectValue(value, isUserInput);\n                // Shift focus to the active item. Note that we shouldn't do this in multiple\n                // mode, because we don't know what chip the user interacted with last.\n                if (correspondingChip) {\n                    if (isUserInput) {\n                        this._keyManager.setActiveItem(correspondingChip);\n                    }\n                }\n            }\n        };\n        /**\n         * Finds and selects the chip based on its value.\n         * @returns Chip that has the corresponding value.\n         */\n        MatChipList.prototype._selectValue = function (value, isUserInput) {\n            var _this = this;\n            if (isUserInput === void 0) { isUserInput = true; }\n            var correspondingChip = this.chips.find(function (chip) {\n                return chip.value != null && _this._compareWith(chip.value, value);\n            });\n            if (correspondingChip) {\n                isUserInput ? correspondingChip.selectViaInteraction() : correspondingChip.select();\n                this._selectionModel.select(correspondingChip);\n            }\n            return correspondingChip;\n        };\n        MatChipList.prototype._initializeSelection = function () {\n            var _this = this;\n            // Defer setting the value in order to avoid the \"Expression\n            // has changed after it was checked\" errors from Angular.\n            Promise.resolve().then(function () {\n                if (_this.ngControl || _this._value) {\n                    _this._setSelectionByValue(_this.ngControl ? _this.ngControl.value : _this._value, false);\n                    _this.stateChanges.next();\n                }\n            });\n        };\n        /**\n         * Deselects every chip in the list.\n         * @param skip Chip that should not be deselected.\n         */\n        MatChipList.prototype._clearSelection = function (skip) {\n            this._selectionModel.clear();\n            this.chips.forEach(function (chip) {\n                if (chip !== skip) {\n                    chip.deselect();\n                }\n            });\n            this.stateChanges.next();\n        };\n        /**\n         * Sorts the model values, ensuring that they keep the same\n         * order that they have in the panel.\n         */\n        MatChipList.prototype._sortValues = function () {\n            var _this = this;\n            if (this._multiple) {\n                this._selectionModel.clear();\n                this.chips.forEach(function (chip) {\n                    if (chip.selected) {\n                        _this._selectionModel.select(chip);\n                    }\n                });\n                this.stateChanges.next();\n            }\n        };\n        /** Emits change event to set the model value. */\n        MatChipList.prototype._propagateChanges = function (fallbackValue) {\n            var valueToEmit = null;\n            if (Array.isArray(this.selected)) {\n                valueToEmit = this.selected.map(function (chip) { return chip.value; });\n            }\n            else {\n                valueToEmit = this.selected ? this.selected.value : fallbackValue;\n            }\n            this._value = valueToEmit;\n            this.change.emit(new MatChipListChange(this, valueToEmit));\n            this.valueChange.emit(valueToEmit);\n            this._onChange(valueToEmit);\n            this._changeDetectorRef.markForCheck();\n        };\n        /** When blurred, mark the field as touched when focus moved outside the chip list. */\n        MatChipList.prototype._blur = function () {\n            var _this = this;\n            if (!this._hasFocusedChip()) {\n                this._keyManager.setActiveItem(-1);\n            }\n            if (!this.disabled) {\n                if (this._chipInput) {\n                    // If there's a chip input, we should check whether the focus moved to chip input.\n                    // If the focus is not moved to chip input, mark the field as touched. If the focus moved\n                    // to chip input, do nothing.\n                    // Timeout is needed to wait for the focus() event trigger on chip input.\n                    setTimeout(function () {\n                        if (!_this.focused) {\n                            _this._markAsTouched();\n                        }\n                    });\n                }\n                else {\n                    // If there's no chip input, then mark the field as touched.\n                    this._markAsTouched();\n                }\n            }\n        };\n        /** Mark the field as touched */\n        MatChipList.prototype._markAsTouched = function () {\n            this._onTouched();\n            this._changeDetectorRef.markForCheck();\n            this.stateChanges.next();\n        };\n        /**\n         * Removes the `tabindex` from the chip list and resets it back afterwards, allowing the\n         * user to tab out of it. This prevents the list from capturing focus and redirecting\n         * it back to the first chip, creating a focus trap, if it user tries to tab away.\n         */\n        MatChipList.prototype._allowFocusEscape = function () {\n            var _this = this;\n            if (this._tabIndex !== -1) {\n                this._tabIndex = -1;\n                setTimeout(function () {\n                    _this._tabIndex = _this._userTabIndex || 0;\n                    _this._changeDetectorRef.markForCheck();\n                });\n            }\n        };\n        MatChipList.prototype._resetChips = function () {\n            this._dropSubscriptions();\n            this._listenToChipsFocus();\n            this._listenToChipsSelection();\n            this._listenToChipsRemoved();\n        };\n        MatChipList.prototype._dropSubscriptions = function () {\n            if (this._chipFocusSubscription) {\n                this._chipFocusSubscription.unsubscribe();\n                this._chipFocusSubscription = null;\n            }\n            if (this._chipBlurSubscription) {\n                this._chipBlurSubscription.unsubscribe();\n                this._chipBlurSubscription = null;\n            }\n            if (this._chipSelectionSubscription) {\n                this._chipSelectionSubscription.unsubscribe();\n                this._chipSelectionSubscription = null;\n            }\n            if (this._chipRemoveSubscription) {\n                this._chipRemoveSubscription.unsubscribe();\n                this._chipRemoveSubscription = null;\n            }\n        };\n        /** Listens to user-generated selection events on each chip. */\n        MatChipList.prototype._listenToChipsSelection = function () {\n            var _this = this;\n            this._chipSelectionSubscription = this.chipSelectionChanges.subscribe(function (event) {\n                event.source.selected\n                    ? _this._selectionModel.select(event.source)\n                    : _this._selectionModel.deselect(event.source);\n                // For single selection chip list, make sure the deselected value is unselected.\n                if (!_this.multiple) {\n                    _this.chips.forEach(function (chip) {\n                        if (!_this._selectionModel.isSelected(chip) && chip.selected) {\n                            chip.deselect();\n                        }\n                    });\n                }\n                if (event.isUserInput) {\n                    _this._propagateChanges();\n                }\n            });\n        };\n        /** Listens to user-generated selection events on each chip. */\n        MatChipList.prototype._listenToChipsFocus = function () {\n            var _this = this;\n            this._chipFocusSubscription = this.chipFocusChanges.subscribe(function (event) {\n                var chipIndex = _this.chips.toArray().indexOf(event.chip);\n                if (_this._isValidIndex(chipIndex)) {\n                    _this._keyManager.updateActiveItem(chipIndex);\n                }\n                _this.stateChanges.next();\n            });\n            this._chipBlurSubscription = this.chipBlurChanges.subscribe(function () {\n                _this._blur();\n                _this.stateChanges.next();\n            });\n        };\n        MatChipList.prototype._listenToChipsRemoved = function () {\n            var _this = this;\n            this._chipRemoveSubscription = this.chipRemoveChanges.subscribe(function (event) {\n                var chip = event.chip;\n                var chipIndex = _this.chips.toArray().indexOf(event.chip);\n                // In case the chip that will be removed is currently focused, we temporarily store\n                // the index in order to be able to determine an appropriate sibling chip that will\n                // receive focus.\n                if (_this._isValidIndex(chipIndex) && chip._hasFocus) {\n                    _this._lastDestroyedChipIndex = chipIndex;\n                }\n            });\n        };\n        /** Checks whether an event comes from inside a chip element. */\n        MatChipList.prototype._originatesFromChip = function (event) {\n            var currentElement = event.target;\n            while (currentElement && currentElement !== this._elementRef.nativeElement) {\n                if (currentElement.classList.contains('mat-chip')) {\n                    return true;\n                }\n                currentElement = currentElement.parentElement;\n            }\n            return false;\n        };\n        /** Checks whether any of the chips is focused. */\n        MatChipList.prototype._hasFocusedChip = function () {\n            return this.chips.some(function (chip) { return chip._hasFocus; });\n        };\n        /** Syncs the list's state with the individual chips. */\n        MatChipList.prototype._syncChipsState = function () {\n            var _this = this;\n            if (this.chips) {\n                this.chips.forEach(function (chip) {\n                    chip.disabled = _this._disabled;\n                    chip._chipListMultiple = _this.multiple;\n                });\n            }\n        };\n        MatChipList.decorators = [\n            { type: core.Component, args: [{\n                        selector: 'mat-chip-list',\n                        template: \"<div class=\\\"mat-chip-list-wrapper\\\"><ng-content></ng-content></div>\",\n                        exportAs: 'matChipList',\n                        host: {\n                            '[attr.tabindex]': 'disabled ? null : _tabIndex',\n                            '[attr.aria-describedby]': '_ariaDescribedby || null',\n                            '[attr.aria-required]': 'role ? required : null',\n                            '[attr.aria-disabled]': 'disabled.toString()',\n                            '[attr.aria-invalid]': 'errorState',\n                            '[attr.aria-multiselectable]': 'multiple',\n                            '[attr.role]': 'role',\n                            '[class.mat-chip-list-disabled]': 'disabled',\n                            '[class.mat-chip-list-invalid]': 'errorState',\n                            '[class.mat-chip-list-required]': 'required',\n                            '[attr.aria-orientation]': 'ariaOrientation',\n                            'class': 'mat-chip-list',\n                            '(focus)': 'focus()',\n                            '(blur)': '_blur()',\n                            '(keydown)': '_keydown($event)',\n                            '[id]': '_uid',\n                        },\n                        providers: [{ provide: formField.MatFormFieldControl, useExisting: MatChipList }],\n                        encapsulation: core.ViewEncapsulation.None,\n                        changeDetection: core.ChangeDetectionStrategy.OnPush,\n                        styles: [\".mat-chip{position:relative;overflow:hidden;box-sizing:border-box;-webkit-tap-highlight-color:transparent;transform:translateZ(0);border:none;-webkit-appearance:none;-moz-appearance:none}.mat-standard-chip{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:inline-flex;padding:7px 12px;border-radius:16px;align-items:center;cursor:default;min-height:32px;height:1px}._mat-animation-noopable.mat-standard-chip{transition:none;animation:none}.mat-standard-chip .mat-chip-remove.mat-icon{width:18px;height:18px}.mat-standard-chip::after{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit;opacity:0;content:\\\"\\\";pointer-events:none;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-standard-chip:hover::after{opacity:.12}.mat-standard-chip:focus{outline:none}.mat-standard-chip:focus::after{opacity:.16}.cdk-high-contrast-active .mat-standard-chip{outline:solid 1px}.cdk-high-contrast-active .mat-standard-chip:focus{outline:dotted 2px}.cdk-high-contrast-active :host .mat-standard-chip{outline:solid 1px}.cdk-high-contrast-active :host .mat-standard-chip:focus{outline:dotted 2px}.mat-standard-chip.mat-chip-disabled::after{opacity:0}.mat-standard-chip.mat-chip-disabled .mat-chip-remove,.mat-standard-chip.mat-chip-disabled .mat-chip-trailing-icon{cursor:default}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar,.mat-standard-chip.mat-chip-with-avatar{padding-top:0;padding-bottom:0}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-right:8px;padding-left:0}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-left:8px;padding-right:0}.mat-standard-chip.mat-chip-with-trailing-icon{padding-top:7px;padding-bottom:7px;padding-right:8px;padding-left:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon{padding-left:8px;padding-right:12px}.mat-standard-chip.mat-chip-with-avatar{padding-left:0;padding-right:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-avatar{padding-right:0;padding-left:12px}.mat-standard-chip .mat-chip-avatar{width:24px;height:24px;margin-right:8px;margin-left:4px}[dir=rtl] .mat-standard-chip .mat-chip-avatar{margin-left:8px;margin-right:4px}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{width:18px;height:18px;cursor:pointer}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-standard-chip .mat-chip-remove,[dir=rtl] .mat-standard-chip .mat-chip-trailing-icon{margin-right:8px;margin-left:0}.mat-chip-list-wrapper{display:flex;flex-direction:row;flex-wrap:wrap;align-items:center;margin:-4px}.mat-chip-list-wrapper input.mat-input-element,.mat-chip-list-wrapper .mat-standard-chip{margin:4px}.mat-chip-list-stacked .mat-chip-list-wrapper{flex-direction:column;align-items:flex-start}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-standard-chip{width:100%}.mat-chip-avatar{border-radius:50%;justify-content:center;align-items:center;display:flex;overflow:hidden;object-fit:cover}input.mat-chip-input{width:150px;margin:4px;flex:1 0 150px}\\n\"]\n                    }] }\n        ];\n        /** @nocollapse */\n        MatChipList.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: core.ChangeDetectorRef },\n            { type: bidi.Directionality, decorators: [{ type: core.Optional }] },\n            { type: forms.NgForm, decorators: [{ type: core.Optional }] },\n            { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] },\n            { type: core$1.ErrorStateMatcher },\n            { type: forms.NgControl, decorators: [{ type: core.Optional }, { type: core.Self }] }\n        ]; };\n        MatChipList.propDecorators = {\n            errorStateMatcher: [{ type: core.Input }],\n            multiple: [{ type: core.Input }],\n            compareWith: [{ type: core.Input }],\n            value: [{ type: core.Input }],\n            required: [{ type: core.Input }],\n            placeholder: [{ type: core.Input }],\n            disabled: [{ type: core.Input }],\n            ariaOrientation: [{ type: core.Input, args: ['aria-orientation',] }],\n            selectable: [{ type: core.Input }],\n            tabIndex: [{ type: core.Input }],\n            change: [{ type: core.Output }],\n            valueChange: [{ type: core.Output }],\n            chips: [{ type: core.ContentChildren, args: [MatChip, {\n                            // We need to use `descendants: true`, because Ivy will no longer match\n                            // indirect descendants if it's left as false.\n                            descendants: true\n                        },] }]\n        };\n        return MatChipList;\n    }(_MatChipListMixinBase));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // Increasing integer for generating unique ids.\n    var nextUniqueId$1 = 0;\n    /**\n     * Directive that adds chip-specific behaviors to an input element inside `<mat-form-field>`.\n     * May be placed inside or outside of an `<mat-chip-list>`.\n     */\n    var MatChipInput = /** @class */ (function () {\n        function MatChipInput(_elementRef, _defaultOptions) {\n            this._elementRef = _elementRef;\n            this._defaultOptions = _defaultOptions;\n            /** Whether the control is focused. */\n            this.focused = false;\n            this._addOnBlur = false;\n            /**\n             * The list of key codes that will trigger a chipEnd event.\n             *\n             * Defaults to `[ENTER]`.\n             */\n            this.separatorKeyCodes = this._defaultOptions.separatorKeyCodes;\n            /** Emitted when a chip is to be added. */\n            this.chipEnd = new core.EventEmitter();\n            /** The input's placeholder text. */\n            this.placeholder = '';\n            /** Unique id for the input. */\n            this.id = \"mat-chip-list-input-\" + nextUniqueId$1++;\n            this._disabled = false;\n            this._inputElement = this._elementRef.nativeElement;\n        }\n        Object.defineProperty(MatChipInput.prototype, \"chipList\", {\n            /** Register input for chip list */\n            set: function (value) {\n                if (value) {\n                    this._chipList = value;\n                    this._chipList.registerInput(this);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipInput.prototype, \"addOnBlur\", {\n            /**\n             * Whether or not the chipEnd event will be emitted when the input is blurred.\n             */\n            get: function () { return this._addOnBlur; },\n            set: function (value) { this._addOnBlur = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipInput.prototype, \"disabled\", {\n            /** Whether the input is disabled. */\n            get: function () { return this._disabled || (this._chipList && this._chipList.disabled); },\n            set: function (value) { this._disabled = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipInput.prototype, \"empty\", {\n            /** Whether the input is empty. */\n            get: function () { return !this._inputElement.value; },\n            enumerable: true,\n            configurable: true\n        });\n        MatChipInput.prototype.ngOnChanges = function () {\n            this._chipList.stateChanges.next();\n        };\n        /** Utility method to make host definition/tests more clear. */\n        MatChipInput.prototype._keydown = function (event) {\n            // Allow the user's focus to escape when they're tabbing forward. Note that we don't\n            // want to do this when going backwards, because focus should go back to the first chip.\n            if (event && event.keyCode === keycodes.TAB && !keycodes.hasModifierKey(event, 'shiftKey')) {\n                this._chipList._allowFocusEscape();\n            }\n            this._emitChipEnd(event);\n        };\n        /** Checks to see if the blur should emit the (chipEnd) event. */\n        MatChipInput.prototype._blur = function () {\n            if (this.addOnBlur) {\n                this._emitChipEnd();\n            }\n            this.focused = false;\n            // Blur the chip list if it is not focused\n            if (!this._chipList.focused) {\n                this._chipList._blur();\n            }\n            this._chipList.stateChanges.next();\n        };\n        MatChipInput.prototype._focus = function () {\n            this.focused = true;\n            this._chipList.stateChanges.next();\n        };\n        /** Checks to see if the (chipEnd) event needs to be emitted. */\n        MatChipInput.prototype._emitChipEnd = function (event) {\n            if (!this._inputElement.value && !!event) {\n                this._chipList._keydown(event);\n            }\n            if (!event || this._isSeparatorKey(event)) {\n                this.chipEnd.emit({ input: this._inputElement, value: this._inputElement.value });\n                if (event) {\n                    event.preventDefault();\n                }\n            }\n        };\n        MatChipInput.prototype._onInput = function () {\n            // Let chip list know whenever the value changes.\n            this._chipList.stateChanges.next();\n        };\n        /** Focuses the input. */\n        MatChipInput.prototype.focus = function (options) {\n            this._inputElement.focus(options);\n        };\n        /** Checks whether a keycode is one of the configured separators. */\n        MatChipInput.prototype._isSeparatorKey = function (event) {\n            if (keycodes.hasModifierKey(event)) {\n                return false;\n            }\n            var separators = this.separatorKeyCodes;\n            var keyCode = event.keyCode;\n            return Array.isArray(separators) ? separators.indexOf(keyCode) > -1 : separators.has(keyCode);\n        };\n        MatChipInput.decorators = [\n            { type: core.Directive, args: [{\n                        selector: 'input[matChipInputFor]',\n                        exportAs: 'matChipInput, matChipInputFor',\n                        host: {\n                            'class': 'mat-chip-input mat-input-element',\n                            '(keydown)': '_keydown($event)',\n                            '(blur)': '_blur()',\n                            '(focus)': '_focus()',\n                            '(input)': '_onInput()',\n                            '[id]': 'id',\n                            '[attr.disabled]': 'disabled || null',\n                            '[attr.placeholder]': 'placeholder || null',\n                            '[attr.aria-invalid]': '_chipList && _chipList.ngControl ? _chipList.ngControl.invalid : null',\n                            '[attr.aria-required]': '_chipList && _chipList.required || null',\n                        }\n                    },] }\n        ];\n        /** @nocollapse */\n        MatChipInput.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: undefined, decorators: [{ type: core.Inject, args: [MAT_CHIPS_DEFAULT_OPTIONS,] }] }\n        ]; };\n        MatChipInput.propDecorators = {\n            chipList: [{ type: core.Input, args: ['matChipInputFor',] }],\n            addOnBlur: [{ type: core.Input, args: ['matChipInputAddOnBlur',] }],\n            separatorKeyCodes: [{ type: core.Input, args: ['matChipInputSeparatorKeyCodes',] }],\n            chipEnd: [{ type: core.Output, args: ['matChipInputTokenEnd',] }],\n            placeholder: [{ type: core.Input }],\n            id: [{ type: core.Input }],\n            disabled: [{ type: core.Input }]\n        };\n        return MatChipInput;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var CHIP_DECLARATIONS = [\n        MatChipList,\n        MatChip,\n        MatChipInput,\n        MatChipRemove,\n        MatChipAvatar,\n        MatChipTrailingIcon,\n    ];\n    var Éµ0 = {\n        separatorKeyCodes: [keycodes.ENTER]\n    };\n    var MatChipsModule = /** @class */ (function () {\n        function MatChipsModule() {\n        }\n        MatChipsModule.decorators = [\n            { type: core.NgModule, args: [{\n                        exports: CHIP_DECLARATIONS,\n                        declarations: CHIP_DECLARATIONS,\n                        providers: [\n                            core$1.ErrorStateMatcher,\n                            {\n                                provide: MAT_CHIPS_DEFAULT_OPTIONS,\n                                useValue: Éµ0\n                            }\n                        ]\n                    },] }\n        ];\n        return MatChipsModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.MAT_CHIPS_DEFAULT_OPTIONS = MAT_CHIPS_DEFAULT_OPTIONS;\n    exports.MatChip = MatChip;\n    exports.MatChipAvatar = MatChipAvatar;\n    exports.MatChipInput = MatChipInput;\n    exports.MatChipList = MatChipList;\n    exports.MatChipListChange = MatChipListChange;\n    exports.MatChipRemove = MatChipRemove;\n    exports.MatChipSelectionChange = MatChipSelectionChange;\n    exports.MatChipTrailingIcon = MatChipTrailingIcon;\n    exports.MatChipsModule = MatChipsModule;\n    exports.Éµ0 = Éµ0;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=material-chips.umd.js.map\n"]}