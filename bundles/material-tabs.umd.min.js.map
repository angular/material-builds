{"version":3,"sources":["src/material/material-tabs.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","material","tabs","cdk","observers","portal","common","core","a11y","platformBrowser","animations","tslib","rxjs","bidi","operators","coercion","scrolling","platform","keycodes","this","core$1","animations$1","_MAT_INK_BAR_POSITIONER","InjectionToken","providedIn","_MAT_INK_BAR_POSITIONER_FACTORY","element","left","offsetLeft","width","offsetWidth","MatInkBar","_elementRef","_ngZone","_inkBarPositioner","_animationMode","prototype","alignToElement","_this","show","requestAnimationFrame","runOutsideAngular","_setStyles","nativeElement","style","visibility","hide","positions","inkBar","decorators","type","Directive","args","selector","host","class","[class._mat-animation-noopable]","ctorParameters","ElementRef","NgZone","undefined","Inject","String","Optional","ANIMATION_MODULE_TYPE","MatTabContent","template","TemplateRef","MatTabLabel","_super","apply","arguments","__extends","CdkPortal","_MatTabMixinBase","mixinDisabled","MatTabBase","MAT_TAB_GROUP","MatTab","_viewContainerRef","_closestTabGroup","call","textLabel","_contentPortal","_stateChanges","Subject","position","origin","isActive","Object","defineProperty","get","_templateLabel","set","value","enumerable","configurable","ngOnChanges","changes","hasOwnProperty","next","ngOnDestroy","complete","ngOnInit","TemplatePortal","_explicitContent","_implicitContent","Component","moduleId","id","inputs","changeDetection","ChangeDetectionStrategy","Default","encapsulation","ViewEncapsulation","None","exportAs","ViewContainerRef","propDecorators","templateLabel","ContentChild","static","read","ViewChild","Input","ariaLabel","ariaLabelledby","matTabsAnimations","translateTab","trigger","state","transform","minHeight","transition","animate","MatTabBodyPortal","componentFactoryResolver","viewContainerRef","_host","_centeringSub","Subscription","EMPTY","_leavingSub","_beforeCentering","pipe","startWith","_isCenterPosition","_position","subscribe","isCentering","hasAttached","attach","_content","_afterLeavingCenter","detach","unsubscribe","ComponentFactoryResolver","MatTabBody","forwardRef","CdkPortalOutlet","_MatTabBodyBase","_dir","changeDetectorRef","_dirChangeSubscription","_translateTabComplete","_onCentering","EventEmitter","_onCentered","animationDuration","change","dir","_computePositionAnimationState","markForCheck","distinctUntilChanged","x","y","fromState","toState","event","emit","_positionIndex","_computePositionFromOrigin","_onTranslateTabStarted","clientHeight","_getLayoutDirection","Directionality","ChangeDetectorRef","Output","elementRef","styles","_portalHost","PortalHostDirective","nextId","MatTabChangeEvent","MAT_TABS_CONFIG","_MatTabGroupBase","_changeDetectorRef","defaultConfig","_tabs","QueryList","_tabsArray","_indexToSelect","_tabBodyWrapperHeight","_tabsSubscription","_tabLabelSubscription","_dynamicHeight","_selectedIndex","headerPosition","selectedIndexChange","focusChange","animationDone","selectedTabChange","_groupId","disablePagination","coerceBooleanProperty","coerceNumberProperty","_animationDuration","test","_backgroundColor","classList","remove","backgroundColor","add","ngAfterContentChecked","indexToSelect","_clampTabIndex","isFirstRun_1","_createChangeEvent","Promise","resolve","then","forEach","tab","index","ngAfterContentInit","_subscribeToAllTabChanges","_subscribeToTabLabels","toArray","i","length","_allTabs","reset","filter","notifyOnChanges","realignInkBar","_tabHeader","_alignInkBarToSelectedTab","_focusChanged","merge","__spread","map","Math","min","max","_getTabLabelId","_getTabContentId","_setTabBodyWrapperHeight","tabHeight","wrapper","_tabBodyWrapper","height","offsetHeight","_removeTabBodyWrapperHeight","_handleClick","tabHeader","disabled","selectedIndex","focusIndex","_getTabIndex","idx","dynamicHeight","mixinColor","mixinDisableRipple","MatTabGroupMixinBase","MatTabGroup","animationMode","providers","provide","useExisting","[class.mat-tab-group-dynamic-height]","[class.mat-tab-group-inverted-header]","ContentChildren","descendants","MatTabLabelWrapper","focus","getOffsetLeft","getOffsetWidth","[class.mat-tab-disabled]","[attr.aria-disabled]","MatTabLabelWrapperBase","passiveEventListenerOptions","normalizePassiveListenerOptions","passive","MatPaginatedTabHeader","_viewportRuler","_platform","_scrollDistance","_selectedIndexChanged","_destroyed","_showPaginationControls","_disableScrollAfter","_disableScrollBefore","_stopScrolling","selectFocusedIndex","indexFocused","fromEvent","takeUntil","_stopInterval","_keyManager","updateActiveItem","ngAfterViewInit","_previousPaginator","_handlePaginatorPress","_nextPaginator","dirChange","of","resize","realign","updatePagination","FocusKeyManager","_items","withHorizontalOrientation","withWrap","newFocusIndex","_setTabFocus","_tabLabelCount","_scrollToLabel","_checkScrollingControls","_scrollDistanceChanged","_updateTabScrollPosition","_handleKeydown","hasModifierKey","keyCode","HOME","setFirstItemActive","preventDefault","END","setLastItemActive","ENTER","SPACE","_itemSelected","onKeydown","_onContentChanges","textContent","_currentTextContent","run","_checkPaginationEnabled","activeItemIndex","_isValidIndex","setActiveItem","tabIndex","containerEl","_tabListContainer","scrollLeft","scrollWidth","scrollDistance","translateX","_tabList","round","TRIDENT","EDGE","_scrollTo","_scrollHeader","direction","_handlePaginatorClick","labelIndex","selectedLabel","labelBeforePos","labelAfterPos","viewLength","_a","beforeVisiblePos","afterVisiblePos","isEnabled","_getMaxScrollDistance","selectedItem","selectedLabelWrapper","_inkBar","timer","distance","maxScrollDistance","ViewportRuler","Platform","_MatTabHeaderBase","viewportRuler","ngZone","_disableRipple","disableRipple","MatTabHeader","outputs","[class.mat-tab-header-pagination-controls-enabled]","[class.mat-tab-header-rtl]","_MatTabNavBase","color","updateActiveLink","_element","items","active","MatTabNav","[class.mat-primary]","[class.mat-accent]","[class.mat-warn]","MatTabLink","_MatTabLinkBase","_tabNavBar","globalRippleOptions","_focusMonitor","_isActive","rippleConfig","parseInt","animation","enterDuration","exitDuration","monitor","stopMonitoring","MAT_RIPPLE_GLOBAL_OPTIONS","Attribute","FocusMonitor","mixinTabIndex","MatTabLinkMixinBase","tabNavBar","focusMonitor","_tabLinkRipple","RippleRenderer","setupTriggerEvents","_removeTriggerEvents","[attr.aria-current]","[attr.tabIndex]","[class.mat-tab-label-active]","MatTabsModule","NgModule","imports","CommonModule","MatCommonModule","PortalModule","MatRippleModule","ObserversModule","A11yModule","declarations","ɵangular_material_src_material_tabs_tabs_a","ɵangular_material_src_material_tabs_tabs_b"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/cdk/observers'), require('@angular/cdk/portal'), require('@angular/common'), require('@angular/core'), require('@angular/cdk/a11y'), require('@angular/material/core'), require('@angular/platform-browser/animations'), require('tslib'), require('rxjs'), require('@angular/cdk/bidi'), require('@angular/animations'), require('rxjs/operators'), require('@angular/cdk/coercion'), require('@angular/cdk/scrolling'), require('@angular/cdk/platform'), require('@angular/cdk/keycodes')) :\n    typeof define === 'function' && define.amd ? define('@angular/material/tabs', ['exports', '@angular/cdk/observers', '@angular/cdk/portal', '@angular/common', '@angular/core', '@angular/cdk/a11y', '@angular/material/core', '@angular/platform-browser/animations', 'tslib', 'rxjs', '@angular/cdk/bidi', '@angular/animations', 'rxjs/operators', '@angular/cdk/coercion', '@angular/cdk/scrolling', '@angular/cdk/platform', '@angular/cdk/keycodes'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.tabs = {}), global.ng.cdk.observers, global.ng.cdk.portal, global.ng.common, global.ng.core, global.ng.cdk.a11y, global.ng.material.core, global.ng.platformBrowser.animations, global.tslib, global.rxjs, global.ng.cdk.bidi, global.ng.animations, global.rxjs.operators, global.ng.cdk.coercion, global.ng.cdk.scrolling, global.ng.cdk.platform, global.ng.cdk.keycodes));\n}(this, function (exports, observers, portal, common, core, a11y, core$1, animations, tslib, rxjs, bidi, animations$1, operators, coercion, scrolling, platform, keycodes) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Injection token for the MatInkBar's Positioner. */\n    var _MAT_INK_BAR_POSITIONER = new core.InjectionToken('MatInkBarPositioner', {\n        providedIn: 'root',\n        factory: _MAT_INK_BAR_POSITIONER_FACTORY\n    });\n    /**\n     * The default positioner function for the MatInkBar.\n     * @docs-private\n     */\n    function _MAT_INK_BAR_POSITIONER_FACTORY() {\n        var method = function (element) { return ({\n            left: element ? (element.offsetLeft || 0) + 'px' : '0',\n            width: element ? (element.offsetWidth || 0) + 'px' : '0',\n        }); };\n        return method;\n    }\n    /**\n     * The ink-bar is used to display and animate the line underneath the current active tab label.\n     * @docs-private\n     */\n    var MatInkBar = /** @class */ (function () {\n        function MatInkBar(_elementRef, _ngZone, _inkBarPositioner, _animationMode) {\n            this._elementRef = _elementRef;\n            this._ngZone = _ngZone;\n            this._inkBarPositioner = _inkBarPositioner;\n            this._animationMode = _animationMode;\n        }\n        /**\n         * Calculates the styles from the provided element in order to align the ink-bar to that element.\n         * Shows the ink bar if previously set as hidden.\n         * @param element\n         */\n        MatInkBar.prototype.alignToElement = function (element) {\n            var _this = this;\n            this.show();\n            if (typeof requestAnimationFrame !== 'undefined') {\n                this._ngZone.runOutsideAngular(function () {\n                    requestAnimationFrame(function () { return _this._setStyles(element); });\n                });\n            }\n            else {\n                this._setStyles(element);\n            }\n        };\n        /** Shows the ink bar. */\n        MatInkBar.prototype.show = function () {\n            this._elementRef.nativeElement.style.visibility = 'visible';\n        };\n        /** Hides the ink bar. */\n        MatInkBar.prototype.hide = function () {\n            this._elementRef.nativeElement.style.visibility = 'hidden';\n        };\n        /**\n         * Sets the proper styles to the ink bar element.\n         * @param element\n         */\n        MatInkBar.prototype._setStyles = function (element) {\n            var positions = this._inkBarPositioner(element);\n            var inkBar = this._elementRef.nativeElement;\n            inkBar.style.left = positions.left;\n            inkBar.style.width = positions.width;\n        };\n        MatInkBar.decorators = [\n            { type: core.Directive, args: [{\n                        selector: 'mat-ink-bar',\n                        host: {\n                            'class': 'mat-ink-bar',\n                            '[class._mat-animation-noopable]': \"_animationMode === 'NoopAnimations'\",\n                        },\n                    },] }\n        ];\n        /** @nocollapse */\n        MatInkBar.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: core.NgZone },\n            { type: undefined, decorators: [{ type: core.Inject, args: [_MAT_INK_BAR_POSITIONER,] }] },\n            { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] }\n        ]; };\n        return MatInkBar;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Decorates the `ng-template` tags and reads out the template from it. */\n    var MatTabContent = /** @class */ (function () {\n        function MatTabContent(template) {\n            this.template = template;\n        }\n        MatTabContent.decorators = [\n            { type: core.Directive, args: [{ selector: '[matTabContent]' },] }\n        ];\n        /** @nocollapse */\n        MatTabContent.ctorParameters = function () { return [\n            { type: core.TemplateRef }\n        ]; };\n        return MatTabContent;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Used to flag tab labels for use with the portal directive */\n    var MatTabLabel = /** @class */ (function (_super) {\n        tslib.__extends(MatTabLabel, _super);\n        function MatTabLabel() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        MatTabLabel.decorators = [\n            { type: core.Directive, args: [{\n                        selector: '[mat-tab-label], [matTabLabel]',\n                    },] }\n        ];\n        return MatTabLabel;\n    }(portal.CdkPortal));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // Boilerplate for applying mixins to MatTab.\n    /** @docs-private */\n    var MatTabBase = /** @class */ (function () {\n        function MatTabBase() {\n        }\n        return MatTabBase;\n    }());\n    var _MatTabMixinBase = core$1.mixinDisabled(MatTabBase);\n    /**\n     * Used to provide a tab group to a tab without causing a circular dependency.\n     * @docs-private\n     */\n    var MAT_TAB_GROUP = new core.InjectionToken('MAT_TAB_GROUP');\n    var MatTab = /** @class */ (function (_super) {\n        tslib.__extends(MatTab, _super);\n        function MatTab(_viewContainerRef, \n        /**\n         * @deprecated `_closestTabGroup` parameter to become required.\n         * @breaking-change 10.0.0\n         */\n        _closestTabGroup) {\n            var _this = _super.call(this) || this;\n            _this._viewContainerRef = _viewContainerRef;\n            _this._closestTabGroup = _closestTabGroup;\n            /** Plain text label for the tab, used when there is no template label. */\n            _this.textLabel = '';\n            /** Portal that will be the hosted content of the tab */\n            _this._contentPortal = null;\n            /** Emits whenever the internal state of the tab changes. */\n            _this._stateChanges = new rxjs.Subject();\n            /**\n             * The relatively indexed position where 0 represents the center, negative is left, and positive\n             * represents the right.\n             */\n            _this.position = null;\n            /**\n             * The initial relatively index origin of the tab if it was created and selected after there\n             * was already a selected tab. Provides context of what position the tab should originate from.\n             */\n            _this.origin = null;\n            /**\n             * Whether the tab is currently active.\n             */\n            _this.isActive = false;\n            return _this;\n        }\n        Object.defineProperty(MatTab.prototype, \"templateLabel\", {\n            /** Content for the tab label given by `<ng-template mat-tab-label>`. */\n            get: function () { return this._templateLabel; },\n            set: function (value) {\n                // Only update the templateLabel via query if there is actually\n                // a MatTabLabel found. This works around an issue where a user may have\n                // manually set `templateLabel` during creation mode, which would then get clobbered\n                // by `undefined` when this query resolves.\n                if (value) {\n                    this._templateLabel = value;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatTab.prototype, \"content\", {\n            /** @docs-private */\n            get: function () {\n                return this._contentPortal;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MatTab.prototype.ngOnChanges = function (changes) {\n            if (changes.hasOwnProperty('textLabel') || changes.hasOwnProperty('disabled')) {\n                this._stateChanges.next();\n            }\n        };\n        MatTab.prototype.ngOnDestroy = function () {\n            this._stateChanges.complete();\n        };\n        MatTab.prototype.ngOnInit = function () {\n            this._contentPortal = new portal.TemplatePortal(this._explicitContent || this._implicitContent, this._viewContainerRef);\n        };\n        MatTab.decorators = [\n            { type: core.Component, args: [{\n                        moduleId: module.id,\n                        selector: 'mat-tab',\n                        template: \"<!-- Create a template for the content of the <mat-tab> so that we can grab a reference to this\\n    TemplateRef and use it in a Portal to render the tab content in the appropriate place in the\\n    tab-group. -->\\n<ng-template><ng-content></ng-content></ng-template>\\n\",\n                        inputs: ['disabled'],\n                        // tslint:disable-next-line:validate-decorators\n                        changeDetection: core.ChangeDetectionStrategy.Default,\n                        encapsulation: core.ViewEncapsulation.None,\n                        exportAs: 'matTab'\n                    }] }\n        ];\n        /** @nocollapse */\n        MatTab.ctorParameters = function () { return [\n            { type: core.ViewContainerRef },\n            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_TAB_GROUP,] }] }\n        ]; };\n        MatTab.propDecorators = {\n            templateLabel: [{ type: core.ContentChild, args: [MatTabLabel, { static: false },] }],\n            _explicitContent: [{ type: core.ContentChild, args: [MatTabContent, { read: core.TemplateRef, static: true },] }],\n            _implicitContent: [{ type: core.ViewChild, args: [core.TemplateRef, { static: true },] }],\n            textLabel: [{ type: core.Input, args: ['label',] }],\n            ariaLabel: [{ type: core.Input, args: ['aria-label',] }],\n            ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }]\n        };\n        return MatTab;\n    }(_MatTabMixinBase));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Animations used by the Material tabs.\n     * @docs-private\n     */\n    var matTabsAnimations = {\n        /** Animation translates a tab along the X axis. */\n        translateTab: animations$1.trigger('translateTab', [\n            // Note: transitions to `none` instead of 0, because some browsers might blur the content.\n            animations$1.state('center, void, left-origin-center, right-origin-center', animations$1.style({ transform: 'none' })),\n            // If the tab is either on the left or right, we additionally add a `min-height` of 1px\n            // in order to ensure that the element has a height before its state changes. This is\n            // necessary because Chrome does seem to skip the transition in RTL mode if the element does\n            // not have a static height and is not rendered. See related issue: #9465\n            animations$1.state('left', animations$1.style({ transform: 'translate3d(-100%, 0, 0)', minHeight: '1px' })),\n            animations$1.state('right', animations$1.style({ transform: 'translate3d(100%, 0, 0)', minHeight: '1px' })),\n            animations$1.transition('* => left, * => right, left => center, right => center', animations$1.animate('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')),\n            animations$1.transition('void => left-origin-center', [\n                animations$1.style({ transform: 'translate3d(-100%, 0, 0)' }),\n                animations$1.animate('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')\n            ]),\n            animations$1.transition('void => right-origin-center', [\n                animations$1.style({ transform: 'translate3d(100%, 0, 0)' }),\n                animations$1.animate('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')\n            ])\n        ])\n    };\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * The portal host directive for the contents of the tab.\n     * @docs-private\n     */\n    var MatTabBodyPortal = /** @class */ (function (_super) {\n        tslib.__extends(MatTabBodyPortal, _super);\n        function MatTabBodyPortal(componentFactoryResolver, viewContainerRef, _host) {\n            var _this = _super.call(this, componentFactoryResolver, viewContainerRef) || this;\n            _this._host = _host;\n            /** Subscription to events for when the tab body begins centering. */\n            _this._centeringSub = rxjs.Subscription.EMPTY;\n            /** Subscription to events for when the tab body finishes leaving from center position. */\n            _this._leavingSub = rxjs.Subscription.EMPTY;\n            return _this;\n        }\n        /** Set initial visibility or set up subscription for changing visibility. */\n        MatTabBodyPortal.prototype.ngOnInit = function () {\n            var _this = this;\n            _super.prototype.ngOnInit.call(this);\n            this._centeringSub = this._host._beforeCentering\n                .pipe(operators.startWith(this._host._isCenterPosition(this._host._position)))\n                .subscribe(function (isCentering) {\n                if (isCentering && !_this.hasAttached()) {\n                    _this.attach(_this._host._content);\n                }\n            });\n            this._leavingSub = this._host._afterLeavingCenter.subscribe(function () {\n                _this.detach();\n            });\n        };\n        /** Clean up centering subscription. */\n        MatTabBodyPortal.prototype.ngOnDestroy = function () {\n            _super.prototype.ngOnDestroy.call(this);\n            this._centeringSub.unsubscribe();\n            this._leavingSub.unsubscribe();\n        };\n        MatTabBodyPortal.decorators = [\n            { type: core.Directive, args: [{\n                        selector: '[matTabBodyHost]'\n                    },] }\n        ];\n        /** @nocollapse */\n        MatTabBodyPortal.ctorParameters = function () { return [\n            { type: core.ComponentFactoryResolver },\n            { type: core.ViewContainerRef },\n            { type: MatTabBody, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return MatTabBody; }),] }] }\n        ]; };\n        return MatTabBodyPortal;\n    }(portal.CdkPortalOutlet));\n    /**\n     * Base class with all of the `MatTabBody` functionality.\n     * @docs-private\n     */\n    var _MatTabBodyBase = /** @class */ (function () {\n        function _MatTabBodyBase(_elementRef, _dir, changeDetectorRef) {\n            var _this = this;\n            this._elementRef = _elementRef;\n            this._dir = _dir;\n            /** Subscription to the directionality change observable. */\n            this._dirChangeSubscription = rxjs.Subscription.EMPTY;\n            /** Emits when an animation on the tab is complete. */\n            this._translateTabComplete = new rxjs.Subject();\n            /** Event emitted when the tab begins to animate towards the center as the active tab. */\n            this._onCentering = new core.EventEmitter();\n            /** Event emitted before the centering of the tab begins. */\n            this._beforeCentering = new core.EventEmitter();\n            /** Event emitted before the centering of the tab begins. */\n            this._afterLeavingCenter = new core.EventEmitter();\n            /** Event emitted when the tab completes its animation towards the center. */\n            this._onCentered = new core.EventEmitter(true);\n            // Note that the default value will always be overwritten by `MatTabBody`, but we need one\n            // anyway to prevent the animations module from throwing an error if the body is used on its own.\n            /** Duration for the tab's animation. */\n            this.animationDuration = '500ms';\n            if (_dir) {\n                this._dirChangeSubscription = _dir.change.subscribe(function (dir) {\n                    _this._computePositionAnimationState(dir);\n                    changeDetectorRef.markForCheck();\n                });\n            }\n            // Ensure that we get unique animation events, because the `.done` callback can get\n            // invoked twice in some browsers. See https://github.com/angular/angular/issues/24084.\n            this._translateTabComplete.pipe(operators.distinctUntilChanged(function (x, y) {\n                return x.fromState === y.fromState && x.toState === y.toState;\n            })).subscribe(function (event) {\n                // If the transition to the center is complete, emit an event.\n                if (_this._isCenterPosition(event.toState) && _this._isCenterPosition(_this._position)) {\n                    _this._onCentered.emit();\n                }\n                if (_this._isCenterPosition(event.fromState) && !_this._isCenterPosition(_this._position)) {\n                    _this._afterLeavingCenter.emit();\n                }\n            });\n        }\n        Object.defineProperty(_MatTabBodyBase.prototype, \"position\", {\n            /** The shifted index position of the tab body, where zero represents the active center tab. */\n            set: function (position) {\n                this._positionIndex = position;\n                this._computePositionAnimationState();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * After initialized, check if the content is centered and has an origin. If so, set the\n         * special position states that transition the tab from the left or right before centering.\n         */\n        _MatTabBodyBase.prototype.ngOnInit = function () {\n            if (this._position == 'center' && this.origin != null) {\n                this._position = this._computePositionFromOrigin(this.origin);\n            }\n        };\n        _MatTabBodyBase.prototype.ngOnDestroy = function () {\n            this._dirChangeSubscription.unsubscribe();\n            this._translateTabComplete.complete();\n        };\n        _MatTabBodyBase.prototype._onTranslateTabStarted = function (event) {\n            var isCentering = this._isCenterPosition(event.toState);\n            this._beforeCentering.emit(isCentering);\n            if (isCentering) {\n                this._onCentering.emit(this._elementRef.nativeElement.clientHeight);\n            }\n        };\n        /** The text direction of the containing app. */\n        _MatTabBodyBase.prototype._getLayoutDirection = function () {\n            return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n        };\n        /** Whether the provided position state is considered center, regardless of origin. */\n        _MatTabBodyBase.prototype._isCenterPosition = function (position) {\n            return position == 'center' ||\n                position == 'left-origin-center' ||\n                position == 'right-origin-center';\n        };\n        /** Computes the position state that will be used for the tab-body animation trigger. */\n        _MatTabBodyBase.prototype._computePositionAnimationState = function (dir) {\n            if (dir === void 0) { dir = this._getLayoutDirection(); }\n            if (this._positionIndex < 0) {\n                this._position = dir == 'ltr' ? 'left' : 'right';\n            }\n            else if (this._positionIndex > 0) {\n                this._position = dir == 'ltr' ? 'right' : 'left';\n            }\n            else {\n                this._position = 'center';\n            }\n        };\n        /**\n         * Computes the position state based on the specified origin position. This is used if the\n         * tab is becoming visible immediately after creation.\n         */\n        _MatTabBodyBase.prototype._computePositionFromOrigin = function (origin) {\n            var dir = this._getLayoutDirection();\n            if ((dir == 'ltr' && origin <= 0) || (dir == 'rtl' && origin > 0)) {\n                return 'left-origin-center';\n            }\n            return 'right-origin-center';\n        };\n        _MatTabBodyBase.decorators = [\n            { type: core.Directive, args: [{\n                        // TODO(crisbeto): this selector can be removed when we update to Angular 9.0.\n                        selector: 'do-not-use-abstract-mat-tab-body-base'\n                    },] }\n        ];\n        /** @nocollapse */\n        _MatTabBodyBase.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: bidi.Directionality, decorators: [{ type: core.Optional }] },\n            { type: core.ChangeDetectorRef }\n        ]; };\n        _MatTabBodyBase.propDecorators = {\n            _onCentering: [{ type: core.Output }],\n            _beforeCentering: [{ type: core.Output }],\n            _afterLeavingCenter: [{ type: core.Output }],\n            _onCentered: [{ type: core.Output }],\n            _content: [{ type: core.Input, args: ['content',] }],\n            origin: [{ type: core.Input }],\n            animationDuration: [{ type: core.Input }],\n            position: [{ type: core.Input }]\n        };\n        return _MatTabBodyBase;\n    }());\n    /**\n     * Wrapper for the contents of a tab.\n     * @docs-private\n     */\n    var MatTabBody = /** @class */ (function (_super) {\n        tslib.__extends(MatTabBody, _super);\n        function MatTabBody(elementRef, dir, changeDetectorRef) {\n            return _super.call(this, elementRef, dir, changeDetectorRef) || this;\n        }\n        MatTabBody.decorators = [\n            { type: core.Component, args: [{\n                        moduleId: module.id,\n                        selector: 'mat-tab-body',\n                        template: \"<div class=\\\"mat-tab-body-content\\\" #content\\n     [@translateTab]=\\\"{\\n        value: _position,\\n        params: {animationDuration: animationDuration}\\n     }\\\"\\n     (@translateTab.start)=\\\"_onTranslateTabStarted($event)\\\"\\n     (@translateTab.done)=\\\"_translateTabComplete.next($event)\\\">\\n  <ng-template matTabBodyHost></ng-template>\\n</div>\\n\",\n                        encapsulation: core.ViewEncapsulation.None,\n                        // tslint:disable-next-line:validate-decorators\n                        changeDetection: core.ChangeDetectionStrategy.Default,\n                        animations: [matTabsAnimations.translateTab],\n                        host: {\n                            'class': 'mat-tab-body',\n                        },\n                        styles: [\".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}\\n\"]\n                    }] }\n        ];\n        /** @nocollapse */\n        MatTabBody.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: bidi.Directionality, decorators: [{ type: core.Optional }] },\n            { type: core.ChangeDetectorRef }\n        ]; };\n        MatTabBody.propDecorators = {\n            _portalHost: [{ type: core.ViewChild, args: [portal.PortalHostDirective, { static: false },] }]\n        };\n        return MatTabBody;\n    }(_MatTabBodyBase));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Used to generate unique ID's for each tab component */\n    var nextId = 0;\n    /** A simple change event emitted on focus or selection changes. */\n    var MatTabChangeEvent = /** @class */ (function () {\n        function MatTabChangeEvent() {\n        }\n        return MatTabChangeEvent;\n    }());\n    /** Injection token that can be used to provide the default options the tabs module. */\n    var MAT_TABS_CONFIG = new core.InjectionToken('MAT_TABS_CONFIG');\n    // Boilerplate for applying mixins to MatTabGroup.\n    /** @docs-private */\n    var MatTabGroupMixinBase = /** @class */ (function () {\n        function MatTabGroupMixinBase(_elementRef) {\n            this._elementRef = _elementRef;\n        }\n        return MatTabGroupMixinBase;\n    }());\n    var _MatTabGroupMixinBase = core$1.mixinColor(core$1.mixinDisableRipple(MatTabGroupMixinBase), 'primary');\n    /**\n     * Base class with all of the `MatTabGroupBase` functionality.\n     * @docs-private\n     */\n    var _MatTabGroupBase = /** @class */ (function (_super) {\n        tslib.__extends(_MatTabGroupBase, _super);\n        function _MatTabGroupBase(elementRef, _changeDetectorRef, defaultConfig, _animationMode) {\n            var _this = _super.call(this, elementRef) || this;\n            _this._changeDetectorRef = _changeDetectorRef;\n            _this._animationMode = _animationMode;\n            /** All of the tabs that belong to the group. */\n            _this._tabs = new core.QueryList();\n            /**\n             * We need to store the tabs in an Iterable due to strict template type checking with *ngFor and\n             * https://github.com/angular/angular/issues/29842.\n             */\n            _this._tabsArray = [];\n            /** The tab index that should be selected after the content has been checked. */\n            _this._indexToSelect = 0;\n            /** Snapshot of the height of the tab body wrapper before another tab is activated. */\n            _this._tabBodyWrapperHeight = 0;\n            /** Subscription to tabs being added/removed. */\n            _this._tabsSubscription = rxjs.Subscription.EMPTY;\n            /** Subscription to changes in the tab labels. */\n            _this._tabLabelSubscription = rxjs.Subscription.EMPTY;\n            _this._dynamicHeight = false;\n            _this._selectedIndex = null;\n            /** Position of the tab header. */\n            _this.headerPosition = 'above';\n            /** Output to enable support for two-way binding on `[(selectedIndex)]` */\n            _this.selectedIndexChange = new core.EventEmitter();\n            /** Event emitted when focus has changed within a tab group. */\n            _this.focusChange = new core.EventEmitter();\n            /** Event emitted when the body animation has completed */\n            _this.animationDone = new core.EventEmitter();\n            /** Event emitted when the tab selection has changed. */\n            _this.selectedTabChange = new core.EventEmitter(true);\n            _this._groupId = nextId++;\n            _this.animationDuration = defaultConfig && defaultConfig.animationDuration ?\n                defaultConfig.animationDuration : '500ms';\n            _this.disablePagination = defaultConfig && defaultConfig.disablePagination != null ?\n                defaultConfig.disablePagination : false;\n            return _this;\n        }\n        Object.defineProperty(_MatTabGroupBase.prototype, \"dynamicHeight\", {\n            /** Whether the tab group should grow to the size of the active tab. */\n            get: function () { return this._dynamicHeight; },\n            set: function (value) { this._dynamicHeight = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(_MatTabGroupBase.prototype, \"selectedIndex\", {\n            /** The index of the active tab. */\n            get: function () { return this._selectedIndex; },\n            set: function (value) {\n                this._indexToSelect = coercion.coerceNumberProperty(value, null);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(_MatTabGroupBase.prototype, \"animationDuration\", {\n            /** Duration for the tab animation. Will be normalized to milliseconds if no units are set. */\n            get: function () { return this._animationDuration; },\n            set: function (value) {\n                this._animationDuration = /^\\d+$/.test(value) ? value + 'ms' : value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(_MatTabGroupBase.prototype, \"backgroundColor\", {\n            /** Background color of the tab group. */\n            get: function () { return this._backgroundColor; },\n            set: function (value) {\n                var nativeElement = this._elementRef.nativeElement;\n                nativeElement.classList.remove(\"mat-background-\" + this.backgroundColor);\n                if (value) {\n                    nativeElement.classList.add(\"mat-background-\" + value);\n                }\n                this._backgroundColor = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * After the content is checked, this component knows what tabs have been defined\n         * and what the selected index should be. This is where we can know exactly what position\n         * each tab should be in according to the new selected index, and additionally we know how\n         * a new selected tab should transition in (from the left or right).\n         */\n        _MatTabGroupBase.prototype.ngAfterContentChecked = function () {\n            var _this = this;\n            // Don't clamp the `indexToSelect` immediately in the setter because it can happen that\n            // the amount of tabs changes before the actual change detection runs.\n            var indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);\n            // If there is a change in selected index, emit a change event. Should not trigger if\n            // the selected index has not yet been initialized.\n            if (this._selectedIndex != indexToSelect) {\n                var isFirstRun_1 = this._selectedIndex == null;\n                if (!isFirstRun_1) {\n                    this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));\n                }\n                // Changing these values after change detection has run\n                // since the checked content may contain references to them.\n                Promise.resolve().then(function () {\n                    _this._tabs.forEach(function (tab, index) { return tab.isActive = index === indexToSelect; });\n                    if (!isFirstRun_1) {\n                        _this.selectedIndexChange.emit(indexToSelect);\n                    }\n                });\n            }\n            // Setup the position for each tab and optionally setup an origin on the next selected tab.\n            this._tabs.forEach(function (tab, index) {\n                tab.position = index - indexToSelect;\n                // If there is already a selected tab, then set up an origin for the next selected tab\n                // if it doesn't have one already.\n                if (_this._selectedIndex != null && tab.position == 0 && !tab.origin) {\n                    tab.origin = indexToSelect - _this._selectedIndex;\n                }\n            });\n            if (this._selectedIndex !== indexToSelect) {\n                this._selectedIndex = indexToSelect;\n                this._changeDetectorRef.markForCheck();\n            }\n        };\n        _MatTabGroupBase.prototype.ngAfterContentInit = function () {\n            var _this = this;\n            this._subscribeToAllTabChanges();\n            this._subscribeToTabLabels();\n            this._tabsArray = this._tabs.toArray();\n            // Subscribe to changes in the amount of tabs, in order to be\n            // able to re-render the content as new tabs are added or removed.\n            this._tabsSubscription = this._tabs.changes.subscribe(function () {\n                var indexToSelect = _this._clampTabIndex(_this._indexToSelect);\n                _this._tabsArray = _this._tabs.toArray();\n                // Maintain the previously-selected tab if a new tab is added or removed and there is no\n                // explicit change that selects a different tab.\n                if (indexToSelect === _this._selectedIndex) {\n                    for (var i = 0; i < _this._tabsArray.length; i++) {\n                        if (_this._tabsArray[i].isActive) {\n                            // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed\n                            // event, otherwise the consumer may end up in an infinite loop in some edge cases like\n                            // adding a tab within the `selectedIndexChange` event.\n                            _this._indexToSelect = _this._selectedIndex = i;\n                            break;\n                        }\n                    }\n                }\n                _this._changeDetectorRef.markForCheck();\n            });\n        };\n        /** Listens to changes in all of the tabs. */\n        _MatTabGroupBase.prototype._subscribeToAllTabChanges = function () {\n            var _this = this;\n            // Since we use a query with `descendants: true` to pick up the tabs, we may end up catching\n            // some that are inside of nested tab groups. We filter them out manually by checking that\n            // the closest group to the tab is the current one.\n            this._allTabs.changes\n                .pipe(operators.startWith(this._allTabs))\n                .subscribe(function (tabs) {\n                _this._tabs.reset(tabs.filter(function (tab) {\n                    // @breaking-change 10.0.0 Remove null check for `_closestTabGroup`\n                    // once it becomes a required parameter in MatTab.\n                    return !tab._closestTabGroup || tab._closestTabGroup === _this;\n                }));\n                _this._tabs.notifyOnChanges();\n            });\n        };\n        _MatTabGroupBase.prototype.ngOnDestroy = function () {\n            this._tabsSubscription.unsubscribe();\n            this._tabLabelSubscription.unsubscribe();\n        };\n        /** Re-aligns the ink bar to the selected tab element. */\n        _MatTabGroupBase.prototype.realignInkBar = function () {\n            if (this._tabHeader) {\n                this._tabHeader._alignInkBarToSelectedTab();\n            }\n        };\n        _MatTabGroupBase.prototype._focusChanged = function (index) {\n            this.focusChange.emit(this._createChangeEvent(index));\n        };\n        _MatTabGroupBase.prototype._createChangeEvent = function (index) {\n            var event = new MatTabChangeEvent;\n            event.index = index;\n            if (this._tabs && this._tabs.length) {\n                event.tab = this._tabs.toArray()[index];\n            }\n            return event;\n        };\n        /**\n         * Subscribes to changes in the tab labels. This is needed, because the @Input for the label is\n         * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the\n         * binding to be updated, we need to subscribe to changes in it and trigger change detection\n         * manually.\n         */\n        _MatTabGroupBase.prototype._subscribeToTabLabels = function () {\n            var _this = this;\n            if (this._tabLabelSubscription) {\n                this._tabLabelSubscription.unsubscribe();\n            }\n            this._tabLabelSubscription = rxjs.merge.apply(void 0, tslib.__spread(this._tabs.map(function (tab) { return tab._stateChanges; }))).subscribe(function () { return _this._changeDetectorRef.markForCheck(); });\n        };\n        /** Clamps the given index to the bounds of 0 and the tabs length. */\n        _MatTabGroupBase.prototype._clampTabIndex = function (index) {\n            // Note the `|| 0`, which ensures that values like NaN can't get through\n            // and which would otherwise throw the component into an infinite loop\n            // (since Math.max(NaN, 0) === NaN).\n            return Math.min(this._tabs.length - 1, Math.max(index || 0, 0));\n        };\n        /** Returns a unique id for each tab label element */\n        _MatTabGroupBase.prototype._getTabLabelId = function (i) {\n            return \"mat-tab-label-\" + this._groupId + \"-\" + i;\n        };\n        /** Returns a unique id for each tab content element */\n        _MatTabGroupBase.prototype._getTabContentId = function (i) {\n            return \"mat-tab-content-\" + this._groupId + \"-\" + i;\n        };\n        /**\n         * Sets the height of the body wrapper to the height of the activating tab if dynamic\n         * height property is true.\n         */\n        _MatTabGroupBase.prototype._setTabBodyWrapperHeight = function (tabHeight) {\n            if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {\n                return;\n            }\n            var wrapper = this._tabBodyWrapper.nativeElement;\n            wrapper.style.height = this._tabBodyWrapperHeight + 'px';\n            // This conditional forces the browser to paint the height so that\n            // the animation to the new height can have an origin.\n            if (this._tabBodyWrapper.nativeElement.offsetHeight) {\n                wrapper.style.height = tabHeight + 'px';\n            }\n        };\n        /** Removes the height of the tab body wrapper. */\n        _MatTabGroupBase.prototype._removeTabBodyWrapperHeight = function () {\n            var wrapper = this._tabBodyWrapper.nativeElement;\n            this._tabBodyWrapperHeight = wrapper.clientHeight;\n            wrapper.style.height = '';\n            this.animationDone.emit();\n        };\n        /** Handle click events, setting new selected index if appropriate. */\n        _MatTabGroupBase.prototype._handleClick = function (tab, tabHeader, index) {\n            if (!tab.disabled) {\n                this.selectedIndex = tabHeader.focusIndex = index;\n            }\n        };\n        /** Retrieves the tabindex for the tab. */\n        _MatTabGroupBase.prototype._getTabIndex = function (tab, idx) {\n            if (tab.disabled) {\n                return null;\n            }\n            return this.selectedIndex === idx ? 0 : -1;\n        };\n        _MatTabGroupBase.decorators = [\n            { type: core.Directive, args: [{\n                        // TODO(crisbeto): this selector can be removed when we update to Angular 9.0.\n                        selector: 'do-not-use-abstract-mat-tab-group-base'\n                    },] }\n        ];\n        /** @nocollapse */\n        _MatTabGroupBase.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: core.ChangeDetectorRef },\n            { type: undefined, decorators: [{ type: core.Inject, args: [MAT_TABS_CONFIG,] }, { type: core.Optional }] },\n            { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] }\n        ]; };\n        _MatTabGroupBase.propDecorators = {\n            dynamicHeight: [{ type: core.Input }],\n            selectedIndex: [{ type: core.Input }],\n            headerPosition: [{ type: core.Input }],\n            animationDuration: [{ type: core.Input }],\n            disablePagination: [{ type: core.Input }],\n            backgroundColor: [{ type: core.Input }],\n            selectedIndexChange: [{ type: core.Output }],\n            focusChange: [{ type: core.Output }],\n            animationDone: [{ type: core.Output }],\n            selectedTabChange: [{ type: core.Output }]\n        };\n        return _MatTabGroupBase;\n    }(_MatTabGroupMixinBase));\n    /**\n     * Material design tab-group component. Supports basic tab pairs (label + content) and includes\n     * animated ink-bar, keyboard navigation, and screen reader.\n     * See: https://material.io/design/components/tabs.html\n     */\n    var MatTabGroup = /** @class */ (function (_super) {\n        tslib.__extends(MatTabGroup, _super);\n        function MatTabGroup(elementRef, changeDetectorRef, defaultConfig, animationMode) {\n            return _super.call(this, elementRef, changeDetectorRef, defaultConfig, animationMode) || this;\n        }\n        MatTabGroup.decorators = [\n            { type: core.Component, args: [{\n                        moduleId: module.id,\n                        selector: 'mat-tab-group',\n                        exportAs: 'matTabGroup',\n                        template: \"<mat-tab-header #tabHeader\\n               [selectedIndex]=\\\"selectedIndex || 0\\\"\\n               [disableRipple]=\\\"disableRipple\\\"\\n               [disablePagination]=\\\"disablePagination\\\"\\n               (indexFocused)=\\\"_focusChanged($event)\\\"\\n               (selectFocusedIndex)=\\\"selectedIndex = $event\\\">\\n  <div class=\\\"mat-tab-label\\\" role=\\\"tab\\\" matTabLabelWrapper mat-ripple cdkMonitorElementFocus\\n       *ngFor=\\\"let tab of _tabsArray; let i = index\\\"\\n       [id]=\\\"_getTabLabelId(i)\\\"\\n       [attr.tabIndex]=\\\"_getTabIndex(tab, i)\\\"\\n       [attr.aria-posinset]=\\\"i + 1\\\"\\n       [attr.aria-setsize]=\\\"_tabs.length\\\"\\n       [attr.aria-controls]=\\\"_getTabContentId(i)\\\"\\n       [attr.aria-selected]=\\\"selectedIndex == i\\\"\\n       [attr.aria-label]=\\\"tab.ariaLabel || null\\\"\\n       [attr.aria-labelledby]=\\\"(!tab.ariaLabel && tab.ariaLabelledby) ? tab.ariaLabelledby : null\\\"\\n       [class.mat-tab-label-active]=\\\"selectedIndex == i\\\"\\n       [disabled]=\\\"tab.disabled\\\"\\n       [matRippleDisabled]=\\\"tab.disabled || disableRipple\\\"\\n       (click)=\\\"_handleClick(tab, tabHeader, i)\\\">\\n\\n\\n    <div class=\\\"mat-tab-label-content\\\">\\n      <!-- If there is a label template, use it. -->\\n      <ng-template [ngIf]=\\\"tab.templateLabel\\\">\\n        <ng-template [cdkPortalOutlet]=\\\"tab.templateLabel\\\"></ng-template>\\n      </ng-template>\\n\\n      <!-- If there is not a label template, fall back to the text label. -->\\n      <ng-template [ngIf]=\\\"!tab.templateLabel\\\">{{tab.textLabel}}</ng-template>\\n    </div>\\n  </div>\\n</mat-tab-header>\\n\\n<div\\n  class=\\\"mat-tab-body-wrapper\\\"\\n  [class._mat-animation-noopable]=\\\"_animationMode === 'NoopAnimations'\\\"\\n  #tabBodyWrapper>\\n  <mat-tab-body role=\\\"tabpanel\\\"\\n               *ngFor=\\\"let tab of _tabsArray; let i = index\\\"\\n               [id]=\\\"_getTabContentId(i)\\\"\\n               [attr.aria-labelledby]=\\\"_getTabLabelId(i)\\\"\\n               [class.mat-tab-body-active]=\\\"selectedIndex == i\\\"\\n               [content]=\\\"tab.content!\\\"\\n               [position]=\\\"tab.position!\\\"\\n               [origin]=\\\"tab.origin\\\"\\n               [animationDuration]=\\\"animationDuration\\\"\\n               (_onCentered)=\\\"_removeTabBodyWrapperHeight()\\\"\\n               (_onCentering)=\\\"_setTabBodyWrapperHeight($event)\\\">\\n  </mat-tab-body>\\n</div>\\n\",\n                        encapsulation: core.ViewEncapsulation.None,\n                        // tslint:disable-next-line:validate-decorators\n                        changeDetection: core.ChangeDetectionStrategy.Default,\n                        inputs: ['color', 'disableRipple'],\n                        providers: [{\n                                provide: MAT_TAB_GROUP,\n                                useExisting: MatTabGroup\n                            }],\n                        host: {\n                            'class': 'mat-tab-group',\n                            '[class.mat-tab-group-dynamic-height]': 'dynamicHeight',\n                            '[class.mat-tab-group-inverted-header]': 'headerPosition === \"below\"',\n                        },\n                        styles: [\".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media(-ms-high-contrast: active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media(-ms-high-contrast: active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media(-ms-high-contrast: active){.mat-tab-label{opacity:1}}@media(max-width: 599px){.mat-tab-label{padding:0 12px}}@media(max-width: 959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height 500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-tab-body-wrapper{transition:none;animation:none}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\\n\"]\n                    }] }\n        ];\n        /** @nocollapse */\n        MatTabGroup.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: core.ChangeDetectorRef },\n            { type: undefined, decorators: [{ type: core.Inject, args: [MAT_TABS_CONFIG,] }, { type: core.Optional }] },\n            { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] }\n        ]; };\n        MatTabGroup.propDecorators = {\n            _allTabs: [{ type: core.ContentChildren, args: [MatTab, { descendants: true },] }],\n            _tabBodyWrapper: [{ type: core.ViewChild, args: ['tabBodyWrapper', { static: false },] }],\n            _tabHeader: [{ type: core.ViewChild, args: ['tabHeader', { static: false },] }]\n        };\n        return MatTabGroup;\n    }(_MatTabGroupBase));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // Boilerplate for applying mixins to MatTabLabelWrapper.\n    /** @docs-private */\n    var MatTabLabelWrapperBase = /** @class */ (function () {\n        function MatTabLabelWrapperBase() {\n        }\n        return MatTabLabelWrapperBase;\n    }());\n    var _MatTabLabelWrapperMixinBase = core$1.mixinDisabled(MatTabLabelWrapperBase);\n    /**\n     * Used in the `mat-tab-group` view to display tab labels.\n     * @docs-private\n     */\n    var MatTabLabelWrapper = /** @class */ (function (_super) {\n        tslib.__extends(MatTabLabelWrapper, _super);\n        function MatTabLabelWrapper(elementRef) {\n            var _this = _super.call(this) || this;\n            _this.elementRef = elementRef;\n            return _this;\n        }\n        /** Sets focus on the wrapper element */\n        MatTabLabelWrapper.prototype.focus = function () {\n            this.elementRef.nativeElement.focus();\n        };\n        MatTabLabelWrapper.prototype.getOffsetLeft = function () {\n            return this.elementRef.nativeElement.offsetLeft;\n        };\n        MatTabLabelWrapper.prototype.getOffsetWidth = function () {\n            return this.elementRef.nativeElement.offsetWidth;\n        };\n        MatTabLabelWrapper.decorators = [\n            { type: core.Directive, args: [{\n                        selector: '[matTabLabelWrapper]',\n                        inputs: ['disabled'],\n                        host: {\n                            '[class.mat-tab-disabled]': 'disabled',\n                            '[attr.aria-disabled]': '!!disabled',\n                        }\n                    },] }\n        ];\n        /** @nocollapse */\n        MatTabLabelWrapper.ctorParameters = function () { return [\n            { type: core.ElementRef }\n        ]; };\n        return MatTabLabelWrapper;\n    }(_MatTabLabelWrapperMixinBase));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Config used to bind passive event listeners */\n    var passiveEventListenerOptions = platform.normalizePassiveListenerOptions({ passive: true });\n    /**\n     * The distance in pixels that will be overshot when scrolling a tab label into view. This helps\n     * provide a small affordance to the label next to it.\n     */\n    var EXAGGERATED_OVERSCROLL = 60;\n    /**\n     * Amount of milliseconds to wait before starting to scroll the header automatically.\n     * Set a little conservatively in order to handle fake events dispatched on touch devices.\n     */\n    var HEADER_SCROLL_DELAY = 650;\n    /**\n     * Interval in milliseconds at which to scroll the header\n     * while the user is holding their pointer.\n     */\n    var HEADER_SCROLL_INTERVAL = 100;\n    /**\n     * Base class for a tab header that supported pagination.\n     * @docs-private\n     */\n    var MatPaginatedTabHeader = /** @class */ (function () {\n        function MatPaginatedTabHeader(_elementRef, _changeDetectorRef, _viewportRuler, _dir, _ngZone, \n        /**\n         * @deprecated @breaking-change 9.0.0 `_platform` and `_animationMode`\n         * parameters to become required.\n         */\n        _platform, _animationMode) {\n            var _this = this;\n            this._elementRef = _elementRef;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._viewportRuler = _viewportRuler;\n            this._dir = _dir;\n            this._ngZone = _ngZone;\n            this._platform = _platform;\n            this._animationMode = _animationMode;\n            /** The distance in pixels that the tab labels should be translated to the left. */\n            this._scrollDistance = 0;\n            /** Whether the header should scroll to the selected index after the view has been checked. */\n            this._selectedIndexChanged = false;\n            /** Emits when the component is destroyed. */\n            this._destroyed = new rxjs.Subject();\n            /** Whether the controls for pagination should be displayed */\n            this._showPaginationControls = false;\n            /** Whether the tab list can be scrolled more towards the end of the tab label list. */\n            this._disableScrollAfter = true;\n            /** Whether the tab list can be scrolled more towards the beginning of the tab label list. */\n            this._disableScrollBefore = true;\n            /** Stream that will stop the automated scrolling. */\n            this._stopScrolling = new rxjs.Subject();\n            /**\n             * Whether pagination should be disabled. This can be used to avoid unnecessary\n             * layout recalculations if it's known that pagination won't be required.\n             */\n            this.disablePagination = false;\n            this._selectedIndex = 0;\n            /** Event emitted when the option is selected. */\n            this.selectFocusedIndex = new core.EventEmitter();\n            /** Event emitted when a label is focused. */\n            this.indexFocused = new core.EventEmitter();\n            // Bind the `mouseleave` event on the outside since it doesn't change anything in the view.\n            _ngZone.runOutsideAngular(function () {\n                rxjs.fromEvent(_elementRef.nativeElement, 'mouseleave')\n                    .pipe(operators.takeUntil(_this._destroyed))\n                    .subscribe(function () {\n                    _this._stopInterval();\n                });\n            });\n        }\n        Object.defineProperty(MatPaginatedTabHeader.prototype, \"selectedIndex\", {\n            /** The index of the active tab. */\n            get: function () { return this._selectedIndex; },\n            set: function (value) {\n                value = coercion.coerceNumberProperty(value);\n                if (this._selectedIndex != value) {\n                    this._selectedIndexChanged = true;\n                    this._selectedIndex = value;\n                    if (this._keyManager) {\n                        this._keyManager.updateActiveItem(value);\n                    }\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MatPaginatedTabHeader.prototype.ngAfterViewInit = function () {\n            var _this = this;\n            // We need to handle these events manually, because we want to bind passive event listeners.\n            rxjs.fromEvent(this._previousPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)\n                .pipe(operators.takeUntil(this._destroyed))\n                .subscribe(function () {\n                _this._handlePaginatorPress('before');\n            });\n            rxjs.fromEvent(this._nextPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)\n                .pipe(operators.takeUntil(this._destroyed))\n                .subscribe(function () {\n                _this._handlePaginatorPress('after');\n            });\n        };\n        MatPaginatedTabHeader.prototype.ngAfterContentInit = function () {\n            var _this = this;\n            var dirChange = this._dir ? this._dir.change : rxjs.of(null);\n            var resize = this._viewportRuler.change(150);\n            var realign = function () {\n                _this.updatePagination();\n                _this._alignInkBarToSelectedTab();\n            };\n            this._keyManager = new a11y.FocusKeyManager(this._items)\n                .withHorizontalOrientation(this._getLayoutDirection())\n                .withWrap();\n            this._keyManager.updateActiveItem(0);\n            // Defer the first call in order to allow for slower browsers to lay out the elements.\n            // This helps in cases where the user lands directly on a page with paginated tabs.\n            typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame(realign) : realign();\n            // On dir change or window resize, realign the ink bar and update the orientation of\n            // the key manager if the direction has changed.\n            rxjs.merge(dirChange, resize, this._items.changes).pipe(operators.takeUntil(this._destroyed)).subscribe(function () {\n                realign();\n                _this._keyManager.withHorizontalOrientation(_this._getLayoutDirection());\n            });\n            // If there is a change in the focus key manager we need to emit the `indexFocused`\n            // event in order to provide a public event that notifies about focus changes. Also we realign\n            // the tabs container by scrolling the new focused tab into the visible section.\n            this._keyManager.change.pipe(operators.takeUntil(this._destroyed)).subscribe(function (newFocusIndex) {\n                _this.indexFocused.emit(newFocusIndex);\n                _this._setTabFocus(newFocusIndex);\n            });\n        };\n        MatPaginatedTabHeader.prototype.ngAfterContentChecked = function () {\n            // If the number of tab labels have changed, check if scrolling should be enabled\n            if (this._tabLabelCount != this._items.length) {\n                this.updatePagination();\n                this._tabLabelCount = this._items.length;\n                this._changeDetectorRef.markForCheck();\n            }\n            // If the selected index has changed, scroll to the label and check if the scrolling controls\n            // should be disabled.\n            if (this._selectedIndexChanged) {\n                this._scrollToLabel(this._selectedIndex);\n                this._checkScrollingControls();\n                this._alignInkBarToSelectedTab();\n                this._selectedIndexChanged = false;\n                this._changeDetectorRef.markForCheck();\n            }\n            // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\n            // then translate the header to reflect this.\n            if (this._scrollDistanceChanged) {\n                this._updateTabScrollPosition();\n                this._scrollDistanceChanged = false;\n                this._changeDetectorRef.markForCheck();\n            }\n        };\n        MatPaginatedTabHeader.prototype.ngOnDestroy = function () {\n            this._destroyed.next();\n            this._destroyed.complete();\n            this._stopScrolling.complete();\n        };\n        /** Handles keyboard events on the header. */\n        MatPaginatedTabHeader.prototype._handleKeydown = function (event) {\n            // We don't handle any key bindings with a modifier key.\n            if (keycodes.hasModifierKey(event)) {\n                return;\n            }\n            switch (event.keyCode) {\n                case keycodes.HOME:\n                    this._keyManager.setFirstItemActive();\n                    event.preventDefault();\n                    break;\n                case keycodes.END:\n                    this._keyManager.setLastItemActive();\n                    event.preventDefault();\n                    break;\n                case keycodes.ENTER:\n                case keycodes.SPACE:\n                    this.selectFocusedIndex.emit(this.focusIndex);\n                    this._itemSelected(event);\n                    break;\n                default:\n                    this._keyManager.onKeydown(event);\n            }\n        };\n        /**\n         * Callback for when the MutationObserver detects that the content has changed.\n         */\n        MatPaginatedTabHeader.prototype._onContentChanges = function () {\n            var _this = this;\n            var textContent = this._elementRef.nativeElement.textContent;\n            // We need to diff the text content of the header, because the MutationObserver callback\n            // will fire even if the text content didn't change which is inefficient and is prone\n            // to infinite loops if a poorly constructed expression is passed in (see #14249).\n            if (textContent !== this._currentTextContent) {\n                this._currentTextContent = textContent || '';\n                // The content observer runs outside the `NgZone` by default, which\n                // means that we need to bring the callback back in ourselves.\n                this._ngZone.run(function () {\n                    _this.updatePagination();\n                    _this._alignInkBarToSelectedTab();\n                    _this._changeDetectorRef.markForCheck();\n                });\n            }\n        };\n        /**\n         * Updates the view whether pagination should be enabled or not.\n         *\n         * WARNING: Calling this method can be very costly in terms of performance. It should be called\n         * as infrequently as possible from outside of the Tabs component as it causes a reflow of the\n         * page.\n         */\n        MatPaginatedTabHeader.prototype.updatePagination = function () {\n            this._checkPaginationEnabled();\n            this._checkScrollingControls();\n            this._updateTabScrollPosition();\n        };\n        Object.defineProperty(MatPaginatedTabHeader.prototype, \"focusIndex\", {\n            /** Tracks which element has focus; used for keyboard navigation */\n            get: function () {\n                return this._keyManager ? this._keyManager.activeItemIndex : 0;\n            },\n            /** When the focus index is set, we must manually send focus to the correct label */\n            set: function (value) {\n                if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {\n                    return;\n                }\n                this._keyManager.setActiveItem(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n         * providing a valid index and return true.\n         */\n        MatPaginatedTabHeader.prototype._isValidIndex = function (index) {\n            if (!this._items) {\n                return true;\n            }\n            var tab = this._items ? this._items.toArray()[index] : null;\n            return !!tab && !tab.disabled;\n        };\n        /**\n         * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n         * scrolling is enabled.\n         */\n        MatPaginatedTabHeader.prototype._setTabFocus = function (tabIndex) {\n            if (this._showPaginationControls) {\n                this._scrollToLabel(tabIndex);\n            }\n            if (this._items && this._items.length) {\n                this._items.toArray()[tabIndex].focus();\n                // Do not let the browser manage scrolling to focus the element, this will be handled\n                // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width\n                // should be the full width minus the offset width.\n                var containerEl = this._tabListContainer.nativeElement;\n                var dir = this._getLayoutDirection();\n                if (dir == 'ltr') {\n                    containerEl.scrollLeft = 0;\n                }\n                else {\n                    containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;\n                }\n            }\n        };\n        /** The layout direction of the containing app. */\n        MatPaginatedTabHeader.prototype._getLayoutDirection = function () {\n            return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n        };\n        /** Performs the CSS transformation on the tab list that will cause the list to scroll. */\n        MatPaginatedTabHeader.prototype._updateTabScrollPosition = function () {\n            if (this.disablePagination) {\n                return;\n            }\n            var scrollDistance = this.scrollDistance;\n            var platform = this._platform;\n            var translateX = this._getLayoutDirection() === 'ltr' ? -scrollDistance : scrollDistance;\n            // Don't use `translate3d` here because we don't want to create a new layer. A new layer\n            // seems to cause flickering and overflow in Internet Explorer. For example, the ink bar\n            // and ripples will exceed the boundaries of the visible tab bar.\n            // See: https://github.com/angular/components/issues/10276\n            // We round the `transform` here, because transforms with sub-pixel precision cause some\n            // browsers to blur the content of the element.\n            this._tabList.nativeElement.style.transform = \"translateX(\" + Math.round(translateX) + \"px)\";\n            // Setting the `transform` on IE will change the scroll offset of the parent, causing the\n            // position to be thrown off in some cases. We have to reset it ourselves to ensure that\n            // it doesn't get thrown off. Note that we scope it only to IE and Edge, because messing\n            // with the scroll position throws off Chrome 71+ in RTL mode (see #14689).\n            // @breaking-change 9.0.0 Remove null check for `platform` after it can no longer be undefined.\n            if (platform && (platform.TRIDENT || platform.EDGE)) {\n                this._tabListContainer.nativeElement.scrollLeft = 0;\n            }\n        };\n        Object.defineProperty(MatPaginatedTabHeader.prototype, \"scrollDistance\", {\n            /** Sets the distance in pixels that the tab header should be transformed in the X-axis. */\n            get: function () { return this._scrollDistance; },\n            set: function (value) {\n                this._scrollTo(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n         * the end of the list, respectively). The distance to scroll is computed to be a third of the\n         * length of the tab list view window.\n         *\n         * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n         * should be called sparingly.\n         */\n        MatPaginatedTabHeader.prototype._scrollHeader = function (direction) {\n            var viewLength = this._tabListContainer.nativeElement.offsetWidth;\n            // Move the scroll distance one-third the length of the tab list's viewport.\n            var scrollAmount = (direction == 'before' ? -1 : 1) * viewLength / 3;\n            return this._scrollTo(this._scrollDistance + scrollAmount);\n        };\n        /** Handles click events on the pagination arrows. */\n        MatPaginatedTabHeader.prototype._handlePaginatorClick = function (direction) {\n            this._stopInterval();\n            this._scrollHeader(direction);\n        };\n        /**\n         * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n         *\n         * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n         * should be called sparingly.\n         */\n        MatPaginatedTabHeader.prototype._scrollToLabel = function (labelIndex) {\n            if (this.disablePagination) {\n                return;\n            }\n            var selectedLabel = this._items ? this._items.toArray()[labelIndex] : null;\n            if (!selectedLabel) {\n                return;\n            }\n            // The view length is the visible width of the tab labels.\n            var viewLength = this._tabListContainer.nativeElement.offsetWidth;\n            var _a = selectedLabel.elementRef.nativeElement, offsetLeft = _a.offsetLeft, offsetWidth = _a.offsetWidth;\n            var labelBeforePos, labelAfterPos;\n            if (this._getLayoutDirection() == 'ltr') {\n                labelBeforePos = offsetLeft;\n                labelAfterPos = labelBeforePos + offsetWidth;\n            }\n            else {\n                labelAfterPos = this._tabList.nativeElement.offsetWidth - offsetLeft;\n                labelBeforePos = labelAfterPos - offsetWidth;\n            }\n            var beforeVisiblePos = this.scrollDistance;\n            var afterVisiblePos = this.scrollDistance + viewLength;\n            if (labelBeforePos < beforeVisiblePos) {\n                // Scroll header to move label to the before direction\n                this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;\n            }\n            else if (labelAfterPos > afterVisiblePos) {\n                // Scroll header to move label to the after direction\n                this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;\n            }\n        };\n        /**\n         * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n         * tab list is wider than the size of the header container, then the pagination controls should\n         * be shown.\n         *\n         * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n         * should be called sparingly.\n         */\n        MatPaginatedTabHeader.prototype._checkPaginationEnabled = function () {\n            if (this.disablePagination) {\n                this._showPaginationControls = false;\n            }\n            else {\n                var isEnabled = this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;\n                if (!isEnabled) {\n                    this.scrollDistance = 0;\n                }\n                if (isEnabled !== this._showPaginationControls) {\n                    this._changeDetectorRef.markForCheck();\n                }\n                this._showPaginationControls = isEnabled;\n            }\n        };\n        /**\n         * Evaluate whether the before and after controls should be enabled or disabled.\n         * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n         * before button. If the header is at the end of the list (scroll distance is equal to the\n         * maximum distance we can scroll), then disable the after button.\n         *\n         * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n         * should be called sparingly.\n         */\n        MatPaginatedTabHeader.prototype._checkScrollingControls = function () {\n            if (this.disablePagination) {\n                this._disableScrollAfter = this._disableScrollBefore = true;\n            }\n            else {\n                // Check if the pagination arrows should be activated.\n                this._disableScrollBefore = this.scrollDistance == 0;\n                this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();\n                this._changeDetectorRef.markForCheck();\n            }\n        };\n        /**\n         * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n         * is equal to the difference in width between the tab list container and tab header container.\n         *\n         * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n         * should be called sparingly.\n         */\n        MatPaginatedTabHeader.prototype._getMaxScrollDistance = function () {\n            var lengthOfTabList = this._tabList.nativeElement.scrollWidth;\n            var viewLength = this._tabListContainer.nativeElement.offsetWidth;\n            return (lengthOfTabList - viewLength) || 0;\n        };\n        /** Tells the ink-bar to align itself to the current label wrapper */\n        MatPaginatedTabHeader.prototype._alignInkBarToSelectedTab = function () {\n            var selectedItem = this._items && this._items.length ?\n                this._items.toArray()[this.selectedIndex] : null;\n            var selectedLabelWrapper = selectedItem ? selectedItem.elementRef.nativeElement : null;\n            if (selectedLabelWrapper) {\n                this._inkBar.alignToElement(selectedLabelWrapper);\n            }\n            else {\n                this._inkBar.hide();\n            }\n        };\n        /** Stops the currently-running paginator interval.  */\n        MatPaginatedTabHeader.prototype._stopInterval = function () {\n            this._stopScrolling.next();\n        };\n        /**\n         * Handles the user pressing down on one of the paginators.\n         * Starts scrolling the header after a certain amount of time.\n         * @param direction In which direction the paginator should be scrolled.\n         */\n        MatPaginatedTabHeader.prototype._handlePaginatorPress = function (direction) {\n            var _this = this;\n            // Avoid overlapping timers.\n            this._stopInterval();\n            // Start a timer after the delay and keep firing based on the interval.\n            rxjs.timer(HEADER_SCROLL_DELAY, HEADER_SCROLL_INTERVAL)\n                // Keep the timer going until something tells it to stop or the component is destroyed.\n                .pipe(operators.takeUntil(rxjs.merge(this._stopScrolling, this._destroyed)))\n                .subscribe(function () {\n                var _a = _this._scrollHeader(direction), maxScrollDistance = _a.maxScrollDistance, distance = _a.distance;\n                // Stop the timer if we've reached the start or the end.\n                if (distance === 0 || distance >= maxScrollDistance) {\n                    _this._stopInterval();\n                }\n            });\n        };\n        /**\n         * Scrolls the header to a given position.\n         * @param position Position to which to scroll.\n         * @returns Information on the current scroll distance and the maximum.\n         */\n        MatPaginatedTabHeader.prototype._scrollTo = function (position) {\n            if (this.disablePagination) {\n                return { maxScrollDistance: 0, distance: 0 };\n            }\n            var maxScrollDistance = this._getMaxScrollDistance();\n            this._scrollDistance = Math.max(0, Math.min(maxScrollDistance, position));\n            // Mark that the scroll distance has changed so that after the view is checked, the CSS\n            // transformation can move the header.\n            this._scrollDistanceChanged = true;\n            this._checkScrollingControls();\n            return { maxScrollDistance: maxScrollDistance, distance: this._scrollDistance };\n        };\n        MatPaginatedTabHeader.decorators = [\n            { type: core.Directive, args: [{\n                        // TODO(crisbeto): this selector can be removed when we update to Angular 9.0.\n                        selector: 'do-not-use-abstract-mat-paginated-tab-header'\n                    },] }\n        ];\n        /** @nocollapse */\n        MatPaginatedTabHeader.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: core.ChangeDetectorRef },\n            { type: scrolling.ViewportRuler },\n            { type: bidi.Directionality, decorators: [{ type: core.Optional }] },\n            { type: core.NgZone },\n            { type: platform.Platform },\n            { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] }\n        ]; };\n        MatPaginatedTabHeader.propDecorators = {\n            disablePagination: [{ type: core.Input }]\n        };\n        return MatPaginatedTabHeader;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Base class with all of the `MatTabHeader` functionality.\n     * @docs-private\n     */\n    var _MatTabHeaderBase = /** @class */ (function (_super) {\n        tslib.__extends(_MatTabHeaderBase, _super);\n        function _MatTabHeaderBase(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, \n        // @breaking-change 9.0.0 `_animationMode` parameter to be made required.\n        animationMode) {\n            var _this = _super.call(this, elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode) || this;\n            _this._disableRipple = false;\n            return _this;\n        }\n        Object.defineProperty(_MatTabHeaderBase.prototype, \"disableRipple\", {\n            /** Whether the ripple effect is disabled or not. */\n            get: function () { return this._disableRipple; },\n            set: function (value) { this._disableRipple = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        _MatTabHeaderBase.prototype._itemSelected = function (event) {\n            event.preventDefault();\n        };\n        _MatTabHeaderBase.decorators = [\n            { type: core.Directive, args: [{\n                        // TODO(crisbeto): this selector can be removed when we update to Angular 9.0.\n                        selector: 'do-not-use-abstract-mat-tab-header-base'\n                    },] }\n        ];\n        /** @nocollapse */\n        _MatTabHeaderBase.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: core.ChangeDetectorRef },\n            { type: scrolling.ViewportRuler },\n            { type: bidi.Directionality, decorators: [{ type: core.Optional }] },\n            { type: core.NgZone },\n            { type: platform.Platform },\n            { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] }\n        ]; };\n        _MatTabHeaderBase.propDecorators = {\n            disableRipple: [{ type: core.Input }]\n        };\n        return _MatTabHeaderBase;\n    }(MatPaginatedTabHeader));\n    /**\n     * The header of the tab group which displays a list of all the tabs in the tab group. Includes\n     * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the\n     * width of the header container, then arrows will be displayed to allow the user to scroll\n     * left and right across the header.\n     * @docs-private\n     */\n    var MatTabHeader = /** @class */ (function (_super) {\n        tslib.__extends(MatTabHeader, _super);\n        function MatTabHeader(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, \n        // @breaking-change 9.0.0 `_animationMode` parameter to be made required.\n        animationMode) {\n            return _super.call(this, elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode) || this;\n        }\n        MatTabHeader.decorators = [\n            { type: core.Component, args: [{\n                        moduleId: module.id,\n                        selector: 'mat-tab-header',\n                        template: \"<div class=\\\"mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4\\\"\\n     #previousPaginator\\n     aria-hidden=\\\"true\\\"\\n     mat-ripple [matRippleDisabled]=\\\"_disableScrollBefore || disableRipple\\\"\\n     [class.mat-tab-header-pagination-disabled]=\\\"_disableScrollBefore\\\"\\n     (click)=\\\"_handlePaginatorClick('before')\\\"\\n     (mousedown)=\\\"_handlePaginatorPress('before')\\\"\\n     (touchend)=\\\"_stopInterval()\\\">\\n  <div class=\\\"mat-tab-header-pagination-chevron\\\"></div>\\n</div>\\n\\n<div class=\\\"mat-tab-label-container\\\" #tabListContainer (keydown)=\\\"_handleKeydown($event)\\\">\\n  <div\\n    #tabList\\n    class=\\\"mat-tab-list\\\"\\n    [class._mat-animation-noopable]=\\\"_animationMode === 'NoopAnimations'\\\"\\n    role=\\\"tablist\\\"\\n    (cdkObserveContent)=\\\"_onContentChanges()\\\">\\n    <div class=\\\"mat-tab-labels\\\">\\n      <ng-content></ng-content>\\n    </div>\\n    <mat-ink-bar></mat-ink-bar>\\n  </div>\\n</div>\\n\\n<div class=\\\"mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4\\\"\\n     #nextPaginator\\n     aria-hidden=\\\"true\\\"\\n     mat-ripple [matRippleDisabled]=\\\"_disableScrollAfter || disableRipple\\\"\\n     [class.mat-tab-header-pagination-disabled]=\\\"_disableScrollAfter\\\"\\n     (mousedown)=\\\"_handlePaginatorPress('after')\\\"\\n     (click)=\\\"_handlePaginatorClick('after')\\\"\\n     (touchend)=\\\"_stopInterval()\\\">\\n  <div class=\\\"mat-tab-header-pagination-chevron\\\"></div>\\n</div>\\n\",\n                        inputs: ['selectedIndex'],\n                        outputs: ['selectFocusedIndex', 'indexFocused'],\n                        encapsulation: core.ViewEncapsulation.None,\n                        // tslint:disable-next-line:validate-decorators\n                        changeDetection: core.ChangeDetectionStrategy.Default,\n                        host: {\n                            'class': 'mat-tab-header',\n                            '[class.mat-tab-header-pagination-controls-enabled]': '_showPaginationControls',\n                            '[class.mat-tab-header-rtl]': \"_getLayoutDirection() == 'rtl'\",\n                        },\n                        styles: [\".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:\\\"\\\";height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media(-ms-high-contrast: active){.mat-ink-bar{outline:solid 2px;height:0}}.mat-tab-labels{display:flex}[mat-align-tabs=center] .mat-tab-labels{justify-content:center}[mat-align-tabs=end] .mat-tab-labels{justify-content:flex-end}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}._mat-animation-noopable.mat-tab-list{transition:none;animation:none}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media(-ms-high-contrast: active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media(-ms-high-contrast: active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media(-ms-high-contrast: active){.mat-tab-label{opacity:1}}@media(max-width: 599px){.mat-tab-label{min-width:72px}}\\n\"]\n                    }] }\n        ];\n        /** @nocollapse */\n        MatTabHeader.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: core.ChangeDetectorRef },\n            { type: scrolling.ViewportRuler },\n            { type: bidi.Directionality, decorators: [{ type: core.Optional }] },\n            { type: core.NgZone },\n            { type: platform.Platform },\n            { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] }\n        ]; };\n        MatTabHeader.propDecorators = {\n            _items: [{ type: core.ContentChildren, args: [MatTabLabelWrapper,] }],\n            _inkBar: [{ type: core.ViewChild, args: [MatInkBar, { static: true },] }],\n            _tabListContainer: [{ type: core.ViewChild, args: ['tabListContainer', { static: true },] }],\n            _tabList: [{ type: core.ViewChild, args: ['tabList', { static: true },] }],\n            _nextPaginator: [{ type: core.ViewChild, args: ['nextPaginator', { static: false },] }],\n            _previousPaginator: [{ type: core.ViewChild, args: ['previousPaginator', { static: false },] }]\n        };\n        return MatTabHeader;\n    }(_MatTabHeaderBase));\n\n    /**\n     * Base class with all of the `MatTabNav` functionality.\n     * @docs-private\n     */\n    var _MatTabNavBase = /** @class */ (function (_super) {\n        tslib.__extends(_MatTabNavBase, _super);\n        function _MatTabNavBase(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, \n        /**\n         * @deprecated @breaking-change 9.0.0 `platform` parameter to become required.\n         */\n        platform, animationMode) {\n            var _this = _super.call(this, elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode) || this;\n            _this._disableRipple = false;\n            /** Theme color of the nav bar. */\n            _this.color = 'primary';\n            return _this;\n        }\n        Object.defineProperty(_MatTabNavBase.prototype, \"backgroundColor\", {\n            /** Background color of the tab nav. */\n            get: function () { return this._backgroundColor; },\n            set: function (value) {\n                var classList = this._elementRef.nativeElement.classList;\n                classList.remove(\"mat-background-\" + this.backgroundColor);\n                if (value) {\n                    classList.add(\"mat-background-\" + value);\n                }\n                this._backgroundColor = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(_MatTabNavBase.prototype, \"disableRipple\", {\n            /** Whether the ripple effect is disabled or not. */\n            get: function () { return this._disableRipple; },\n            set: function (value) { this._disableRipple = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        _MatTabNavBase.prototype._itemSelected = function () {\n            // noop\n        };\n        _MatTabNavBase.prototype.ngAfterContentInit = function () {\n            var _this = this;\n            // We need this to run before the `changes` subscription in parent to ensure that the\n            // selectedIndex is up-to-date by the time the super class starts looking for it.\n            this._items.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroyed)).subscribe(function () {\n                _this.updateActiveLink();\n            });\n            _super.prototype.ngAfterContentInit.call(this);\n        };\n        /**\n         * Notifies the component that the active link has been changed.\n         * @breaking-change 8.0.0 `element` parameter to be removed.\n         */\n        _MatTabNavBase.prototype.updateActiveLink = function (_element) {\n            if (!this._items) {\n                return;\n            }\n            var items = this._items.toArray();\n            for (var i = 0; i < items.length; i++) {\n                if (items[i].active) {\n                    this.selectedIndex = i;\n                    this._changeDetectorRef.markForCheck();\n                    return;\n                }\n            }\n            // The ink bar should hide itself if no items are active.\n            this.selectedIndex = -1;\n            this._inkBar.hide();\n        };\n        _MatTabNavBase.decorators = [\n            { type: core.Directive, args: [{\n                        // TODO(crisbeto): this selector can be removed when we update to Angular 9.0.\n                        selector: 'do-not-use-abstract-mat-tab-nav-base'\n                    },] }\n        ];\n        /** @nocollapse */\n        _MatTabNavBase.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: bidi.Directionality, decorators: [{ type: core.Optional }] },\n            { type: core.NgZone },\n            { type: core.ChangeDetectorRef },\n            { type: scrolling.ViewportRuler },\n            { type: platform.Platform, decorators: [{ type: core.Optional }] },\n            { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] }\n        ]; };\n        _MatTabNavBase.propDecorators = {\n            backgroundColor: [{ type: core.Input }],\n            disableRipple: [{ type: core.Input }],\n            color: [{ type: core.Input }]\n        };\n        return _MatTabNavBase;\n    }(MatPaginatedTabHeader));\n    /**\n     * Navigation component matching the styles of the tab group header.\n     * Provides anchored navigation with animated ink bar.\n     */\n    var MatTabNav = /** @class */ (function (_super) {\n        tslib.__extends(MatTabNav, _super);\n        function MatTabNav(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, \n        /**\n         * @deprecated @breaking-change 9.0.0 `platform` parameter to become required.\n         */\n        platform, animationMode) {\n            return _super.call(this, elementRef, dir, ngZone, changeDetectorRef, viewportRuler, platform, animationMode) || this;\n        }\n        MatTabNav.decorators = [\n            { type: core.Component, args: [{\n                        moduleId: module.id,\n                        selector: '[mat-tab-nav-bar]',\n                        exportAs: 'matTabNavBar, matTabNav',\n                        inputs: ['color'],\n                        template: \"<div class=\\\"mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4\\\"\\n     #previousPaginator\\n     aria-hidden=\\\"true\\\"\\n     mat-ripple [matRippleDisabled]=\\\"_disableScrollBefore || disableRipple\\\"\\n     [class.mat-tab-header-pagination-disabled]=\\\"_disableScrollBefore\\\"\\n     (click)=\\\"_handlePaginatorClick('before')\\\"\\n     (mousedown)=\\\"_handlePaginatorPress('before')\\\"\\n     (touchend)=\\\"_stopInterval()\\\">\\n  <div class=\\\"mat-tab-header-pagination-chevron\\\"></div>\\n</div>\\n\\n<div class=\\\"mat-tab-link-container\\\" #tabListContainer (keydown)=\\\"_handleKeydown($event)\\\">\\n  <div class=\\\"mat-tab-list\\\" #tabList (cdkObserveContent)=\\\"_onContentChanges()\\\">\\n    <div class=\\\"mat-tab-links\\\">\\n      <ng-content></ng-content>\\n    </div>\\n    <mat-ink-bar></mat-ink-bar>\\n  </div>\\n</div>\\n\\n<div class=\\\"mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4\\\"\\n     #nextPaginator\\n     aria-hidden=\\\"true\\\"\\n     mat-ripple [matRippleDisabled]=\\\"_disableScrollAfter || disableRipple\\\"\\n     [class.mat-tab-header-pagination-disabled]=\\\"_disableScrollAfter\\\"\\n     (mousedown)=\\\"_handlePaginatorPress('after')\\\"\\n     (click)=\\\"_handlePaginatorClick('after')\\\"\\n     (touchend)=\\\"_stopInterval()\\\">\\n  <div class=\\\"mat-tab-header-pagination-chevron\\\"></div>\\n</div>\\n\",\n                        host: {\n                            'class': 'mat-tab-nav-bar mat-tab-header',\n                            '[class.mat-tab-header-pagination-controls-enabled]': '_showPaginationControls',\n                            '[class.mat-tab-header-rtl]': \"_getLayoutDirection() == 'rtl'\",\n                            '[class.mat-primary]': 'color !== \"warn\" && color !== \"accent\"',\n                            '[class.mat-accent]': 'color === \"accent\"',\n                            '[class.mat-warn]': 'color === \"warn\"',\n                        },\n                        encapsulation: core.ViewEncapsulation.None,\n                        // tslint:disable-next-line:validate-decorators\n                        changeDetection: core.ChangeDetectionStrategy.Default,\n                        styles: [\".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:\\\"\\\";height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-tab-links{display:flex}[mat-align-tabs=center] .mat-tab-links{justify-content:center}[mat-align-tabs=end] .mat-tab-links{justify-content:flex-end}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media(-ms-high-contrast: active){.mat-ink-bar{outline:solid 2px;height:0}}.mat-tab-link-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:none}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}@media(-ms-high-contrast: active){.mat-tab-link:focus{outline:dotted 2px}}.mat-tab-link.mat-tab-disabled{cursor:default}@media(-ms-high-contrast: active){.mat-tab-link.mat-tab-disabled{opacity:.5}}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media(-ms-high-contrast: active){.mat-tab-link{opacity:1}}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media(max-width: 599px){.mat-tab-link{min-width:72px}}\\n\"]\n                    }] }\n        ];\n        /** @nocollapse */\n        MatTabNav.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: bidi.Directionality, decorators: [{ type: core.Optional }] },\n            { type: core.NgZone },\n            { type: core.ChangeDetectorRef },\n            { type: scrolling.ViewportRuler },\n            { type: platform.Platform, decorators: [{ type: core.Optional }] },\n            { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] }\n        ]; };\n        MatTabNav.propDecorators = {\n            _items: [{ type: core.ContentChildren, args: [core.forwardRef(function () { return MatTabLink; }), { descendants: true },] }],\n            _inkBar: [{ type: core.ViewChild, args: [MatInkBar, { static: true },] }],\n            _tabListContainer: [{ type: core.ViewChild, args: ['tabListContainer', { static: true },] }],\n            _tabList: [{ type: core.ViewChild, args: ['tabList', { static: true },] }],\n            _nextPaginator: [{ type: core.ViewChild, args: ['nextPaginator', { static: false },] }],\n            _previousPaginator: [{ type: core.ViewChild, args: ['previousPaginator', { static: false },] }]\n        };\n        return MatTabNav;\n    }(_MatTabNavBase));\n    // Boilerplate for applying mixins to MatTabLink.\n    var MatTabLinkMixinBase = /** @class */ (function () {\n        function MatTabLinkMixinBase() {\n        }\n        return MatTabLinkMixinBase;\n    }());\n    var _MatTabLinkMixinBase = core$1.mixinTabIndex(core$1.mixinDisableRipple(core$1.mixinDisabled(MatTabLinkMixinBase)));\n    /** Base class with all of the `MatTabLink` functionality. */\n    var _MatTabLinkBase = /** @class */ (function (_super) {\n        tslib.__extends(_MatTabLinkBase, _super);\n        function _MatTabLinkBase(_tabNavBar, elementRef, globalRippleOptions, tabIndex, _focusMonitor, animationMode) {\n            var _this = _super.call(this) || this;\n            _this._tabNavBar = _tabNavBar;\n            _this.elementRef = elementRef;\n            _this._focusMonitor = _focusMonitor;\n            /** Whether the tab link is active or not. */\n            _this._isActive = false;\n            _this.rippleConfig = globalRippleOptions || {};\n            _this.tabIndex = parseInt(tabIndex) || 0;\n            if (animationMode === 'NoopAnimations') {\n                _this.rippleConfig.animation = { enterDuration: 0, exitDuration: 0 };\n            }\n            _focusMonitor.monitor(elementRef);\n            return _this;\n        }\n        Object.defineProperty(_MatTabLinkBase.prototype, \"active\", {\n            /** Whether the link is active. */\n            get: function () { return this._isActive; },\n            set: function (value) {\n                if (value !== this._isActive) {\n                    this._isActive = value;\n                    this._tabNavBar.updateActiveLink(this.elementRef);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(_MatTabLinkBase.prototype, \"rippleDisabled\", {\n            /**\n             * Whether ripples are disabled on interaction.\n             * @docs-private\n             */\n            get: function () {\n                return this.disabled || this.disableRipple || this._tabNavBar.disableRipple ||\n                    !!this.rippleConfig.disabled;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        _MatTabLinkBase.prototype.focus = function () {\n            this.elementRef.nativeElement.focus();\n        };\n        _MatTabLinkBase.prototype.ngOnDestroy = function () {\n            this._focusMonitor.stopMonitoring(this.elementRef);\n        };\n        _MatTabLinkBase.decorators = [\n            { type: core.Directive, args: [{\n                        // TODO(crisbeto): this selector can be removed when we update to Angular 9.0.\n                        selector: 'do-not-use-abstract-mat-tab-link-base'\n                    },] }\n        ];\n        /** @nocollapse */\n        _MatTabLinkBase.ctorParameters = function () { return [\n            { type: _MatTabNavBase },\n            { type: core.ElementRef },\n            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core$1.MAT_RIPPLE_GLOBAL_OPTIONS,] }] },\n            { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] },\n            { type: a11y.FocusMonitor },\n            { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] }\n        ]; };\n        _MatTabLinkBase.propDecorators = {\n            active: [{ type: core.Input }]\n        };\n        return _MatTabLinkBase;\n    }(_MatTabLinkMixinBase));\n    /**\n     * Link inside of a `mat-tab-nav-bar`.\n     */\n    var MatTabLink = /** @class */ (function (_super) {\n        tslib.__extends(MatTabLink, _super);\n        function MatTabLink(tabNavBar, elementRef, ngZone, platform, globalRippleOptions, tabIndex, focusMonitor, animationMode) {\n            var _this = _super.call(this, tabNavBar, elementRef, globalRippleOptions, tabIndex, focusMonitor, animationMode) || this;\n            _this._tabLinkRipple = new core$1.RippleRenderer(_this, ngZone, elementRef, platform);\n            _this._tabLinkRipple.setupTriggerEvents(elementRef.nativeElement);\n            return _this;\n        }\n        MatTabLink.prototype.ngOnDestroy = function () {\n            _super.prototype.ngOnDestroy.call(this);\n            this._tabLinkRipple._removeTriggerEvents();\n        };\n        MatTabLink.decorators = [\n            { type: core.Directive, args: [{\n                        selector: '[mat-tab-link], [matTabLink]',\n                        exportAs: 'matTabLink',\n                        inputs: ['disabled', 'disableRipple', 'tabIndex'],\n                        host: {\n                            'class': 'mat-tab-link',\n                            '[attr.aria-current]': 'active ? \"page\" : null',\n                            '[attr.aria-disabled]': 'disabled',\n                            '[attr.tabIndex]': 'tabIndex',\n                            '[class.mat-tab-disabled]': 'disabled',\n                            '[class.mat-tab-label-active]': 'active',\n                        }\n                    },] }\n        ];\n        /** @nocollapse */\n        MatTabLink.ctorParameters = function () { return [\n            { type: MatTabNav },\n            { type: core.ElementRef },\n            { type: core.NgZone },\n            { type: platform.Platform },\n            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core$1.MAT_RIPPLE_GLOBAL_OPTIONS,] }] },\n            { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] },\n            { type: a11y.FocusMonitor },\n            { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] }\n        ]; };\n        return MatTabLink;\n    }(_MatTabLinkBase));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var MatTabsModule = /** @class */ (function () {\n        function MatTabsModule() {\n        }\n        MatTabsModule.decorators = [\n            { type: core.NgModule, args: [{\n                        imports: [\n                            common.CommonModule,\n                            core$1.MatCommonModule,\n                            portal.PortalModule,\n                            core$1.MatRippleModule,\n                            observers.ObserversModule,\n                            a11y.A11yModule,\n                        ],\n                        // Don't export all components because some are only to be used internally.\n                        exports: [\n                            core$1.MatCommonModule,\n                            MatTabGroup,\n                            MatTabLabel,\n                            MatTab,\n                            MatTabNav,\n                            MatTabLink,\n                            MatTabContent,\n                        ],\n                        declarations: [\n                            MatTabGroup,\n                            MatTabLabel,\n                            MatTab,\n                            MatInkBar,\n                            MatTabLabelWrapper,\n                            MatTabNav,\n                            MatTabLink,\n                            MatTabBody,\n                            MatTabBodyPortal,\n                            MatTabHeader,\n                            MatTabContent,\n                            // TODO(crisbeto): these can be removed once they're turned into selector-less directives.\n                            MatPaginatedTabHeader,\n                            _MatTabGroupBase,\n                            _MatTabNavBase,\n                            _MatTabBodyBase,\n                            _MatTabHeaderBase,\n                            _MatTabLinkBase,\n                        ],\n                    },] }\n        ];\n        return MatTabsModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.ɵangular_material_src_material_tabs_tabs_a = _MAT_INK_BAR_POSITIONER_FACTORY;\n    exports.ɵangular_material_src_material_tabs_tabs_b = MatPaginatedTabHeader;\n    exports.MatTabsModule = MatTabsModule;\n    exports.MatInkBar = MatInkBar;\n    exports._MAT_INK_BAR_POSITIONER = _MAT_INK_BAR_POSITIONER;\n    exports.MatTabBody = MatTabBody;\n    exports._MatTabBodyBase = _MatTabBodyBase;\n    exports.MatTabBodyPortal = MatTabBodyPortal;\n    exports.MatTabHeader = MatTabHeader;\n    exports._MatTabHeaderBase = _MatTabHeaderBase;\n    exports.MatTabLabelWrapper = MatTabLabelWrapper;\n    exports.MatTab = MatTab;\n    exports.MAT_TAB_GROUP = MAT_TAB_GROUP;\n    exports.MatTabLabel = MatTabLabel;\n    exports.MatTabNav = MatTabNav;\n    exports.MatTabLink = MatTabLink;\n    exports._MatTabNavBase = _MatTabNavBase;\n    exports._MatTabLinkBase = _MatTabLinkBase;\n    exports.MatTabContent = MatTabContent;\n    exports.MatTabChangeEvent = MatTabChangeEvent;\n    exports.MAT_TABS_CONFIG = MAT_TABS_CONFIG;\n    exports._MatTabGroupBase = _MatTabGroupBase;\n    exports.MatTabGroup = MatTabGroup;\n    exports.matTabsAnimations = matTabsAnimations;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=material-tabs.umd.js.map\n"]}