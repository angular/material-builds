/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ComponentHarness, parallel } from '@angular/cdk/testing';
import { MatCalendarHarness } from './calendar-harness';
/** Base class for harnesses that can trigger a calendar. */
export class DatepickerTriggerHarnessBase extends ComponentHarness {
    /** Opens the calendar if the trigger is enabled and it has a calendar. */
    async openCalendar() {
        const [isDisabled, hasCalendar] = await parallel(() => [this.isDisabled(), this.hasCalendar()]);
        if (!isDisabled && hasCalendar) {
            return this._openCalendar();
        }
    }
    /** Closes the calendar if it is open. */
    async closeCalendar() {
        if (await this.isCalendarOpen()) {
            await closeCalendar(getCalendarId(this.host()), this.documentRootLocatorFactory());
            // This is necessary so that we wait for the closing animation to finish in touch UI mode.
            await this.forceStabilize();
        }
    }
    /** Gets whether there is a calendar associated with the trigger. */
    async hasCalendar() {
        return (await getCalendarId(this.host())) != null;
    }
    /**
     * Gets the `MatCalendarHarness` that is associated with the trigger.
     * @param filter Optionally filters which calendar is included.
     */
    async getCalendar(filter = {}) {
        return getCalendar(filter, this.host(), this.documentRootLocatorFactory());
    }
}
/** Gets the ID of the calendar that a particular test element can trigger. */
export async function getCalendarId(host) {
    return (await host).getAttribute('data-mat-calendar');
}
/** Closes the calendar with a specific ID. */
export async function closeCalendar(calendarId, documentLocator) {
    // We close the calendar by clicking on the backdrop, even though all datepicker variants
    // have the ability to close by pressing escape. The backdrop is preferrable, because the
    // escape key has multiple functions inside a range picker (either cancel the current range
    // or close the calendar). Since we don't have access to set the ID on the backdrop in all
    // cases, we set a unique class instead which is the same as the calendar's ID and suffixed
    // with `-backdrop`.
    const backdropSelector = `.${await calendarId}-backdrop`;
    return (await documentLocator.locatorFor(backdropSelector)()).click();
}
/** Gets the test harness for a calendar associated with a particular host. */
export async function getCalendar(filter, host, documentLocator) {
    const calendarId = await getCalendarId(host);
    if (!calendarId) {
        throw Error(`Element is not associated with a calendar`);
    }
    return documentLocator.locatorFor(MatCalendarHarness.with({
        ...filter,
        selector: `#${calendarId}`
    }))();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci10cmlnZ2VyLWhhcm5lc3MtYmFzZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9tYXRlcmlhbC9kYXRlcGlja2VyL3Rlc3RpbmcvZGF0ZXBpY2tlci10cmlnZ2VyLWhhcm5lc3MtYmFzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEVBQUMsZ0JBQWdCLEVBQWtCLFFBQVEsRUFBYyxNQUFNLHNCQUFzQixDQUFDO0FBRTdGLE9BQU8sRUFBQyxrQkFBa0IsRUFBQyxNQUFNLG9CQUFvQixDQUFDO0FBV3RELDREQUE0RDtBQUM1RCxNQUFNLE9BQWdCLDRCQUE2QixTQUFRLGdCQUFnQjtJQVd6RSwwRUFBMEU7SUFDMUUsS0FBSyxDQUFDLFlBQVk7UUFDaEIsTUFBTSxDQUFDLFVBQVUsRUFBRSxXQUFXLENBQUMsR0FBRyxNQUFNLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBRWhHLElBQUksQ0FBQyxVQUFVLElBQUksV0FBVyxFQUFFO1lBQzlCLE9BQU8sSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1NBQzdCO0lBQ0gsQ0FBQztJQUVELHlDQUF5QztJQUN6QyxLQUFLLENBQUMsYUFBYTtRQUNqQixJQUFJLE1BQU0sSUFBSSxDQUFDLGNBQWMsRUFBRSxFQUFFO1lBQy9CLE1BQU0sYUFBYSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsMEJBQTBCLEVBQUUsQ0FBQyxDQUFDO1lBQ25GLDBGQUEwRjtZQUMxRixNQUFNLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztTQUM3QjtJQUNILENBQUM7SUFFRCxvRUFBb0U7SUFDcEUsS0FBSyxDQUFDLFdBQVc7UUFDZixPQUFPLENBQUMsTUFBTSxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUM7SUFDcEQsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxXQUFXLENBQUMsU0FBaUMsRUFBRTtRQUNuRCxPQUFPLFdBQVcsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxFQUFFLElBQUksQ0FBQywwQkFBMEIsRUFBRSxDQUFDLENBQUM7SUFDN0UsQ0FBQztDQUNGO0FBRUQsOEVBQThFO0FBQzlFLE1BQU0sQ0FBQyxLQUFLLFVBQVUsYUFBYSxDQUFDLElBQTBCO0lBQzVELE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLFlBQVksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQ3hELENBQUM7QUFFRCw4Q0FBOEM7QUFDOUMsTUFBTSxDQUFDLEtBQUssVUFBVSxhQUFhLENBQ2pDLFVBQWtDLEVBQ2xDLGVBQStCO0lBQy9CLHlGQUF5RjtJQUN6Rix5RkFBeUY7SUFDekYsMkZBQTJGO0lBQzNGLDBGQUEwRjtJQUMxRiwyRkFBMkY7SUFDM0Ysb0JBQW9CO0lBQ3BCLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxNQUFNLFVBQVUsV0FBVyxDQUFDO0lBQ3pELE9BQU8sQ0FBQyxNQUFNLGVBQWUsQ0FBQyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDeEUsQ0FBQztBQUVELDhFQUE4RTtBQUM5RSxNQUFNLENBQUMsS0FBSyxVQUFVLFdBQVcsQ0FDL0IsTUFBOEIsRUFDOUIsSUFBMEIsRUFDMUIsZUFBK0I7SUFDL0IsTUFBTSxVQUFVLEdBQUcsTUFBTSxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFN0MsSUFBSSxDQUFDLFVBQVUsRUFBRTtRQUNmLE1BQU0sS0FBSyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7S0FDMUQ7SUFFRCxPQUFPLGVBQWUsQ0FBQyxVQUFVLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDO1FBQ3hELEdBQUcsTUFBTTtRQUNULFFBQVEsRUFBRSxJQUFJLFVBQVUsRUFBRTtLQUMzQixDQUFDLENBQUMsRUFBRSxDQUFDO0FBQ1IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge0NvbXBvbmVudEhhcm5lc3MsIExvY2F0b3JGYWN0b3J5LCBwYXJhbGxlbCwgVGVzdEVsZW1lbnR9IGZyb20gJ0Bhbmd1bGFyL2Nkay90ZXN0aW5nJztcbmltcG9ydCB7Q2FsZW5kYXJIYXJuZXNzRmlsdGVyc30gZnJvbSAnLi9kYXRlcGlja2VyLWhhcm5lc3MtZmlsdGVycyc7XG5pbXBvcnQge01hdENhbGVuZGFySGFybmVzc30gZnJvbSAnLi9jYWxlbmRhci1oYXJuZXNzJztcblxuLyoqIEludGVyZmFjZSBmb3IgYSB0ZXN0IGhhcm5lc3MgdGhhdCBjYW4gb3BlbiBhbmQgY2xvc2UgYSBjYWxlbmRhci4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZXBpY2tlclRyaWdnZXIge1xuICBpc0NhbGVuZGFyT3BlbigpOiBQcm9taXNlPGJvb2xlYW4+O1xuICBvcGVuQ2FsZW5kYXIoKTogUHJvbWlzZTx2b2lkPjtcbiAgY2xvc2VDYWxlbmRhcigpOiBQcm9taXNlPHZvaWQ+O1xuICBoYXNDYWxlbmRhcigpOiBQcm9taXNlPGJvb2xlYW4+O1xuICBnZXRDYWxlbmRhcihmaWx0ZXI/OiBDYWxlbmRhckhhcm5lc3NGaWx0ZXJzKTogUHJvbWlzZTxNYXRDYWxlbmRhckhhcm5lc3M+O1xufVxuXG4vKiogQmFzZSBjbGFzcyBmb3IgaGFybmVzc2VzIHRoYXQgY2FuIHRyaWdnZXIgYSBjYWxlbmRhci4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEYXRlcGlja2VyVHJpZ2dlckhhcm5lc3NCYXNlIGV4dGVuZHMgQ29tcG9uZW50SGFybmVzcyBpbXBsZW1lbnRzXG4gIERhdGVwaWNrZXJUcmlnZ2VyIHtcbiAgLyoqIFdoZXRoZXIgdGhlIHRyaWdnZXIgaXMgZGlzYWJsZWQuICovXG4gIGFic3RyYWN0IGlzRGlzYWJsZWQoKTogUHJvbWlzZTxib29sZWFuPjtcblxuICAvKiogV2hldGhlciB0aGUgY2FsZW5kYXIgYXNzb2NpYXRlZCB3aXRoIHRoZSB0cmlnZ2VyIGlzIG9wZW4uICovXG4gIGFic3RyYWN0IGlzQ2FsZW5kYXJPcGVuKCk6IFByb21pc2U8Ym9vbGVhbj47XG5cbiAgLyoqIE9wZW5zIHRoZSBjYWxlbmRhciBhc3NvY2lhdGVkIHdpdGggdGhlIHRyaWdnZXIuICovXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBfb3BlbkNhbGVuZGFyKCk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqIE9wZW5zIHRoZSBjYWxlbmRhciBpZiB0aGUgdHJpZ2dlciBpcyBlbmFibGVkIGFuZCBpdCBoYXMgYSBjYWxlbmRhci4gKi9cbiAgYXN5bmMgb3BlbkNhbGVuZGFyKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IFtpc0Rpc2FibGVkLCBoYXNDYWxlbmRhcl0gPSBhd2FpdCBwYXJhbGxlbCgoKSA9PiBbdGhpcy5pc0Rpc2FibGVkKCksIHRoaXMuaGFzQ2FsZW5kYXIoKV0pO1xuXG4gICAgaWYgKCFpc0Rpc2FibGVkICYmIGhhc0NhbGVuZGFyKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb3BlbkNhbGVuZGFyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIENsb3NlcyB0aGUgY2FsZW5kYXIgaWYgaXQgaXMgb3Blbi4gKi9cbiAgYXN5bmMgY2xvc2VDYWxlbmRhcigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoYXdhaXQgdGhpcy5pc0NhbGVuZGFyT3BlbigpKSB7XG4gICAgICBhd2FpdCBjbG9zZUNhbGVuZGFyKGdldENhbGVuZGFySWQodGhpcy5ob3N0KCkpLCB0aGlzLmRvY3VtZW50Um9vdExvY2F0b3JGYWN0b3J5KCkpO1xuICAgICAgLy8gVGhpcyBpcyBuZWNlc3Nhcnkgc28gdGhhdCB3ZSB3YWl0IGZvciB0aGUgY2xvc2luZyBhbmltYXRpb24gdG8gZmluaXNoIGluIHRvdWNoIFVJIG1vZGUuXG4gICAgICBhd2FpdCB0aGlzLmZvcmNlU3RhYmlsaXplKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEdldHMgd2hldGhlciB0aGVyZSBpcyBhIGNhbGVuZGFyIGFzc29jaWF0ZWQgd2l0aCB0aGUgdHJpZ2dlci4gKi9cbiAgYXN5bmMgaGFzQ2FsZW5kYXIoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIChhd2FpdCBnZXRDYWxlbmRhcklkKHRoaXMuaG9zdCgpKSkgIT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBgTWF0Q2FsZW5kYXJIYXJuZXNzYCB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdHJpZ2dlci5cbiAgICogQHBhcmFtIGZpbHRlciBPcHRpb25hbGx5IGZpbHRlcnMgd2hpY2ggY2FsZW5kYXIgaXMgaW5jbHVkZWQuXG4gICAqL1xuICBhc3luYyBnZXRDYWxlbmRhcihmaWx0ZXI6IENhbGVuZGFySGFybmVzc0ZpbHRlcnMgPSB7fSk6IFByb21pc2U8TWF0Q2FsZW5kYXJIYXJuZXNzPiB7XG4gICAgcmV0dXJuIGdldENhbGVuZGFyKGZpbHRlciwgdGhpcy5ob3N0KCksIHRoaXMuZG9jdW1lbnRSb290TG9jYXRvckZhY3RvcnkoKSk7XG4gIH1cbn1cblxuLyoqIEdldHMgdGhlIElEIG9mIHRoZSBjYWxlbmRhciB0aGF0IGEgcGFydGljdWxhciB0ZXN0IGVsZW1lbnQgY2FuIHRyaWdnZXIuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FsZW5kYXJJZChob3N0OiBQcm9taXNlPFRlc3RFbGVtZW50Pik6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICByZXR1cm4gKGF3YWl0IGhvc3QpLmdldEF0dHJpYnV0ZSgnZGF0YS1tYXQtY2FsZW5kYXInKTtcbn1cblxuLyoqIENsb3NlcyB0aGUgY2FsZW5kYXIgd2l0aCBhIHNwZWNpZmljIElELiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsb3NlQ2FsZW5kYXIoXG4gIGNhbGVuZGFySWQ6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4sXG4gIGRvY3VtZW50TG9jYXRvcjogTG9jYXRvckZhY3RvcnkpIHtcbiAgLy8gV2UgY2xvc2UgdGhlIGNhbGVuZGFyIGJ5IGNsaWNraW5nIG9uIHRoZSBiYWNrZHJvcCwgZXZlbiB0aG91Z2ggYWxsIGRhdGVwaWNrZXIgdmFyaWFudHNcbiAgLy8gaGF2ZSB0aGUgYWJpbGl0eSB0byBjbG9zZSBieSBwcmVzc2luZyBlc2NhcGUuIFRoZSBiYWNrZHJvcCBpcyBwcmVmZXJyYWJsZSwgYmVjYXVzZSB0aGVcbiAgLy8gZXNjYXBlIGtleSBoYXMgbXVsdGlwbGUgZnVuY3Rpb25zIGluc2lkZSBhIHJhbmdlIHBpY2tlciAoZWl0aGVyIGNhbmNlbCB0aGUgY3VycmVudCByYW5nZVxuICAvLyBvciBjbG9zZSB0aGUgY2FsZW5kYXIpLiBTaW5jZSB3ZSBkb24ndCBoYXZlIGFjY2VzcyB0byBzZXQgdGhlIElEIG9uIHRoZSBiYWNrZHJvcCBpbiBhbGxcbiAgLy8gY2FzZXMsIHdlIHNldCBhIHVuaXF1ZSBjbGFzcyBpbnN0ZWFkIHdoaWNoIGlzIHRoZSBzYW1lIGFzIHRoZSBjYWxlbmRhcidzIElEIGFuZCBzdWZmaXhlZFxuICAvLyB3aXRoIGAtYmFja2Ryb3BgLlxuICBjb25zdCBiYWNrZHJvcFNlbGVjdG9yID0gYC4ke2F3YWl0IGNhbGVuZGFySWR9LWJhY2tkcm9wYDtcbiAgcmV0dXJuIChhd2FpdCBkb2N1bWVudExvY2F0b3IubG9jYXRvckZvcihiYWNrZHJvcFNlbGVjdG9yKSgpKS5jbGljaygpO1xufVxuXG4vKiogR2V0cyB0aGUgdGVzdCBoYXJuZXNzIGZvciBhIGNhbGVuZGFyIGFzc29jaWF0ZWQgd2l0aCBhIHBhcnRpY3VsYXIgaG9zdC4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYWxlbmRhcihcbiAgZmlsdGVyOiBDYWxlbmRhckhhcm5lc3NGaWx0ZXJzLFxuICBob3N0OiBQcm9taXNlPFRlc3RFbGVtZW50PixcbiAgZG9jdW1lbnRMb2NhdG9yOiBMb2NhdG9yRmFjdG9yeSk6IFByb21pc2U8TWF0Q2FsZW5kYXJIYXJuZXNzPiB7XG4gIGNvbnN0IGNhbGVuZGFySWQgPSBhd2FpdCBnZXRDYWxlbmRhcklkKGhvc3QpO1xuXG4gIGlmICghY2FsZW5kYXJJZCkge1xuICAgIHRocm93IEVycm9yKGBFbGVtZW50IGlzIG5vdCBhc3NvY2lhdGVkIHdpdGggYSBjYWxlbmRhcmApO1xuICB9XG5cbiAgcmV0dXJuIGRvY3VtZW50TG9jYXRvci5sb2NhdG9yRm9yKE1hdENhbGVuZGFySGFybmVzcy53aXRoKHtcbiAgICAuLi5maWx0ZXIsXG4gICAgc2VsZWN0b3I6IGAjJHtjYWxlbmRhcklkfWBcbiAgfSkpKCk7XG59XG4iXX0=