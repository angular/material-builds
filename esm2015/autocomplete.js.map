{"version":3,"file":"autocomplete.js","sources":["../../../src/lib/autocomplete/index.ts","../../../src/lib/autocomplete/autocomplete-module.ts","../../../src/lib/autocomplete/autocomplete-trigger.ts","../../../src/lib/autocomplete/autocomplete.ts"],"sourcesContent":["/**\n * Generated bundle index. Do not edit.\n */\n\nexport {MatAutocompleteSelectedEvent,MatAutocomplete,MatAutocompleteModule,AUTOCOMPLETE_OPTION_HEIGHT,AUTOCOMPLETE_PANEL_HEIGHT,MAT_AUTOCOMPLETE_SCROLL_STRATEGY,MAT_AUTOCOMPLETE_SCROLL_STRATEGY_PROVIDER_FACTORY,MAT_AUTOCOMPLETE_SCROLL_STRATEGY_PROVIDER,MAT_AUTOCOMPLETE_VALUE_ACCESSOR,getMatAutocompleteMissingPanelError,MatAutocompleteTrigger} from './public_api';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {NgModule} from '@angular/core';\nimport {CommonModule} from '@angular/common';\nimport {OverlayModule} from '@angular/cdk/overlay';\nimport {MatOptionModule, MatCommonModule} from '@angular/material/core';\nimport {MatAutocomplete} from './autocomplete';\nimport {\n  MatAutocompleteTrigger,\n  MAT_AUTOCOMPLETE_SCROLL_STRATEGY_PROVIDER,\n} from './autocomplete-trigger';\nexport class MatAutocompleteModule {static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  imports: [MatOptionModule, OverlayModule, MatCommonModule, CommonModule],\n  exports: [MatAutocomplete, MatOptionModule, MatAutocompleteTrigger, MatCommonModule],\n  declarations: [MatAutocomplete, MatAutocompleteTrigger],\n  providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_PROVIDER],\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction MatAutocompleteModule_tsickle_Closure_declarations() {\n/** @type {?} */\nMatAutocompleteModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nMatAutocompleteModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Directionality} from '@angular/cdk/bidi';\nimport {DOWN_ARROW, ENTER, ESCAPE, UP_ARROW, TAB} from '@angular/cdk/keycodes';\nimport {\n  ConnectedPositionStrategy,\n  Overlay,\n  OverlayRef,\n  OverlayConfig,\n  PositionStrategy,\n  RepositionScrollStrategy,\n  ScrollStrategy,\n} from '@angular/cdk/overlay';\nimport {TemplatePortal} from '@angular/cdk/portal';\nimport {filter, first, map, RxChain, switchMap} from '@angular/cdk/rxjs';\nimport {\n  ChangeDetectorRef,\n  Directive,\n  ElementRef,\n  forwardRef,\n  Host,\n  Inject,\n  InjectionToken,\n  Input,\n  NgZone,\n  OnDestroy,\n  Optional,\n  ViewContainerRef,\n} from '@angular/core';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '@angular/forms';\nimport {MatOption, MatOptionSelectionChange} from '@angular/material/core';\nimport {MatFormField} from '@angular/material/form-field';\nimport {DOCUMENT} from '@angular/platform-browser';\nimport {Observable} from 'rxjs/Observable';\nimport {fromEvent} from 'rxjs/observable/fromEvent';\nimport {merge} from 'rxjs/observable/merge';\nimport {of as observableOf} from 'rxjs/observable/of';\nimport {Subscription} from 'rxjs/Subscription';\nimport {MatAutocomplete} from './autocomplete';\n/**\n * The height of each autocomplete option.\n */\nexport const AUTOCOMPLETE_OPTION_HEIGHT = 48;\n/**\n * The total height of the autocomplete panel.\n */\nexport const AUTOCOMPLETE_PANEL_HEIGHT = 256;\n/**\n * Injection token that determines the scroll handling while the autocomplete panel is open.\n */\nexport const MAT_AUTOCOMPLETE_SCROLL_STRATEGY =\n    new InjectionToken<() => ScrollStrategy>('mat-autocomplete-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nexport function MAT_AUTOCOMPLETE_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay: Overlay):\n    () => RepositionScrollStrategy {\n  return () => overlay.scrollStrategies.reposition();\n}\n/**\n * \\@docs-private\n */\nexport const MAT_AUTOCOMPLETE_SCROLL_STRATEGY_PROVIDER = {\n  provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n/**\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * \\@docs-private\n */\nexport const MAT_AUTOCOMPLETE_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatAutocompleteTrigger),\n  multi: true\n};\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n * @return {?}\n */\nexport function getMatAutocompleteMissingPanelError(): Error {\n  return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' +\n               'Make sure that the id passed to the `matAutocomplete` is correct and that ' +\n               'you\\'re attempting to open it after the ngAfterContentInit hook.');\n}\nexport class MatAutocompleteTrigger implements ControlValueAccessor, OnDestroy {\nprivate _overlayRef: OverlayRef | null;\nprivate _portal: TemplatePortal<any>;\nprivate _panelOpen: boolean = false;\n/**\n * Strategy that is used to position the panel.\n */\nprivate _positionStrategy: ConnectedPositionStrategy;\n/**\n * Whether or not the placeholder state is being overridden.\n */\nprivate _manuallyFloatingPlaceholder = false;\n/**\n * The subscription for closing actions (some are bound to document).\n */\nprivate _closingActionsSubscription: Subscription;\n/**\n * View -> model callback called when value changes\n */\n_onChange: (value: any) => void = () => {};\n/**\n * View -> model callback called when autocomplete has been touched\n */\n_onTouched = () => {};\n\n  /* The autocomplete panel to be attached to this trigger. */\n   autocomplete: MatAutocomplete;\n/**\n * @param {?} _element\n * @param {?} _overlay\n * @param {?} _viewContainerRef\n * @param {?} _zone\n * @param {?} _changeDetectorRef\n * @param {?} _scrollStrategy\n * @param {?} _dir\n * @param {?} _formField\n * @param {?} _document\n */\nconstructor(private _element: ElementRef,\nprivate _overlay: Overlay,\nprivate _viewContainerRef: ViewContainerRef,\nprivate _zone: NgZone,\nprivate _changeDetectorRef: ChangeDetectorRef,\nprivate _scrollStrategy,\nprivate _dir: Directionality,\nprivate _formField: MatFormField,\nprivate _document: any) {}\n/**\n * @return {?}\n */\nngOnDestroy() {\n    this._destroyPanel();\n  }\n/**\n * @return {?}\n */\nget panelOpen(): boolean {\n    return this._panelOpen && this.autocomplete.showPanel;\n  }\n/**\n * Opens the autocomplete suggestion panel.\n * @return {?}\n */\nopenPanel(): void {\n    this._attachOverlay();\n    this._floatPlaceholder();\n  }\n/**\n * Closes the autocomplete suggestion panel.\n * @return {?}\n */\nclosePanel(): void {\n    if (this._overlayRef && this._overlayRef.hasAttached()) {\n      this._overlayRef.detach();\n      this._closingActionsSubscription.unsubscribe();\n    }\n\n    this._resetPlaceholder();\n\n    if (this._panelOpen) {\n      this.autocomplete._isOpen = this._panelOpen = false;\n\n      // We need to trigger change detection manually, because\n      // `fromEvent` doesn't seem to do it at the proper time.\n      // This ensures that the placeholder is reset when the\n      // user clicks outside.\n      this._changeDetectorRef.detectChanges();\n    }\n  }\n/**\n * A stream of actions that should close the autocomplete panel, including\n * when an option is selected, on blur, and when TAB is pressed.\n * @return {?}\n */\nget panelClosingActions(): Observable<MatOptionSelectionChange> {\n    return merge(\n      this.optionSelections,\n      this.autocomplete._keyManager.tabOut,\n      this._outsideClickStream\n    );\n  }\n/**\n * Stream of autocomplete option selections.\n * @return {?}\n */\nget optionSelections(): Observable<MatOptionSelectionChange> {\n    return merge(...this.autocomplete.options.map(option => option.onSelectionChange));\n  }\n/**\n * The currently active option, coerced to MatOption type.\n * @return {?}\n */\nget activeOption(): MatOption | null {\n    if (this.autocomplete && this.autocomplete._keyManager) {\n      return this.autocomplete._keyManager.activeItem;\n    }\n\n    return null;\n  }\n/**\n * Stream of clicks outside of the autocomplete panel.\n * @return {?}\n */\nprivate get _outsideClickStream(): Observable<any> {\n    if (!this._document) {\n      return observableOf(null);\n    }\n\n    return RxChain.from(merge(\n      fromEvent(this._document, 'click'),\n      fromEvent(this._document, 'touchend')\n    )).call(filter, (event: MouseEvent | TouchEvent) => {\n      const /** @type {?} */ clickTarget = /** @type {?} */(( event.target as HTMLElement));\n      const /** @type {?} */ formField = this._formField ?\n          this._formField._elementRef.nativeElement : null;\n\n      return this._panelOpen &&\n             clickTarget !== this._element.nativeElement &&\n             (!formField || !formField.contains(clickTarget)) &&\n             (!!this._overlayRef && !this._overlayRef.overlayElement.contains(clickTarget));\n    }).result();\n  }\n/**\n * Sets the autocomplete's value. Part of the ControlValueAccessor interface\n * required to integrate with Angular's core forms API.\n * \n * @param {?} value New value to be written to the model.\n * @return {?}\n */\nwriteValue(value: any): void {\n    Promise.resolve(null).then(() => this._setTriggerValue(value));\n  }\n/**\n * Saves a callback function to be invoked when the autocomplete's value\n * changes from user input. Part of the ControlValueAccessor interface\n * required to integrate with Angular's core forms API.\n * \n * @param {?} fn Callback to be triggered when the value changes.\n * @return {?}\n */\nregisterOnChange(fn: (value: any) => {}): void {\n    this._onChange = fn;\n  }\n/**\n * Saves a callback function to be invoked when the autocomplete is blurred\n * by the user. Part of the ControlValueAccessor interface required\n * to integrate with Angular's core forms API.\n * \n * @param {?} fn Callback to be triggered when the component has been touched.\n * @return {?}\n */\nregisterOnTouched(fn: () => {}) {\n    this._onTouched = fn;\n  }\n/**\n * @param {?} event\n * @return {?}\n */\n_handleKeydown(event: KeyboardEvent): void {\n    const /** @type {?} */ keyCode = event.keyCode;\n\n    if (keyCode === ESCAPE && this.panelOpen) {\n      this._resetActiveItem();\n      this.closePanel();\n      event.stopPropagation();\n    } else if (this.activeOption && keyCode === ENTER && this.panelOpen) {\n      this.activeOption._selectViaInteraction();\n      this._resetActiveItem();\n      event.preventDefault();\n    } else {\n      const /** @type {?} */ prevActiveItem = this.autocomplete._keyManager.activeItem;\n      const /** @type {?} */ isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\n\n      if (this.panelOpen || keyCode === TAB) {\n        this.autocomplete._keyManager.onKeydown(event);\n      } else if (isArrowKey) {\n        this.openPanel();\n      }\n\n      Promise.resolve().then(() => {\n        if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {\n          this._scrollToOption();\n        }\n      });\n    }\n  }\n/**\n * @param {?} event\n * @return {?}\n */\n_handleInput(event: KeyboardEvent): void {\n    // We need to ensure that the input is focused, because IE will fire the `input`\n    // event on focus/blur/load if the input has a placeholder. See:\n    // https://connect.microsoft.com/IE/feedback/details/885747/\n    if (document.activeElement === event.target) {\n      this._onChange(( /** @type {?} */((event.target as HTMLInputElement))).value);\n      this.openPanel();\n    }\n  }\n/**\n * @return {?}\n */\n_handleFocus(): void {\n    if (!this._element.nativeElement.readOnly) {\n      this._attachOverlay();\n      this._floatPlaceholder(true);\n    }\n  }\n/**\n * In \"auto\" mode, the placeholder will animate down as soon as focus is lost.\n * This causes the value to jump when selecting an option with the mouse.\n * This method manually floats the placeholder until the panel can be closed.\n * @param {?=} shouldAnimate Whether the placeholder should be animated when it is floated.\n * @return {?}\n */\nprivate _floatPlaceholder(shouldAnimate = false): void {\n    if (this._formField && this._formField.floatPlaceholder === 'auto') {\n      if (shouldAnimate) {\n        this._formField._animateAndLockPlaceholder();\n      } else {\n        this._formField.floatPlaceholder = 'always';\n      }\n\n      this._manuallyFloatingPlaceholder = true;\n    }\n  }\n/**\n * If the placeholder has been manually elevated, return it to its normal state.\n * @return {?}\n */\nprivate _resetPlaceholder(): void  {\n    if (this._manuallyFloatingPlaceholder) {\n      this._formField.floatPlaceholder = 'auto';\n      this._manuallyFloatingPlaceholder = false;\n    }\n  }\n/**\n * Given that we are not actually focusing active options, we must manually adjust scroll\n * to reveal options below the fold. First, we find the offset of the option from the top\n * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n * the panel height + the option height, so the active option will be just visible at the\n * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n * will become the offset. If that offset is visible within the panel already, the scrollTop is\n * not adjusted.\n * @return {?}\n */\nprivate _scrollToOption(): void {\n    const /** @type {?} */ activeOptionIndex = this.autocomplete._keyManager.activeItemIndex || 0;\n    const /** @type {?} */ labelCount = MatOption.countGroupLabelsBeforeOption(activeOptionIndex,\n        this.autocomplete.options, this.autocomplete.optionGroups);\n    const /** @type {?} */ optionOffset = (activeOptionIndex + labelCount) * AUTOCOMPLETE_OPTION_HEIGHT;\n    const /** @type {?} */ panelTop = this.autocomplete._getScrollTop();\n\n    if (optionOffset < panelTop) {\n      // Scroll up to reveal selected option scrolled above the panel top\n      this.autocomplete._setScrollTop(optionOffset);\n    } else if (optionOffset + AUTOCOMPLETE_OPTION_HEIGHT > panelTop + AUTOCOMPLETE_PANEL_HEIGHT) {\n      // Scroll down to reveal selected option scrolled below the panel bottom\n      const /** @type {?} */ newScrollTop =\n          Math.max(0, optionOffset - AUTOCOMPLETE_PANEL_HEIGHT + AUTOCOMPLETE_OPTION_HEIGHT);\n      this.autocomplete._setScrollTop(newScrollTop);\n    }\n  }\n/**\n * This method listens to a stream of panel closing actions and resets the\n * stream every time the option list changes.\n * @return {?}\n */\nprivate _subscribeToClosingActions(): Subscription {\n    const /** @type {?} */ firstStable = first.call(this._zone.onStable.asObservable());\n    const /** @type {?} */ optionChanges = map.call(this.autocomplete.options.changes, () =>\n      this._positionStrategy.recalculateLastPosition());\n\n    // When the zone is stable initially, and when the option list changes...\n    return RxChain.from(merge(firstStable, optionChanges))\n      // create a new stream of panelClosingActions, replacing any previous streams\n      // that were created, and flatten it so our stream only emits closing events...\n      .call(switchMap, () => {\n        this._resetActiveItem();\n        this.autocomplete._setVisibility();\n        return this.panelClosingActions;\n      })\n      // when the first closing event occurs...\n      .call(first)\n      // set the value, close the panel, and complete.\n      .subscribe(event => this._setValueAndClose(event));\n  }\n/**\n * Destroys the autocomplete suggestion panel.\n * @return {?}\n */\nprivate _destroyPanel(): void {\n    if (this._overlayRef) {\n      this.closePanel();\n      this._overlayRef.dispose();\n      this._overlayRef = null;\n    }\n  }\n/**\n * @param {?} value\n * @return {?}\n */\nprivate _setTriggerValue(value: any): void {\n    const /** @type {?} */ toDisplay = this.autocomplete && this.autocomplete.displayWith ?\n      this.autocomplete.displayWith(value) :\n      value;\n\n    // Simply falling back to an empty string if the display value is falsy does not work properly.\n    // The display value can also be the number zero and shouldn't fall back to an empty string.\n    const /** @type {?} */ inputValue = toDisplay != null ? toDisplay : '';\n\n    // If it's used within a `MatFormField`, we should set it through the property so it can go\n    // through change detection.\n    if (this._formField) {\n      this._formField._control.value = inputValue;\n    } else {\n      this._element.nativeElement.value = inputValue;\n    }\n  }\n/**\n * This method closes the panel, and if a value is specified, also sets the associated\n * control to that value. It will also mark the control as dirty if this interaction\n * stemmed from the user.\n * @param {?} event\n * @return {?}\n */\nprivate _setValueAndClose(event: MatOptionSelectionChange | null): void {\n    if (event && event.source) {\n      this._clearPreviousSelectedOption(event.source);\n      this._setTriggerValue(event.source.value);\n      this._onChange(event.source.value);\n      this._element.nativeElement.focus();\n      this.autocomplete._emitSelectEvent(event.source);\n    }\n\n    this.closePanel();\n  }\n/**\n * Clear any previous selected option and emit a selection change event for this option\n * @param {?} skip\n * @return {?}\n */\nprivate _clearPreviousSelectedOption(skip: MatOption) {\n    this.autocomplete.options.forEach(option => {\n      if (option != skip && option.selected) {\n        option.deselect();\n      }\n    });\n  }\n/**\n * @return {?}\n */\nprivate _attachOverlay(): void {\n    if (!this.autocomplete) {\n      throw getMatAutocompleteMissingPanelError();\n    }\n\n    if (!this._overlayRef) {\n      this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef);\n      this._overlayRef = this._overlay.create(this._getOverlayConfig());\n    } else {\n      /** Update the panel width, in case the host width has changed */\n      this._overlayRef.getConfig().width = this._getHostWidth();\n      this._overlayRef.updateSize();\n    }\n\n    if (this._overlayRef && !this._overlayRef.hasAttached()) {\n      this._overlayRef.attach(this._portal);\n      this._closingActionsSubscription = this._subscribeToClosingActions();\n    }\n\n    this.autocomplete._setVisibility();\n    this.autocomplete._isOpen = this._panelOpen = true;\n  }\n/**\n * @return {?}\n */\nprivate _getOverlayConfig(): OverlayConfig {\n    return new OverlayConfig({\n      positionStrategy: this._getOverlayPosition(),\n      scrollStrategy: this._scrollStrategy(),\n      width: this._getHostWidth(),\n      direction: this._dir ? this._dir.value : 'ltr'\n    });\n  }\n/**\n * @return {?}\n */\nprivate _getOverlayPosition(): PositionStrategy {\n    this._positionStrategy =  this._overlay.position().connectedTo(\n        this._getConnectedElement(),\n        {originX: 'start', originY: 'bottom'}, {overlayX: 'start', overlayY: 'top'})\n        .withFallbackPosition(\n            {originX: 'start', originY: 'top'}, {overlayX: 'start', overlayY: 'bottom'}\n        );\n    return this._positionStrategy;\n  }\n/**\n * @return {?}\n */\nprivate _getConnectedElement(): ElementRef {\n    return this._formField ? this._formField._connectionContainerRef : this._element;\n  }\n/**\n * Returns the width of the input element, so the panel width can match it.\n * @return {?}\n */\nprivate _getHostWidth(): number {\n    return this._getConnectedElement().nativeElement.getBoundingClientRect().width;\n  }\n/**\n * Reset active item to -1 so arrow events will activate the correct options.\n * @return {?}\n */\nprivate _resetActiveItem(): void {\n    this.autocomplete._keyManager.setActiveItem(-1);\n  }\n\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: `input[matAutocomplete], textarea[matAutocomplete]`,\n  host: {\n    'role': 'combobox',\n    'autocomplete': 'off',\n    'aria-autocomplete': 'list',\n    '[attr.aria-activedescendant]': 'activeOption?.id',\n    '[attr.aria-expanded]': 'panelOpen.toString()',\n    '[attr.aria-owns]': 'autocomplete?.id',\n    // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\n    // a little earlier. This avoids issues where IE delays the focusing of the input.\n    '(focusin)': '_handleFocus()',\n    '(blur)': '_onTouched()',\n    '(input)': '_handleInput($event)',\n    '(keydown)': '_handleKeydown($event)',\n  },\n  providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: Overlay, },\n{type: ViewContainerRef, },\n{type: NgZone, },\n{type: ChangeDetectorRef, },\n{type: undefined, decorators: [{ type: Inject, args: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY, ] }, ]},\n{type: Directionality, decorators: [{ type: Optional }, ]},\n{type: MatFormField, decorators: [{ type: Optional }, { type: Host }, ]},\n{type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT, ] }, ]},\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'autocomplete': [{ type: Input, args: ['matAutocomplete', ] },],\n};\n}\n\nfunction MatAutocompleteTrigger_tsickle_Closure_declarations() {\n/** @type {?} */\nMatAutocompleteTrigger.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nMatAutocompleteTrigger.ctorParameters;\n/** @type {?} */\nMatAutocompleteTrigger.propDecorators;\n/** @type {?} */\nMatAutocompleteTrigger.prototype._overlayRef;\n/** @type {?} */\nMatAutocompleteTrigger.prototype._portal;\n/** @type {?} */\nMatAutocompleteTrigger.prototype._panelOpen;\n/**\n * Strategy that is used to position the panel.\n * @type {?}\n */\nMatAutocompleteTrigger.prototype._positionStrategy;\n/**\n * Whether or not the placeholder state is being overridden.\n * @type {?}\n */\nMatAutocompleteTrigger.prototype._manuallyFloatingPlaceholder;\n/**\n * The subscription for closing actions (some are bound to document).\n * @type {?}\n */\nMatAutocompleteTrigger.prototype._closingActionsSubscription;\n/**\n * View -> model callback called when value changes\n * @type {?}\n */\nMatAutocompleteTrigger.prototype._onChange;\n/**\n * View -> model callback called when autocomplete has been touched\n * @type {?}\n */\nMatAutocompleteTrigger.prototype._onTouched;\n/** @type {?} */\nMatAutocompleteTrigger.prototype.autocomplete;\n/** @type {?} */\nMatAutocompleteTrigger.prototype._element;\n/** @type {?} */\nMatAutocompleteTrigger.prototype._overlay;\n/** @type {?} */\nMatAutocompleteTrigger.prototype._viewContainerRef;\n/** @type {?} */\nMatAutocompleteTrigger.prototype._zone;\n/** @type {?} */\nMatAutocompleteTrigger.prototype._changeDetectorRef;\n/** @type {?} */\nMatAutocompleteTrigger.prototype._scrollStrategy;\n/** @type {?} */\nMatAutocompleteTrigger.prototype._dir;\n/** @type {?} */\nMatAutocompleteTrigger.prototype._formField;\n/** @type {?} */\nMatAutocompleteTrigger.prototype._document;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {\n  AfterContentInit,\n  Component,\n  ContentChildren,\n  ElementRef,\n  Input,\n  QueryList,\n  TemplateRef,\n  ViewChild,\n  ViewEncapsulation,\n  ChangeDetectorRef,\n  ChangeDetectionStrategy,\n  EventEmitter,\n  Output,\n} from '@angular/core';\nimport {MatOption, MatOptgroup} from '@angular/material/core';\nimport {ActiveDescendantKeyManager} from '@angular/cdk/a11y';\n/**\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n */\nlet _uniqueAutocompleteIdCounter = 0;\n/**\n * Event object that is emitted when an autocomplete option is selected\n */\nexport class MatAutocompleteSelectedEvent {\n/**\n * @param {?} source\n * @param {?} option\n */\nconstructor(public source: MatAutocomplete,\npublic option: MatOption) { }\n}\n\nfunction MatAutocompleteSelectedEvent_tsickle_Closure_declarations() {\n/** @type {?} */\nMatAutocompleteSelectedEvent.prototype.source;\n/** @type {?} */\nMatAutocompleteSelectedEvent.prototype.option;\n}\n\nexport class MatAutocomplete implements AfterContentInit {\n/**\n * Manages active item in option list based on key events.\n */\n_keyManager: ActiveDescendantKeyManager<MatOption>;\n/**\n * Whether the autocomplete panel should be visible, depending on option length.\n */\nshowPanel = false;\n/**\n * Whether the autocomplete panel is open.\n * @return {?}\n */\nget isOpen(): boolean {\n    return this._isOpen && this.showPanel;\n  }\n  _isOpen: boolean = false;\n/**\n * \\@docs-private\n */\ntemplate: TemplateRef<any>;\n/**\n * Element for the panel containing the autocomplete options.\n */\npanel: ElementRef;\n/**\n * \\@docs-private\n */\noptions: QueryList<MatOption>;\n/**\n * \\@docs-private\n */\noptionGroups: QueryList<MatOptgroup>;\n/**\n * Function that maps an option's control value to its display value in the trigger.\n */\ndisplayWith: ((value: any) => string) | null = null;\n/**\n * Event that is emitted whenever an option from the list is selected.\n */\noptionSelected: EventEmitter<MatAutocompleteSelectedEvent> =\n      new EventEmitter<MatAutocompleteSelectedEvent>();\n/**\n * Takes classes set on the host md-autocomplete element and applies them to the panel\n * inside the overlay container to allow for easy styling.\n * @param {?} classList\n * @return {?}\n */\nset classList(classList: string) {\n    if (classList && classList.length) {\n      classList.split(' ').forEach(className => this._classList[className.trim()] = true);\n      this._elementRef.nativeElement.className = '';\n    }\n  }\n  _classList: {[key: string]: boolean} = {};\n/**\n * Unique ID to be used by autocomplete trigger's \"aria-owns\" property.\n */\nid: string = `mat-autocomplete-${_uniqueAutocompleteIdCounter++}`;\n/**\n * @param {?} _changeDetectorRef\n * @param {?} _elementRef\n */\nconstructor(private _changeDetectorRef: ChangeDetectorRef,\nprivate _elementRef: ElementRef) { }\n/**\n * @return {?}\n */\nngAfterContentInit() {\n    this._keyManager = new ActiveDescendantKeyManager<MatOption>(this.options).withWrap();\n    // Set the initial visibiity state.\n    this._setVisibility();\n  }\n/**\n * Sets the panel scrollTop. This allows us to manually scroll to display options\n * above or below the fold, as they are not actually being focused when active.\n * @param {?} scrollTop\n * @return {?}\n */\n_setScrollTop(scrollTop: number): void {\n    if (this.panel) {\n      this.panel.nativeElement.scrollTop = scrollTop;\n    }\n  }\n/**\n * Returns the panel's scrollTop.\n * @return {?}\n */\n_getScrollTop(): number {\n    return this.panel ? this.panel.nativeElement.scrollTop : 0;\n  }\n/**\n * Panel should hide itself when the option list is empty.\n * @return {?}\n */\n_setVisibility(): void {\n    Promise.resolve().then(() => {\n      this.showPanel = !!this.options.length;\n      this._classList['mat-autocomplete-visible'] = this.showPanel;\n      this._classList['mat-autocomplete-hidden'] = !this.showPanel;\n      this._changeDetectorRef.markForCheck();\n    });\n  }\n/**\n * Emits the `select` event.\n * @param {?} option\n * @return {?}\n */\n_emitSelectEvent(option: MatOption): void {\n    const /** @type {?} */ event = new MatAutocompleteSelectedEvent(this, option);\n    this.optionSelected.emit(event);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Component, args: [{\n  moduleId: module.id,\n  selector: 'mat-autocomplete',\n  templateUrl: 'autocomplete.html',\n  styleUrls: ['autocomplete.css'],\n  encapsulation: ViewEncapsulation.None,\n  preserveWhitespaces: false,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  exportAs: 'matAutocomplete',\n  host: {\n    'class': 'mat-autocomplete'\n  }\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ChangeDetectorRef, },\n{type: ElementRef, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'template': [{ type: ViewChild, args: [TemplateRef, ] },],\n'panel': [{ type: ViewChild, args: ['panel', ] },],\n'options': [{ type: ContentChildren, args: [MatOption, { descendants: true }, ] },],\n'optionGroups': [{ type: ContentChildren, args: [MatOptgroup, ] },],\n'displayWith': [{ type: Input },],\n'optionSelected': [{ type: Output },],\n'classList': [{ type: Input, args: ['class', ] },],\n};\n}\n\nfunction MatAutocomplete_tsickle_Closure_declarations() {\n/** @type {?} */\nMatAutocomplete.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nMatAutocomplete.ctorParameters;\n/** @type {?} */\nMatAutocomplete.propDecorators;\n/**\n * Manages active item in option list based on key events.\n * @type {?}\n */\nMatAutocomplete.prototype._keyManager;\n/**\n * Whether the autocomplete panel should be visible, depending on option length.\n * @type {?}\n */\nMatAutocomplete.prototype.showPanel;\n/** @type {?} */\nMatAutocomplete.prototype._isOpen;\n/**\n * \\@docs-private\n * @type {?}\n */\nMatAutocomplete.prototype.template;\n/**\n * Element for the panel containing the autocomplete options.\n * @type {?}\n */\nMatAutocomplete.prototype.panel;\n/**\n * \\@docs-private\n * @type {?}\n */\nMatAutocomplete.prototype.options;\n/**\n * \\@docs-private\n * @type {?}\n */\nMatAutocomplete.prototype.optionGroups;\n/**\n * Function that maps an option's control value to its display value in the trigger.\n * @type {?}\n */\nMatAutocomplete.prototype.displayWith;\n/**\n * Event that is emitted whenever an option from the list is selected.\n * @type {?}\n */\nMatAutocomplete.prototype.optionSelected;\n/** @type {?} */\nMatAutocomplete.prototype._classList;\n/**\n * Unique ID to be used by autocomplete trigger's \"aria-owns\" property.\n * @type {?}\n */\nMatAutocomplete.prototype.id;\n/** @type {?} */\nMatAutocomplete.prototype._changeDetectorRef;\n/** @type {?} */\nMatAutocomplete.prototype._elementRef;\n}\n\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":["observableOf"],"mappings":"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"}