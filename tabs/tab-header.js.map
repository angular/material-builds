{"version":3,"sources":["tabs/tab-header.ts"],"names":[],"mappings":";;;;;;;;;;;;OAAO,EACL,SAAS,EACT,SAAS,EACT,KAAK,EACL,MAAM,EACN,SAAS,EACT,UAAU,EACV,iBAAiB,EAAE,eAAe,EAAE,MAAM,EAAE,YAAY,EAAE,QAAQ,EACnE,MAAM,eAAe;OACf,EAAC,WAAW,EAAE,UAAU,EAAE,KAAK,EAAE,GAAG,EAAkB,MAAM,SAAS;OACrE,EAAC,iBAAiB,EAAC,MAAM,qBAAqB;OAC9C,EAAC,QAAQ,EAAC,MAAM,WAAW;OAC3B,uBAAuB;OACvB,EAAC,iBAAiB,EAAC,MAAM,+BAA+B;AAS/D;;;GAGG;AACH,IAAM,sBAAsB,GAAG,EAAE,CAAC;AAElC;;;;;GAKG;AAaH;IAmDE,qBAAoB,KAAa,EACb,WAAuB,EACX,IAAS;QAFrB,UAAK,GAAL,KAAK,CAAQ;QACb,gBAAW,GAAX,WAAW,CAAY;QACX,SAAI,GAAJ,IAAI,CAAK;QA9CzC,qCAAqC;QAC7B,gBAAW,GAAW,CAAC,CAAC;QAEhC,mFAAmF;QAC3E,oBAAe,GAAG,CAAC,CAAC;QAE5B,8FAA8F;QACtF,0BAAqB,GAAG,KAAK,CAAC;QAEtC,8DAA8D;QAC9D,4BAAuB,GAAG,KAAK,CAAC;QAEhC,uFAAuF;QACvF,wBAAmB,GAAG,IAAI,CAAC;QAE3B,6FAA6F;QAC7F,yBAAoB,GAAG,IAAI,CAAC;QAWpB,mBAAc,GAAW,CAAC,CAAC;QAWnC,iDAAiD;QACvC,uBAAkB,GAAG,IAAI,YAAY,EAAE,CAAC;QAElD,6CAA6C;QACnC,iBAAY,GAAG,IAAI,YAAY,EAAE,CAAC;IAIA,CAAC;IAhBpC,sBAAI,sCAAa;aAM1B,cAA8B,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;QAP3D,mCAAmC;aAC1B,UAAkB,KAAa;YACtC,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC,cAAc,IAAI,KAAK,CAAC;YAE1D,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;YAC5B,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;QAC3B,CAAC;;;OAAA;IAaD,2CAAqB,GAArB;QACE,iFAAiF;QACjF,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC;YACtD,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACzB,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC;QACnD,CAAC;QAGD,6FAA6F;QAC7F,sBAAsB;QACtB,EAAE,CAAC,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC,CAAC;YAC/B,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;YACzC,IAAI,CAAC,uBAAuB,EAAE,CAAC;YAC/B,IAAI,CAAC,qBAAqB,GAAG,KAAK,CAAC;QACrC,CAAC;QAED,8FAA8F;QAC9F,6CAA6C;QAC7C,EAAE,CAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAAC;YAChC,IAAI,CAAC,wBAAwB,EAAE,CAAC;YAChC,IAAI,CAAC,sBAAsB,GAAG,KAAK,CAAC;QACtC,CAAC;IACH,CAAC;IAED;;;OAGG;IACH,wCAAkB,GAAlB;QAAA,iBAMC;QALC,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC;YAC3B,MAAM,CAAC,qBAAqB,CAAC;gBAC3B,KAAI,CAAC,yBAAyB,EAAE,CAAC;YACnC,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAED,oCAAc,GAAd,UAAe,KAAoB;QACjC,MAAM,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;YACtB,KAAK,WAAW;gBACd,IAAI,CAAC,aAAa,EAAE,CAAC;gBACrB,KAAK,CAAC;YACR,KAAK,UAAU;gBACb,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBACzB,KAAK,CAAC;YACR,KAAK,KAAK;gBACR,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;gBAC9C,KAAK,CAAC;QACV,CAAC;IACH,CAAC;IAED;;OAEG;IACH,uCAAiB,GAAjB;QACE,IAAI,CAAC,uBAAuB,EAAE,CAAC;QAC/B,IAAI,CAAC,uBAAuB,EAAE,CAAC;QAC/B,IAAI,CAAC,wBAAwB,EAAE,CAAC;IAClC,CAAC;IAGD,sBAAI,mCAAU;QASd,mEAAmE;aACnE,cAA2B,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;QAXrD,oFAAoF;aACpF,UAAe,KAAa;YAC1B,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,WAAW,IAAI,KAAK,CAAC,CAAC,CAAC;gBAAC,MAAM,CAAC;YAAC,CAAC;YAExE,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;YACzB,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAE9B,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;QAC3B,CAAC;;;OAAA;IAKD;;;OAGG;IACH,mCAAa,GAAb,UAAc,KAAa;QACzB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;YAAC,MAAM,CAAC,IAAI,CAAC;QAAC,CAAC;QAE1C,IAAM,GAAG,GAAG,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC;QACjD,MAAM,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC;IAC9B,CAAC;IAED;;;OAGG;IACH,kCAAY,GAAZ,UAAa,QAAgB;QAC3B,EAAE,CAAC,CAAC,IAAI,CAAC,uBAAuB,CAAC,CAAC,CAAC;YACjC,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;QAChC,CAAC;QAED,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC;YACtD,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,CAAC,QAAQ,CAAC,CAAC,KAAK,EAAE,CAAC;YAEhD,qFAAqF;YACrF,sFAAsF;YACtF,mDAAmD;YACnD,IAAM,WAAW,GAAG,IAAI,CAAC,iBAAiB,CAAC,aAAa,CAAC;YACzD,IAAM,GAAG,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;YACvC,EAAE,CAAC,CAAC,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC;gBACjB,WAAW,CAAC,UAAU,GAAG,CAAC,CAAC;YAC7B,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,WAAW,CAAC,UAAU,GAAG,WAAW,CAAC,WAAW,GAAG,WAAW,CAAC,WAAW,CAAC;YAC7E,CAAC;QACH,CAAC;IACH,CAAC;IAED;;;OAGG;IACH,gCAAU,GAAV,UAAW,MAAc;QACvB,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;YACxB,IAAM,IAAI,GAAwB,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,CAAC;YAChE,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,UAAU,GAAG,MAAM,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,MAAM,EAAE,CAAC;gBAC9E,EAAE,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC1B,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC;oBACpB,MAAM,CAAC;gBACT,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED,iEAAiE;IACjE,mCAAa,GAAb;QACE,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,mBAAmB,EAAE,IAAI,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IAChE,CAAC;IAED,iEAAiE;IACjE,uCAAiB,GAAjB;QACE,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,mBAAmB,EAAE,IAAI,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IAChE,CAAC;IAED,kDAAkD;IAClD,yCAAmB,GAAnB;QACE,MAAM,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;IAChE,CAAC;IAED,0FAA0F;IAC1F,8CAAwB,GAAxB;QACE,IAAI,UAAU,GAAG,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;QAC5C,EAAE,CAAC,CAAC,IAAI,CAAC,mBAAmB,EAAE,IAAI,KAAK,CAAC,CAAC,CAAC;YACxC,UAAU,GAAG,GAAG,GAAG,UAAU,CAAC;QAChC,CAAC;QAED,iBAAiB,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,EAAE,iBAAe,UAAU,YAAS,CAAC,CAAC;IACrF,CAAC;IAGD,sBAAI,uCAAc;aASlB,cAA+B,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,CAAE,CAAC;QAV9D,2FAA2F;aAC3F,UAAmB,CAAS;YAC1B,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,qBAAqB,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;YAE9E,uFAAuF;YACvF,sCAAsC;YACtC,IAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC;YAEnC,IAAI,CAAC,uBAAuB,EAAE,CAAC;QACjC,CAAC;;;OAAA;IAGD;;;;;;;OAOG;IACH,mCAAa,GAAb,UAAc,SAA0B;QACtC,IAAM,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC,aAAa,CAAC,WAAW,CAAC;QAEpE,4EAA4E;QAC5E,IAAI,CAAC,cAAc,IAAI,CAAC,SAAS,IAAI,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC;IAC3E,CAAC;IAED;;;;;OAKG;IACH,oCAAc,GAAd,UAAe,UAAkB;QAC/B,IAAM,aAAa,GAAG,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,CAAC,UAAU,CAAC,CAAC;QAChE,EAAE,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;YAAC,MAAM,CAAC;QAAC,CAAC;QAE/B,0DAA0D;QAC1D,IAAM,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC,aAAa,CAAC,WAAW,CAAC;QAEpE,IAAI,cAAsB,EAAE,aAAqB,CAAC;QAClD,EAAE,CAAC,CAAC,IAAI,CAAC,mBAAmB,EAAE,IAAI,KAAK,CAAC,CAAC,CAAC;YACxC,cAAc,GAAG,aAAa,CAAC,aAAa,EAAE,CAAC;YAC/C,aAAa,GAAG,cAAc,GAAG,aAAa,CAAC,cAAc,EAAE,CAAC;QAClE,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,aAAa,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,WAAW,GAAG,aAAa,CAAC,aAAa,EAAE,CAAC;YACxF,cAAc,GAAG,aAAa,GAAG,aAAa,CAAC,cAAc,EAAE,CAAC;QAClE,CAAC;QAED,IAAM,gBAAgB,GAAG,IAAI,CAAC,cAAc,CAAC;QAC7C,IAAM,eAAe,GAAG,IAAI,CAAC,cAAc,GAAG,UAAU,CAAC;QAEzD,EAAE,CAAC,CAAC,cAAc,GAAG,gBAAgB,CAAC,CAAC,CAAC;YACtC,sDAAsD;YACtD,IAAI,CAAC,cAAc,IAAI,gBAAgB,GAAG,cAAc,GAAG,sBAAsB,CAAC;QACpF,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,aAAa,GAAG,eAAe,CAAC,CAAC,CAAC;YAC3C,qDAAqD;YACrD,IAAI,CAAC,cAAc,IAAI,aAAa,GAAG,eAAe,GAAG,sBAAsB,CAAC;QAClF,CAAC;IACH,CAAC;IAED;;;;;;;OAOG;IACH,6CAAuB,GAAvB;QACE,IAAI,CAAC,uBAAuB;YACxB,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,WAAW,CAAC;QAEzF,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,uBAAuB,CAAC,CAAC,CAAC;YAClC,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC;QAC1B,CAAC;IACH,CAAC;IAED;;;;;;;;OAQG;IACH,6CAAuB,GAAvB;QACE,sDAAsD;QACtD,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,cAAc,IAAI,CAAC,CAAC;QACrD,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,qBAAqB,EAAE,CAAC;IACjF,CAAC;IAED;;;;;;OAMG;IACH,2CAAqB,GAArB;QACE,IAAM,eAAe,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,WAAW,CAAC;QAChE,IAAM,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC,aAAa,CAAC,WAAW,CAAC;QACpE,MAAM,CAAC,eAAe,GAAG,UAAU,CAAC;IACtC,CAAC;IAED,qEAAqE;IAC7D,+CAAyB,GAAjC;QACE,IAAM,oBAAoB,GAAG,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM;cACxE,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,UAAU,CAAC,aAAa;cAC1E,IAAI,CAAC;QACX,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,oBAAoB,CAAC,CAAC;IACpD,CAAC;IA3TD;QAAC,eAAe,CAAC,iBAAiB,CAAC;;uDAAA;IAEnC;QAAC,SAAS,CAAC,QAAQ,CAAC;;gDAAA;IACpB;QAAC,SAAS,CAAC,kBAAkB,CAAC;;0DAAA;IAC9B;QAAC,SAAS,CAAC,SAAS,CAAC;;iDAAA;IAgCrB;QAAC,KAAK,EAAE;;;oDAAA;IASR;QAAC,MAAM,EAAE;;2DAAA;IAGT;QAAC,MAAM,EAAE;;qDAAA;IA7DX;QAAC,SAAS,CAAC;YACT,QAAQ,EAAE,MAAM,CAAC,EAAE;YACnB,QAAQ,EAAE,eAAe;YACzB,WAAW,EAAE,iBAAiB;YAC9B,SAAS,EAAE,CAAC,gBAAgB,CAAC;YAC7B,aAAa,EAAE,iBAAiB,CAAC,IAAI;YACrC,IAAI,EAAE;gBACJ,OAAO,EAAE,eAAe;gBACxB,mDAAmD,EAAE,yBAAyB;gBAC9E,2BAA2B,EAAE,gCAAgC;aAC9D;SACF,CAAC;mBAsDa,QAAQ,EAAE;;mBAtDvB;IA8TF,kBAAC;AAAD,CA7TA,AA6TC,IAAA","file":"tab-header.js","sourcesContent":["import {\n  ViewChild,\n  Component,\n  Input,\n  NgZone,\n  QueryList,\n  ElementRef,\n  ViewEncapsulation, ContentChildren, Output, EventEmitter, Optional\n} from '@angular/core';\nimport {RIGHT_ARROW, LEFT_ARROW, ENTER, Dir, LayoutDirection} from '../core';\nimport {MdTabLabelWrapper} from './tab-label-wrapper';\nimport {MdInkBar} from './ink-bar';\nimport 'rxjs/add/operator/map';\nimport {applyCssTransform} from '../core/style/apply-transform';\n\n/**\n * The directions that scrolling can go in when the header's tabs exceed the header width. 'After'\n * will scroll the header towards the end of the tabs list and 'before' will scroll towards the\n * beginning of the list.\n */\nexport type ScrollDirection = 'after' | 'before';\n\n/**\n * The distance in pixels that will be overshot when scrolling a tab label into view. This helps\n * provide a small affordance to the label next to it.\n */\nconst EXAGGERATED_OVERSCROLL = 60;\n\n/**\n * The header of the tab group which displays a list of all the tabs in the tab group. Includes\n * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the\n * width of the header container, then arrows will be displayed to allow the user to scroll\n * left and right across the header.\n */\n@Component({\n  moduleId: module.id,\n  selector: 'md-tab-header',\n  templateUrl: 'tab-header.html',\n  styleUrls: ['tab-header.css'],\n  encapsulation: ViewEncapsulation.None,\n  host: {\n    'class': 'md-tab-header',\n    '[class.md-tab-header-pagination-controls-enabled]': '_showPaginationControls',\n    '[class.md-tab-header-rtl]': \"_getLayoutDirection() == 'rtl'\",\n  }\n})\nexport class MdTabHeader {\n  @ContentChildren(MdTabLabelWrapper) _labelWrappers: QueryList<MdTabLabelWrapper>;\n\n  @ViewChild(MdInkBar) _inkBar: MdInkBar;\n  @ViewChild('tabListContainer') _tabListContainer: ElementRef;\n  @ViewChild('tabList') _tabList: ElementRef;\n\n  /** The tab index that is focused. */\n  private _focusIndex: number = 0;\n\n  /** The distance in pixels that the tab labels should be translated to the left. */\n  private _scrollDistance = 0;\n\n  /** Whether the header should scroll to the selected index after the view has been checked. */\n  private _selectedIndexChanged = false;\n\n  /** Whether the controls for pagination should be displayed */\n  _showPaginationControls = false;\n\n  /** Whether the tab list can be scrolled more towards the end of the tab label list. */\n  _disableScrollAfter = true;\n\n  /** Whether the tab list can be scrolled more towards the beginning of the tab label list. */\n  _disableScrollBefore = true;\n\n  /**\n   * The number of tab labels that are displayed on the header. When this changes, the header\n   * should re-evaluate the scroll position.\n   */\n  private _tabLabelCount: number;\n\n  /** Whether the scroll distance has changed and should be applied after the view is checked. */\n  private _scrollDistanceChanged: boolean;\n\n  private _selectedIndex: number = 0;\n\n  /** The index of the active tab. */\n  @Input() set selectedIndex(value: number) {\n    this._selectedIndexChanged = this._selectedIndex != value;\n\n    this._selectedIndex = value;\n    this._focusIndex = value;\n  }\n  get selectedIndex(): number { return this._selectedIndex; }\n\n  /** Event emitted when the option is selected. */\n  @Output() selectFocusedIndex = new EventEmitter();\n\n  /** Event emitted when a label is focused. */\n  @Output() indexFocused = new EventEmitter();\n\n  constructor(private _zone: NgZone,\n              private _elementRef: ElementRef,\n              @Optional() private _dir: Dir) {}\n\n  ngAfterContentChecked(): void {\n    // If the number of tab labels have changed, check if scrolling should be enabled\n    if (this._tabLabelCount != this._labelWrappers.length) {\n      this._updatePagination();\n      this._tabLabelCount = this._labelWrappers.length;\n    }\n\n\n    // If the selected index has changed, scroll to the label and check if the scrolling controls\n    // should be disabled.\n    if (this._selectedIndexChanged) {\n      this._scrollToLabel(this._selectedIndex);\n      this._checkScrollingControls();\n      this._selectedIndexChanged = false;\n    }\n\n    // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\n    // then translate the header to reflect this.\n    if (this._scrollDistanceChanged) {\n      this._updateTabScrollPosition();\n      this._scrollDistanceChanged = false;\n    }\n  }\n\n  /**\n   * Waits one frame for the view to update, then updates the ink bar and scroll.\n   * Note: This must be run outside of the zone or it will create an infinite change detection loop.\n   */\n  ngAfterViewChecked(): void {\n    this._zone.runOutsideAngular(() => {\n      window.requestAnimationFrame(() => {\n        this._alignInkBarToSelectedTab();\n      });\n    });\n  }\n\n  _handleKeydown(event: KeyboardEvent) {\n    switch (event.keyCode) {\n      case RIGHT_ARROW:\n        this._focusNextTab();\n        break;\n      case LEFT_ARROW:\n        this._focusPreviousTab();\n        break;\n      case ENTER:\n        this.selectFocusedIndex.emit(this.focusIndex);\n        break;\n    }\n  }\n\n  /**\n   * Updating the view whether pagination should be enabled or not\n   */\n  _updatePagination() {\n    this._checkPaginationEnabled();\n    this._checkScrollingControls();\n    this._updateTabScrollPosition();\n  }\n\n  /** When the focus index is set, we must manually send focus to the correct label */\n  set focusIndex(value: number) {\n    if (!this._isValidIndex(value) || this._focusIndex == value) { return; }\n\n    this._focusIndex = value;\n    this.indexFocused.emit(value);\n\n    this._setTabFocus(value);\n  }\n\n  /** Tracks which element has focus; used for keyboard navigation */\n  get focusIndex(): number { return this._focusIndex; }\n\n  /**\n   * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n   * providing a valid index and return true.\n   */\n  _isValidIndex(index: number): boolean {\n    if (!this._labelWrappers) { return true; }\n\n    const tab = this._labelWrappers.toArray()[index];\n    return tab && !tab.disabled;\n  }\n\n  /**\n   * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n   * scrolling is enabled.\n   */\n  _setTabFocus(tabIndex: number) {\n    if (this._showPaginationControls) {\n      this._scrollToLabel(tabIndex);\n    }\n\n    if (this._labelWrappers && this._labelWrappers.length) {\n      this._labelWrappers.toArray()[tabIndex].focus();\n\n      // Do not let the browser manage scrolling to focus the element, this will be handled\n      // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width\n      // should be the full width minus the offset width.\n      const containerEl = this._tabListContainer.nativeElement;\n      const dir = this._getLayoutDirection();\n      if (dir == 'ltr') {\n        containerEl.scrollLeft = 0;\n      } else {\n        containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;\n      }\n    }\n  }\n\n  /**\n   * Moves the focus towards the beginning or the end of the list depending on the offset provided.\n   * Valid offsets are 1 and -1.\n   */\n  _moveFocus(offset: number) {\n    if (this._labelWrappers) {\n      const tabs: MdTabLabelWrapper[] = this._labelWrappers.toArray();\n      for (let i = this.focusIndex + offset; i < tabs.length && i >= 0; i += offset) {\n        if (this._isValidIndex(i)) {\n          this.focusIndex = i;\n          return;\n        }\n      }\n    }\n  }\n\n  /** Increment the focus index by 1 until a valid tab is found. */\n  _focusNextTab(): void {\n    this._moveFocus(this._getLayoutDirection() == 'ltr' ? 1 : -1);\n  }\n\n  /** Decrement the focus index by 1 until a valid tab is found. */\n  _focusPreviousTab(): void {\n    this._moveFocus(this._getLayoutDirection() == 'ltr' ? -1 : 1);\n  }\n\n  /** The layout direction of the containing app. */\n  _getLayoutDirection(): LayoutDirection {\n    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n  }\n\n  /** Performs the CSS transformation on the tab list that will cause the list to scroll. */\n  _updateTabScrollPosition() {\n    let translateX = this.scrollDistance + 'px';\n    if (this._getLayoutDirection() == 'ltr') {\n      translateX = '-' + translateX;\n    }\n\n    applyCssTransform(this._tabList.nativeElement, `translate3d(${translateX}, 0, 0)`);\n  }\n\n  /** Sets the distance in pixels that the tab header should be transformed in the X-axis. */\n  set scrollDistance(v: number) {\n    this._scrollDistance = Math.max(0, Math.min(this._getMaxScrollDistance(), v));\n\n    // Mark that the scroll distance has changed so that after the view is checked, the CSS\n    // transformation can move the header.\n    this._scrollDistanceChanged = true;\n\n    this._checkScrollingControls();\n  }\n  get scrollDistance(): number { return this._scrollDistance;  }\n\n  /**\n   * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n   * the end of the list, respectively). The distance to scroll is computed to be a third of the\n   * length of the tab list view window.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   */\n  _scrollHeader(scrollDir: ScrollDirection) {\n    const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n\n    // Move the scroll distance one-third the length of the tab list's viewport.\n    this.scrollDistance += (scrollDir == 'before' ? -1 : 1) * viewLength / 3;\n  }\n\n  /**\n   * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   */\n  _scrollToLabel(labelIndex: number) {\n    const selectedLabel = this._labelWrappers.toArray()[labelIndex];\n    if (!selectedLabel) { return; }\n\n    // The view length is the visible width of the tab labels.\n    const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n\n    let labelBeforePos: number, labelAfterPos: number;\n    if (this._getLayoutDirection() == 'ltr') {\n      labelBeforePos = selectedLabel.getOffsetLeft();\n      labelAfterPos = labelBeforePos + selectedLabel.getOffsetWidth();\n    } else {\n      labelAfterPos = this._tabList.nativeElement.offsetWidth - selectedLabel.getOffsetLeft();\n      labelBeforePos = labelAfterPos - selectedLabel.getOffsetWidth();\n    }\n\n    const beforeVisiblePos = this.scrollDistance;\n    const afterVisiblePos = this.scrollDistance + viewLength;\n\n    if (labelBeforePos < beforeVisiblePos) {\n      // Scroll header to move label to the before direction\n      this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;\n    } else if (labelAfterPos > afterVisiblePos) {\n      // Scroll header to move label to the after direction\n      this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;\n    }\n  }\n\n  /**\n   * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n   * tab list is wider than the size of the header container, then the pagination controls should\n   * be shown.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   */\n  _checkPaginationEnabled() {\n    this._showPaginationControls =\n        this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;\n\n    if (!this._showPaginationControls) {\n      this.scrollDistance = 0;\n    }\n  }\n\n  /**\n   * Evaluate whether the before and after controls should be enabled or disabled.\n   * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n   * before button. If the header is at the end of the list (scroll distance is equal to the\n   * maximum distance we can scroll), then disable the after button.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   */\n  _checkScrollingControls() {\n    // Check if the pagination arrows should be activated.\n    this._disableScrollBefore = this.scrollDistance == 0;\n    this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();\n  }\n\n  /**\n   * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n   * is equal to the difference in width between the tab list container and tab header container.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   */\n  _getMaxScrollDistance(): number {\n    const lengthOfTabList = this._tabList.nativeElement.scrollWidth;\n    const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n    return lengthOfTabList - viewLength;\n  }\n\n  /** Tells the ink-bar to align itself to the current label wrapper */\n  private _alignInkBarToSelectedTab(): void {\n    const selectedLabelWrapper = this._labelWrappers && this._labelWrappers.length\n        ? this._labelWrappers.toArray()[this.selectedIndex].elementRef.nativeElement\n        : null;\n    this._inkBar.alignToElement(selectedLabelWrapper);\n  }\n}\n"]}