{
  "version": 3,
  "sources": ["../../../../../../../../node_modules/picocolors/picocolors.js", "../../../../../../../../node_modules/postcss/lib/tokenize.js", "../../../../../../../../node_modules/postcss/lib/terminal-highlight.js", "../../../../../../../../node_modules/postcss/lib/css-syntax-error.js", "../../../../../../../../node_modules/postcss/lib/symbols.js", "../../../../../../../../node_modules/postcss/lib/stringifier.js", "../../../../../../../../node_modules/postcss/lib/stringify.js", "../../../../../../../../node_modules/postcss/lib/node.js", "../../../../../../../../node_modules/postcss/lib/declaration.js", "../../../../../../../../node_modules/source-map-js/lib/base64.js", "../../../../../../../../node_modules/source-map-js/lib/base64-vlq.js", "../../../../../../../../node_modules/source-map-js/lib/util.js", "../../../../../../../../node_modules/source-map-js/lib/array-set.js", "../../../../../../../../node_modules/source-map-js/lib/mapping-list.js", "../../../../../../../../node_modules/source-map-js/lib/source-map-generator.js", "../../../../../../../../node_modules/source-map-js/lib/binary-search.js", "../../../../../../../../node_modules/source-map-js/lib/quick-sort.js", "../../../../../../../../node_modules/source-map-js/lib/source-map-consumer.js", "../../../../../../../../node_modules/source-map-js/lib/source-node.js", "../../../../../../../../node_modules/source-map-js/source-map.js", "../../../../../../../../node_modules/nanoid/non-secure/index.cjs", "../../../../../../../../node_modules/postcss/lib/previous-map.js", "../../../../../../../../node_modules/postcss/lib/input.js", "../../../../../../../../node_modules/postcss/lib/map-generator.js", "../../../../../../../../node_modules/postcss/lib/comment.js", "../../../../../../../../node_modules/postcss/lib/container.js", "../../../../../../../../node_modules/postcss/lib/document.js", "../../../../../../../../node_modules/postcss/lib/warn-once.js", "../../../../../../../../node_modules/postcss/lib/warning.js", "../../../../../../../../node_modules/postcss/lib/result.js", "../../../../../../../../node_modules/postcss/lib/at-rule.js", "../../../../../../../../node_modules/postcss/lib/root.js", "../../../../../../../../node_modules/postcss/lib/list.js", "../../../../../../../../node_modules/postcss/lib/rule.js", "../../../../../../../../node_modules/postcss/lib/parser.js", "../../../../../../../../node_modules/postcss/lib/parse.js", "../../../../../../../../node_modules/postcss/lib/lazy-result.js", "../../../../../../../../node_modules/postcss/lib/no-work-result.js", "../../../../../../../../node_modules/postcss/lib/processor.js", "../../../../../../../../node_modules/postcss/lib/fromJSON.js", "../../../../../../../../node_modules/postcss/lib/postcss.js", "../../../../../../../../node_modules/postcss-scss/lib/scss-stringifier.js", "../../../../../../../../node_modules/postcss-scss/lib/scss-stringify.js", "../../../../../../../../node_modules/postcss-scss/lib/nested-declaration.js", "../../../../../../../../node_modules/postcss-scss/lib/scss-tokenize.js", "../../../../../../../../node_modules/postcss-scss/lib/scss-parser.js", "../../../../../../../../node_modules/postcss-scss/lib/scss-parse.js", "../../../../../../../../node_modules/postcss-scss/lib/scss-syntax.js", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/index.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/style-migrator.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/autocomplete/autocomplete-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/button/button-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/card/card-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/template-migrator.ts", "../../../../../../../../../../packages/compiler/src/ml_parser/tags.ts", "../../../../../../../../../../packages/compiler/src/ml_parser/html_tags.ts", "../../../../../../../../../../packages/compiler/src/selector.ts", "../../../../../../../../../../packages/compiler/src/core.ts", "../../../../../../../../../../packages/compiler/src/util.ts", "../../../../../../../../../../packages/compiler/src/i18n/big_integer.ts", "../../../../../../../../../../packages/compiler/src/i18n/digest.ts", "../../../../../../../../../../packages/compiler/src/output/output_ast.ts", "../../../../../../../../../../packages/compiler/src/constant_pool.ts", "../../../../../../../../../../packages/compiler/src/render3/r3_identifiers.ts", "../../../../../../../../../../packages/compiler/src/output/source_map.ts", "../../../../../../../../../../packages/compiler/src/output/abstract_emitter.ts", "../../../../../../../../../../packages/compiler/src/render3/util.ts", "../../../../../../../../../../packages/compiler/src/render3/r3_factory.ts", "../../../../../../../../../../packages/compiler/src/render3/r3_ast.ts", "../../../../../../../../../../packages/compiler/src/i18n/i18n_ast.ts", "../../../../../../../../../../packages/compiler/src/i18n/serializers/serializer.ts", "../../../../../../../../../../packages/compiler/src/i18n/serializers/xml_helper.ts", "../../../../../../../../../../packages/compiler/src/i18n/serializers/xmb.ts", "../../../../../../../../../../packages/compiler/src/render3/view/i18n/util.ts", "../../../../../../../../../../packages/compiler/src/render3/view/util.ts", "../../../../../../../../../../packages/compiler/src/injectable_compiler_2.ts", "../../../../../../../../../../packages/compiler/src/assertions.ts", "../../../../../../../../../../packages/compiler/src/ml_parser/interpolation_config.ts", "../../../../../../../../../../packages/compiler/src/chars.ts", "../../../../../../../../../../packages/compiler/src/parse_util.ts", "../../../../../../../../../../packages/compiler/src/output/abstract_js_emitter.ts", "../../../../../../../../../../packages/compiler/src/output/output_jit_trusted_types.ts", "../../../../../../../../../../packages/compiler/src/output/output_jit.ts", "../../../../../../../../../../packages/compiler/src/render3/r3_injector_compiler.ts", "../../../../../../../../../../packages/compiler/src/render3/r3_jit.ts", "../../../../../../../../../../packages/compiler/src/render3/r3_module_compiler.ts", "../../../../../../../../../../packages/compiler/src/render3/r3_pipe_compiler.ts", "../../../../../../../../../../packages/compiler/src/render3/view/api.ts", "../../../../../../../../../../packages/compiler/src/expression_parser/ast.ts", "../../../../../../../../../../packages/compiler/src/compiler_util/expression_converter.ts", "../../../../../../../../../../packages/compiler/src/schema/dom_security_schema.ts", "../../../../../../../../../../packages/compiler/src/shadow_css.ts", "../../../../../../../../../../packages/compiler/src/render3/view/style_parser.ts", "../../../../../../../../../../packages/compiler/src/render3/view/styling_builder.ts", "../../../../../../../../../../packages/compiler/src/expression_parser/lexer.ts", "../../../../../../../../../../packages/compiler/src/expression_parser/parser.ts", "../../../../../../../../../../packages/compiler/src/ml_parser/ast.ts", "../../../../../../../../../../packages/compiler/src/ml_parser/entities.ts", "../../../../../../../../../../packages/compiler/src/ml_parser/lexer.ts", "../../../../../../../../../../packages/compiler/src/ml_parser/parser.ts", "../../../../../../../../../../packages/compiler/src/ml_parser/html_parser.ts", "../../../../../../../../../../packages/compiler/src/ml_parser/html_whitespaces.ts", "../../../../../../../../../../packages/compiler/src/output/map_util.ts", "../../../../../../../../../../packages/compiler/src/schema/element_schema_registry.ts", "../../../../../../../../../../packages/compiler/src/schema/dom_element_schema_registry.ts", "../../../../../../../../../../packages/compiler/src/schema/trusted_types_sinks.ts", "../../../../../../../../../../packages/compiler/src/template_parser/binding_parser.ts", "../../../../../../../../../../packages/compiler/src/style_url_resolver.ts", "../../../../../../../../../../packages/compiler/src/template_parser/template_preparser.ts", "../../../../../../../../../../packages/compiler/src/render3/r3_template_transform.ts", "../../../../../../../../../../packages/compiler/src/render3/view/i18n/context.ts", "../../../../../../../../../../packages/compiler/src/render3/view/i18n/icu_serializer.ts", "../../../../../../../../../../packages/compiler/src/i18n/serializers/placeholder.ts", "../../../../../../../../../../packages/compiler/src/i18n/i18n_parser.ts", "../../../../../../../../../../packages/compiler/src/i18n/parse_util.ts", "../../../../../../../../../../packages/compiler/src/render3/view/i18n/meta.ts", "../../../../../../../../../../packages/compiler/src/render3/view/i18n/get_msg_utils.ts", "../../../../../../../../../../packages/compiler/src/render3/view/i18n/localize_utils.ts", "../../../../../../../../../../packages/compiler/src/render3/view/template.ts", "../../../../../../../../../../packages/compiler/src/render3/view/compiler.ts", "../../../../../../../../../../packages/compiler/src/resource_loader.ts", "../../../../../../../../../../packages/compiler/src/jit_compiler_facade.ts", "../../../../../../../../../../packages/compiler/src/version.ts", "../../../../../../../../../../packages/compiler/src/config.ts", "../../../../../../../../../../packages/compiler/src/i18n/extractor_merger.ts", "../../../../../../../../../../packages/compiler/src/ml_parser/xml_tags.ts", "../../../../../../../../../../packages/compiler/src/ml_parser/xml_parser.ts", "../../../../../../../../../../packages/compiler/src/i18n/serializers/xliff.ts", "../../../../../../../../../../packages/compiler/src/i18n/serializers/xliff2.ts", "../../../../../../../../../../packages/compiler/src/i18n/serializers/xtb.ts", "../../../../../../../../../../packages/compiler/src/i18n/translation_bundle.ts", "../../../../../../../../../../packages/compiler/src/i18n/i18n_html_parser.ts", "../../../../../../../../../../packages/compiler/src/i18n/message_bundle.ts", "../../../../../../../../../../packages/compiler/src/i18n/index.ts", "../../../../../../../../../../packages/compiler/src/render3/partial/api.ts", "../../../../../../../../../../packages/compiler/src/render3/view/t2_binder.ts", "../../../../../../../../../../packages/compiler/src/render3/r3_class_metadata_compiler.ts", "../../../../../../../../../../packages/compiler/src/render3/partial/class_metadata.ts", "../../../../../../../../../../packages/compiler/src/render3/partial/util.ts", "../../../../../../../../../../packages/compiler/src/render3/partial/directive.ts", "../../../../../../../../../../packages/compiler/src/render3/partial/component.ts", "../../../../../../../../../../packages/compiler/src/render3/partial/factory.ts", "../../../../../../../../../../packages/compiler/src/render3/partial/injectable.ts", "../../../../../../../../../../packages/compiler/src/render3/partial/injector.ts", "../../../../../../../../../../packages/compiler/src/render3/partial/ng_module.ts", "../../../../../../../../../../packages/compiler/src/render3/partial/pipe.ts", "../../../../../../../../../../packages/compiler/src/compiler.ts", "../../../../../../../../../../packages/compiler/public_api.ts", "../../../../../../../../../../packages/compiler/compiler.ts", "../../../../../../../../../../packages/compiler/index.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/tree-traversal.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/card/card-template.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/checkbox/checkbox-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/chips/chips-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/chips/chips-template.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/dialog/dialog-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/form-field/form-field-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/input/input-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/list/list-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/menu/menu-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/paginator/paginator-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/progress-bar/progress-bar-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/progress-spinner/progress-spinner-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/radio/radio-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/select/select-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/slide-toggle/slide-toggle-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/slider/slider-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/snack-bar/snack-bar-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/table/table-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/tabs/tabs-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/tooltip/tooltip-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/optgroup/optgroup-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/option/option-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/form-field/form-field-template.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/slider/slider-template.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/typography-hierarchy/constants.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/typography-hierarchy/typography-hierarchy-template.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/components/typography-hierarchy/typography-hierarchy-styles.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/index.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/ts-migration/runtime-migration.ts", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/theming-styles.ts", "../../../../../../../../node_modules/postcss/lib/postcss.mjs", "../../../../../../../../node_modules/postcss-scss/lib/scss-syntax.mjs", "../../../../../../../../src/material/schematics/ng-generate/mdc-migration/rules/template-migration.ts", "../../../../../../../../src/material/schematics/migration-utilities/typescript/import-operations.ts", "../../../../../../../../src/material/schematics/migration-utilities/update.ts", "../../../../../../../../src/material/schematics/migration-utilities/index.ts"],
  "sourcesContent": ["let tty = require(\"tty\")\n\nlet isColorSupported =\n\t!(\"NO_COLOR\" in process.env || process.argv.includes(\"--no-color\")) &&\n\t(\"FORCE_COLOR\" in process.env ||\n\t\tprocess.argv.includes(\"--color\") ||\n\t\tprocess.platform === \"win32\" ||\n\t\t(tty.isatty(1) && process.env.TERM !== \"dumb\") ||\n\t\t\"CI\" in process.env)\n\nlet formatter =\n\t(open, close, replace = open) =>\n\tinput => {\n\t\tlet string = \"\" + input\n\t\tlet index = string.indexOf(close, open.length)\n\t\treturn ~index\n\t\t\t? open + replaceClose(string, close, replace, index) + close\n\t\t\t: open + string + close\n\t}\n\nlet replaceClose = (string, close, replace, index) => {\n\tlet start = string.substring(0, index) + replace\n\tlet end = string.substring(index + close.length)\n\tlet nextIndex = end.indexOf(close)\n\treturn ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end\n}\n\nlet createColors = (enabled = isColorSupported) => ({\n\tisColorSupported: enabled,\n\treset: enabled ? s => `\\x1b[0m${s}\\x1b[0m` : String,\n\tbold: enabled ? formatter(\"\\x1b[1m\", \"\\x1b[22m\", \"\\x1b[22m\\x1b[1m\") : String,\n\tdim: enabled ? formatter(\"\\x1b[2m\", \"\\x1b[22m\", \"\\x1b[22m\\x1b[2m\") : String,\n\titalic: enabled ? formatter(\"\\x1b[3m\", \"\\x1b[23m\") : String,\n\tunderline: enabled ? formatter(\"\\x1b[4m\", \"\\x1b[24m\") : String,\n\tinverse: enabled ? formatter(\"\\x1b[7m\", \"\\x1b[27m\") : String,\n\thidden: enabled ? formatter(\"\\x1b[8m\", \"\\x1b[28m\") : String,\n\tstrikethrough: enabled ? formatter(\"\\x1b[9m\", \"\\x1b[29m\") : String,\n\tblack: enabled ? formatter(\"\\x1b[30m\", \"\\x1b[39m\") : String,\n\tred: enabled ? formatter(\"\\x1b[31m\", \"\\x1b[39m\") : String,\n\tgreen: enabled ? formatter(\"\\x1b[32m\", \"\\x1b[39m\") : String,\n\tyellow: enabled ? formatter(\"\\x1b[33m\", \"\\x1b[39m\") : String,\n\tblue: enabled ? formatter(\"\\x1b[34m\", \"\\x1b[39m\") : String,\n\tmagenta: enabled ? formatter(\"\\x1b[35m\", \"\\x1b[39m\") : String,\n\tcyan: enabled ? formatter(\"\\x1b[36m\", \"\\x1b[39m\") : String,\n\twhite: enabled ? formatter(\"\\x1b[37m\", \"\\x1b[39m\") : String,\n\tgray: enabled ? formatter(\"\\x1b[90m\", \"\\x1b[39m\") : String,\n\tbgBlack: enabled ? formatter(\"\\x1b[40m\", \"\\x1b[49m\") : String,\n\tbgRed: enabled ? formatter(\"\\x1b[41m\", \"\\x1b[49m\") : String,\n\tbgGreen: enabled ? formatter(\"\\x1b[42m\", \"\\x1b[49m\") : String,\n\tbgYellow: enabled ? formatter(\"\\x1b[43m\", \"\\x1b[49m\") : String,\n\tbgBlue: enabled ? formatter(\"\\x1b[44m\", \"\\x1b[49m\") : String,\n\tbgMagenta: enabled ? formatter(\"\\x1b[45m\", \"\\x1b[49m\") : String,\n\tbgCyan: enabled ? formatter(\"\\x1b[46m\", \"\\x1b[49m\") : String,\n\tbgWhite: enabled ? formatter(\"\\x1b[47m\", \"\\x1b[49m\") : String,\n})\n\nmodule.exports = createColors()\nmodule.exports.createColors = createColors\n", "'use strict'\n\nconst SINGLE_QUOTE = \"'\".charCodeAt(0)\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0)\nconst BACKSLASH = '\\\\'.charCodeAt(0)\nconst SLASH = '/'.charCodeAt(0)\nconst NEWLINE = '\\n'.charCodeAt(0)\nconst SPACE = ' '.charCodeAt(0)\nconst FEED = '\\f'.charCodeAt(0)\nconst TAB = '\\t'.charCodeAt(0)\nconst CR = '\\r'.charCodeAt(0)\nconst OPEN_SQUARE = '['.charCodeAt(0)\nconst CLOSE_SQUARE = ']'.charCodeAt(0)\nconst OPEN_PARENTHESES = '('.charCodeAt(0)\nconst CLOSE_PARENTHESES = ')'.charCodeAt(0)\nconst OPEN_CURLY = '{'.charCodeAt(0)\nconst CLOSE_CURLY = '}'.charCodeAt(0)\nconst SEMICOLON = ';'.charCodeAt(0)\nconst ASTERISK = '*'.charCodeAt(0)\nconst COLON = ':'.charCodeAt(0)\nconst AT = '@'.charCodeAt(0)\n\nconst RE_AT_END = /[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g\nconst RE_WORD_END = /[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g\nconst RE_BAD_BRACKET = /.[\\n\"'(/\\\\]/\nconst RE_HEX_ESCAPE = /[\\da-f]/i\n\nmodule.exports = function tokenizer(input, options = {}) {\n  let css = input.css.valueOf()\n  let ignore = options.ignoreErrors\n\n  let code, next, quote, content, escape\n  let escaped, escapePos, prev, n, currentToken\n\n  let length = css.length\n  let pos = 0\n  let buffer = []\n  let returned = []\n\n  function position() {\n    return pos\n  }\n\n  function unclosed(what) {\n    throw input.error('Unclosed ' + what, pos)\n  }\n\n  function endOfFile() {\n    return returned.length === 0 && pos >= length\n  }\n\n  function nextToken(opts) {\n    if (returned.length) return returned.pop()\n    if (pos >= length) return\n\n    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false\n\n    code = css.charCodeAt(pos)\n\n    switch (code) {\n      case NEWLINE:\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED: {\n        next = pos\n        do {\n          next += 1\n          code = css.charCodeAt(next)\n        } while (\n          code === SPACE ||\n          code === NEWLINE ||\n          code === TAB ||\n          code === CR ||\n          code === FEED\n        )\n\n        currentToken = ['space', css.slice(pos, next)]\n        pos = next - 1\n        break\n      }\n\n      case OPEN_SQUARE:\n      case CLOSE_SQUARE:\n      case OPEN_CURLY:\n      case CLOSE_CURLY:\n      case COLON:\n      case SEMICOLON:\n      case CLOSE_PARENTHESES: {\n        let controlChar = String.fromCharCode(code)\n        currentToken = [controlChar, controlChar, pos]\n        break\n      }\n\n      case OPEN_PARENTHESES: {\n        prev = buffer.length ? buffer.pop()[1] : ''\n        n = css.charCodeAt(pos + 1)\n        if (\n          prev === 'url' &&\n          n !== SINGLE_QUOTE &&\n          n !== DOUBLE_QUOTE &&\n          n !== SPACE &&\n          n !== NEWLINE &&\n          n !== TAB &&\n          n !== FEED &&\n          n !== CR\n        ) {\n          next = pos\n          do {\n            escaped = false\n            next = css.indexOf(')', next + 1)\n            if (next === -1) {\n              if (ignore || ignoreUnclosed) {\n                next = pos\n                break\n              } else {\n                unclosed('bracket')\n              }\n            }\n            escapePos = next\n            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n              escapePos -= 1\n              escaped = !escaped\n            }\n          } while (escaped)\n\n          currentToken = ['brackets', css.slice(pos, next + 1), pos, next]\n\n          pos = next\n        } else {\n          next = css.indexOf(')', pos + 1)\n          content = css.slice(pos, next + 1)\n\n          if (next === -1 || RE_BAD_BRACKET.test(content)) {\n            currentToken = ['(', '(', pos]\n          } else {\n            currentToken = ['brackets', content, pos, next]\n            pos = next\n          }\n        }\n\n        break\n      }\n\n      case SINGLE_QUOTE:\n      case DOUBLE_QUOTE: {\n        quote = code === SINGLE_QUOTE ? \"'\" : '\"'\n        next = pos\n        do {\n          escaped = false\n          next = css.indexOf(quote, next + 1)\n          if (next === -1) {\n            if (ignore || ignoreUnclosed) {\n              next = pos + 1\n              break\n            } else {\n              unclosed('string')\n            }\n          }\n          escapePos = next\n          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n            escapePos -= 1\n            escaped = !escaped\n          }\n        } while (escaped)\n\n        currentToken = ['string', css.slice(pos, next + 1), pos, next]\n        pos = next\n        break\n      }\n\n      case AT: {\n        RE_AT_END.lastIndex = pos + 1\n        RE_AT_END.test(css)\n        if (RE_AT_END.lastIndex === 0) {\n          next = css.length - 1\n        } else {\n          next = RE_AT_END.lastIndex - 2\n        }\n\n        currentToken = ['at-word', css.slice(pos, next + 1), pos, next]\n\n        pos = next\n        break\n      }\n\n      case BACKSLASH: {\n        next = pos\n        escape = true\n        while (css.charCodeAt(next + 1) === BACKSLASH) {\n          next += 1\n          escape = !escape\n        }\n        code = css.charCodeAt(next + 1)\n        if (\n          escape &&\n          code !== SLASH &&\n          code !== SPACE &&\n          code !== NEWLINE &&\n          code !== TAB &&\n          code !== CR &&\n          code !== FEED\n        ) {\n          next += 1\n          if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {\n              next += 1\n            }\n            if (css.charCodeAt(next + 1) === SPACE) {\n              next += 1\n            }\n          }\n        }\n\n        currentToken = ['word', css.slice(pos, next + 1), pos, next]\n\n        pos = next\n        break\n      }\n\n      default: {\n        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n          next = css.indexOf('*/', pos + 2) + 1\n          if (next === 0) {\n            if (ignore || ignoreUnclosed) {\n              next = css.length\n            } else {\n              unclosed('comment')\n            }\n          }\n\n          currentToken = ['comment', css.slice(pos, next + 1), pos, next]\n          pos = next\n        } else {\n          RE_WORD_END.lastIndex = pos + 1\n          RE_WORD_END.test(css)\n          if (RE_WORD_END.lastIndex === 0) {\n            next = css.length - 1\n          } else {\n            next = RE_WORD_END.lastIndex - 2\n          }\n\n          currentToken = ['word', css.slice(pos, next + 1), pos, next]\n          buffer.push(currentToken)\n          pos = next\n        }\n\n        break\n      }\n    }\n\n    pos++\n    return currentToken\n  }\n\n  function back(token) {\n    returned.push(token)\n  }\n\n  return {\n    back,\n    nextToken,\n    endOfFile,\n    position\n  }\n}\n", "'use strict'\n\nlet pico = require('picocolors')\n\nlet tokenizer = require('./tokenize')\n\nlet Input\n\nfunction registerInput(dependant) {\n  Input = dependant\n}\n\nconst HIGHLIGHT_THEME = {\n  'brackets': pico.cyan,\n  'at-word': pico.cyan,\n  'comment': pico.gray,\n  'string': pico.green,\n  'class': pico.yellow,\n  'hash': pico.magenta,\n  'call': pico.cyan,\n  '(': pico.cyan,\n  ')': pico.cyan,\n  '{': pico.yellow,\n  '}': pico.yellow,\n  '[': pico.yellow,\n  ']': pico.yellow,\n  ':': pico.yellow,\n  ';': pico.yellow\n}\n\nfunction getTokenType([type, value], processor) {\n  if (type === 'word') {\n    if (value[0] === '.') {\n      return 'class'\n    }\n    if (value[0] === '#') {\n      return 'hash'\n    }\n  }\n\n  if (!processor.endOfFile()) {\n    let next = processor.nextToken()\n    processor.back(next)\n    if (next[0] === 'brackets' || next[0] === '(') return 'call'\n  }\n\n  return type\n}\n\nfunction terminalHighlight(css) {\n  let processor = tokenizer(new Input(css), { ignoreErrors: true })\n  let result = ''\n  while (!processor.endOfFile()) {\n    let token = processor.nextToken()\n    let color = HIGHLIGHT_THEME[getTokenType(token, processor)]\n    if (color) {\n      result += token[1]\n        .split(/\\r?\\n/)\n        .map(i => color(i))\n        .join('\\n')\n    } else {\n      result += token[1]\n    }\n  }\n  return result\n}\n\nterminalHighlight.registerInput = registerInput\n\nmodule.exports = terminalHighlight\n", "'use strict'\n\nlet pico = require('picocolors')\n\nlet terminalHighlight = require('./terminal-highlight')\n\nclass CssSyntaxError extends Error {\n  constructor(message, line, column, source, file, plugin) {\n    super(message)\n    this.name = 'CssSyntaxError'\n    this.reason = message\n\n    if (file) {\n      this.file = file\n    }\n    if (source) {\n      this.source = source\n    }\n    if (plugin) {\n      this.plugin = plugin\n    }\n    if (typeof line !== 'undefined' && typeof column !== 'undefined') {\n      if (typeof line === 'number') {\n        this.line = line\n        this.column = column\n      } else {\n        this.line = line.line\n        this.column = line.column\n        this.endLine = column.line\n        this.endColumn = column.column\n      }\n    }\n\n    this.setMessage()\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, CssSyntaxError)\n    }\n  }\n\n  setMessage() {\n    this.message = this.plugin ? this.plugin + ': ' : ''\n    this.message += this.file ? this.file : '<css input>'\n    if (typeof this.line !== 'undefined') {\n      this.message += ':' + this.line + ':' + this.column\n    }\n    this.message += ': ' + this.reason\n  }\n\n  showSourceCode(color) {\n    if (!this.source) return ''\n\n    let css = this.source\n    if (color == null) color = pico.isColorSupported\n    if (terminalHighlight) {\n      if (color) css = terminalHighlight(css)\n    }\n\n    let lines = css.split(/\\r?\\n/)\n    let start = Math.max(this.line - 3, 0)\n    let end = Math.min(this.line + 2, lines.length)\n\n    let maxWidth = String(end).length\n\n    let mark, aside\n    if (color) {\n      let { bold, red, gray } = pico.createColors(true)\n      mark = text => bold(red(text))\n      aside = text => gray(text)\n    } else {\n      mark = aside = str => str\n    }\n\n    return lines\n      .slice(start, end)\n      .map((line, index) => {\n        let number = start + 1 + index\n        let gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | '\n        if (number === this.line) {\n          let spacing =\n            aside(gutter.replace(/\\d/g, ' ')) +\n            line.slice(0, this.column - 1).replace(/[^\\t]/g, ' ')\n          return mark('>') + aside(gutter) + line + '\\n ' + spacing + mark('^')\n        }\n        return ' ' + aside(gutter) + line\n      })\n      .join('\\n')\n  }\n\n  toString() {\n    let code = this.showSourceCode()\n    if (code) {\n      code = '\\n\\n' + code + '\\n'\n    }\n    return this.name + ': ' + this.message + code\n  }\n}\n\nmodule.exports = CssSyntaxError\nCssSyntaxError.default = CssSyntaxError\n", "'use strict'\n\nmodule.exports.isClean = Symbol('isClean')\n\nmodule.exports.my = Symbol('my')\n", "'use strict'\n\nconst DEFAULT_RAW = {\n  colon: ': ',\n  indent: '    ',\n  beforeDecl: '\\n',\n  beforeRule: '\\n',\n  beforeOpen: ' ',\n  beforeClose: '\\n',\n  beforeComment: '\\n',\n  after: '\\n',\n  emptyBody: '',\n  commentLeft: ' ',\n  commentRight: ' ',\n  semicolon: false\n}\n\nfunction capitalize(str) {\n  return str[0].toUpperCase() + str.slice(1)\n}\n\nclass Stringifier {\n  constructor(builder) {\n    this.builder = builder\n  }\n\n  stringify(node, semicolon) {\n    /* c8 ignore start */\n    if (!this[node.type]) {\n      throw new Error(\n        'Unknown AST node type ' +\n          node.type +\n          '. ' +\n          'Maybe you need to change PostCSS stringifier.'\n      )\n    }\n    /* c8 ignore stop */\n    this[node.type](node, semicolon)\n  }\n\n  document(node) {\n    this.body(node)\n  }\n\n  root(node) {\n    this.body(node)\n    if (node.raws.after) this.builder(node.raws.after)\n  }\n\n  comment(node) {\n    let left = this.raw(node, 'left', 'commentLeft')\n    let right = this.raw(node, 'right', 'commentRight')\n    this.builder('/*' + left + node.text + right + '*/', node)\n  }\n\n  decl(node, semicolon) {\n    let between = this.raw(node, 'between', 'colon')\n    let string = node.prop + between + this.rawValue(node, 'value')\n\n    if (node.important) {\n      string += node.raws.important || ' !important'\n    }\n\n    if (semicolon) string += ';'\n    this.builder(string, node)\n  }\n\n  rule(node) {\n    this.block(node, this.rawValue(node, 'selector'))\n    if (node.raws.ownSemicolon) {\n      this.builder(node.raws.ownSemicolon, node, 'end')\n    }\n  }\n\n  atrule(node, semicolon) {\n    let name = '@' + node.name\n    let params = node.params ? this.rawValue(node, 'params') : ''\n\n    if (typeof node.raws.afterName !== 'undefined') {\n      name += node.raws.afterName\n    } else if (params) {\n      name += ' '\n    }\n\n    if (node.nodes) {\n      this.block(node, name + params)\n    } else {\n      let end = (node.raws.between || '') + (semicolon ? ';' : '')\n      this.builder(name + params + end, node)\n    }\n  }\n\n  body(node) {\n    let last = node.nodes.length - 1\n    while (last > 0) {\n      if (node.nodes[last].type !== 'comment') break\n      last -= 1\n    }\n\n    let semicolon = this.raw(node, 'semicolon')\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i]\n      let before = this.raw(child, 'before')\n      if (before) this.builder(before)\n      this.stringify(child, last !== i || semicolon)\n    }\n  }\n\n  block(node, start) {\n    let between = this.raw(node, 'between', 'beforeOpen')\n    this.builder(start + between + '{', node, 'start')\n\n    let after\n    if (node.nodes && node.nodes.length) {\n      this.body(node)\n      after = this.raw(node, 'after')\n    } else {\n      after = this.raw(node, 'after', 'emptyBody')\n    }\n\n    if (after) this.builder(after)\n    this.builder('}', node, 'end')\n  }\n\n  raw(node, own, detect) {\n    let value\n    if (!detect) detect = own\n\n    // Already had\n    if (own) {\n      value = node.raws[own]\n      if (typeof value !== 'undefined') return value\n    }\n\n    let parent = node.parent\n\n    if (detect === 'before') {\n      // Hack for first rule in CSS\n      if (!parent || (parent.type === 'root' && parent.first === node)) {\n        return ''\n      }\n\n      // `root` nodes in `document` should use only their own raws\n      if (parent && parent.type === 'document') {\n        return ''\n      }\n    }\n\n    // Floating child without parent\n    if (!parent) return DEFAULT_RAW[detect]\n\n    // Detect style by other nodes\n    let root = node.root()\n    if (!root.rawCache) root.rawCache = {}\n    if (typeof root.rawCache[detect] !== 'undefined') {\n      return root.rawCache[detect]\n    }\n\n    if (detect === 'before' || detect === 'after') {\n      return this.beforeAfter(node, detect)\n    } else {\n      let method = 'raw' + capitalize(detect)\n      if (this[method]) {\n        value = this[method](root, node)\n      } else {\n        root.walk(i => {\n          value = i.raws[own]\n          if (typeof value !== 'undefined') return false\n        })\n      }\n    }\n\n    if (typeof value === 'undefined') value = DEFAULT_RAW[detect]\n\n    root.rawCache[detect] = value\n    return value\n  }\n\n  rawSemicolon(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && i.nodes.length && i.last.type === 'decl') {\n        value = i.raws.semicolon\n        if (typeof value !== 'undefined') return false\n      }\n    })\n    return value\n  }\n\n  rawEmptyBody(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && i.nodes.length === 0) {\n        value = i.raws.after\n        if (typeof value !== 'undefined') return false\n      }\n    })\n    return value\n  }\n\n  rawIndent(root) {\n    if (root.raws.indent) return root.raws.indent\n    let value\n    root.walk(i => {\n      let p = i.parent\n      if (p && p !== root && p.parent && p.parent === root) {\n        if (typeof i.raws.before !== 'undefined') {\n          let parts = i.raws.before.split('\\n')\n          value = parts[parts.length - 1]\n          value = value.replace(/\\S/g, '')\n          return false\n        }\n      }\n    })\n    return value\n  }\n\n  rawBeforeComment(root, node) {\n    let value\n    root.walkComments(i => {\n      if (typeof i.raws.before !== 'undefined') {\n        value = i.raws.before\n        if (value.includes('\\n')) {\n          value = value.replace(/[^\\n]+$/, '')\n        }\n        return false\n      }\n    })\n    if (typeof value === 'undefined') {\n      value = this.raw(node, null, 'beforeDecl')\n    } else if (value) {\n      value = value.replace(/\\S/g, '')\n    }\n    return value\n  }\n\n  rawBeforeDecl(root, node) {\n    let value\n    root.walkDecls(i => {\n      if (typeof i.raws.before !== 'undefined') {\n        value = i.raws.before\n        if (value.includes('\\n')) {\n          value = value.replace(/[^\\n]+$/, '')\n        }\n        return false\n      }\n    })\n    if (typeof value === 'undefined') {\n      value = this.raw(node, null, 'beforeRule')\n    } else if (value) {\n      value = value.replace(/\\S/g, '')\n    }\n    return value\n  }\n\n  rawBeforeRule(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && (i.parent !== root || root.first !== i)) {\n        if (typeof i.raws.before !== 'undefined') {\n          value = i.raws.before\n          if (value.includes('\\n')) {\n            value = value.replace(/[^\\n]+$/, '')\n          }\n          return false\n        }\n      }\n    })\n    if (value) value = value.replace(/\\S/g, '')\n    return value\n  }\n\n  rawBeforeClose(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && i.nodes.length > 0) {\n        if (typeof i.raws.after !== 'undefined') {\n          value = i.raws.after\n          if (value.includes('\\n')) {\n            value = value.replace(/[^\\n]+$/, '')\n          }\n          return false\n        }\n      }\n    })\n    if (value) value = value.replace(/\\S/g, '')\n    return value\n  }\n\n  rawBeforeOpen(root) {\n    let value\n    root.walk(i => {\n      if (i.type !== 'decl') {\n        value = i.raws.between\n        if (typeof value !== 'undefined') return false\n      }\n    })\n    return value\n  }\n\n  rawColon(root) {\n    let value\n    root.walkDecls(i => {\n      if (typeof i.raws.between !== 'undefined') {\n        value = i.raws.between.replace(/[^\\s:]/g, '')\n        return false\n      }\n    })\n    return value\n  }\n\n  beforeAfter(node, detect) {\n    let value\n    if (node.type === 'decl') {\n      value = this.raw(node, null, 'beforeDecl')\n    } else if (node.type === 'comment') {\n      value = this.raw(node, null, 'beforeComment')\n    } else if (detect === 'before') {\n      value = this.raw(node, null, 'beforeRule')\n    } else {\n      value = this.raw(node, null, 'beforeClose')\n    }\n\n    let buf = node.parent\n    let depth = 0\n    while (buf && buf.type !== 'root') {\n      depth += 1\n      buf = buf.parent\n    }\n\n    if (value.includes('\\n')) {\n      let indent = this.raw(node, null, 'indent')\n      if (indent.length) {\n        for (let step = 0; step < depth; step++) value += indent\n      }\n    }\n\n    return value\n  }\n\n  rawValue(node, prop) {\n    let value = node[prop]\n    let raw = node.raws[prop]\n    if (raw && raw.value === value) {\n      return raw.raw\n    }\n\n    return value\n  }\n}\n\nmodule.exports = Stringifier\nStringifier.default = Stringifier\n", "'use strict'\n\nlet Stringifier = require('./stringifier')\n\nfunction stringify(node, builder) {\n  let str = new Stringifier(builder)\n  str.stringify(node)\n}\n\nmodule.exports = stringify\nstringify.default = stringify\n", "'use strict'\n\nlet { isClean, my } = require('./symbols')\nlet CssSyntaxError = require('./css-syntax-error')\nlet Stringifier = require('./stringifier')\nlet stringify = require('./stringify')\n\nfunction cloneNode(obj, parent) {\n  let cloned = new obj.constructor()\n\n  for (let i in obj) {\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) {\n      /* c8 ignore next 2 */\n      continue\n    }\n    if (i === 'proxyCache') continue\n    let value = obj[i]\n    let type = typeof value\n\n    if (i === 'parent' && type === 'object') {\n      if (parent) cloned[i] = parent\n    } else if (i === 'source') {\n      cloned[i] = value\n    } else if (Array.isArray(value)) {\n      cloned[i] = value.map(j => cloneNode(j, cloned))\n    } else {\n      if (type === 'object' && value !== null) value = cloneNode(value)\n      cloned[i] = value\n    }\n  }\n\n  return cloned\n}\n\nclass Node {\n  constructor(defaults = {}) {\n    this.raws = {}\n    this[isClean] = false\n    this[my] = true\n\n    for (let name in defaults) {\n      if (name === 'nodes') {\n        this.nodes = []\n        for (let node of defaults[name]) {\n          if (typeof node.clone === 'function') {\n            this.append(node.clone())\n          } else {\n            this.append(node)\n          }\n        }\n      } else {\n        this[name] = defaults[name]\n      }\n    }\n  }\n\n  error(message, opts = {}) {\n    if (this.source) {\n      let { start, end } = this.rangeBy(opts)\n      return this.source.input.error(\n        message,\n        { line: start.line, column: start.column },\n        { line: end.line, column: end.column },\n        opts\n      )\n    }\n    return new CssSyntaxError(message)\n  }\n\n  warn(result, text, opts) {\n    let data = { node: this }\n    for (let i in opts) data[i] = opts[i]\n    return result.warn(text, data)\n  }\n\n  remove() {\n    if (this.parent) {\n      this.parent.removeChild(this)\n    }\n    this.parent = undefined\n    return this\n  }\n\n  toString(stringifier = stringify) {\n    if (stringifier.stringify) stringifier = stringifier.stringify\n    let result = ''\n    stringifier(this, i => {\n      result += i\n    })\n    return result\n  }\n\n  assign(overrides = {}) {\n    for (let name in overrides) {\n      this[name] = overrides[name]\n    }\n    return this\n  }\n\n  clone(overrides = {}) {\n    let cloned = cloneNode(this)\n    for (let name in overrides) {\n      cloned[name] = overrides[name]\n    }\n    return cloned\n  }\n\n  cloneBefore(overrides = {}) {\n    let cloned = this.clone(overrides)\n    this.parent.insertBefore(this, cloned)\n    return cloned\n  }\n\n  cloneAfter(overrides = {}) {\n    let cloned = this.clone(overrides)\n    this.parent.insertAfter(this, cloned)\n    return cloned\n  }\n\n  replaceWith(...nodes) {\n    if (this.parent) {\n      let bookmark = this\n      let foundSelf = false\n      for (let node of nodes) {\n        if (node === this) {\n          foundSelf = true\n        } else if (foundSelf) {\n          this.parent.insertAfter(bookmark, node)\n          bookmark = node\n        } else {\n          this.parent.insertBefore(bookmark, node)\n        }\n      }\n\n      if (!foundSelf) {\n        this.remove()\n      }\n    }\n\n    return this\n  }\n\n  next() {\n    if (!this.parent) return undefined\n    let index = this.parent.index(this)\n    return this.parent.nodes[index + 1]\n  }\n\n  prev() {\n    if (!this.parent) return undefined\n    let index = this.parent.index(this)\n    return this.parent.nodes[index - 1]\n  }\n\n  before(add) {\n    this.parent.insertBefore(this, add)\n    return this\n  }\n\n  after(add) {\n    this.parent.insertAfter(this, add)\n    return this\n  }\n\n  root() {\n    let result = this\n    while (result.parent && result.parent.type !== 'document') {\n      result = result.parent\n    }\n    return result\n  }\n\n  raw(prop, defaultType) {\n    let str = new Stringifier()\n    return str.raw(this, prop, defaultType)\n  }\n\n  cleanRaws(keepBetween) {\n    delete this.raws.before\n    delete this.raws.after\n    if (!keepBetween) delete this.raws.between\n  }\n\n  toJSON(_, inputs) {\n    let fixed = {}\n    let emitInputs = inputs == null\n    inputs = inputs || new Map()\n    let inputsNextIndex = 0\n\n    for (let name in this) {\n      if (!Object.prototype.hasOwnProperty.call(this, name)) {\n        /* c8 ignore next 2 */\n        continue\n      }\n      if (name === 'parent' || name === 'proxyCache') continue\n      let value = this[name]\n\n      if (Array.isArray(value)) {\n        fixed[name] = value.map(i => {\n          if (typeof i === 'object' && i.toJSON) {\n            return i.toJSON(null, inputs)\n          } else {\n            return i\n          }\n        })\n      } else if (typeof value === 'object' && value.toJSON) {\n        fixed[name] = value.toJSON(null, inputs)\n      } else if (name === 'source') {\n        let inputId = inputs.get(value.input)\n        if (inputId == null) {\n          inputId = inputsNextIndex\n          inputs.set(value.input, inputsNextIndex)\n          inputsNextIndex++\n        }\n        fixed[name] = {\n          inputId,\n          start: value.start,\n          end: value.end\n        }\n      } else {\n        fixed[name] = value\n      }\n    }\n\n    if (emitInputs) {\n      fixed.inputs = [...inputs.keys()].map(input => input.toJSON())\n    }\n\n    return fixed\n  }\n\n  positionInside(index) {\n    let string = this.toString()\n    let column = this.source.start.column\n    let line = this.source.start.line\n\n    for (let i = 0; i < index; i++) {\n      if (string[i] === '\\n') {\n        column = 1\n        line += 1\n      } else {\n        column += 1\n      }\n    }\n\n    return { line, column }\n  }\n\n  positionBy(opts) {\n    let pos = this.source.start\n    if (opts.index) {\n      pos = this.positionInside(opts.index)\n    } else if (opts.word) {\n      let index = this.toString().indexOf(opts.word)\n      if (index !== -1) pos = this.positionInside(index)\n    }\n    return pos\n  }\n\n  rangeBy(opts) {\n    let start = {\n      line: this.source.start.line,\n      column: this.source.start.column\n    }\n    let end = this.source.end\n      ? {\n          line: this.source.end.line,\n          column: this.source.end.column + 1\n        }\n      : {\n          line: start.line,\n          column: start.column + 1\n        }\n\n    if (opts.word) {\n      let index = this.toString().indexOf(opts.word)\n      if (index !== -1) {\n        start = this.positionInside(index)\n        end = this.positionInside(index + opts.word.length)\n      }\n    } else {\n      if (opts.start) {\n        start = {\n          line: opts.start.line,\n          column: opts.start.column\n        }\n      } else if (opts.index) {\n        start = this.positionInside(opts.index)\n      }\n\n      if (opts.end) {\n        end = {\n          line: opts.end.line,\n          column: opts.end.column\n        }\n      } else if (opts.endIndex) {\n        end = this.positionInside(opts.endIndex)\n      } else if (opts.index) {\n        end = this.positionInside(opts.index + 1)\n      }\n    }\n\n    if (\n      end.line < start.line ||\n      (end.line === start.line && end.column <= start.column)\n    ) {\n      end = { line: start.line, column: start.column + 1 }\n    }\n\n    return { start, end }\n  }\n\n  getProxyProcessor() {\n    return {\n      set(node, prop, value) {\n        if (node[prop] === value) return true\n        node[prop] = value\n        if (\n          prop === 'prop' ||\n          prop === 'value' ||\n          prop === 'name' ||\n          prop === 'params' ||\n          prop === 'important' ||\n          /* c8 ignore next */\n          prop === 'text'\n        ) {\n          node.markDirty()\n        }\n        return true\n      },\n\n      get(node, prop) {\n        if (prop === 'proxyOf') {\n          return node\n        } else if (prop === 'root') {\n          return () => node.root().toProxy()\n        } else {\n          return node[prop]\n        }\n      }\n    }\n  }\n\n  toProxy() {\n    if (!this.proxyCache) {\n      this.proxyCache = new Proxy(this, this.getProxyProcessor())\n    }\n    return this.proxyCache\n  }\n\n  addToError(error) {\n    error.postcssNode = this\n    if (error.stack && this.source && /\\n\\s{4}at /.test(error.stack)) {\n      let s = this.source\n      error.stack = error.stack.replace(\n        /\\n\\s{4}at /,\n        `$&${s.input.from}:${s.start.line}:${s.start.column}$&`\n      )\n    }\n    return error\n  }\n\n  markDirty() {\n    if (this[isClean]) {\n      this[isClean] = false\n      let next = this\n      while ((next = next.parent)) {\n        next[isClean] = false\n      }\n    }\n  }\n\n  get proxyOf() {\n    return this\n  }\n}\n\nmodule.exports = Node\nNode.default = Node\n", "'use strict'\n\nlet Node = require('./node')\n\nclass Declaration extends Node {\n  constructor(defaults) {\n    if (\n      defaults &&\n      typeof defaults.value !== 'undefined' &&\n      typeof defaults.value !== 'string'\n    ) {\n      defaults = { ...defaults, value: String(defaults.value) }\n    }\n    super(defaults)\n    this.type = 'decl'\n  }\n\n  get variable() {\n    return this.prop.startsWith('--') || this.prop[0] === '$'\n  }\n}\n\nmodule.exports = Declaration\nDeclaration.default = Declaration\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\nvar MAX_CACHED_INPUTS = 32;\n\n/**\n * Takes some function `f(input) -> result` and returns a memoized version of\n * `f`.\n *\n * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The\n * memoization is a dumb-simple, linear least-recently-used cache.\n */\nfunction lruMemoize(f) {\n  var cache = [];\n\n  return function(input) {\n    for (var i = 0; i < cache.length; i++) {\n      if (cache[i].input === input) {\n        var temp = cache[0];\n        cache[0] = cache[i];\n        cache[i] = temp;\n        return cache[0].result;\n      }\n    }\n\n    var result = f(input);\n\n    cache.unshift({\n      input,\n      result,\n    });\n\n    if (cache.length > MAX_CACHED_INPUTS) {\n      cache.pop();\n    }\n\n    return result;\n  };\n}\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nvar normalize = lruMemoize(function normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n  // Split the path into parts between `/` characters. This is much faster than\n  // using `.split(/\\/+/g)`.\n  var parts = [];\n  var start = 0;\n  var i = 0;\n  while (true) {\n    start = i;\n    i = path.indexOf(\"/\", start);\n    if (i === -1) {\n      parts.push(path.slice(start));\n      break;\n    } else {\n      parts.push(path.slice(start, i));\n      while (i < path.length && path[i] === \"/\") {\n        i++;\n      }\n    }\n  }\n\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n});\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\nfunction compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || '';\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n      sourceRoot += '/';\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   \u201Csources\u201D entry.  This value is prepended to the individual\n    //   entries in the \u201Csource\u201D field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   \u201CsourceRoot\u201D, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    var parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      var index = parsed.path.lastIndexOf('/');\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    if (hasNativeMap) {\n      this._set.set(aStr, idx);\n    } else {\n      this._set[sStr] = idx;\n    }\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  if (hasNativeMap) {\n    return this._set.has(aStr);\n  } else {\n    var sStr = util.toSetString(aStr);\n    return has.call(this._set, sStr);\n  }\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  if (hasNativeMap) {\n    var idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n  } else {\n    var sStr = util.toSetString(aStr);\n    if (has.call(this._set, sStr)) {\n      return this._set[sStr];\n    }\n  }\n\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var sourceRelative = sourceFile;\n      if (sourceRoot !== null) {\n        sourceRelative = util.relative(sourceRoot, sourceFile);\n      }\n\n      if (!generator._sources.has(sourceRelative)) {\n        generator._sources.add(sourceRelative);\n      }\n\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n        throw new Error(\n            'original.line and original.column are not numbers -- you probably meant to omit ' +\n            'the original mapping entirely and only map the generated position. If so, pass ' +\n            'null for the original mapping instead of an object with empty or null values.'\n        );\n    }\n\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\nfunction SortTemplate(comparator) {\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot, false) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n  return doQuickSort;\n}\n\nfunction cloneSort(comparator) {\n  let template = SortTemplate.toString();\n  let templateFn = new Function(`return ${template}`)();\n  return templateFn(comparator);\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\n\nlet sortCache = new WeakMap();\nexports.quickSort = function (ary, comparator, start = 0) {\n  let doQuickSort = sortCache.get(comparator);\n  if (doQuickSort === void 0) {\n    doQuickSort = cloneSort(comparator);\n    sortCache.set(comparator, doQuickSort);\n  }\n  doQuickSort(ary, comparator, start, ary.length - 1);\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    var boundCallback = aCallback.bind(context);\n    var names = this._names;\n    var sources = this._sources;\n    var sourceMapURL = this._sourceMapURL;\n\n    for (var i = 0, n = mappings.length; i < n; i++) {\n      var mapping = mappings[i];\n      var source = mapping.source === null ? null : sources.at(mapping.source);\n      source = util.computeSourceURL(sourceRoot, source, sourceMapURL);\n      boundCallback({\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : names.at(mapping.name)\n      });\n    }\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number is 1-based.\n *   - column: Optional. the column number in the original source.\n *    The column number is 0-based.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *    line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *    The column number is 0-based.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n      return [];\n    }\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  if (sourceRoot) {\n    sourceRoot = util.normalize(sourceRoot);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this._absoluteSources = this._sources.toArray().map(function (s) {\n    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n  });\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this._sourceMapURL = aSourceMapURL;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Utility function to find the index of a source.  Returns -1 if not\n * found.\n */\nBasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {\n  var relativeSource = aSource;\n  if (this.sourceRoot != null) {\n    relativeSource = util.relative(this.sourceRoot, relativeSource);\n  }\n\n  if (this._sources.has(relativeSource)) {\n    return this._sources.indexOf(relativeSource);\n  }\n\n  // Maybe aSource is an absolute URL as returned by |sources|.  In\n  // this case we can't simply undo the transform.\n  var i;\n  for (i = 0; i < this._absoluteSources.length; ++i) {\n    if (this._absoluteSources[i] == aSource) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @param String aSourceMapURL\n *        The URL at which the source map can be found (optional)\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n    smc._sourceMapURL = aSourceMapURL;\n    smc._absoluteSources = smc._sources.toArray().map(function (s) {\n      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\n    });\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._absoluteSources.slice();\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\n\nconst compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;\nfunction sortGenerated(array, start) {\n  let l = array.length;\n  let n = array.length - start;\n  if (n <= 1) {\n    return;\n  } else if (n == 2) {\n    let a = array[start];\n    let b = array[start + 1];\n    if (compareGenerated(a, b) > 0) {\n      array[start] = b;\n      array[start + 1] = a;\n    }\n  } else if (n < 20) {\n    for (let i = start; i < l; i++) {\n      for (let j = i; j > start; j--) {\n        let a = array[j - 1];\n        let b = array[j];\n        if (compareGenerated(a, b) <= 0) {\n          break;\n        }\n        array[j - 1] = b;\n        array[j] = a;\n      }\n    }\n  } else {\n    quickSort(array, compareGenerated, start);\n  }\n}\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    let subarrayStart = 0;\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n\n        sortGenerated(generatedMappings, subarrayStart);\n        subarrayStart = generatedMappings.length;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = [];\n        while (index < end) {\n          base64VLQ.decode(aStr, index, temp);\n          value = temp.value;\n          index = temp.rest;\n          segment.push(value);\n        }\n\n        if (segment.length === 2) {\n          throw new Error('Found a source, but no line and column');\n        }\n\n        if (segment.length === 3) {\n          throw new Error('Found a source and line, but no column');\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          let currentSource = mapping.source;\n          while (originalMappings.length <= currentSource) {\n            originalMappings.push(null);\n          }\n          if (originalMappings[currentSource] === null) {\n            originalMappings[currentSource] = [];\n          }\n          originalMappings[currentSource].push(mapping);\n        }\n      }\n    }\n\n    sortGenerated(generatedMappings, subarrayStart);\n    this.__generatedMappings = generatedMappings;\n\n    for (var i = 0; i < originalMappings.length; i++) {\n      if (originalMappings[i] != null) {\n        quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);\n      }\n    }\n    this.__originalMappings = [].concat(...originalMappings);\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    var index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    var relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + relativeSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based. \n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = null;\n        if (mapping.name) {\n          name = section.consumer._names.at(mapping.name);\n          this._names.add(name);\n          name = this._names.indexOf(name);\n        }\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n      var lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      var newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[remainingLinesIndex] || '';\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[remainingLinesIndex] || '';\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n", "/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\nexports.SourceNode = require('./lib/source-node').SourceNode;\n", "let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\nmodule.exports = { nanoid, customAlphabet }\n", "'use strict'\n\nlet { SourceMapConsumer, SourceMapGenerator } = require('source-map-js')\nlet { existsSync, readFileSync } = require('fs')\nlet { dirname, join } = require('path')\n\nfunction fromBase64(str) {\n  if (Buffer) {\n    return Buffer.from(str, 'base64').toString()\n  } else {\n    /* c8 ignore next 2 */\n    return window.atob(str)\n  }\n}\n\nclass PreviousMap {\n  constructor(css, opts) {\n    if (opts.map === false) return\n    this.loadAnnotation(css)\n    this.inline = this.startWith(this.annotation, 'data:')\n\n    let prev = opts.map ? opts.map.prev : undefined\n    let text = this.loadMap(opts.from, prev)\n    if (!this.mapFile && opts.from) {\n      this.mapFile = opts.from\n    }\n    if (this.mapFile) this.root = dirname(this.mapFile)\n    if (text) this.text = text\n  }\n\n  consumer() {\n    if (!this.consumerCache) {\n      this.consumerCache = new SourceMapConsumer(this.text)\n    }\n    return this.consumerCache\n  }\n\n  withContent() {\n    return !!(\n      this.consumer().sourcesContent &&\n      this.consumer().sourcesContent.length > 0\n    )\n  }\n\n  startWith(string, start) {\n    if (!string) return false\n    return string.substr(0, start.length) === start\n  }\n\n  getAnnotationURL(sourceMapString) {\n    return sourceMapString.replace(/^\\/\\*\\s*# sourceMappingURL=/, '').trim()\n  }\n\n  loadAnnotation(css) {\n    let comments = css.match(/\\/\\*\\s*# sourceMappingURL=/gm)\n    if (!comments) return\n\n    // sourceMappingURLs from comments, strings, etc.\n    let start = css.lastIndexOf(comments.pop())\n    let end = css.indexOf('*/', start)\n\n    if (start > -1 && end > -1) {\n      // Locate the last sourceMappingURL to avoid pickin\n      this.annotation = this.getAnnotationURL(css.substring(start, end))\n    }\n  }\n\n  decodeInline(text) {\n    let baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/\n    let baseUri = /^data:application\\/json;base64,/\n    let charsetUri = /^data:application\\/json;charset=utf-?8,/\n    let uri = /^data:application\\/json,/\n\n    if (charsetUri.test(text) || uri.test(text)) {\n      return decodeURIComponent(text.substr(RegExp.lastMatch.length))\n    }\n\n    if (baseCharsetUri.test(text) || baseUri.test(text)) {\n      return fromBase64(text.substr(RegExp.lastMatch.length))\n    }\n\n    let encoding = text.match(/data:application\\/json;([^,]+),/)[1]\n    throw new Error('Unsupported source map encoding ' + encoding)\n  }\n\n  loadFile(path) {\n    this.root = dirname(path)\n    if (existsSync(path)) {\n      this.mapFile = path\n      return readFileSync(path, 'utf-8').toString().trim()\n    }\n  }\n\n  loadMap(file, prev) {\n    if (prev === false) return false\n\n    if (prev) {\n      if (typeof prev === 'string') {\n        return prev\n      } else if (typeof prev === 'function') {\n        let prevPath = prev(file)\n        if (prevPath) {\n          let map = this.loadFile(prevPath)\n          if (!map) {\n            throw new Error(\n              'Unable to load previous source map: ' + prevPath.toString()\n            )\n          }\n          return map\n        }\n      } else if (prev instanceof SourceMapConsumer) {\n        return SourceMapGenerator.fromSourceMap(prev).toString()\n      } else if (prev instanceof SourceMapGenerator) {\n        return prev.toString()\n      } else if (this.isMap(prev)) {\n        return JSON.stringify(prev)\n      } else {\n        throw new Error(\n          'Unsupported previous source map format: ' + prev.toString()\n        )\n      }\n    } else if (this.inline) {\n      return this.decodeInline(this.annotation)\n    } else if (this.annotation) {\n      let map = this.annotation\n      if (file) map = join(dirname(file), map)\n      return this.loadFile(map)\n    }\n  }\n\n  isMap(map) {\n    if (typeof map !== 'object') return false\n    return (\n      typeof map.mappings === 'string' ||\n      typeof map._mappings === 'string' ||\n      Array.isArray(map.sections)\n    )\n  }\n}\n\nmodule.exports = PreviousMap\nPreviousMap.default = PreviousMap\n", "'use strict'\n\nlet { SourceMapConsumer, SourceMapGenerator } = require('source-map-js')\nlet { fileURLToPath, pathToFileURL } = require('url')\nlet { resolve, isAbsolute } = require('path')\nlet { nanoid } = require('nanoid/non-secure')\n\nlet terminalHighlight = require('./terminal-highlight')\nlet CssSyntaxError = require('./css-syntax-error')\nlet PreviousMap = require('./previous-map')\n\nlet fromOffsetCache = Symbol('fromOffsetCache')\n\nlet sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)\nlet pathAvailable = Boolean(resolve && isAbsolute)\n\nclass Input {\n  constructor(css, opts = {}) {\n    if (\n      css === null ||\n      typeof css === 'undefined' ||\n      (typeof css === 'object' && !css.toString)\n    ) {\n      throw new Error(`PostCSS received ${css} instead of CSS string`)\n    }\n\n    this.css = css.toString()\n\n    if (this.css[0] === '\\uFEFF' || this.css[0] === '\\uFFFE') {\n      this.hasBOM = true\n      this.css = this.css.slice(1)\n    } else {\n      this.hasBOM = false\n    }\n\n    if (opts.from) {\n      if (\n        !pathAvailable ||\n        /^\\w+:\\/\\//.test(opts.from) ||\n        isAbsolute(opts.from)\n      ) {\n        this.file = opts.from\n      } else {\n        this.file = resolve(opts.from)\n      }\n    }\n\n    if (pathAvailable && sourceMapAvailable) {\n      let map = new PreviousMap(this.css, opts)\n      if (map.text) {\n        this.map = map\n        let file = map.consumer().file\n        if (!this.file && file) this.file = this.mapResolve(file)\n      }\n    }\n\n    if (!this.file) {\n      this.id = '<input css ' + nanoid(6) + '>'\n    }\n    if (this.map) this.map.file = this.from\n  }\n\n  fromOffset(offset) {\n    let lastLine, lineToIndex\n    if (!this[fromOffsetCache]) {\n      let lines = this.css.split('\\n')\n      lineToIndex = new Array(lines.length)\n      let prevIndex = 0\n\n      for (let i = 0, l = lines.length; i < l; i++) {\n        lineToIndex[i] = prevIndex\n        prevIndex += lines[i].length + 1\n      }\n\n      this[fromOffsetCache] = lineToIndex\n    } else {\n      lineToIndex = this[fromOffsetCache]\n    }\n    lastLine = lineToIndex[lineToIndex.length - 1]\n\n    let min = 0\n    if (offset >= lastLine) {\n      min = lineToIndex.length - 1\n    } else {\n      let max = lineToIndex.length - 2\n      let mid\n      while (min < max) {\n        mid = min + ((max - min) >> 1)\n        if (offset < lineToIndex[mid]) {\n          max = mid - 1\n        } else if (offset >= lineToIndex[mid + 1]) {\n          min = mid + 1\n        } else {\n          min = mid\n          break\n        }\n      }\n    }\n    return {\n      line: min + 1,\n      col: offset - lineToIndex[min] + 1\n    }\n  }\n\n  error(message, line, column, opts = {}) {\n    let result, endLine, endColumn\n\n    if (line && typeof line === 'object') {\n      let start = line\n      let end = column\n      if (typeof line.offset === 'number') {\n        let pos = this.fromOffset(start.offset)\n        line = pos.line\n        column = pos.col\n      } else {\n        line = start.line\n        column = start.column\n      }\n      if (typeof end.offset === 'number') {\n        let pos = this.fromOffset(end.offset)\n        endLine = pos.line\n        endColumn = pos.col\n      } else {\n        endLine = end.line\n        endColumn = end.column\n      }\n    } else if (!column) {\n      let pos = this.fromOffset(line)\n      line = pos.line\n      column = pos.col\n    }\n\n    let origin = this.origin(line, column, endLine, endColumn)\n    if (origin) {\n      result = new CssSyntaxError(\n        message,\n        origin.endLine === undefined\n          ? origin.line\n          : { line: origin.line, column: origin.column },\n        origin.endLine === undefined\n          ? origin.column\n          : { line: origin.endLine, column: origin.endColumn },\n        origin.source,\n        origin.file,\n        opts.plugin\n      )\n    } else {\n      result = new CssSyntaxError(\n        message,\n        endLine === undefined ? line : { line, column },\n        endLine === undefined ? column : { line: endLine, column: endColumn },\n        this.css,\n        this.file,\n        opts.plugin\n      )\n    }\n\n    result.input = { line, column, endLine, endColumn, source: this.css }\n    if (this.file) {\n      if (pathToFileURL) {\n        result.input.url = pathToFileURL(this.file).toString()\n      }\n      result.input.file = this.file\n    }\n\n    return result\n  }\n\n  origin(line, column, endLine, endColumn) {\n    if (!this.map) return false\n    let consumer = this.map.consumer()\n\n    let from = consumer.originalPositionFor({ line, column })\n    if (!from.source) return false\n\n    let to\n    if (typeof endLine === 'number') {\n      to = consumer.originalPositionFor({ line: endLine, column: endColumn })\n    }\n\n    let fromUrl\n\n    if (isAbsolute(from.source)) {\n      fromUrl = pathToFileURL(from.source)\n    } else {\n      fromUrl = new URL(\n        from.source,\n        this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)\n      )\n    }\n\n    let result = {\n      url: fromUrl.toString(),\n      line: from.line,\n      column: from.column,\n      endLine: to && to.line,\n      endColumn: to && to.column\n    }\n\n    if (fromUrl.protocol === 'file:') {\n      if (fileURLToPath) {\n        result.file = fileURLToPath(fromUrl)\n      } else {\n        /* c8 ignore next 2 */\n        throw new Error(`file: protocol is not available in this PostCSS build`)\n      }\n    }\n\n    let source = consumer.sourceContentFor(from.source)\n    if (source) result.source = source\n\n    return result\n  }\n\n  mapResolve(file) {\n    if (/^\\w+:\\/\\//.test(file)) {\n      return file\n    }\n    return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file)\n  }\n\n  get from() {\n    return this.file || this.id\n  }\n\n  toJSON() {\n    let json = {}\n    for (let name of ['hasBOM', 'css', 'file', 'id']) {\n      if (this[name] != null) {\n        json[name] = this[name]\n      }\n    }\n    if (this.map) {\n      json.map = { ...this.map }\n      if (json.map.consumerCache) {\n        json.map.consumerCache = undefined\n      }\n    }\n    return json\n  }\n}\n\nmodule.exports = Input\nInput.default = Input\n\nif (terminalHighlight && terminalHighlight.registerInput) {\n  terminalHighlight.registerInput(Input)\n}\n", "'use strict'\n\nlet { SourceMapConsumer, SourceMapGenerator } = require('source-map-js')\nlet { dirname, resolve, relative, sep } = require('path')\nlet { pathToFileURL } = require('url')\n\nlet Input = require('./input')\n\nlet sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)\nlet pathAvailable = Boolean(dirname && resolve && relative && sep)\n\nclass MapGenerator {\n  constructor(stringify, root, opts, cssString) {\n    this.stringify = stringify\n    this.mapOpts = opts.map || {}\n    this.root = root\n    this.opts = opts\n    this.css = cssString\n    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute\n  }\n\n  isMap() {\n    if (typeof this.opts.map !== 'undefined') {\n      return !!this.opts.map\n    }\n    return this.previous().length > 0\n  }\n\n  previous() {\n    if (!this.previousMaps) {\n      this.previousMaps = []\n      if (this.root) {\n        this.root.walk(node => {\n          if (node.source && node.source.input.map) {\n            let map = node.source.input.map\n            if (!this.previousMaps.includes(map)) {\n              this.previousMaps.push(map)\n            }\n          }\n        })\n      } else {\n        let input = new Input(this.css, this.opts)\n        if (input.map) this.previousMaps.push(input.map)\n      }\n    }\n\n    return this.previousMaps\n  }\n\n  isInline() {\n    if (typeof this.mapOpts.inline !== 'undefined') {\n      return this.mapOpts.inline\n    }\n\n    let annotation = this.mapOpts.annotation\n    if (typeof annotation !== 'undefined' && annotation !== true) {\n      return false\n    }\n\n    if (this.previous().length) {\n      return this.previous().some(i => i.inline)\n    }\n    return true\n  }\n\n  isSourcesContent() {\n    if (typeof this.mapOpts.sourcesContent !== 'undefined') {\n      return this.mapOpts.sourcesContent\n    }\n    if (this.previous().length) {\n      return this.previous().some(i => i.withContent())\n    }\n    return true\n  }\n\n  clearAnnotation() {\n    if (this.mapOpts.annotation === false) return\n\n    if (this.root) {\n      let node\n      for (let i = this.root.nodes.length - 1; i >= 0; i--) {\n        node = this.root.nodes[i]\n        if (node.type !== 'comment') continue\n        if (node.text.indexOf('# sourceMappingURL=') === 0) {\n          this.root.removeChild(i)\n        }\n      }\n    } else if (this.css) {\n      this.css = this.css.replace(/(\\n)?\\/\\*#[\\S\\s]*?\\*\\/$/gm, '')\n    }\n  }\n\n  setSourcesContent() {\n    let already = {}\n    if (this.root) {\n      this.root.walk(node => {\n        if (node.source) {\n          let from = node.source.input.from\n          if (from && !already[from]) {\n            already[from] = true\n            let fromUrl = this.usesFileUrls\n              ? this.toFileUrl(from)\n              : this.toUrl(this.path(from))\n            this.map.setSourceContent(fromUrl, node.source.input.css)\n          }\n        }\n      })\n    } else if (this.css) {\n      let from = this.opts.from\n        ? this.toUrl(this.path(this.opts.from))\n        : '<no source>'\n      this.map.setSourceContent(from, this.css)\n    }\n  }\n\n  applyPrevMaps() {\n    for (let prev of this.previous()) {\n      let from = this.toUrl(this.path(prev.file))\n      let root = prev.root || dirname(prev.file)\n      let map\n\n      if (this.mapOpts.sourcesContent === false) {\n        map = new SourceMapConsumer(prev.text)\n        if (map.sourcesContent) {\n          map.sourcesContent = map.sourcesContent.map(() => null)\n        }\n      } else {\n        map = prev.consumer()\n      }\n\n      this.map.applySourceMap(map, from, this.toUrl(this.path(root)))\n    }\n  }\n\n  isAnnotation() {\n    if (this.isInline()) {\n      return true\n    }\n    if (typeof this.mapOpts.annotation !== 'undefined') {\n      return this.mapOpts.annotation\n    }\n    if (this.previous().length) {\n      return this.previous().some(i => i.annotation)\n    }\n    return true\n  }\n\n  toBase64(str) {\n    if (Buffer) {\n      return Buffer.from(str).toString('base64')\n    } else {\n      return window.btoa(unescape(encodeURIComponent(str)))\n    }\n  }\n\n  addAnnotation() {\n    let content\n\n    if (this.isInline()) {\n      content =\n        'data:application/json;base64,' + this.toBase64(this.map.toString())\n    } else if (typeof this.mapOpts.annotation === 'string') {\n      content = this.mapOpts.annotation\n    } else if (typeof this.mapOpts.annotation === 'function') {\n      content = this.mapOpts.annotation(this.opts.to, this.root)\n    } else {\n      content = this.outputFile() + '.map'\n    }\n    let eol = '\\n'\n    if (this.css.includes('\\r\\n')) eol = '\\r\\n'\n\n    this.css += eol + '/*# sourceMappingURL=' + content + ' */'\n  }\n\n  outputFile() {\n    if (this.opts.to) {\n      return this.path(this.opts.to)\n    } else if (this.opts.from) {\n      return this.path(this.opts.from)\n    } else {\n      return 'to.css'\n    }\n  }\n\n  generateMap() {\n    if (this.root) {\n      this.generateString()\n    } else if (this.previous().length === 1) {\n      let prev = this.previous()[0].consumer()\n      prev.file = this.outputFile()\n      this.map = SourceMapGenerator.fromSourceMap(prev)\n    } else {\n      this.map = new SourceMapGenerator({ file: this.outputFile() })\n      this.map.addMapping({\n        source: this.opts.from\n          ? this.toUrl(this.path(this.opts.from))\n          : '<no source>',\n        generated: { line: 1, column: 0 },\n        original: { line: 1, column: 0 }\n      })\n    }\n\n    if (this.isSourcesContent()) this.setSourcesContent()\n    if (this.root && this.previous().length > 0) this.applyPrevMaps()\n    if (this.isAnnotation()) this.addAnnotation()\n\n    if (this.isInline()) {\n      return [this.css]\n    } else {\n      return [this.css, this.map]\n    }\n  }\n\n  path(file) {\n    if (file.indexOf('<') === 0) return file\n    if (/^\\w+:\\/\\//.test(file)) return file\n    if (this.mapOpts.absolute) return file\n\n    let from = this.opts.to ? dirname(this.opts.to) : '.'\n\n    if (typeof this.mapOpts.annotation === 'string') {\n      from = dirname(resolve(from, this.mapOpts.annotation))\n    }\n\n    file = relative(from, file)\n    return file\n  }\n\n  toUrl(path) {\n    if (sep === '\\\\') {\n      path = path.replace(/\\\\/g, '/')\n    }\n    return encodeURI(path).replace(/[#?]/g, encodeURIComponent)\n  }\n\n  toFileUrl(path) {\n    if (pathToFileURL) {\n      return pathToFileURL(path).toString()\n    } else {\n      throw new Error(\n        '`map.absolute` option is not available in this PostCSS build'\n      )\n    }\n  }\n\n  sourcePath(node) {\n    if (this.mapOpts.from) {\n      return this.toUrl(this.mapOpts.from)\n    } else if (this.usesFileUrls) {\n      return this.toFileUrl(node.source.input.from)\n    } else {\n      return this.toUrl(this.path(node.source.input.from))\n    }\n  }\n\n  generateString() {\n    this.css = ''\n    this.map = new SourceMapGenerator({ file: this.outputFile() })\n\n    let line = 1\n    let column = 1\n\n    let noSource = '<no source>'\n    let mapping = {\n      source: '',\n      generated: { line: 0, column: 0 },\n      original: { line: 0, column: 0 }\n    }\n\n    let lines, last\n    this.stringify(this.root, (str, node, type) => {\n      this.css += str\n\n      if (node && type !== 'end') {\n        mapping.generated.line = line\n        mapping.generated.column = column - 1\n        if (node.source && node.source.start) {\n          mapping.source = this.sourcePath(node)\n          mapping.original.line = node.source.start.line\n          mapping.original.column = node.source.start.column - 1\n          this.map.addMapping(mapping)\n        } else {\n          mapping.source = noSource\n          mapping.original.line = 1\n          mapping.original.column = 0\n          this.map.addMapping(mapping)\n        }\n      }\n\n      lines = str.match(/\\n/g)\n      if (lines) {\n        line += lines.length\n        last = str.lastIndexOf('\\n')\n        column = str.length - last\n      } else {\n        column += str.length\n      }\n\n      if (node && type !== 'start') {\n        let p = node.parent || { raws: {} }\n        if (node.type !== 'decl' || node !== p.last || p.raws.semicolon) {\n          if (node.source && node.source.end) {\n            mapping.source = this.sourcePath(node)\n            mapping.original.line = node.source.end.line\n            mapping.original.column = node.source.end.column - 1\n            mapping.generated.line = line\n            mapping.generated.column = column - 2\n            this.map.addMapping(mapping)\n          } else {\n            mapping.source = noSource\n            mapping.original.line = 1\n            mapping.original.column = 0\n            mapping.generated.line = line\n            mapping.generated.column = column - 1\n            this.map.addMapping(mapping)\n          }\n        }\n      }\n    })\n  }\n\n  generate() {\n    this.clearAnnotation()\n    if (pathAvailable && sourceMapAvailable && this.isMap()) {\n      return this.generateMap()\n    } else {\n      let result = ''\n      this.stringify(this.root, i => {\n        result += i\n      })\n      return [result]\n    }\n  }\n}\n\nmodule.exports = MapGenerator\n", "'use strict'\n\nlet Node = require('./node')\n\nclass Comment extends Node {\n  constructor(defaults) {\n    super(defaults)\n    this.type = 'comment'\n  }\n}\n\nmodule.exports = Comment\nComment.default = Comment\n", "'use strict'\n\nlet { isClean, my } = require('./symbols')\nlet Declaration = require('./declaration')\nlet Comment = require('./comment')\nlet Node = require('./node')\n\nlet parse, Rule, AtRule, Root\n\nfunction cleanSource(nodes) {\n  return nodes.map(i => {\n    if (i.nodes) i.nodes = cleanSource(i.nodes)\n    delete i.source\n    return i\n  })\n}\n\nfunction markDirtyUp(node) {\n  node[isClean] = false\n  if (node.proxyOf.nodes) {\n    for (let i of node.proxyOf.nodes) {\n      markDirtyUp(i)\n    }\n  }\n}\n\nclass Container extends Node {\n  push(child) {\n    child.parent = this\n    this.proxyOf.nodes.push(child)\n    return this\n  }\n\n  each(callback) {\n    if (!this.proxyOf.nodes) return undefined\n    let iterator = this.getIterator()\n\n    let index, result\n    while (this.indexes[iterator] < this.proxyOf.nodes.length) {\n      index = this.indexes[iterator]\n      result = callback(this.proxyOf.nodes[index], index)\n      if (result === false) break\n\n      this.indexes[iterator] += 1\n    }\n\n    delete this.indexes[iterator]\n    return result\n  }\n\n  walk(callback) {\n    return this.each((child, i) => {\n      let result\n      try {\n        result = callback(child, i)\n      } catch (e) {\n        throw child.addToError(e)\n      }\n      if (result !== false && child.walk) {\n        result = child.walk(callback)\n      }\n\n      return result\n    })\n  }\n\n  walkDecls(prop, callback) {\n    if (!callback) {\n      callback = prop\n      return this.walk((child, i) => {\n        if (child.type === 'decl') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (prop instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'decl' && prop.test(child.prop)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'decl' && child.prop === prop) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  walkRules(selector, callback) {\n    if (!callback) {\n      callback = selector\n\n      return this.walk((child, i) => {\n        if (child.type === 'rule') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (selector instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'rule' && selector.test(child.selector)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'rule' && child.selector === selector) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  walkAtRules(name, callback) {\n    if (!callback) {\n      callback = name\n      return this.walk((child, i) => {\n        if (child.type === 'atrule') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (name instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'atrule' && name.test(child.name)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'atrule' && child.name === name) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  walkComments(callback) {\n    return this.walk((child, i) => {\n      if (child.type === 'comment') {\n        return callback(child, i)\n      }\n    })\n  }\n\n  append(...children) {\n    for (let child of children) {\n      let nodes = this.normalize(child, this.last)\n      for (let node of nodes) this.proxyOf.nodes.push(node)\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  prepend(...children) {\n    children = children.reverse()\n    for (let child of children) {\n      let nodes = this.normalize(child, this.first, 'prepend').reverse()\n      for (let node of nodes) this.proxyOf.nodes.unshift(node)\n      for (let id in this.indexes) {\n        this.indexes[id] = this.indexes[id] + nodes.length\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  cleanRaws(keepBetween) {\n    super.cleanRaws(keepBetween)\n    if (this.nodes) {\n      for (let node of this.nodes) node.cleanRaws(keepBetween)\n    }\n  }\n\n  insertBefore(exist, add) {\n    let existIndex = this.index(exist)\n    let type = exist === 0 ? 'prepend' : false\n    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse()\n    existIndex = this.index(exist)\n    for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (existIndex <= index) {\n        this.indexes[id] = index + nodes.length\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  insertAfter(exist, add) {\n    let existIndex = this.index(exist)\n    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse()\n    existIndex = this.index(exist)\n    for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (existIndex < index) {\n        this.indexes[id] = index + nodes.length\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  removeChild(child) {\n    child = this.index(child)\n    this.proxyOf.nodes[child].parent = undefined\n    this.proxyOf.nodes.splice(child, 1)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (index >= child) {\n        this.indexes[id] = index - 1\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  removeAll() {\n    for (let node of this.proxyOf.nodes) node.parent = undefined\n    this.proxyOf.nodes = []\n\n    this.markDirty()\n\n    return this\n  }\n\n  replaceValues(pattern, opts, callback) {\n    if (!callback) {\n      callback = opts\n      opts = {}\n    }\n\n    this.walkDecls(decl => {\n      if (opts.props && !opts.props.includes(decl.prop)) return\n      if (opts.fast && !decl.value.includes(opts.fast)) return\n\n      decl.value = decl.value.replace(pattern, callback)\n    })\n\n    this.markDirty()\n\n    return this\n  }\n\n  every(condition) {\n    return this.nodes.every(condition)\n  }\n\n  some(condition) {\n    return this.nodes.some(condition)\n  }\n\n  index(child) {\n    if (typeof child === 'number') return child\n    if (child.proxyOf) child = child.proxyOf\n    return this.proxyOf.nodes.indexOf(child)\n  }\n\n  get first() {\n    if (!this.proxyOf.nodes) return undefined\n    return this.proxyOf.nodes[0]\n  }\n\n  get last() {\n    if (!this.proxyOf.nodes) return undefined\n    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1]\n  }\n\n  normalize(nodes, sample) {\n    if (typeof nodes === 'string') {\n      nodes = cleanSource(parse(nodes).nodes)\n    } else if (Array.isArray(nodes)) {\n      nodes = nodes.slice(0)\n      for (let i of nodes) {\n        if (i.parent) i.parent.removeChild(i, 'ignore')\n      }\n    } else if (nodes.type === 'root' && this.type !== 'document') {\n      nodes = nodes.nodes.slice(0)\n      for (let i of nodes) {\n        if (i.parent) i.parent.removeChild(i, 'ignore')\n      }\n    } else if (nodes.type) {\n      nodes = [nodes]\n    } else if (nodes.prop) {\n      if (typeof nodes.value === 'undefined') {\n        throw new Error('Value field is missed in node creation')\n      } else if (typeof nodes.value !== 'string') {\n        nodes.value = String(nodes.value)\n      }\n      nodes = [new Declaration(nodes)]\n    } else if (nodes.selector) {\n      nodes = [new Rule(nodes)]\n    } else if (nodes.name) {\n      nodes = [new AtRule(nodes)]\n    } else if (nodes.text) {\n      nodes = [new Comment(nodes)]\n    } else {\n      throw new Error('Unknown node type in node creation')\n    }\n\n    let processed = nodes.map(i => {\n      /* c8 ignore next */\n      if (!i[my]) Container.rebuild(i)\n      i = i.proxyOf\n      if (i.parent) i.parent.removeChild(i)\n      if (i[isClean]) markDirtyUp(i)\n      if (typeof i.raws.before === 'undefined') {\n        if (sample && typeof sample.raws.before !== 'undefined') {\n          i.raws.before = sample.raws.before.replace(/\\S/g, '')\n        }\n      }\n      i.parent = this.proxyOf\n      return i\n    })\n\n    return processed\n  }\n\n  getProxyProcessor() {\n    return {\n      set(node, prop, value) {\n        if (node[prop] === value) return true\n        node[prop] = value\n        if (prop === 'name' || prop === 'params' || prop === 'selector') {\n          node.markDirty()\n        }\n        return true\n      },\n\n      get(node, prop) {\n        if (prop === 'proxyOf') {\n          return node\n        } else if (!node[prop]) {\n          return node[prop]\n        } else if (\n          prop === 'each' ||\n          (typeof prop === 'string' && prop.startsWith('walk'))\n        ) {\n          return (...args) => {\n            return node[prop](\n              ...args.map(i => {\n                if (typeof i === 'function') {\n                  return (child, index) => i(child.toProxy(), index)\n                } else {\n                  return i\n                }\n              })\n            )\n          }\n        } else if (prop === 'every' || prop === 'some') {\n          return cb => {\n            return node[prop]((child, ...other) =>\n              cb(child.toProxy(), ...other)\n            )\n          }\n        } else if (prop === 'root') {\n          return () => node.root().toProxy()\n        } else if (prop === 'nodes') {\n          return node.nodes.map(i => i.toProxy())\n        } else if (prop === 'first' || prop === 'last') {\n          return node[prop].toProxy()\n        } else {\n          return node[prop]\n        }\n      }\n    }\n  }\n\n  getIterator() {\n    if (!this.lastEach) this.lastEach = 0\n    if (!this.indexes) this.indexes = {}\n\n    this.lastEach += 1\n    let iterator = this.lastEach\n    this.indexes[iterator] = 0\n\n    return iterator\n  }\n}\n\nContainer.registerParse = dependant => {\n  parse = dependant\n}\n\nContainer.registerRule = dependant => {\n  Rule = dependant\n}\n\nContainer.registerAtRule = dependant => {\n  AtRule = dependant\n}\n\nContainer.registerRoot = dependant => {\n  Root = dependant\n}\n\nmodule.exports = Container\nContainer.default = Container\n\n/* c8 ignore start */\nContainer.rebuild = node => {\n  if (node.type === 'atrule') {\n    Object.setPrototypeOf(node, AtRule.prototype)\n  } else if (node.type === 'rule') {\n    Object.setPrototypeOf(node, Rule.prototype)\n  } else if (node.type === 'decl') {\n    Object.setPrototypeOf(node, Declaration.prototype)\n  } else if (node.type === 'comment') {\n    Object.setPrototypeOf(node, Comment.prototype)\n  } else if (node.type === 'root') {\n    Object.setPrototypeOf(node, Root.prototype)\n  }\n\n  node[my] = true\n\n  if (node.nodes) {\n    node.nodes.forEach(child => {\n      Container.rebuild(child)\n    })\n  }\n}\n/* c8 ignore stop */\n", "'use strict'\n\nlet Container = require('./container')\n\nlet LazyResult, Processor\n\nclass Document extends Container {\n  constructor(defaults) {\n    // type needs to be passed to super, otherwise child roots won't be normalized correctly\n    super({ type: 'document', ...defaults })\n\n    if (!this.nodes) {\n      this.nodes = []\n    }\n  }\n\n  toResult(opts = {}) {\n    let lazy = new LazyResult(new Processor(), this, opts)\n\n    return lazy.stringify()\n  }\n}\n\nDocument.registerLazyResult = dependant => {\n  LazyResult = dependant\n}\n\nDocument.registerProcessor = dependant => {\n  Processor = dependant\n}\n\nmodule.exports = Document\nDocument.default = Document\n", "/* eslint-disable no-console */\n'use strict'\n\nlet printed = {}\n\nmodule.exports = function warnOnce(message) {\n  if (printed[message]) return\n  printed[message] = true\n\n  if (typeof console !== 'undefined' && console.warn) {\n    console.warn(message)\n  }\n}\n", "'use strict'\n\nclass Warning {\n  constructor(text, opts = {}) {\n    this.type = 'warning'\n    this.text = text\n\n    if (opts.node && opts.node.source) {\n      let range = opts.node.rangeBy(opts)\n      this.line = range.start.line\n      this.column = range.start.column\n      this.endLine = range.end.line\n      this.endColumn = range.end.column\n    }\n\n    for (let opt in opts) this[opt] = opts[opt]\n  }\n\n  toString() {\n    if (this.node) {\n      return this.node.error(this.text, {\n        plugin: this.plugin,\n        index: this.index,\n        word: this.word\n      }).message\n    }\n\n    if (this.plugin) {\n      return this.plugin + ': ' + this.text\n    }\n\n    return this.text\n  }\n}\n\nmodule.exports = Warning\nWarning.default = Warning\n", "'use strict'\n\nlet Warning = require('./warning')\n\nclass Result {\n  constructor(processor, root, opts) {\n    this.processor = processor\n    this.messages = []\n    this.root = root\n    this.opts = opts\n    this.css = undefined\n    this.map = undefined\n  }\n\n  toString() {\n    return this.css\n  }\n\n  warn(text, opts = {}) {\n    if (!opts.plugin) {\n      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {\n        opts.plugin = this.lastPlugin.postcssPlugin\n      }\n    }\n\n    let warning = new Warning(text, opts)\n    this.messages.push(warning)\n\n    return warning\n  }\n\n  warnings() {\n    return this.messages.filter(i => i.type === 'warning')\n  }\n\n  get content() {\n    return this.css\n  }\n}\n\nmodule.exports = Result\nResult.default = Result\n", "'use strict'\n\nlet Container = require('./container')\n\nclass AtRule extends Container {\n  constructor(defaults) {\n    super(defaults)\n    this.type = 'atrule'\n  }\n\n  append(...children) {\n    if (!this.proxyOf.nodes) this.nodes = []\n    return super.append(...children)\n  }\n\n  prepend(...children) {\n    if (!this.proxyOf.nodes) this.nodes = []\n    return super.prepend(...children)\n  }\n}\n\nmodule.exports = AtRule\nAtRule.default = AtRule\n\nContainer.registerAtRule(AtRule)\n", "'use strict'\n\nlet Container = require('./container')\n\nlet LazyResult, Processor\n\nclass Root extends Container {\n  constructor(defaults) {\n    super(defaults)\n    this.type = 'root'\n    if (!this.nodes) this.nodes = []\n  }\n\n  removeChild(child, ignore) {\n    let index = this.index(child)\n\n    if (!ignore && index === 0 && this.nodes.length > 1) {\n      this.nodes[1].raws.before = this.nodes[index].raws.before\n    }\n\n    return super.removeChild(child)\n  }\n\n  normalize(child, sample, type) {\n    let nodes = super.normalize(child)\n\n    if (sample) {\n      if (type === 'prepend') {\n        if (this.nodes.length > 1) {\n          sample.raws.before = this.nodes[1].raws.before\n        } else {\n          delete sample.raws.before\n        }\n      } else if (this.first !== sample) {\n        for (let node of nodes) {\n          node.raws.before = sample.raws.before\n        }\n      }\n    }\n\n    return nodes\n  }\n\n  toResult(opts = {}) {\n    let lazy = new LazyResult(new Processor(), this, opts)\n    return lazy.stringify()\n  }\n}\n\nRoot.registerLazyResult = dependant => {\n  LazyResult = dependant\n}\n\nRoot.registerProcessor = dependant => {\n  Processor = dependant\n}\n\nmodule.exports = Root\nRoot.default = Root\n\nContainer.registerRoot(Root)\n", "'use strict'\n\nlet list = {\n  split(string, separators, last) {\n    let array = []\n    let current = ''\n    let split = false\n\n    let func = 0\n    let inQuote = false\n    let prevQuote = ''\n    let escape = false\n\n    for (let letter of string) {\n      if (escape) {\n        escape = false\n      } else if (letter === '\\\\') {\n        escape = true\n      } else if (inQuote) {\n        if (letter === prevQuote) {\n          inQuote = false\n        }\n      } else if (letter === '\"' || letter === \"'\") {\n        inQuote = true\n        prevQuote = letter\n      } else if (letter === '(') {\n        func += 1\n      } else if (letter === ')') {\n        if (func > 0) func -= 1\n      } else if (func === 0) {\n        if (separators.includes(letter)) split = true\n      }\n\n      if (split) {\n        if (current !== '') array.push(current.trim())\n        current = ''\n        split = false\n      } else {\n        current += letter\n      }\n    }\n\n    if (last || current !== '') array.push(current.trim())\n    return array\n  },\n\n  space(string) {\n    let spaces = [' ', '\\n', '\\t']\n    return list.split(string, spaces)\n  },\n\n  comma(string) {\n    return list.split(string, [','], true)\n  }\n}\n\nmodule.exports = list\nlist.default = list\n", "'use strict'\n\nlet Container = require('./container')\nlet list = require('./list')\n\nclass Rule extends Container {\n  constructor(defaults) {\n    super(defaults)\n    this.type = 'rule'\n    if (!this.nodes) this.nodes = []\n  }\n\n  get selectors() {\n    return list.comma(this.selector)\n  }\n\n  set selectors(values) {\n    let match = this.selector ? this.selector.match(/,\\s*/) : null\n    let sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen')\n    this.selector = values.join(sep)\n  }\n}\n\nmodule.exports = Rule\nRule.default = Rule\n\nContainer.registerRule(Rule)\n", "'use strict'\n\nlet Declaration = require('./declaration')\nlet tokenizer = require('./tokenize')\nlet Comment = require('./comment')\nlet AtRule = require('./at-rule')\nlet Root = require('./root')\nlet Rule = require('./rule')\n\nconst SAFE_COMMENT_NEIGHBOR = {\n  empty: true,\n  space: true\n}\n\nfunction findLastWithPosition(tokens) {\n  for (let i = tokens.length - 1; i >= 0; i--) {\n    let token = tokens[i]\n    let pos = token[3] || token[2]\n    if (pos) return pos\n  }\n}\n\nclass Parser {\n  constructor(input) {\n    this.input = input\n\n    this.root = new Root()\n    this.current = this.root\n    this.spaces = ''\n    this.semicolon = false\n    this.customProperty = false\n\n    this.createTokenizer()\n    this.root.source = { input, start: { offset: 0, line: 1, column: 1 } }\n  }\n\n  createTokenizer() {\n    this.tokenizer = tokenizer(this.input)\n  }\n\n  parse() {\n    let token\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1]\n          break\n\n        case ';':\n          this.freeSemicolon(token)\n          break\n\n        case '}':\n          this.end(token)\n          break\n\n        case 'comment':\n          this.comment(token)\n          break\n\n        case 'at-word':\n          this.atrule(token)\n          break\n\n        case '{':\n          this.emptyRule(token)\n          break\n\n        default:\n          this.other(token)\n          break\n      }\n    }\n    this.endFile()\n  }\n\n  comment(token) {\n    let node = new Comment()\n    this.init(node, token[2])\n    node.source.end = this.getPosition(token[3] || token[2])\n\n    let text = token[1].slice(2, -2)\n    if (/^\\s*$/.test(text)) {\n      node.text = ''\n      node.raws.left = text\n      node.raws.right = ''\n    } else {\n      let match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/)\n      node.text = match[2]\n      node.raws.left = match[1]\n      node.raws.right = match[3]\n    }\n  }\n\n  emptyRule(token) {\n    let node = new Rule()\n    this.init(node, token[2])\n    node.selector = ''\n    node.raws.between = ''\n    this.current = node\n  }\n\n  other(start) {\n    let end = false\n    let type = null\n    let colon = false\n    let bracket = null\n    let brackets = []\n    let customProperty = start[1].startsWith('--')\n\n    let tokens = []\n    let token = start\n    while (token) {\n      type = token[0]\n      tokens.push(token)\n\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (customProperty && colon && type === '{') {\n        if (!bracket) bracket = token\n        brackets.push('}')\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens, customProperty)\n            return\n          } else {\n            break\n          }\n        } else if (type === '{') {\n          this.rule(tokens)\n          return\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop())\n          end = true\n          break\n        } else if (type === ':') {\n          colon = true\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n        if (brackets.length === 0) bracket = null\n      }\n\n      token = this.tokenizer.nextToken()\n    }\n\n    if (this.tokenizer.endOfFile()) end = true\n    if (brackets.length > 0) this.unclosedBracket(bracket)\n\n    if (end && colon) {\n      if (!customProperty) {\n        while (tokens.length) {\n          token = tokens[tokens.length - 1][0]\n          if (token !== 'space' && token !== 'comment') break\n          this.tokenizer.back(tokens.pop())\n        }\n      }\n      this.decl(tokens, customProperty)\n    } else {\n      this.unknownWord(tokens)\n    }\n  }\n\n  rule(tokens) {\n    tokens.pop()\n\n    let node = new Rule()\n    this.init(node, tokens[0][2])\n\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens)\n    this.raw(node, 'selector', tokens)\n    this.current = node\n  }\n\n  decl(tokens, customProperty) {\n    let node = new Declaration()\n    this.init(node, tokens[0][2])\n\n    let last = tokens[tokens.length - 1]\n    if (last[0] === ';') {\n      this.semicolon = true\n      tokens.pop()\n    }\n\n    node.source.end = this.getPosition(\n      last[3] || last[2] || findLastWithPosition(tokens)\n    )\n\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens)\n      node.raws.before += tokens.shift()[1]\n    }\n    node.source.start = this.getPosition(tokens[0][2])\n\n    node.prop = ''\n    while (tokens.length) {\n      let type = tokens[0][0]\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break\n      }\n      node.prop += tokens.shift()[1]\n    }\n\n    node.raws.between = ''\n\n    let token\n    while (tokens.length) {\n      token = tokens.shift()\n\n      if (token[0] === ':') {\n        node.raws.between += token[1]\n        break\n      } else {\n        if (token[0] === 'word' && /\\w/.test(token[1])) {\n          this.unknownWord([token])\n        }\n        node.raws.between += token[1]\n      }\n    }\n\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0]\n      node.prop = node.prop.slice(1)\n    }\n\n    let firstSpaces = []\n    let next\n    while (tokens.length) {\n      next = tokens[0][0]\n      if (next !== 'space' && next !== 'comment') break\n      firstSpaces.push(tokens.shift())\n    }\n\n    this.precheckMissedSemicolon(tokens)\n\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i]\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true\n        let string = this.stringFrom(tokens, i)\n        string = this.spacesFromEnd(tokens) + string\n        if (string !== ' !important') node.raws.important = string\n        break\n      } else if (token[1].toLowerCase() === 'important') {\n        let cache = tokens.slice(0)\n        let str = ''\n        for (let j = i; j > 0; j--) {\n          let type = cache[j][0]\n          if (str.trim().indexOf('!') === 0 && type !== 'space') {\n            break\n          }\n          str = cache.pop()[1] + str\n        }\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true\n          node.raws.important = str\n          tokens = cache\n        }\n      }\n\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break\n      }\n    }\n\n    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment')\n\n    if (hasWord) {\n      node.raws.between += firstSpaces.map(i => i[1]).join('')\n      firstSpaces = []\n    }\n    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty)\n\n    if (node.value.includes(':') && !customProperty) {\n      this.checkMissedSemicolon(tokens)\n    }\n  }\n\n  atrule(token) {\n    let node = new AtRule()\n    node.name = token[1].slice(1)\n    if (node.name === '') {\n      this.unnamedAtrule(node, token)\n    }\n    this.init(node, token[2])\n\n    let type\n    let prev\n    let shift\n    let last = false\n    let open = false\n    let params = []\n    let brackets = []\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n      type = token[0]\n\n      if (type === '(' || type === '[') {\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (type === '{' && brackets.length > 0) {\n        brackets.push('}')\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n      }\n\n      if (brackets.length === 0) {\n        if (type === ';') {\n          node.source.end = this.getPosition(token[2])\n          this.semicolon = true\n          break\n        } else if (type === '{') {\n          open = true\n          break\n        } else if (type === '}') {\n          if (params.length > 0) {\n            shift = params.length - 1\n            prev = params[shift]\n            while (prev && prev[0] === 'space') {\n              prev = params[--shift]\n            }\n            if (prev) {\n              node.source.end = this.getPosition(prev[3] || prev[2])\n            }\n          }\n          this.end(token)\n          break\n        } else {\n          params.push(token)\n        }\n      } else {\n        params.push(token)\n      }\n\n      if (this.tokenizer.endOfFile()) {\n        last = true\n        break\n      }\n    }\n\n    node.raws.between = this.spacesAndCommentsFromEnd(params)\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params)\n      this.raw(node, 'params', params)\n      if (last) {\n        token = params[params.length - 1]\n        node.source.end = this.getPosition(token[3] || token[2])\n        this.spaces = node.raws.between\n        node.raws.between = ''\n      }\n    } else {\n      node.raws.afterName = ''\n      node.params = ''\n    }\n\n    if (open) {\n      node.nodes = []\n      this.current = node\n    }\n  }\n\n  end(token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.semicolon = false\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n    this.spaces = ''\n\n    if (this.current.parent) {\n      this.current.source.end = this.getPosition(token[2])\n      this.current = this.current.parent\n    } else {\n      this.unexpectedClose(token)\n    }\n  }\n\n  endFile() {\n    if (this.current.parent) this.unclosedBlock()\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n  }\n\n  freeSemicolon(token) {\n    this.spaces += token[1]\n    if (this.current.nodes) {\n      let prev = this.current.nodes[this.current.nodes.length - 1]\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces\n        this.spaces = ''\n      }\n    }\n  }\n\n  // Helpers\n\n  getPosition(offset) {\n    let pos = this.input.fromOffset(offset)\n    return {\n      offset,\n      line: pos.line,\n      column: pos.col\n    }\n  }\n\n  init(node, offset) {\n    this.current.push(node)\n    node.source = {\n      start: this.getPosition(offset),\n      input: this.input\n    }\n    node.raws.before = this.spaces\n    this.spaces = ''\n    if (node.type !== 'comment') this.semicolon = false\n  }\n\n  raw(node, prop, tokens, customProperty) {\n    let token, type\n    let length = tokens.length\n    let value = ''\n    let clean = true\n    let next, prev\n\n    for (let i = 0; i < length; i += 1) {\n      token = tokens[i]\n      type = token[0]\n      if (type === 'space' && i === length - 1 && !customProperty) {\n        clean = false\n      } else if (type === 'comment') {\n        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty'\n        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty'\n        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {\n          if (value.slice(-1) === ',') {\n            clean = false\n          } else {\n            value += token[1]\n          }\n        } else {\n          clean = false\n        }\n      } else {\n        value += token[1]\n      }\n    }\n    if (!clean) {\n      let raw = tokens.reduce((all, i) => all + i[1], '')\n      node.raws[prop] = { value, raw }\n    }\n    node[prop] = value\n  }\n\n  spacesAndCommentsFromEnd(tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  spacesAndCommentsFromStart(tokens) {\n    let next\n    let spaces = ''\n    while (tokens.length) {\n      next = tokens[0][0]\n      if (next !== 'space' && next !== 'comment') break\n      spaces += tokens.shift()[1]\n    }\n    return spaces\n  }\n\n  spacesFromEnd(tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  stringFrom(tokens, from) {\n    let result = ''\n    for (let i = from; i < tokens.length; i++) {\n      result += tokens[i][1]\n    }\n    tokens.splice(from, tokens.length - from)\n    return result\n  }\n\n  colon(tokens) {\n    let brackets = 0\n    let token, type, prev\n    for (let [i, element] of tokens.entries()) {\n      token = element\n      type = token[0]\n\n      if (type === '(') {\n        brackets += 1\n      }\n      if (type === ')') {\n        brackets -= 1\n      }\n      if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token)\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue\n        } else {\n          return i\n        }\n      }\n\n      prev = token\n    }\n    return false\n  }\n\n  // Errors\n\n  unclosedBracket(bracket) {\n    throw this.input.error(\n      'Unclosed bracket',\n      { offset: bracket[2] },\n      { offset: bracket[2] + 1 }\n    )\n  }\n\n  unknownWord(tokens) {\n    throw this.input.error(\n      'Unknown word',\n      { offset: tokens[0][2] },\n      { offset: tokens[0][2] + tokens[0][1].length }\n    )\n  }\n\n  unexpectedClose(token) {\n    throw this.input.error(\n      'Unexpected }',\n      { offset: token[2] },\n      { offset: token[2] + 1 }\n    )\n  }\n\n  unclosedBlock() {\n    let pos = this.current.source.start\n    throw this.input.error('Unclosed block', pos.line, pos.column)\n  }\n\n  doubleColon(token) {\n    throw this.input.error(\n      'Double colon',\n      { offset: token[2] },\n      { offset: token[2] + token[1].length }\n    )\n  }\n\n  unnamedAtrule(node, token) {\n    throw this.input.error(\n      'At-rule without name',\n      { offset: token[2] },\n      { offset: token[2] + token[1].length }\n    )\n  }\n\n  precheckMissedSemicolon(/* tokens */) {\n    // Hook for Safe Parser\n  }\n\n  checkMissedSemicolon(tokens) {\n    let colon = this.colon(tokens)\n    if (colon === false) return\n\n    let founded = 0\n    let token\n    for (let j = colon - 1; j >= 0; j--) {\n      token = tokens[j]\n      if (token[0] !== 'space') {\n        founded += 1\n        if (founded === 2) break\n      }\n    }\n    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.\n    // Then we need to return the colon after that word token. [3] is the \"end\" colon of that word.\n    // And because we need it after that one we do +1 to get the next one.\n    throw this.input.error(\n      'Missed semicolon',\n      token[0] === 'word' ? token[3] + 1 : token[2]\n    )\n  }\n}\n\nmodule.exports = Parser\n", "'use strict'\n\nlet Container = require('./container')\nlet Parser = require('./parser')\nlet Input = require('./input')\n\nfunction parse(css, opts) {\n  let input = new Input(css, opts)\n  let parser = new Parser(input)\n  try {\n    parser.parse()\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (e.name === 'CssSyntaxError' && opts && opts.from) {\n        if (/\\.scss$/i.test(opts.from)) {\n          e.message +=\n            '\\nYou tried to parse SCSS with ' +\n            'the standard CSS parser; ' +\n            'try again with the postcss-scss parser'\n        } else if (/\\.sass/i.test(opts.from)) {\n          e.message +=\n            '\\nYou tried to parse Sass with ' +\n            'the standard CSS parser; ' +\n            'try again with the postcss-sass parser'\n        } else if (/\\.less$/i.test(opts.from)) {\n          e.message +=\n            '\\nYou tried to parse Less with ' +\n            'the standard CSS parser; ' +\n            'try again with the postcss-less parser'\n        }\n      }\n    }\n    throw e\n  }\n\n  return parser.root\n}\n\nmodule.exports = parse\nparse.default = parse\n\nContainer.registerParse(parse)\n", "'use strict'\n\nlet { isClean, my } = require('./symbols')\nlet MapGenerator = require('./map-generator')\nlet stringify = require('./stringify')\nlet Container = require('./container')\nlet Document = require('./document')\nlet warnOnce = require('./warn-once')\nlet Result = require('./result')\nlet parse = require('./parse')\nlet Root = require('./root')\n\nconst TYPE_TO_CLASS_NAME = {\n  document: 'Document',\n  root: 'Root',\n  atrule: 'AtRule',\n  rule: 'Rule',\n  decl: 'Declaration',\n  comment: 'Comment'\n}\n\nconst PLUGIN_PROPS = {\n  postcssPlugin: true,\n  prepare: true,\n  Once: true,\n  Document: true,\n  Root: true,\n  Declaration: true,\n  Rule: true,\n  AtRule: true,\n  Comment: true,\n  DeclarationExit: true,\n  RuleExit: true,\n  AtRuleExit: true,\n  CommentExit: true,\n  RootExit: true,\n  DocumentExit: true,\n  OnceExit: true\n}\n\nconst NOT_VISITORS = {\n  postcssPlugin: true,\n  prepare: true,\n  Once: true\n}\n\nconst CHILDREN = 0\n\nfunction isPromise(obj) {\n  return typeof obj === 'object' && typeof obj.then === 'function'\n}\n\nfunction getEvents(node) {\n  let key = false\n  let type = TYPE_TO_CLASS_NAME[node.type]\n  if (node.type === 'decl') {\n    key = node.prop.toLowerCase()\n  } else if (node.type === 'atrule') {\n    key = node.name.toLowerCase()\n  }\n\n  if (key && node.append) {\n    return [\n      type,\n      type + '-' + key,\n      CHILDREN,\n      type + 'Exit',\n      type + 'Exit-' + key\n    ]\n  } else if (key) {\n    return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key]\n  } else if (node.append) {\n    return [type, CHILDREN, type + 'Exit']\n  } else {\n    return [type, type + 'Exit']\n  }\n}\n\nfunction toStack(node) {\n  let events\n  if (node.type === 'document') {\n    events = ['Document', CHILDREN, 'DocumentExit']\n  } else if (node.type === 'root') {\n    events = ['Root', CHILDREN, 'RootExit']\n  } else {\n    events = getEvents(node)\n  }\n\n  return {\n    node,\n    events,\n    eventIndex: 0,\n    visitors: [],\n    visitorIndex: 0,\n    iterator: 0\n  }\n}\n\nfunction cleanMarks(node) {\n  node[isClean] = false\n  if (node.nodes) node.nodes.forEach(i => cleanMarks(i))\n  return node\n}\n\nlet postcss = {}\n\nclass LazyResult {\n  constructor(processor, css, opts) {\n    this.stringified = false\n    this.processed = false\n\n    let root\n    if (\n      typeof css === 'object' &&\n      css !== null &&\n      (css.type === 'root' || css.type === 'document')\n    ) {\n      root = cleanMarks(css)\n    } else if (css instanceof LazyResult || css instanceof Result) {\n      root = cleanMarks(css.root)\n      if (css.map) {\n        if (typeof opts.map === 'undefined') opts.map = {}\n        if (!opts.map.inline) opts.map.inline = false\n        opts.map.prev = css.map\n      }\n    } else {\n      let parser = parse\n      if (opts.syntax) parser = opts.syntax.parse\n      if (opts.parser) parser = opts.parser\n      if (parser.parse) parser = parser.parse\n\n      try {\n        root = parser(css, opts)\n      } catch (error) {\n        this.processed = true\n        this.error = error\n      }\n\n      if (root && !root[my]) {\n        /* c8 ignore next 2 */\n        Container.rebuild(root)\n      }\n    }\n\n    this.result = new Result(processor, root, opts)\n    this.helpers = { ...postcss, result: this.result, postcss }\n    this.plugins = this.processor.plugins.map(plugin => {\n      if (typeof plugin === 'object' && plugin.prepare) {\n        return { ...plugin, ...plugin.prepare(this.result) }\n      } else {\n        return plugin\n      }\n    })\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'LazyResult'\n  }\n\n  get processor() {\n    return this.result.processor\n  }\n\n  get opts() {\n    return this.result.opts\n  }\n\n  get css() {\n    return this.stringify().css\n  }\n\n  get content() {\n    return this.stringify().content\n  }\n\n  get map() {\n    return this.stringify().map\n  }\n\n  get root() {\n    return this.sync().root\n  }\n\n  get messages() {\n    return this.sync().messages\n  }\n\n  warnings() {\n    return this.sync().warnings()\n  }\n\n  toString() {\n    return this.css\n  }\n\n  then(onFulfilled, onRejected) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!('from' in this.opts)) {\n        warnOnce(\n          'Without `from` option PostCSS could generate wrong source map ' +\n            'and will not find Browserslist config. Set it to CSS file path ' +\n            'or to `undefined` to prevent this warning.'\n        )\n      }\n    }\n    return this.async().then(onFulfilled, onRejected)\n  }\n\n  catch(onRejected) {\n    return this.async().catch(onRejected)\n  }\n\n  finally(onFinally) {\n    return this.async().then(onFinally, onFinally)\n  }\n\n  async() {\n    if (this.error) return Promise.reject(this.error)\n    if (this.processed) return Promise.resolve(this.result)\n    if (!this.processing) {\n      this.processing = this.runAsync()\n    }\n    return this.processing\n  }\n\n  sync() {\n    if (this.error) throw this.error\n    if (this.processed) return this.result\n    this.processed = true\n\n    if (this.processing) {\n      throw this.getAsyncError()\n    }\n\n    for (let plugin of this.plugins) {\n      let promise = this.runOnRoot(plugin)\n      if (isPromise(promise)) {\n        throw this.getAsyncError()\n      }\n    }\n\n    this.prepareVisitors()\n    if (this.hasListener) {\n      let root = this.result.root\n      while (!root[isClean]) {\n        root[isClean] = true\n        this.walkSync(root)\n      }\n      if (this.listeners.OnceExit) {\n        if (root.type === 'document') {\n          for (let subRoot of root.nodes) {\n            this.visitSync(this.listeners.OnceExit, subRoot)\n          }\n        } else {\n          this.visitSync(this.listeners.OnceExit, root)\n        }\n      }\n    }\n\n    return this.result\n  }\n\n  stringify() {\n    if (this.error) throw this.error\n    if (this.stringified) return this.result\n    this.stringified = true\n\n    this.sync()\n\n    let opts = this.result.opts\n    let str = stringify\n    if (opts.syntax) str = opts.syntax.stringify\n    if (opts.stringifier) str = opts.stringifier\n    if (str.stringify) str = str.stringify\n\n    let map = new MapGenerator(str, this.result.root, this.result.opts)\n    let data = map.generate()\n    this.result.css = data[0]\n    this.result.map = data[1]\n\n    return this.result\n  }\n\n  walkSync(node) {\n    node[isClean] = true\n    let events = getEvents(node)\n    for (let event of events) {\n      if (event === CHILDREN) {\n        if (node.nodes) {\n          node.each(child => {\n            if (!child[isClean]) this.walkSync(child)\n          })\n        }\n      } else {\n        let visitors = this.listeners[event]\n        if (visitors) {\n          if (this.visitSync(visitors, node.toProxy())) return\n        }\n      }\n    }\n  }\n\n  visitSync(visitors, node) {\n    for (let [plugin, visitor] of visitors) {\n      this.result.lastPlugin = plugin\n      let promise\n      try {\n        promise = visitor(node, this.helpers)\n      } catch (e) {\n        throw this.handleError(e, node.proxyOf)\n      }\n      if (node.type !== 'root' && node.type !== 'document' && !node.parent) {\n        return true\n      }\n      if (isPromise(promise)) {\n        throw this.getAsyncError()\n      }\n    }\n  }\n\n  runOnRoot(plugin) {\n    this.result.lastPlugin = plugin\n    try {\n      if (typeof plugin === 'object' && plugin.Once) {\n        if (this.result.root.type === 'document') {\n          let roots = this.result.root.nodes.map(root =>\n            plugin.Once(root, this.helpers)\n          )\n\n          if (isPromise(roots[0])) {\n            return Promise.all(roots)\n          }\n\n          return roots\n        }\n\n        return plugin.Once(this.result.root, this.helpers)\n      } else if (typeof plugin === 'function') {\n        return plugin(this.result.root, this.result)\n      }\n    } catch (error) {\n      throw this.handleError(error)\n    }\n  }\n\n  getAsyncError() {\n    throw new Error('Use process(css).then(cb) to work with async plugins')\n  }\n\n  handleError(error, node) {\n    let plugin = this.result.lastPlugin\n    try {\n      if (node) node.addToError(error)\n      this.error = error\n      if (error.name === 'CssSyntaxError' && !error.plugin) {\n        error.plugin = plugin.postcssPlugin\n        error.setMessage()\n      } else if (plugin.postcssVersion) {\n        if (process.env.NODE_ENV !== 'production') {\n          let pluginName = plugin.postcssPlugin\n          let pluginVer = plugin.postcssVersion\n          let runtimeVer = this.result.processor.version\n          let a = pluginVer.split('.')\n          let b = runtimeVer.split('.')\n\n          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {\n            // eslint-disable-next-line no-console\n            console.error(\n              'Unknown error from PostCSS plugin. Your current PostCSS ' +\n                'version is ' +\n                runtimeVer +\n                ', but ' +\n                pluginName +\n                ' uses ' +\n                pluginVer +\n                '. Perhaps this is the source of the error below.'\n            )\n          }\n        }\n      }\n    } catch (err) {\n      /* c8 ignore next 3 */\n      // eslint-disable-next-line no-console\n      if (console && console.error) console.error(err)\n    }\n    return error\n  }\n\n  async runAsync() {\n    this.plugin = 0\n    for (let i = 0; i < this.plugins.length; i++) {\n      let plugin = this.plugins[i]\n      let promise = this.runOnRoot(plugin)\n      if (isPromise(promise)) {\n        try {\n          await promise\n        } catch (error) {\n          throw this.handleError(error)\n        }\n      }\n    }\n\n    this.prepareVisitors()\n    if (this.hasListener) {\n      let root = this.result.root\n      while (!root[isClean]) {\n        root[isClean] = true\n        let stack = [toStack(root)]\n        while (stack.length > 0) {\n          let promise = this.visitTick(stack)\n          if (isPromise(promise)) {\n            try {\n              await promise\n            } catch (e) {\n              let node = stack[stack.length - 1].node\n              throw this.handleError(e, node)\n            }\n          }\n        }\n      }\n\n      if (this.listeners.OnceExit) {\n        for (let [plugin, visitor] of this.listeners.OnceExit) {\n          this.result.lastPlugin = plugin\n          try {\n            if (root.type === 'document') {\n              let roots = root.nodes.map(subRoot =>\n                visitor(subRoot, this.helpers)\n              )\n\n              await Promise.all(roots)\n            } else {\n              await visitor(root, this.helpers)\n            }\n          } catch (e) {\n            throw this.handleError(e)\n          }\n        }\n      }\n    }\n\n    this.processed = true\n    return this.stringify()\n  }\n\n  prepareVisitors() {\n    this.listeners = {}\n    let add = (plugin, type, cb) => {\n      if (!this.listeners[type]) this.listeners[type] = []\n      this.listeners[type].push([plugin, cb])\n    }\n    for (let plugin of this.plugins) {\n      if (typeof plugin === 'object') {\n        for (let event in plugin) {\n          if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {\n            throw new Error(\n              `Unknown event ${event} in ${plugin.postcssPlugin}. ` +\n                `Try to update PostCSS (${this.processor.version} now).`\n            )\n          }\n          if (!NOT_VISITORS[event]) {\n            if (typeof plugin[event] === 'object') {\n              for (let filter in plugin[event]) {\n                if (filter === '*') {\n                  add(plugin, event, plugin[event][filter])\n                } else {\n                  add(\n                    plugin,\n                    event + '-' + filter.toLowerCase(),\n                    plugin[event][filter]\n                  )\n                }\n              }\n            } else if (typeof plugin[event] === 'function') {\n              add(plugin, event, plugin[event])\n            }\n          }\n        }\n      }\n    }\n    this.hasListener = Object.keys(this.listeners).length > 0\n  }\n\n  visitTick(stack) {\n    let visit = stack[stack.length - 1]\n    let { node, visitors } = visit\n\n    if (node.type !== 'root' && node.type !== 'document' && !node.parent) {\n      stack.pop()\n      return\n    }\n\n    if (visitors.length > 0 && visit.visitorIndex < visitors.length) {\n      let [plugin, visitor] = visitors[visit.visitorIndex]\n      visit.visitorIndex += 1\n      if (visit.visitorIndex === visitors.length) {\n        visit.visitors = []\n        visit.visitorIndex = 0\n      }\n      this.result.lastPlugin = plugin\n      try {\n        return visitor(node.toProxy(), this.helpers)\n      } catch (e) {\n        throw this.handleError(e, node)\n      }\n    }\n\n    if (visit.iterator !== 0) {\n      let iterator = visit.iterator\n      let child\n      while ((child = node.nodes[node.indexes[iterator]])) {\n        node.indexes[iterator] += 1\n        if (!child[isClean]) {\n          child[isClean] = true\n          stack.push(toStack(child))\n          return\n        }\n      }\n      visit.iterator = 0\n      delete node.indexes[iterator]\n    }\n\n    let events = visit.events\n    while (visit.eventIndex < events.length) {\n      let event = events[visit.eventIndex]\n      visit.eventIndex += 1\n      if (event === CHILDREN) {\n        if (node.nodes && node.nodes.length) {\n          node[isClean] = true\n          visit.iterator = node.getIterator()\n        }\n        return\n      } else if (this.listeners[event]) {\n        visit.visitors = this.listeners[event]\n        return\n      }\n    }\n    stack.pop()\n  }\n}\n\nLazyResult.registerPostcss = dependant => {\n  postcss = dependant\n}\n\nmodule.exports = LazyResult\nLazyResult.default = LazyResult\n\nRoot.registerLazyResult(LazyResult)\nDocument.registerLazyResult(LazyResult)\n", "'use strict'\n\nlet MapGenerator = require('./map-generator')\nlet stringify = require('./stringify')\nlet warnOnce = require('./warn-once')\nlet parse = require('./parse')\nconst Result = require('./result')\n\nclass NoWorkResult {\n  constructor(processor, css, opts) {\n    css = css.toString()\n    this.stringified = false\n\n    this._processor = processor\n    this._css = css\n    this._opts = opts\n    this._map = undefined\n    let root\n\n    let str = stringify\n    this.result = new Result(this._processor, root, this._opts)\n    this.result.css = css\n\n    let self = this\n    Object.defineProperty(this.result, 'root', {\n      get() {\n        return self.root\n      }\n    })\n\n    let map = new MapGenerator(str, root, this._opts, css)\n    if (map.isMap()) {\n      let [generatedCSS, generatedMap] = map.generate()\n      if (generatedCSS) {\n        this.result.css = generatedCSS\n      }\n      if (generatedMap) {\n        this.result.map = generatedMap\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'NoWorkResult'\n  }\n\n  get processor() {\n    return this.result.processor\n  }\n\n  get opts() {\n    return this.result.opts\n  }\n\n  get css() {\n    return this.result.css\n  }\n\n  get content() {\n    return this.result.css\n  }\n\n  get map() {\n    return this.result.map\n  }\n\n  get root() {\n    if (this._root) {\n      return this._root\n    }\n\n    let root\n    let parser = parse\n\n    try {\n      root = parser(this._css, this._opts)\n    } catch (error) {\n      this.error = error\n    }\n\n    if (this.error) {\n      throw this.error\n    } else {\n      this._root = root\n      return root\n    }\n  }\n\n  get messages() {\n    return []\n  }\n\n  warnings() {\n    return []\n  }\n\n  toString() {\n    return this._css\n  }\n\n  then(onFulfilled, onRejected) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!('from' in this._opts)) {\n        warnOnce(\n          'Without `from` option PostCSS could generate wrong source map ' +\n            'and will not find Browserslist config. Set it to CSS file path ' +\n            'or to `undefined` to prevent this warning.'\n        )\n      }\n    }\n\n    return this.async().then(onFulfilled, onRejected)\n  }\n\n  catch(onRejected) {\n    return this.async().catch(onRejected)\n  }\n\n  finally(onFinally) {\n    return this.async().then(onFinally, onFinally)\n  }\n\n  async() {\n    if (this.error) return Promise.reject(this.error)\n    return Promise.resolve(this.result)\n  }\n\n  sync() {\n    if (this.error) throw this.error\n    return this.result\n  }\n}\n\nmodule.exports = NoWorkResult\nNoWorkResult.default = NoWorkResult\n", "'use strict'\n\nlet NoWorkResult = require('./no-work-result')\nlet LazyResult = require('./lazy-result')\nlet Document = require('./document')\nlet Root = require('./root')\n\nclass Processor {\n  constructor(plugins = []) {\n    this.version = '8.4.18'\n    this.plugins = this.normalize(plugins)\n  }\n\n  use(plugin) {\n    this.plugins = this.plugins.concat(this.normalize([plugin]))\n    return this\n  }\n\n  process(css, opts = {}) {\n    if (\n      this.plugins.length === 0 &&\n      typeof opts.parser === 'undefined' &&\n      typeof opts.stringifier === 'undefined' &&\n      typeof opts.syntax === 'undefined'\n    ) {\n      return new NoWorkResult(this, css, opts)\n    } else {\n      return new LazyResult(this, css, opts)\n    }\n  }\n\n  normalize(plugins) {\n    let normalized = []\n    for (let i of plugins) {\n      if (i.postcss === true) {\n        i = i()\n      } else if (i.postcss) {\n        i = i.postcss\n      }\n\n      if (typeof i === 'object' && Array.isArray(i.plugins)) {\n        normalized = normalized.concat(i.plugins)\n      } else if (typeof i === 'object' && i.postcssPlugin) {\n        normalized.push(i)\n      } else if (typeof i === 'function') {\n        normalized.push(i)\n      } else if (typeof i === 'object' && (i.parse || i.stringify)) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(\n            'PostCSS syntaxes cannot be used as plugins. Instead, please use ' +\n              'one of the syntax/parser/stringifier options as outlined ' +\n              'in your PostCSS runner documentation.'\n          )\n        }\n      } else {\n        throw new Error(i + ' is not a PostCSS plugin')\n      }\n    }\n    return normalized\n  }\n}\n\nmodule.exports = Processor\nProcessor.default = Processor\n\nRoot.registerProcessor(Processor)\nDocument.registerProcessor(Processor)\n", "'use strict'\n\nlet Declaration = require('./declaration')\nlet PreviousMap = require('./previous-map')\nlet Comment = require('./comment')\nlet AtRule = require('./at-rule')\nlet Input = require('./input')\nlet Root = require('./root')\nlet Rule = require('./rule')\n\nfunction fromJSON(json, inputs) {\n  if (Array.isArray(json)) return json.map(n => fromJSON(n))\n\n  let { inputs: ownInputs, ...defaults } = json\n  if (ownInputs) {\n    inputs = []\n    for (let input of ownInputs) {\n      let inputHydrated = { ...input, __proto__: Input.prototype }\n      if (inputHydrated.map) {\n        inputHydrated.map = {\n          ...inputHydrated.map,\n          __proto__: PreviousMap.prototype\n        }\n      }\n      inputs.push(inputHydrated)\n    }\n  }\n  if (defaults.nodes) {\n    defaults.nodes = json.nodes.map(n => fromJSON(n, inputs))\n  }\n  if (defaults.source) {\n    let { inputId, ...source } = defaults.source\n    defaults.source = source\n    if (inputId != null) {\n      defaults.source.input = inputs[inputId]\n    }\n  }\n  if (defaults.type === 'root') {\n    return new Root(defaults)\n  } else if (defaults.type === 'decl') {\n    return new Declaration(defaults)\n  } else if (defaults.type === 'rule') {\n    return new Rule(defaults)\n  } else if (defaults.type === 'comment') {\n    return new Comment(defaults)\n  } else if (defaults.type === 'atrule') {\n    return new AtRule(defaults)\n  } else {\n    throw new Error('Unknown node type: ' + json.type)\n  }\n}\n\nmodule.exports = fromJSON\nfromJSON.default = fromJSON\n", "'use strict'\n\nlet CssSyntaxError = require('./css-syntax-error')\nlet Declaration = require('./declaration')\nlet LazyResult = require('./lazy-result')\nlet Container = require('./container')\nlet Processor = require('./processor')\nlet stringify = require('./stringify')\nlet fromJSON = require('./fromJSON')\nlet Document = require('./document')\nlet Warning = require('./warning')\nlet Comment = require('./comment')\nlet AtRule = require('./at-rule')\nlet Result = require('./result.js')\nlet Input = require('./input')\nlet parse = require('./parse')\nlet list = require('./list')\nlet Rule = require('./rule')\nlet Root = require('./root')\nlet Node = require('./node')\n\nfunction postcss(...plugins) {\n  if (plugins.length === 1 && Array.isArray(plugins[0])) {\n    plugins = plugins[0]\n  }\n  return new Processor(plugins)\n}\n\npostcss.plugin = function plugin(name, initializer) {\n  let warningPrinted = false\n  function creator(...args) {\n    // eslint-disable-next-line no-console\n    if (console && console.warn && !warningPrinted) {\n      warningPrinted = true\n      // eslint-disable-next-line no-console\n      console.warn(\n        name +\n          ': postcss.plugin was deprecated. Migration guide:\\n' +\n          'https://evilmartians.com/chronicles/postcss-8-plugin-migration'\n      )\n      if (process.env.LANG && process.env.LANG.startsWith('cn')) {\n        /* c8 ignore next 7 */\n        // eslint-disable-next-line no-console\n        console.warn(\n          name +\n            ': \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:\\n' +\n            'https://www.w3ctech.com/topic/2226'\n        )\n      }\n    }\n    let transformer = initializer(...args)\n    transformer.postcssPlugin = name\n    transformer.postcssVersion = new Processor().version\n    return transformer\n  }\n\n  let cache\n  Object.defineProperty(creator, 'postcss', {\n    get() {\n      if (!cache) cache = creator()\n      return cache\n    }\n  })\n\n  creator.process = function (css, processOpts, pluginOpts) {\n    return postcss([creator(pluginOpts)]).process(css, processOpts)\n  }\n\n  return creator\n}\n\npostcss.stringify = stringify\npostcss.parse = parse\npostcss.fromJSON = fromJSON\npostcss.list = list\n\npostcss.comment = defaults => new Comment(defaults)\npostcss.atRule = defaults => new AtRule(defaults)\npostcss.decl = defaults => new Declaration(defaults)\npostcss.rule = defaults => new Rule(defaults)\npostcss.root = defaults => new Root(defaults)\npostcss.document = defaults => new Document(defaults)\n\npostcss.CssSyntaxError = CssSyntaxError\npostcss.Declaration = Declaration\npostcss.Container = Container\npostcss.Processor = Processor\npostcss.Document = Document\npostcss.Comment = Comment\npostcss.Warning = Warning\npostcss.AtRule = AtRule\npostcss.Result = Result\npostcss.Input = Input\npostcss.Rule = Rule\npostcss.Root = Root\npostcss.Node = Node\n\nLazyResult.registerPostcss(postcss)\n\nmodule.exports = postcss\npostcss.default = postcss\n", "let Stringifier = require('postcss/lib/stringifier')\n\nclass ScssStringifier extends Stringifier {\n  comment (node) {\n    let left = this.raw(node, 'left', 'commentLeft')\n    let right = this.raw(node, 'right', 'commentRight')\n\n    if (node.raws.inline) {\n      let text = node.raws.text || node.text\n      this.builder('//' + left + text + right, node)\n    } else {\n      this.builder('/*' + left + node.text + right + '*/', node)\n    }\n  }\n\n  decl (node, semicolon) {\n    if (!node.isNested) {\n      super.decl(node, semicolon)\n    } else {\n      let between = this.raw(node, 'between', 'colon')\n      let string = node.prop + between + this.rawValue(node, 'value')\n      if (node.important) {\n        string += node.raws.important || ' !important'\n      }\n\n      this.builder(string + '{', node, 'start')\n\n      let after\n      if (node.nodes && node.nodes.length) {\n        this.body(node)\n        after = this.raw(node, 'after')\n      } else {\n        after = this.raw(node, 'after', 'emptyBody')\n      }\n      if (after) this.builder(after)\n      this.builder('}', node, 'end')\n    }\n  }\n\n  rawValue (node, prop) {\n    let value = node[prop]\n    let raw = node.raws[prop]\n    if (raw && raw.value === value) {\n      return raw.scss ? raw.scss : raw.raw\n    } else {\n      return value\n    }\n  }\n}\n\nmodule.exports = ScssStringifier\n", "let ScssStringifier = require('./scss-stringifier')\n\nmodule.exports = function scssStringify (node, builder) {\n  let str = new ScssStringifier(builder)\n  str.stringify(node)\n}\n", "const { Container } = require('postcss')\n\nclass NestedDeclaration extends Container {\n  constructor (defaults) {\n    super(defaults)\n    this.type = 'decl'\n    this.isNested = true\n    if (!this.nodes) this.nodes = []\n  }\n}\n\nmodule.exports = NestedDeclaration\n", "'use strict'\n\nconst SINGLE_QUOTE = \"'\".charCodeAt(0)\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0)\nconst BACKSLASH = '\\\\'.charCodeAt(0)\nconst SLASH = '/'.charCodeAt(0)\nconst NEWLINE = '\\n'.charCodeAt(0)\nconst SPACE = ' '.charCodeAt(0)\nconst FEED = '\\f'.charCodeAt(0)\nconst TAB = '\\t'.charCodeAt(0)\nconst CR = '\\r'.charCodeAt(0)\nconst OPEN_SQUARE = '['.charCodeAt(0)\nconst CLOSE_SQUARE = ']'.charCodeAt(0)\nconst OPEN_PARENTHESES = '('.charCodeAt(0)\nconst CLOSE_PARENTHESES = ')'.charCodeAt(0)\nconst OPEN_CURLY = '{'.charCodeAt(0)\nconst CLOSE_CURLY = '}'.charCodeAt(0)\nconst SEMICOLON = ';'.charCodeAt(0)\nconst ASTERISK = '*'.charCodeAt(0)\nconst COLON = ':'.charCodeAt(0)\nconst AT = '@'.charCodeAt(0)\n\n// SCSS PATCH {\nconst COMMA = ','.charCodeAt(0)\nconst HASH = '#'.charCodeAt(0)\n// } SCSS PATCH\n\nconst RE_AT_END = /[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g\nconst RE_WORD_END = /[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g\nconst RE_BAD_BRACKET = /.[\\n\"'(/\\\\]/\nconst RE_HEX_ESCAPE = /[\\da-f]/i\n\nconst RE_NEW_LINE = /[\\n\\f\\r]/g // SCSS PATCH\n\n// SCSS PATCH function name was changed\nmodule.exports = function scssTokenize (input, options = {}) {\n  let css = input.css.valueOf()\n  let ignore = options.ignoreErrors\n\n  let code, next, quote, content, escape\n  let escaped, prev, n, currentToken\n\n  let length = css.length\n  let pos = 0\n  let buffer = []\n  let returned = []\n\n  let brackets // SCSS PATCH\n\n  function position () {\n    return pos\n  }\n\n  function unclosed (what) {\n    throw input.error('Unclosed ' + what, pos)\n  }\n\n  function endOfFile () {\n    return returned.length === 0 && pos >= length\n  }\n\n  // SCSS PATCH {\n  function interpolation () {\n    let deep = 1\n    let stringQuote = false\n    let stringEscaped = false\n    while (deep > 0) {\n      next += 1\n      if (css.length <= next) unclosed('interpolation')\n\n      code = css.charCodeAt(next)\n      n = css.charCodeAt(next + 1)\n\n      if (stringQuote) {\n        if (!stringEscaped && code === stringQuote) {\n          stringQuote = false\n          stringEscaped = false\n        } else if (code === BACKSLASH) {\n          stringEscaped = !stringEscaped\n        } else if (stringEscaped) {\n          stringEscaped = false\n        }\n      } else if (code === SINGLE_QUOTE || code === DOUBLE_QUOTE) {\n        stringQuote = code\n      } else if (code === CLOSE_CURLY) {\n        deep -= 1\n      } else if (code === HASH && n === OPEN_CURLY) {\n        deep += 1\n      }\n    }\n  }\n  // } SCSS PATCH\n\n  function nextToken (opts) {\n    if (returned.length) return returned.pop()\n    if (pos >= length) return\n\n    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false\n\n    code = css.charCodeAt(pos)\n\n    switch (code) {\n      case NEWLINE:\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED: {\n        next = pos\n        do {\n          next += 1\n          code = css.charCodeAt(next)\n        } while (\n          code === SPACE ||\n          code === NEWLINE ||\n          code === TAB ||\n          code === CR ||\n          code === FEED\n        )\n\n        currentToken = ['space', css.slice(pos, next)]\n        pos = next - 1\n        break\n      }\n\n      case OPEN_SQUARE:\n      case CLOSE_SQUARE:\n      case OPEN_CURLY:\n      case CLOSE_CURLY:\n      case COLON:\n      case SEMICOLON:\n      case CLOSE_PARENTHESES: {\n        let controlChar = String.fromCharCode(code)\n        currentToken = [controlChar, controlChar, pos]\n        break\n      }\n\n      // SCSS PATCH {\n      case COMMA: {\n        currentToken = ['word', ',', pos, pos + 1]\n        break\n      }\n      // } SCSS PATCH\n\n      case OPEN_PARENTHESES: {\n        prev = buffer.length ? buffer.pop()[1] : ''\n        n = css.charCodeAt(pos + 1)\n\n        // SCSS PATCH {\n        if (prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE) {\n          brackets = 1\n          escaped = false\n          next = pos + 1\n          while (next <= css.length - 1) {\n            n = css.charCodeAt(next)\n            if (n === BACKSLASH) {\n              escaped = !escaped\n            } else if (n === OPEN_PARENTHESES) {\n              brackets += 1\n            } else if (n === CLOSE_PARENTHESES) {\n              brackets -= 1\n              if (brackets === 0) break\n            }\n            next += 1\n          }\n\n          content = css.slice(pos, next + 1)\n          currentToken = ['brackets', content, pos, next]\n          pos = next\n          // } SCSS PATCH\n        } else {\n          next = css.indexOf(')', pos + 1)\n          content = css.slice(pos, next + 1)\n\n          if (next === -1 || RE_BAD_BRACKET.test(content)) {\n            currentToken = ['(', '(', pos]\n          } else {\n            currentToken = ['brackets', content, pos, next]\n            pos = next\n          }\n        }\n\n        break\n      }\n\n      case SINGLE_QUOTE:\n      case DOUBLE_QUOTE: {\n        // SCSS PATCH {\n        quote = code\n        next = pos\n\n        escaped = false\n        while (next < length) {\n          next++\n          if (next === length) unclosed('string')\n\n          code = css.charCodeAt(next)\n          n = css.charCodeAt(next + 1)\n\n          if (!escaped && code === quote) {\n            break\n          } else if (code === BACKSLASH) {\n            escaped = !escaped\n          } else if (escaped) {\n            escaped = false\n          } else if (code === HASH && n === OPEN_CURLY) {\n            interpolation()\n          }\n        }\n        // } SCSS PATCH\n\n        currentToken = ['string', css.slice(pos, next + 1), pos, next]\n        pos = next\n        break\n      }\n\n      case AT: {\n        RE_AT_END.lastIndex = pos + 1\n        RE_AT_END.test(css)\n        if (RE_AT_END.lastIndex === 0) {\n          next = css.length - 1\n        } else {\n          next = RE_AT_END.lastIndex - 2\n        }\n\n        currentToken = ['at-word', css.slice(pos, next + 1), pos, next]\n\n        pos = next\n        break\n      }\n\n      case BACKSLASH: {\n        next = pos\n        escape = true\n        while (css.charCodeAt(next + 1) === BACKSLASH) {\n          next += 1\n          escape = !escape\n        }\n        code = css.charCodeAt(next + 1)\n        if (\n          escape &&\n          code !== SLASH &&\n          code !== SPACE &&\n          code !== NEWLINE &&\n          code !== TAB &&\n          code !== CR &&\n          code !== FEED\n        ) {\n          next += 1\n          if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {\n              next += 1\n            }\n            if (css.charCodeAt(next + 1) === SPACE) {\n              next += 1\n            }\n          }\n        }\n\n        currentToken = ['word', css.slice(pos, next + 1), pos, next]\n\n        pos = next\n        break\n      }\n\n      default:\n        // SCSS PATCH {\n        n = css.charCodeAt(pos + 1)\n\n        if (code === HASH && n === OPEN_CURLY) {\n          next = pos\n          interpolation()\n          content = css.slice(pos, next + 1)\n          currentToken = ['word', content, pos, next]\n          pos = next\n        } else if (code === SLASH && n === ASTERISK) {\n          // } SCSS PATCH\n          next = css.indexOf('*/', pos + 2) + 1\n          if (next === 0) {\n            if (ignore || ignoreUnclosed) {\n              next = css.length\n            } else {\n              unclosed('comment')\n            }\n          }\n\n          currentToken = ['comment', css.slice(pos, next + 1), pos, next]\n          pos = next\n\n          // SCSS PATCH {\n        } else if (code === SLASH && n === SLASH) {\n          RE_NEW_LINE.lastIndex = pos + 1\n          RE_NEW_LINE.test(css)\n          if (RE_NEW_LINE.lastIndex === 0) {\n            next = css.length - 1\n          } else {\n            next = RE_NEW_LINE.lastIndex - 2\n          }\n\n          content = css.slice(pos, next + 1)\n          currentToken = ['comment', content, pos, next, 'inline']\n\n          pos = next\n          // } SCSS PATCH\n        } else {\n          RE_WORD_END.lastIndex = pos + 1\n          RE_WORD_END.test(css)\n          if (RE_WORD_END.lastIndex === 0) {\n            next = css.length - 1\n          } else {\n            next = RE_WORD_END.lastIndex - 2\n          }\n\n          currentToken = ['word', css.slice(pos, next + 1), pos, next]\n          buffer.push(currentToken)\n          pos = next\n        }\n\n        break\n    }\n\n    pos++\n    return currentToken\n  }\n\n  function back (token) {\n    returned.push(token)\n  }\n\n  return {\n    back,\n    nextToken,\n    endOfFile,\n    position\n  }\n}\n", "let { Comment } = require('postcss')\nlet Parser = require('postcss/lib/parser')\n\nlet NestedDeclaration = require('./nested-declaration')\nlet scssTokenizer = require('./scss-tokenize')\n\nclass ScssParser extends Parser {\n  createTokenizer() {\n    this.tokenizer = scssTokenizer(this.input)\n  }\n\n  rule(tokens) {\n    let withColon = false\n    let brackets = 0\n    let value = ''\n    for (let i of tokens) {\n      if (withColon) {\n        if (i[0] !== 'comment' && i[0] !== '{') {\n          value += i[1]\n        }\n      } else if (i[0] === 'space' && i[1].includes('\\n')) {\n        break\n      } else if (i[0] === '(') {\n        brackets += 1\n      } else if (i[0] === ')') {\n        brackets -= 1\n      } else if (brackets === 0 && i[0] === ':') {\n        withColon = true\n      }\n    }\n\n    if (!withColon || value.trim() === '' || /^[#:A-Za-z-]/.test(value)) {\n      super.rule(tokens)\n    } else {\n      tokens.pop()\n      let node = new NestedDeclaration()\n      this.init(node, tokens[0][2])\n\n      let last\n      for (let i = tokens.length - 1; i >= 0; i--) {\n        if (tokens[i][0] !== 'space') {\n          last = tokens[i]\n          break\n        }\n      }\n      if (last[3]) {\n        let pos = this.input.fromOffset(last[3])\n        node.source.end = { offset: last[3], line: pos.line, column: pos.col }\n      } else {\n        let pos = this.input.fromOffset(last[2])\n        node.source.end = { offset: last[2], line: pos.line, column: pos.col }\n      }\n\n      while (tokens[0][0] !== 'word') {\n        node.raws.before += tokens.shift()[1]\n      }\n\n      if (tokens[0][2]) {\n        let pos = this.input.fromOffset(tokens[0][2])\n        node.source.start = {\n          offset: tokens[0][2],\n          line: pos.line,\n          column: pos.col\n        }\n      }\n\n      node.prop = ''\n      while (tokens.length) {\n        let type = tokens[0][0]\n        if (type === ':' || type === 'space' || type === 'comment') {\n          break\n        }\n        node.prop += tokens.shift()[1]\n      }\n\n      node.raws.between = ''\n\n      let token\n      while (tokens.length) {\n        token = tokens.shift()\n\n        if (token[0] === ':') {\n          node.raws.between += token[1]\n          break\n        } else {\n          node.raws.between += token[1]\n        }\n      }\n\n      if (node.prop[0] === '_' || node.prop[0] === '*') {\n        node.raws.before += node.prop[0]\n        node.prop = node.prop.slice(1)\n      }\n      node.raws.between += this.spacesAndCommentsFromStart(tokens)\n      this.precheckMissedSemicolon(tokens)\n\n      for (let i = tokens.length - 1; i > 0; i--) {\n        token = tokens[i]\n        if (token[1] === '!important') {\n          node.important = true\n          let string = this.stringFrom(tokens, i)\n          string = this.spacesFromEnd(tokens) + string\n          if (string !== ' !important') {\n            node.raws.important = string\n          }\n          break\n        } else if (token[1] === 'important') {\n          let cache = tokens.slice(0)\n          let str = ''\n          for (let j = i; j > 0; j--) {\n            let type = cache[j][0]\n            if (str.trim().indexOf('!') === 0 && type !== 'space') {\n              break\n            }\n            str = cache.pop()[1] + str\n          }\n          if (str.trim().indexOf('!') === 0) {\n            node.important = true\n            node.raws.important = str\n            tokens = cache\n          }\n        }\n\n        if (token[0] !== 'space' && token[0] !== 'comment') {\n          break\n        }\n      }\n\n      this.raw(node, 'value', tokens)\n\n      if (node.value.includes(':')) {\n        this.checkMissedSemicolon(tokens)\n      }\n\n      this.current = node\n    }\n  }\n\n  comment(token) {\n    if (token[4] === 'inline') {\n      let node = new Comment()\n      this.init(node, token[2])\n      node.raws.inline = true\n      let pos = this.input.fromOffset(token[3])\n      node.source.end = { offset: token[3], line: pos.line, column: pos.col }\n\n      let text = token[1].slice(2)\n      if (/^\\s*$/.test(text)) {\n        node.text = ''\n        node.raws.left = text\n        node.raws.right = ''\n      } else {\n        let match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/)\n        let fixed = match[2].replace(/(\\*\\/|\\/\\*)/g, '*//*')\n        node.text = fixed\n        node.raws.left = match[1]\n        node.raws.right = match[3]\n        node.raws.text = match[2]\n      }\n    } else {\n      super.comment(token)\n    }\n  }\n\n  atrule(token) {\n    let name = token[1]\n    let prev = token\n    while (!this.tokenizer.endOfFile()) {\n      let next = this.tokenizer.nextToken()\n      if (next[0] === 'word' && next[2] === prev[3] + 1) {\n        name += next[1]\n        prev = next\n      } else {\n        this.tokenizer.back(next)\n        break\n      }\n    }\n\n    super.atrule(['at-word', name, token[2], prev[3]])\n  }\n\n  raw(node, prop, tokens, customProperty) {\n    super.raw(node, prop, tokens, customProperty)\n    if (node.raws[prop]) {\n      let scss = node.raws[prop].raw\n      node.raws[prop].raw = tokens.reduce((all, i) => {\n        if (i[0] === 'comment' && i[4] === 'inline') {\n          let text = i[1].slice(2).replace(/(\\*\\/|\\/\\*)/g, '*//*')\n          return all + '/*' + text + '*/'\n        } else {\n          return all + i[1]\n        }\n      }, '')\n      if (scss !== node.raws[prop].raw) {\n        node.raws[prop].scss = scss\n      }\n    }\n  }\n}\n\nmodule.exports = ScssParser\n", "let { Input } = require('postcss')\n\nlet ScssParser = require('./scss-parser')\n\nmodule.exports = function scssParse (scss, opts) {\n  let input = new Input(scss, opts)\n\n  let parser = new ScssParser(input)\n  parser.parse()\n\n  return parser.root\n}\n", "let stringify = require('./scss-stringify')\nlet parse = require('./scss-parse')\n\nmodule.exports = { parse, stringify }\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentMigrator, MIGRATORS, PERMANENT_MIGRATORS} from './rules';\nimport {\n  DevkitFileSystem,\n  UpdateProject,\n  findStylesheetFiles,\n  WorkspacePath,\n  getWorkspaceConfigGracefully,\n  getTargetTsconfigPath,\n} from '@angular/cdk/schematics';\nimport {Rule, SchematicContext, Tree} from '@angular-devkit/schematics';\n\nimport {RuntimeCodeMigration} from './rules/ts-migration/runtime-migration';\nimport {Schema} from './schema';\nimport {TemplateMigration} from './rules/template-migration';\nimport {ThemingStylesMigration} from './rules/theming-styles';\n\n/** Groups of components that must be migrated together. */\nconst migrationGroups = [\n  ['autocomplete', 'form-field', 'input', 'option', 'optgroup', 'select'],\n  ['button'],\n  ['card'],\n  ['checkbox'],\n  ['chips'],\n  ['dialog'],\n  ['list'],\n  ['menu'],\n  ['paginator'],\n  ['progress-bar'],\n  ['progress-spinner'],\n  ['radio'],\n  ['slide-toggle'],\n  ['slider'],\n  ['snack-bar'],\n  ['table'],\n  ['tabs'],\n  ['tooltip'],\n];\n\nfunction getComponentsToMigrate(requested: string[]): Set<string> {\n  const componentsToMigrate = new Set<string>(requested);\n  if (componentsToMigrate.has('all')) {\n    componentsToMigrate.clear();\n    migrationGroups.forEach(group =>\n      group.forEach(component => componentsToMigrate.add(component)),\n    );\n  } else {\n    for (const group of migrationGroups) {\n      if (group.some(component => componentsToMigrate.has(component))) {\n        group.forEach(component => componentsToMigrate.add(component));\n      }\n    }\n  }\n  return componentsToMigrate;\n}\n\nfunction runMigrations(\n  context: SchematicContext,\n  fileSystem: DevkitFileSystem,\n  tsconfigPath: WorkspacePath,\n  migrators: ComponentMigrator[],\n  analyzedFiles: Set<WorkspacePath>,\n  additionalStylesheetPaths: string[],\n  limitToDirectory?: string,\n): boolean {\n  const program = UpdateProject.createProgramFromTsconfig(tsconfigPath, fileSystem);\n  const project = new UpdateProject(context, program, fileSystem, analyzedFiles, context.logger);\n  return !project.migrate(\n    [ThemingStylesMigration, TemplateMigration, RuntimeCodeMigration],\n    null,\n    migrators,\n    additionalStylesheetPaths,\n    limitToDirectory,\n  ).hasFailures;\n}\n\nexport default function (options: Schema): Rule {\n  return async (tree: Tree, context: SchematicContext) => {\n    const logger = context.logger;\n    const workspace = await getWorkspaceConfigGracefully(tree);\n    if (workspace === null) {\n      logger.error('Could not find workspace configuration file.');\n      return;\n    }\n\n    const projectNames = workspace.projects.keys();\n    const fileSystem = new DevkitFileSystem(tree);\n    const analyzedFiles = new Set<WorkspacePath>();\n    const componentsToMigrate = getComponentsToMigrate(options.components);\n    const migrators = [\n      ...MIGRATORS.filter(m => componentsToMigrate.has(m.component)),\n      ...PERMANENT_MIGRATORS,\n    ];\n    let success = true;\n\n    if (options.directory) {\n      logger.info(`Limiting migration to: ${options.directory}`);\n    }\n    logger.info(`Migrating components:\\n${[...componentsToMigrate].join('\\n')}`);\n\n    for (const projectName of projectNames) {\n      const project = workspace.projects.get(projectName)!;\n      const tsconfigPaths = [\n        getTargetTsconfigPath(project, 'build'),\n        getTargetTsconfigPath(project, 'test'),\n      ].filter((p): p is WorkspacePath => !!p);\n\n      if (!tsconfigPaths.length) {\n        logger.warn(\n          `Skipping migration for project ${projectName}. Unable to determine 'tsconfig.json' file in workspace config.`,\n        );\n        continue;\n      }\n\n      const additionalStylesheetPaths = findStylesheetFiles(tree, project.root);\n\n      logger.info(`Migrating project: ${projectName}`);\n\n      for (const tsconfigPath of tsconfigPaths) {\n        success &&= runMigrations(\n          context,\n          fileSystem,\n          tsconfigPath,\n          migrators,\n          analyzedFiles,\n          additionalStylesheetPaths,\n          options.directory || undefined,\n        );\n      }\n    }\n\n    // Commit all recorded edits in the update recorder. We apply the edits after all\n    // migrations ran because otherwise offsets in the TypeScript program would be\n    // shifted and individual migrations could no longer update the same source file.\n    fileSystem.commitEdits();\n\n    if (!success) {\n      logger.error('Unable to migrate project. See errors above.');\n    } else {\n      logger.info('Successfully migrated the project.');\n    }\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as postcss from 'postcss';\n\nconst END_OF_SELECTOR_REGEX = '(?!-)';\nconst MIXIN_ARGUMENTS_REGEX = '\\\\(((\\\\s|.)*)\\\\)';\n\n/** The changes to a class names. */\nexport interface ClassNameChange {\n  /** The legacy class name. */\n  old: string;\n\n  /** The new class name. */\n  new: string;\n}\n\n/** The changes to an scss mixin. */\nexport interface MixinChange {\n  /** The name of the legacy scss mixin. */\n  old: string;\n\n  /** The name(s) of the new scss mixin(s). */\n  new: string[] | null;\n\n  /** Optional check to see if new scss mixin(s) already exist in the styles */\n  checkForDuplicates?: boolean;\n}\n\n/** StyleMigrator implements the basic case for migrating old component styles to new ones. */\nexport abstract class StyleMigrator {\n  /** The name of the component that this migration handles. */\n  abstract component: string;\n\n  /** The old and new class names of this component. */\n  abstract classChanges: ClassNameChange[];\n\n  /** The old mixins and their replacements. */\n  abstract mixinChanges: MixinChange[];\n\n  /** The prefix of classes that are specific to the old components */\n  abstract deprecatedPrefixes: string[];\n\n  /**\n   * Data structure used to track which migrators have been applied to an AST node\n   * already so they don't have to be re-run when PostCSS detects changes in the AST.\n   */\n  private _processedNodes = new WeakMap<postcss.Node, Set<string>>();\n\n  /**\n   * Wraps a value in a placeholder string to prevent it\n   * from being matched multiple times in a migration.\n   */\n  static wrapValue(value: string): string {\n    const escapeString = '__NG_MDC_MIGRATION_PLACEHOLDER__';\n    return `${escapeString}${value}${escapeString}`;\n  }\n\n  /** Unwraps all the values that we wrapped by `wrapValue`. */\n  static unwrapAllValues(content: string): string {\n    return content.replace(/__NG_MDC_MIGRATION_PLACEHOLDER__/g, '');\n  }\n\n  /**\n   * Returns whether the given at-include at-rule is a use of a legacy mixin for this component.\n   *\n   * @param namespace the namespace being used for angular/material.\n   * @param atRule a postcss at-include at-rule.\n   * @returns `true` if the given at-rule is a use of a legacy mixin for this component.\n   */\n  isLegacyMixin(namespace: string, atRule: postcss.AtRule): boolean {\n    return this.mixinChanges.some(change => atRule.params.includes(`${namespace}.${change.old}`));\n  }\n\n  /**\n   * Gets the mixin change object that has the new mixin(s) replacements if\n   * found for the at rule node.\n   *\n   * @param namespace the namespace being used for angular/material.\n   * @param atRule an at-include at-rule of a legacy mixin for this component.\n   * @returns the mixin change object or null if not found\n   */\n  getMixinChange(namespace: string, atRule: postcss.AtRule): MixinChange | null {\n    const processedKey = `mixinChange-${namespace}`;\n\n    if (this._nodeIsProcessed(atRule, processedKey)) {\n      return null;\n    }\n\n    const change = this.mixinChanges.find(c => {\n      return atRule.params.includes(`${namespace}.${c.old}`);\n    });\n\n    if (!change) {\n      return null;\n    }\n\n    // Check if mixin replacements already exist in the stylesheet\n    const replacements = [...(change.new ?? [])];\n    if (change.checkForDuplicates) {\n      const mixinArgumentMatches = atRule.params?.match(MIXIN_ARGUMENTS_REGEX);\n      atRule.root().walkAtRules(rule => {\n        for (const index in replacements) {\n          // Include arguments if applicable since there can be multiple themes.\n          // The first element of the match object includes parentheses since\n          // it's the whole match from the regex.\n          const mixinName =\n            replacements[index] + (mixinArgumentMatches ? mixinArgumentMatches[0] : '');\n          // Remove replacement if mixin found in styles and make sure to not\n          // count component-legacy-theme as a duplicate of component-theme\n          if (rule.params.includes('.' + mixinName)) {\n            replacements.splice(Number(index), 1);\n          }\n        }\n      });\n    }\n\n    this._trackProcessedNode(atRule, processedKey);\n    return {old: change.old, new: replacements.length ? replacements : null};\n  }\n\n  /**\n   * Returns whether the given postcss rule uses a legacy selector of this component.\n   *\n   * @param rule a postcss rule.\n   * @returns `true` if the given Rule uses a legacy selector of this component.\n   */\n  isLegacySelector(rule: postcss.Rule): boolean {\n    // Since a legacy class can also have the deprecated prefix, we also\n    // check that a match isn't actually a longer deprecated class.\n    return this.classChanges.some(\n      change => rule.selector?.match(change.old + END_OF_SELECTOR_REGEX) !== null,\n    );\n  }\n\n  /**\n   * Replaces a legacy selector of this component with the new one.\n   *\n   * @param rule a postcss rule.\n   */\n  replaceLegacySelector(rule: postcss.Rule): void {\n    if (!this._nodeIsProcessed(rule, 'replaceLegacySelector')) {\n      for (let i = 0; i < this.classChanges.length; i++) {\n        const change = this.classChanges[i];\n        if (rule.selector?.match(change.old + END_OF_SELECTOR_REGEX)) {\n          rule.selector = rule.selector.replace(change.old, change.new);\n        }\n      }\n      this._trackProcessedNode(rule, 'replaceLegacySelector');\n    }\n  }\n\n  /**\n   * Returns whether the given postcss rule uses a potentially deprecated\n   * selector of the old component.\n   *\n   * @param rule a postcss rule.\n   * @returns `true` if the given Rule uses a selector with the deprecated prefix.\n   */\n  isDeprecatedSelector(rule: postcss.Rule): boolean {\n    return this.deprecatedPrefixes.some(deprecatedPrefix =>\n      rule.selector.includes(deprecatedPrefix),\n    );\n  }\n\n  /** Tracks that a node has been processed by a specific action. */\n  private _trackProcessedNode(node: postcss.Node, action: string) {\n    const appliedActions = this._processedNodes.get(node) || new Set();\n    appliedActions.add(action);\n    this._processedNodes.set(node, appliedActions);\n  }\n\n  /** Checks whether a node has been processed by an action in this migrator. */\n  private _nodeIsProcessed(node: postcss.Node, action: string) {\n    return !!this._processedNodes.get(node)?.has(action);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class AutocompleteStylesMigrator extends StyleMigrator {\n  component = 'autocomplete';\n\n  deprecatedPrefixes = ['mat-autocomplete'];\n\n  mixinChanges = [\n    {\n      old: 'legacy-autocomplete-theme',\n      new: ['autocomplete-theme'],\n    },\n    {\n      old: 'legacy-autocomplete-color',\n      new: ['autocomplete-color'],\n    },\n    {\n      old: 'legacy-autocomplete-typography',\n      new: ['autocomplete-typography'],\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [{old: '.mat-autocomplete', new: '.mat-mdc-autocomplete'}];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class ButtonStylesMigrator extends StyleMigrator {\n  component = 'button';\n\n  deprecatedPrefixes = ['mat-button'];\n\n  mixinChanges = [\n    {\n      old: 'legacy-button-theme',\n      new: ['button-theme', 'fab-theme', 'icon-button-theme'],\n      checkForDuplicates: true,\n    },\n    {\n      old: 'legacy-button-color',\n      new: ['button-color', 'fab-color', 'icon-button-color'],\n      checkForDuplicates: true,\n    },\n    {\n      old: 'legacy-button-typography',\n      new: ['button-typography', 'fab-typography', 'icon-button-typography'],\n      checkForDuplicates: true,\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [\n    {old: '.mat-button-base', new: '.mat-mdc-button-base'},\n    {old: '.mat-button', new: '.mat-mdc-button'},\n    {old: '.mat-raised-button', new: '.mat-mdc-raised-button'},\n    {old: '.mat-icon-button', new: '.mat-mdc-icon-button'},\n    {old: '.mat-fab', new: '.mat-mdc-fab'},\n    {old: '.mat-mini-fab', new: '.mat-mdc-mini-fab'},\n    {old: '.mat-stroked-button', new: '.mat-mdc-outlined-button'},\n    {old: '.mat-flat-button', new: '.mat-mdc-flat-button'},\n  ];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class CardStylesMigrator extends StyleMigrator {\n  component = 'card';\n\n  deprecatedPrefixes = ['mat-card'];\n\n  mixinChanges = [\n    {\n      old: 'legacy-card-theme',\n      new: ['card-theme'],\n    },\n    {\n      old: 'legacy-card-color',\n      new: ['card-color'],\n    },\n    {\n      old: 'legacy-card-typography',\n      new: ['card-typography'],\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [\n    {old: '.mat-card', new: '.mat-mdc-card'},\n    {old: `.mat-card-title`, new: `.mat-mdc-card-title`},\n    {old: `.mat-card-title-group`, new: `.mat-mdc-card-title-group`},\n    {old: `.mat-card-content`, new: `.mat-mdc-card-content`},\n    {old: `.mat-card-subtitle`, new: `.mat-mdc-card-subtitle`},\n    {old: `.mat-card-actions`, new: `.mat-mdc-card-actions`},\n    {old: `.mat-card-header`, new: `.mat-mdc-card-header`},\n    {old: `.mat-card-footer`, new: `.mat-mdc-card-footer`},\n    {old: `.mat-card-image`, new: `.mat-mdc-card-image`},\n    {old: `.mat-card-avatar`, new: `.mat-mdc-card-avatar`},\n    {old: `.mat-card-sm-image`, new: `.mat-mdc-card-sm-image`},\n    {old: `.mat-card-md-image`, new: `.mat-mdc-card-md-image`},\n    {old: `.mat-card-lg-image`, new: `.mat-mdc-card-lg-image`},\n    {old: `.mat-card-xl-image`, new: `.mat-mdc-card-xl-image`},\n  ];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as compiler from '@angular/compiler';\nimport {Update} from '../../../migration-utilities';\n\nexport abstract class TemplateMigrator {\n  /** Returns the data needed to update the given node. */\n  abstract getUpdates(ast: compiler.ParsedTemplate): Update[];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport enum TagContentType {\n  RAW_TEXT,\n  ESCAPABLE_RAW_TEXT,\n  PARSABLE_DATA\n}\n\nexport interface TagDefinition {\n  closedByParent: boolean;\n  implicitNamespacePrefix: string|null;\n  isVoid: boolean;\n  ignoreFirstLf: boolean;\n  canSelfClose: boolean;\n  preventNamespaceInheritance: boolean;\n\n  isClosedByChild(name: string): boolean;\n  getContentType(prefix?: string): TagContentType;\n}\n\nexport function splitNsName(elementName: string): [string|null, string] {\n  if (elementName[0] != ':') {\n    return [null, elementName];\n  }\n\n  const colonIndex = elementName.indexOf(':', 1);\n\n  if (colonIndex === -1) {\n    throw new Error(`Unsupported format \"${elementName}\" expecting \":namespace:name\"`);\n  }\n\n  return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\n\n// `<ng-container>` tags work the same regardless the namespace\nexport function isNgContainer(tagName: string): boolean {\n  return splitNsName(tagName)[1] === 'ng-container';\n}\n\n// `<ng-content>` tags work the same regardless the namespace\nexport function isNgContent(tagName: string): boolean {\n  return splitNsName(tagName)[1] === 'ng-content';\n}\n\n// `<ng-template>` tags work the same regardless the namespace\nexport function isNgTemplate(tagName: string): boolean {\n  return splitNsName(tagName)[1] === 'ng-template';\n}\n\nexport function getNsPrefix(fullName: string): string;\nexport function getNsPrefix(fullName: null): null;\nexport function getNsPrefix(fullName: string|null): string|null {\n  return fullName === null ? null : splitNsName(fullName)[0];\n}\n\nexport function mergeNsAndName(prefix: string, localName: string): string {\n  return prefix ? `:${prefix}:${localName}` : localName;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TagContentType, TagDefinition} from './tags';\n\nexport class HtmlTagDefinition implements TagDefinition {\n  private closedByChildren: {[key: string]: boolean} = {};\n  private contentType: TagContentType|\n      {default: TagContentType, [namespace: string]: TagContentType};\n\n  closedByParent: boolean = false;\n  implicitNamespacePrefix: string|null;\n  isVoid: boolean;\n  ignoreFirstLf: boolean;\n  canSelfClose: boolean = false;\n  preventNamespaceInheritance: boolean;\n\n  constructor({\n    closedByChildren,\n    implicitNamespacePrefix,\n    contentType = TagContentType.PARSABLE_DATA,\n    closedByParent = false,\n    isVoid = false,\n    ignoreFirstLf = false,\n    preventNamespaceInheritance = false\n  }: {\n    closedByChildren?: string[],\n    closedByParent?: boolean,\n    implicitNamespacePrefix?: string,\n    contentType?: TagContentType|{default: TagContentType, [namespace: string]: TagContentType},\n    isVoid?: boolean,\n    ignoreFirstLf?: boolean,\n    preventNamespaceInheritance?: boolean\n  } = {}) {\n    if (closedByChildren && closedByChildren.length > 0) {\n      closedByChildren.forEach(tagName => this.closedByChildren[tagName] = true);\n    }\n    this.isVoid = isVoid;\n    this.closedByParent = closedByParent || isVoid;\n    this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n    this.contentType = contentType;\n    this.ignoreFirstLf = ignoreFirstLf;\n    this.preventNamespaceInheritance = preventNamespaceInheritance;\n  }\n\n  isClosedByChild(name: string): boolean {\n    return this.isVoid || name.toLowerCase() in this.closedByChildren;\n  }\n\n  getContentType(prefix?: string): TagContentType {\n    if (typeof this.contentType === 'object') {\n      const overrideType = prefix === undefined ? undefined : this.contentType[prefix];\n      return overrideType ?? this.contentType.default;\n    }\n    return this.contentType;\n  }\n}\n\nlet _DEFAULT_TAG_DEFINITION!: HtmlTagDefinition;\n\n// see https://www.w3.org/TR/html51/syntax.html#optional-tags\n// This implementation does not fully conform to the HTML5 spec.\nlet TAG_DEFINITIONS!: {[key: string]: HtmlTagDefinition};\n\nexport function getHtmlTagDefinition(tagName: string): HtmlTagDefinition {\n  if (!TAG_DEFINITIONS) {\n    _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();\n    TAG_DEFINITIONS = {\n      'base': new HtmlTagDefinition({isVoid: true}),\n      'meta': new HtmlTagDefinition({isVoid: true}),\n      'area': new HtmlTagDefinition({isVoid: true}),\n      'embed': new HtmlTagDefinition({isVoid: true}),\n      'link': new HtmlTagDefinition({isVoid: true}),\n      'img': new HtmlTagDefinition({isVoid: true}),\n      'input': new HtmlTagDefinition({isVoid: true}),\n      'param': new HtmlTagDefinition({isVoid: true}),\n      'hr': new HtmlTagDefinition({isVoid: true}),\n      'br': new HtmlTagDefinition({isVoid: true}),\n      'source': new HtmlTagDefinition({isVoid: true}),\n      'track': new HtmlTagDefinition({isVoid: true}),\n      'wbr': new HtmlTagDefinition({isVoid: true}),\n      'p': new HtmlTagDefinition({\n        closedByChildren: [\n          'address', 'article', 'aside',   'blockquote', 'div',  'dl',  'fieldset',\n          'footer',  'form',    'h1',      'h2',         'h3',   'h4',  'h5',\n          'h6',      'header',  'hgroup',  'hr',         'main', 'nav', 'ol',\n          'p',       'pre',     'section', 'table',      'ul'\n        ],\n        closedByParent: true\n      }),\n      'thead': new HtmlTagDefinition({closedByChildren: ['tbody', 'tfoot']}),\n      'tbody': new HtmlTagDefinition({closedByChildren: ['tbody', 'tfoot'], closedByParent: true}),\n      'tfoot': new HtmlTagDefinition({closedByChildren: ['tbody'], closedByParent: true}),\n      'tr': new HtmlTagDefinition({closedByChildren: ['tr'], closedByParent: true}),\n      'td': new HtmlTagDefinition({closedByChildren: ['td', 'th'], closedByParent: true}),\n      'th': new HtmlTagDefinition({closedByChildren: ['td', 'th'], closedByParent: true}),\n      'col': new HtmlTagDefinition({isVoid: true}),\n      'svg': new HtmlTagDefinition({implicitNamespacePrefix: 'svg'}),\n      'foreignObject': new HtmlTagDefinition({\n        // Usually the implicit namespace here would be redundant since it will be inherited from\n        // the parent `svg`, but we have to do it for `foreignObject`, because the way the parser\n        // works is that the parent node of an end tag is its own start tag which means that\n        // the `preventNamespaceInheritance` on `foreignObject` would have it default to the\n        // implicit namespace which is `html`, unless specified otherwise.\n        implicitNamespacePrefix: 'svg',\n        // We want to prevent children of foreignObject from inheriting its namespace, because\n        // the point of the element is to allow nodes from other namespaces to be inserted.\n        preventNamespaceInheritance: true,\n      }),\n      'math': new HtmlTagDefinition({implicitNamespacePrefix: 'math'}),\n      'li': new HtmlTagDefinition({closedByChildren: ['li'], closedByParent: true}),\n      'dt': new HtmlTagDefinition({closedByChildren: ['dt', 'dd']}),\n      'dd': new HtmlTagDefinition({closedByChildren: ['dt', 'dd'], closedByParent: true}),\n      'rb': new HtmlTagDefinition(\n          {closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n      'rt': new HtmlTagDefinition(\n          {closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n      'rtc': new HtmlTagDefinition({closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true}),\n      'rp': new HtmlTagDefinition(\n          {closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n      'optgroup': new HtmlTagDefinition({closedByChildren: ['optgroup'], closedByParent: true}),\n      'option':\n          new HtmlTagDefinition({closedByChildren: ['option', 'optgroup'], closedByParent: true}),\n      'pre': new HtmlTagDefinition({ignoreFirstLf: true}),\n      'listing': new HtmlTagDefinition({ignoreFirstLf: true}),\n      'style': new HtmlTagDefinition({contentType: TagContentType.RAW_TEXT}),\n      'script': new HtmlTagDefinition({contentType: TagContentType.RAW_TEXT}),\n      'title': new HtmlTagDefinition({\n        // The browser supports two separate `title` tags which have to use\n        // a different content type: `HTMLTitleElement` and `SVGTitleElement`\n        contentType: {default: TagContentType.ESCAPABLE_RAW_TEXT, svg: TagContentType.PARSABLE_DATA}\n      }),\n      'textarea': new HtmlTagDefinition(\n          {contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true}),\n    };\n  }\n  // We have to make both a case-sensitive and a case-insensitive lookup, because\n  // HTML tag names are case insensitive, whereas some SVG tags are case sensitive.\n  return TAG_DEFINITIONS[tagName] ?? TAG_DEFINITIONS[tagName.toLowerCase()] ??\n      _DEFAULT_TAG_DEFINITION;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getHtmlTagDefinition} from './ml_parser/html_tags';\n\nconst _SELECTOR_REGEXP = new RegExp(\n    '(\\\\:not\\\\()|' +               // 1: \":not(\"\n        '(([\\\\.\\\\#]?)[-\\\\w]+)|' +  // 2: \"tag\"; 3: \".\"/\"#\";\n        // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n        // 4: attribute; 5: attribute_string; 6: attribute_value\n        '(?:\\\\[([-.\\\\w*\\\\\\\\$]+)(?:=([\\\"\\']?)([^\\\\]\\\"\\']*)\\\\5)?\\\\])|' +  // \"[name]\", \"[name=value]\",\n                                                                        // \"[name=\"value\"]\",\n                                                                        // \"[name='value']\"\n        '(\\\\))|' +                                                      // 7: \")\"\n        '(\\\\s*,\\\\s*)',                                                  // 8: \",\"\n    'g');\n\n/**\n * These offsets should match the match-groups in `_SELECTOR_REGEXP` offsets.\n */\nconst enum SelectorRegexp {\n  ALL = 0,  // The whole match\n  NOT = 1,\n  TAG = 2,\n  PREFIX = 3,\n  ATTRIBUTE = 4,\n  ATTRIBUTE_STRING = 5,\n  ATTRIBUTE_VALUE = 6,\n  NOT_END = 7,\n  SEPARATOR = 8,\n}\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nexport class CssSelector {\n  element: string|null = null;\n  classNames: string[] = [];\n  /**\n   * The selectors are encoded in pairs where:\n   * - even locations are attribute names\n   * - odd locations are attribute values.\n   *\n   * Example:\n   * Selector: `[key1=value1][key2]` would parse to:\n   * ```\n   * ['key1', 'value1', 'key2', '']\n   * ```\n   */\n  attrs: string[] = [];\n  notSelectors: CssSelector[] = [];\n\n  static parse(selector: string): CssSelector[] {\n    const results: CssSelector[] = [];\n    const _addResult = (res: CssSelector[], cssSel: CssSelector) => {\n      if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\n          cssSel.attrs.length == 0) {\n        cssSel.element = '*';\n      }\n      res.push(cssSel);\n    };\n    let cssSelector = new CssSelector();\n    let match: string[]|null;\n    let current = cssSelector;\n    let inNot = false;\n    _SELECTOR_REGEXP.lastIndex = 0;\n    while (match = _SELECTOR_REGEXP.exec(selector)) {\n      if (match[SelectorRegexp.NOT]) {\n        if (inNot) {\n          throw new Error('Nesting :not in a selector is not allowed');\n        }\n        inNot = true;\n        current = new CssSelector();\n        cssSelector.notSelectors.push(current);\n      }\n      const tag = match[SelectorRegexp.TAG];\n      if (tag) {\n        const prefix = match[SelectorRegexp.PREFIX];\n        if (prefix === '#') {\n          // #hash\n          current.addAttribute('id', tag.slice(1));\n        } else if (prefix === '.') {\n          // Class\n          current.addClassName(tag.slice(1));\n        } else {\n          // Element\n          current.setElement(tag);\n        }\n      }\n      const attribute = match[SelectorRegexp.ATTRIBUTE];\n\n      if (attribute) {\n        current.addAttribute(\n            current.unescapeAttribute(attribute), match[SelectorRegexp.ATTRIBUTE_VALUE]);\n      }\n      if (match[SelectorRegexp.NOT_END]) {\n        inNot = false;\n        current = cssSelector;\n      }\n      if (match[SelectorRegexp.SEPARATOR]) {\n        if (inNot) {\n          throw new Error('Multiple selectors in :not are not supported');\n        }\n        _addResult(results, cssSelector);\n        cssSelector = current = new CssSelector();\n      }\n    }\n    _addResult(results, cssSelector);\n    return results;\n  }\n\n  /**\n   * Unescape `\\$` sequences from the CSS attribute selector.\n   *\n   * This is needed because `$` can have a special meaning in CSS selectors,\n   * but we might want to match an attribute that contains `$`.\n   * [MDN web link for more\n   * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\n   * @param attr the attribute to unescape.\n   * @returns the unescaped string.\n   */\n  unescapeAttribute(attr: string): string {\n    let result = '';\n    let escaping = false;\n    for (let i = 0; i < attr.length; i++) {\n      const char = attr.charAt(i);\n      if (char === '\\\\') {\n        escaping = true;\n        continue;\n      }\n      if (char === '$' && !escaping) {\n        throw new Error(\n            `Error in attribute selector \"${attr}\". ` +\n            `Unescaped \"$\" is not supported. Please escape with \"\\\\$\".`);\n      }\n      escaping = false;\n      result += char;\n    }\n    return result;\n  }\n\n  /**\n   * Escape `$` sequences from the CSS attribute selector.\n   *\n   * This is needed because `$` can have a special meaning in CSS selectors,\n   * with this method we are escaping `$` with `\\$'.\n   * [MDN web link for more\n   * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\n   * @param attr the attribute to escape.\n   * @returns the escaped string.\u00A0\n   */\n  escapeAttribute(attr: string): string {\n    return attr.replace(/\\\\/g, '\\\\\\\\').replace(/\\$/g, '\\\\$');\n  }\n\n  isElementSelector(): boolean {\n    return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\n        this.notSelectors.length === 0;\n  }\n\n  hasElementSelector(): boolean {\n    return !!this.element;\n  }\n\n  setElement(element: string|null = null) {\n    this.element = element;\n  }\n\n  /** Gets a template string for an element that matches the selector. */\n  getMatchingElementTemplate(): string {\n    const tagName = this.element || 'div';\n    const classAttr = this.classNames.length > 0 ? ` class=\"${this.classNames.join(' ')}\"` : '';\n\n    let attrs = '';\n    for (let i = 0; i < this.attrs.length; i += 2) {\n      const attrName = this.attrs[i];\n      const attrValue = this.attrs[i + 1] !== '' ? `=\"${this.attrs[i + 1]}\"` : '';\n      attrs += ` ${attrName}${attrValue}`;\n    }\n\n    return getHtmlTagDefinition(tagName).isVoid ? `<${tagName}${classAttr}${attrs}/>` :\n                                                  `<${tagName}${classAttr}${attrs}></${tagName}>`;\n  }\n\n  getAttrs(): string[] {\n    const result: string[] = [];\n    if (this.classNames.length > 0) {\n      result.push('class', this.classNames.join(' '));\n    }\n    return result.concat(this.attrs);\n  }\n\n  addAttribute(name: string, value: string = '') {\n    this.attrs.push(name, value && value.toLowerCase() || '');\n  }\n\n  addClassName(name: string) {\n    this.classNames.push(name.toLowerCase());\n  }\n\n  toString(): string {\n    let res: string = this.element || '';\n    if (this.classNames) {\n      this.classNames.forEach(klass => res += `.${klass}`);\n    }\n    if (this.attrs) {\n      for (let i = 0; i < this.attrs.length; i += 2) {\n        const name = this.escapeAttribute(this.attrs[i]);\n        const value = this.attrs[i + 1];\n        res += `[${name}${value ? '=' + value : ''}]`;\n      }\n    }\n    this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);\n    return res;\n  }\n}\n\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nexport class SelectorMatcher<T = any> {\n  static createNotMatcher(notSelectors: CssSelector[]): SelectorMatcher<null> {\n    const notMatcher = new SelectorMatcher<null>();\n    notMatcher.addSelectables(notSelectors, null);\n    return notMatcher;\n  }\n\n  private _elementMap = new Map<string, SelectorContext<T>[]>();\n  private _elementPartialMap = new Map<string, SelectorMatcher<T>>();\n  private _classMap = new Map<string, SelectorContext<T>[]>();\n  private _classPartialMap = new Map<string, SelectorMatcher<T>>();\n  private _attrValueMap = new Map<string, Map<string, SelectorContext<T>[]>>();\n  private _attrValuePartialMap = new Map<string, Map<string, SelectorMatcher<T>>>();\n  private _listContexts: SelectorListContext[] = [];\n\n  addSelectables(cssSelectors: CssSelector[], callbackCtxt?: T) {\n    let listContext: SelectorListContext = null!;\n    if (cssSelectors.length > 1) {\n      listContext = new SelectorListContext(cssSelectors);\n      this._listContexts.push(listContext);\n    }\n    for (let i = 0; i < cssSelectors.length; i++) {\n      this._addSelectable(cssSelectors[i], callbackCtxt as T, listContext);\n    }\n  }\n\n  /**\n   * Add an object that can be found later on by calling `match`.\n   * @param cssSelector A css selector\n   * @param callbackCtxt An opaque object that will be given to the callback of the `match` function\n   */\n  private _addSelectable(\n      cssSelector: CssSelector, callbackCtxt: T, listContext: SelectorListContext) {\n    let matcher: SelectorMatcher<T> = this;\n    const element = cssSelector.element;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n    const selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n\n    if (element) {\n      const isTerminal = attrs.length === 0 && classNames.length === 0;\n      if (isTerminal) {\n        this._addTerminal(matcher._elementMap, element, selectable);\n      } else {\n        matcher = this._addPartial(matcher._elementPartialMap, element);\n      }\n    }\n\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const isTerminal = attrs.length === 0 && i === classNames.length - 1;\n        const className = classNames[i];\n        if (isTerminal) {\n          this._addTerminal(matcher._classMap, className, selectable);\n        } else {\n          matcher = this._addPartial(matcher._classPartialMap, className);\n        }\n      }\n    }\n\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const isTerminal = i === attrs.length - 2;\n        const name = attrs[i];\n        const value = attrs[i + 1];\n        if (isTerminal) {\n          const terminalMap = matcher._attrValueMap;\n          let terminalValuesMap = terminalMap.get(name);\n          if (!terminalValuesMap) {\n            terminalValuesMap = new Map<string, SelectorContext<T>[]>();\n            terminalMap.set(name, terminalValuesMap);\n          }\n          this._addTerminal(terminalValuesMap, value, selectable);\n        } else {\n          const partialMap = matcher._attrValuePartialMap;\n          let partialValuesMap = partialMap.get(name);\n          if (!partialValuesMap) {\n            partialValuesMap = new Map<string, SelectorMatcher<T>>();\n            partialMap.set(name, partialValuesMap);\n          }\n          matcher = this._addPartial(partialValuesMap, value);\n        }\n      }\n    }\n  }\n\n  private _addTerminal(\n      map: Map<string, SelectorContext<T>[]>, name: string, selectable: SelectorContext<T>) {\n    let terminalList = map.get(name);\n    if (!terminalList) {\n      terminalList = [];\n      map.set(name, terminalList);\n    }\n    terminalList.push(selectable);\n  }\n\n  private _addPartial(map: Map<string, SelectorMatcher<T>>, name: string): SelectorMatcher<T> {\n    let matcher = map.get(name);\n    if (!matcher) {\n      matcher = new SelectorMatcher<T>();\n      map.set(name, matcher);\n    }\n    return matcher;\n  }\n\n  /**\n   * Find the objects that have been added via `addSelectable`\n   * whose css selector is contained in the given css selector.\n   * @param cssSelector A css selector\n   * @param matchedCallback This callback will be called with the object handed into `addSelectable`\n   * @return boolean true if a match was found\n   */\n  match(cssSelector: CssSelector, matchedCallback: ((c: CssSelector, a: T) => void)|null): boolean {\n    let result = false;\n    const element = cssSelector.element!;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n\n    for (let i = 0; i < this._listContexts.length; i++) {\n      this._listContexts[i].alreadyMatched = false;\n    }\n\n    result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n    result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\n        result;\n\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const className = classNames[i];\n        result =\n            this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n        result =\n            this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n            result;\n      }\n    }\n\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const name = attrs[i];\n        const value = attrs[i + 1];\n\n        const terminalValuesMap = this._attrValueMap.get(name)!;\n        if (value) {\n          result =\n              this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n            this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n\n        const partialValuesMap = this._attrValuePartialMap.get(name)!;\n        if (value) {\n          result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n            this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n      }\n    }\n    return result;\n  }\n\n  /** @internal */\n  _matchTerminal(\n      map: Map<string, SelectorContext<T>[]>, name: string, cssSelector: CssSelector,\n      matchedCallback: ((c: CssSelector, a: any) => void)|null): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    let selectables: SelectorContext<T>[] = map.get(name) || [];\n    const starSelectables: SelectorContext<T>[] = map.get('*')!;\n    if (starSelectables) {\n      selectables = selectables.concat(starSelectables);\n    }\n    if (selectables.length === 0) {\n      return false;\n    }\n    let selectable: SelectorContext<T>;\n    let result = false;\n    for (let i = 0; i < selectables.length; i++) {\n      selectable = selectables[i];\n      result = selectable.finalize(cssSelector, matchedCallback) || result;\n    }\n    return result;\n  }\n\n  /** @internal */\n  _matchPartial(\n      map: Map<string, SelectorMatcher<T>>, name: string, cssSelector: CssSelector,\n      matchedCallback: ((c: CssSelector, a: any) => void)|null): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    const nestedSelector = map.get(name);\n    if (!nestedSelector) {\n      return false;\n    }\n    // TODO(perf): get rid of recursion and measure again\n    // TODO(perf): don't pass the whole selector into the recursion,\n    // but only the not processed parts\n    return nestedSelector.match(cssSelector, matchedCallback);\n  }\n}\n\n\nexport class SelectorListContext {\n  alreadyMatched: boolean = false;\n\n  constructor(public selectors: CssSelector[]) {}\n}\n\n// Store context to pass back selector and context when a selector is matched\nexport class SelectorContext<T = any> {\n  notSelectors: CssSelector[];\n\n  constructor(\n      public selector: CssSelector, public cbContext: T, public listContext: SelectorListContext) {\n    this.notSelectors = selector.notSelectors;\n  }\n\n  finalize(cssSelector: CssSelector, callback: ((c: CssSelector, a: T) => void)|null): boolean {\n    let result = true;\n    if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n      const notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n      result = !notMatcher.match(cssSelector, null);\n    }\n    if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n      if (this.listContext) {\n        this.listContext.alreadyMatched = true;\n      }\n      callback(this.selector, this.cbContext);\n    }\n    return result;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Attention:\n// This file duplicates types and values from @angular/core\n// so that we are able to make @angular/compiler independent of @angular/core.\n// This is important to prevent a build cycle, as @angular/core needs to\n// be compiled with the compiler.\n\nimport {CssSelector} from './selector';\n\n// Stores the default value of `emitDistinctChangesOnly` when the `emitDistinctChangesOnly` is not\n// explicitly set.\nexport const emitDistinctChangesOnlyDefaultValue = true;\n\nexport enum ViewEncapsulation {\n  Emulated = 0,\n  // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n  None = 2,\n  ShadowDom = 3\n}\n\nexport enum ChangeDetectionStrategy {\n  OnPush = 0,\n  Default = 1\n}\n\nexport interface Input {\n  bindingPropertyName?: string;\n}\n\nexport interface Output {\n  bindingPropertyName?: string;\n}\n\nexport interface HostBinding {\n  hostPropertyName?: string;\n}\n\nexport interface HostListener {\n  eventName?: string;\n  args?: string[];\n}\n\nexport interface SchemaMetadata {\n  name: string;\n}\n\nexport const CUSTOM_ELEMENTS_SCHEMA: SchemaMetadata = {\n  name: 'custom-elements'\n};\n\nexport const NO_ERRORS_SCHEMA: SchemaMetadata = {\n  name: 'no-errors-schema'\n};\n\nexport interface Type extends Function {\n  new(...args: any[]): any;\n}\nexport const Type = Function;\n\nexport enum SecurityContext {\n  NONE = 0,\n  HTML = 1,\n  STYLE = 2,\n  SCRIPT = 3,\n  URL = 4,\n  RESOURCE_URL = 5,\n}\n\n/**\n * Injection flags for DI.\n */\nexport const enum InjectFlags {\n  Default = 0,\n\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n  Host = 1 << 0,\n  /** Don't descend into ancestors of the node requesting injection. */\n  Self = 1 << 1,\n  /** Skip the node that is requesting injection. */\n  SkipSelf = 1 << 2,\n  /** Inject `defaultValue` instead if token not found. */\n  Optional = 1 << 3,\n  /**\n   * This token is being injected into a pipe.\n   * @internal\n   */\n  ForPipe = 1 << 4,\n}\n\nexport enum MissingTranslationStrategy {\n  Error = 0,\n  Warning = 1,\n  Ignore = 2,\n}\n\n/**\n * Flags used to generate R3-style CSS Selectors. They are pasted from\n * core/src/render3/projection.ts because they cannot be referenced directly.\n */\nexport const enum SelectorFlags {\n  /** Indicates this is the beginning of a new negative selector */\n  NOT = 0b0001,\n\n  /** Mode for matching attributes */\n  ATTRIBUTE = 0b0010,\n\n  /** Mode for matching tag names */\n  ELEMENT = 0b0100,\n\n  /** Mode for matching class names */\n  CLASS = 0b1000,\n}\n\n// These are a copy the CSS types from core/src/render3/interfaces/projection.ts\n// They are duplicated here as they cannot be directly referenced from core.\nexport type R3CssSelector = (string|SelectorFlags)[];\nexport type R3CssSelectorList = R3CssSelector[];\n\nfunction parserSelectorToSimpleSelector(selector: CssSelector): R3CssSelector {\n  const classes = selector.classNames && selector.classNames.length ?\n      [SelectorFlags.CLASS, ...selector.classNames] :\n      [];\n  const elementName = selector.element && selector.element !== '*' ? selector.element : '';\n  return [elementName, ...selector.attrs, ...classes];\n}\n\nfunction parserSelectorToNegativeSelector(selector: CssSelector): R3CssSelector {\n  const classes = selector.classNames && selector.classNames.length ?\n      [SelectorFlags.CLASS, ...selector.classNames] :\n      [];\n\n  if (selector.element) {\n    return [\n      SelectorFlags.NOT | SelectorFlags.ELEMENT, selector.element, ...selector.attrs, ...classes\n    ];\n  } else if (selector.attrs.length) {\n    return [SelectorFlags.NOT | SelectorFlags.ATTRIBUTE, ...selector.attrs, ...classes];\n  } else {\n    return selector.classNames && selector.classNames.length ?\n        [SelectorFlags.NOT | SelectorFlags.CLASS, ...selector.classNames] :\n        [];\n  }\n}\n\nfunction parserSelectorToR3Selector(selector: CssSelector): R3CssSelector {\n  const positive = parserSelectorToSimpleSelector(selector);\n\n  const negative: R3CssSelectorList = selector.notSelectors && selector.notSelectors.length ?\n      selector.notSelectors.map(notSelector => parserSelectorToNegativeSelector(notSelector)) :\n      [];\n\n  return positive.concat(...negative);\n}\n\nexport function parseSelectorToR3Selector(selector: string|null): R3CssSelectorList {\n  return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];\n}\n\n// Pasted from render3/interfaces/definition since it cannot be referenced directly\n/**\n * Flags passed into template functions to determine which blocks (i.e. creation, update)\n * should be executed.\n *\n * Typically, a template runs both the creation block and the update block on initialization and\n * subsequent runs only execute the update block. However, dynamically created views require that\n * the creation block be executed separately from the update block (for backwards compat).\n */\nexport const enum RenderFlags {\n  /* Whether to run the creation block (e.g. create elements and directives) */\n  Create = 0b01,\n\n  /* Whether to run the update block (e.g. refresh bindings) */\n  Update = 0b10\n}\n\n// Pasted from render3/interfaces/node.ts\n/**\n * A set of marker values to be used in the attributes arrays. These markers indicate that some\n * items are not regular attributes and the processing should be adapted accordingly.\n */\nexport const enum AttributeMarker {\n  /**\n   * Marker indicates that the following 3 values in the attributes array are:\n   * namespaceUri, attributeName, attributeValue\n   * in that order.\n   */\n  NamespaceURI = 0,\n\n  /**\n   * Signals class declaration.\n   *\n   * Each value following `Classes` designates a class name to include on the element.\n   * ## Example:\n   *\n   * Given:\n   * ```\n   * <div class=\"foo bar baz\">...<d/vi>\n   * ```\n   *\n   * the generated code is:\n   * ```\n   * var _c1 = [AttributeMarker.Classes, 'foo', 'bar', 'baz'];\n   * ```\n   */\n  Classes = 1,\n\n  /**\n   * Signals style declaration.\n   *\n   * Each pair of values following `Styles` designates a style name and value to include on the\n   * element.\n   * ## Example:\n   *\n   * Given:\n   * ```\n   * <div style=\"width:100px; height:200px; color:red\">...</div>\n   * ```\n   *\n   * the generated code is:\n   * ```\n   * var _c1 = [AttributeMarker.Styles, 'width', '100px', 'height'. '200px', 'color', 'red'];\n   * ```\n   */\n  Styles = 2,\n\n  /**\n   * Signals that the following attribute names were extracted from input or output bindings.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div moo=\"car\" [foo]=\"exp\" (bar)=\"doSth()\">\n   * ```\n   *\n   * the generated code is:\n   *\n   * ```\n   * var _c1 = ['moo', 'car', AttributeMarker.Bindings, 'foo', 'bar'];\n   * ```\n   */\n  Bindings = 3,\n\n  /**\n   * Signals that the following attribute names were hoisted from an inline-template declaration.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div *ngFor=\"let value of values; trackBy:trackBy\" dirA [dirB]=\"value\">\n   * ```\n   *\n   * the generated code for the `template()` instruction would include:\n   *\n   * ```\n   * ['dirA', '', AttributeMarker.Bindings, 'dirB', AttributeMarker.Template, 'ngFor', 'ngForOf',\n   * 'ngForTrackBy', 'let-value']\n   * ```\n   *\n   * while the generated code for the `element()` instruction inside the template function would\n   * include:\n   *\n   * ```\n   * ['dirA', '', AttributeMarker.Bindings, 'dirB']\n   * ```\n   */\n  Template = 4,\n\n  /**\n   * Signals that the following attribute is `ngProjectAs` and its value is a parsed `CssSelector`.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <h1 attr=\"value\" ngProjectAs=\"[title]\">\n   * ```\n   *\n   * the generated code for the `element()` instruction would include:\n   *\n   * ```\n   * ['attr', 'value', AttributeMarker.ProjectAs, ['', 'title', '']]\n   * ```\n   */\n  ProjectAs = 5,\n\n  /**\n   * Signals that the following attribute will be translated by runtime i18n\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div moo=\"car\" foo=\"value\" i18n-foo [bar]=\"binding\" i18n-bar>\n   * ```\n   *\n   * the generated code is:\n   *\n   * ```\n   * var _c1 = ['moo', 'car', AttributeMarker.I18n, 'foo', 'bar'];\n   */\n  I18n = 6,\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n\nexport function dashCaseToCamelCase(input: string): string {\n  return input.replace(DASH_CASE_REGEXP, (...m: any[]) => m[1].toUpperCase());\n}\n\nexport function splitAtColon(input: string, defaultValues: string[]): string[] {\n  return _splitAt(input, ':', defaultValues);\n}\n\nexport function splitAtPeriod(input: string, defaultValues: string[]): string[] {\n  return _splitAt(input, '.', defaultValues);\n}\n\nfunction _splitAt(input: string, character: string, defaultValues: string[]): string[] {\n  const characterIndex = input.indexOf(character);\n  if (characterIndex == -1) return defaultValues;\n  return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\n\nexport function noUndefined<T>(val: T|undefined): T {\n  return val === undefined ? null! : val;\n}\n\nexport function error(msg: string): never {\n  throw new Error(`Internal Error: ${msg}`);\n}\n\n// Escape characters that have a special meaning in Regular Expressions\nexport function escapeRegExp(s: string): string {\n  return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\n\nexport type Byte = number;\n\nexport function utf8Encode(str: string): Byte[] {\n  let encoded: Byte[] = [];\n  for (let index = 0; index < str.length; index++) {\n    let codePoint = str.charCodeAt(index);\n\n    // decode surrogate\n    // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n    if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {\n      const low = str.charCodeAt(index + 1);\n      if (low >= 0xdc00 && low <= 0xdfff) {\n        index++;\n        codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n      }\n    }\n\n    if (codePoint <= 0x7f) {\n      encoded.push(codePoint);\n    } else if (codePoint <= 0x7ff) {\n      encoded.push(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);\n    } else if (codePoint <= 0xffff) {\n      encoded.push(\n          (codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n    } else if (codePoint <= 0x1fffff) {\n      encoded.push(\n          ((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80,\n          ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n    }\n  }\n\n  return encoded;\n}\n\nexport function stringify(token: any): string {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (Array.isArray(token)) {\n    return '[' + token.map(stringify).join(', ') + ']';\n  }\n\n  if (token == null) {\n    return '' + token;\n  }\n\n  if (token.overriddenName) {\n    return `${token.overriddenName}`;\n  }\n\n  if (token.name) {\n    return `${token.name}`;\n  }\n\n  if (!token.toString) {\n    return 'object';\n  }\n\n  // WARNING: do not try to `JSON.stringify(token)` here\n  // see https://github.com/angular/angular/issues/23440\n  const res = token.toString();\n\n  if (res == null) {\n    return '' + res;\n  }\n\n  const newLineIndex = res.indexOf('\\n');\n  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n\nexport class Version {\n  public readonly major: string;\n  public readonly minor: string;\n  public readonly patch: string;\n\n  constructor(public full: string) {\n    const splits = full.split('.');\n    this.major = splits[0];\n    this.minor = splits[1];\n    this.patch = splits.slice(2).join('.');\n  }\n}\n\nexport interface Console {\n  log(message: string): void;\n  warn(message: string): void;\n}\n\n\ndeclare var WorkerGlobalScope: any;\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\ndeclare var global: any;\n\n// Check `global` first, because in Node tests both `global` and `window` may be defined and our\n// `_global` variable should point to the NodeJS `global` in that case. Note: Typeof/Instanceof\n// checks are considered side-effects in Terser. We explicitly mark this as side-effect free:\n// https://github.com/terser/terser/issues/250.\nconst _global: {[name: string]: any} = (/* @__PURE__ */ (\n    () => (typeof global !== 'undefined' && global) || (typeof window !== 'undefined' && window) ||\n        (typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n         self instanceof WorkerGlobalScope && self))());\n\nexport {_global as global};\n\nexport function newArray<T = any>(size: number): T[];\nexport function newArray<T>(size: number, value: T): T[];\nexport function newArray<T>(size: number, value?: T): T[] {\n  const list: T[] = [];\n  for (let i = 0; i < size; i++) {\n    list.push(value!);\n  }\n  return list;\n}\n\n/**\n * Partitions a given array into 2 arrays, based on a boolean value returned by the condition\n * function.\n *\n * @param arr Input array that should be partitioned\n * @param conditionFn Condition function that is called for each item in a given array and returns a\n * boolean value.\n */\nexport function partitionArray<T, F = T>(\n    arr: (T|F)[], conditionFn: (value: T|F) => boolean): [T[], F[]] {\n  const truthy: T[] = [];\n  const falsy: F[] = [];\n  for (const item of arr) {\n    (conditionFn(item) ? truthy : falsy).push(item as any);\n  }\n  return [truthy, falsy];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Represents a big integer using a buffer of its individual digits, with the least significant\n * digit stored at the beginning of the array (little endian).\n *\n * For performance reasons, each instance is mutable. The addition operation can be done in-place\n * to reduce memory pressure of allocation for the digits array.\n */\nexport class BigInteger {\n  static zero(): BigInteger {\n    return new BigInteger([0]);\n  }\n\n  static one(): BigInteger {\n    return new BigInteger([1]);\n  }\n\n  /**\n   * Creates a big integer using its individual digits in little endian storage.\n   */\n  private constructor(private readonly digits: number[]) {}\n\n  /**\n   * Creates a clone of this instance.\n   */\n  clone(): BigInteger {\n    return new BigInteger(this.digits.slice());\n  }\n\n  /**\n   * Returns a new big integer with the sum of `this` and `other` as its value. This does not mutate\n   * `this` but instead returns a new instance, unlike `addToSelf`.\n   */\n  add(other: BigInteger): BigInteger {\n    const result = this.clone();\n    result.addToSelf(other);\n    return result;\n  }\n\n  /**\n   * Adds `other` to the instance itself, thereby mutating its value.\n   */\n  addToSelf(other: BigInteger): void {\n    const maxNrOfDigits = Math.max(this.digits.length, other.digits.length);\n    let carry = 0;\n    for (let i = 0; i < maxNrOfDigits; i++) {\n      let digitSum = carry;\n      if (i < this.digits.length) {\n        digitSum += this.digits[i];\n      }\n      if (i < other.digits.length) {\n        digitSum += other.digits[i];\n      }\n\n      if (digitSum >= 10) {\n        this.digits[i] = digitSum - 10;\n        carry = 1;\n      } else {\n        this.digits[i] = digitSum;\n        carry = 0;\n      }\n    }\n\n    // Apply a remaining carry if needed.\n    if (carry > 0) {\n      this.digits[maxNrOfDigits] = 1;\n    }\n  }\n\n  /**\n   * Builds the decimal string representation of the big integer. As this is stored in\n   * little endian, the digits are concatenated in reverse order.\n   */\n  toString(): string {\n    let res = '';\n    for (let i = this.digits.length - 1; i >= 0; i--) {\n      res += this.digits[i];\n    }\n    return res;\n  }\n}\n\n/**\n * Represents a big integer which is optimized for multiplication operations, as its power-of-twos\n * are memoized. See `multiplyBy()` for details on the multiplication algorithm.\n */\nexport class BigIntForMultiplication {\n  /**\n   * Stores all memoized power-of-twos, where each index represents `this.number * 2^index`.\n   */\n  private readonly powerOfTwos: BigInteger[];\n\n  constructor(value: BigInteger) {\n    this.powerOfTwos = [value];\n  }\n\n  /**\n   * Returns the big integer itself.\n   */\n  getValue(): BigInteger {\n    return this.powerOfTwos[0];\n  }\n\n  /**\n   * Computes the value for `num * b`, where `num` is a JS number and `b` is a big integer. The\n   * value for `b` is represented by a storage model that is optimized for this computation.\n   *\n   * This operation is implemented in N(log2(num)) by continuous halving of the number, where the\n   * least-significant bit (LSB) is tested in each iteration. If the bit is set, the bit's index is\n   * used as exponent into the power-of-two multiplication of `b`.\n   *\n   * As an example, consider the multiplication num=42, b=1337. In binary 42 is 0b00101010 and the\n   * algorithm unrolls into the following iterations:\n   *\n   *  Iteration | num        | LSB  | b * 2^iter | Add? | product\n   * -----------|------------|------|------------|------|--------\n   *  0         | 0b00101010 | 0    | 1337       | No   | 0\n   *  1         | 0b00010101 | 1    | 2674       | Yes  | 2674\n   *  2         | 0b00001010 | 0    | 5348       | No   | 2674\n   *  3         | 0b00000101 | 1    | 10696      | Yes  | 13370\n   *  4         | 0b00000010 | 0    | 21392      | No   | 13370\n   *  5         | 0b00000001 | 1    | 42784      | Yes  | 56154\n   *  6         | 0b00000000 | 0    | 85568      | No   | 56154\n   *\n   * The computed product of 56154 is indeed the correct result.\n   *\n   * The `BigIntForMultiplication` representation for a big integer provides memoized access to the\n   * power-of-two values to reduce the workload in computing those values.\n   */\n  multiplyBy(num: number): BigInteger {\n    const product = BigInteger.zero();\n    this.multiplyByAndAddTo(num, product);\n    return product;\n  }\n\n  /**\n   * See `multiplyBy()` for details. This function allows for the computed product to be added\n   * directly to the provided result big integer.\n   */\n  multiplyByAndAddTo(num: number, result: BigInteger): void {\n    for (let exponent = 0; num !== 0; num = num >>> 1, exponent++) {\n      if (num & 1) {\n        const value = this.getMultipliedByPowerOfTwo(exponent);\n        result.addToSelf(value);\n      }\n    }\n  }\n\n  /**\n   * Computes and memoizes the big integer value for `this.number * 2^exponent`.\n   */\n  private getMultipliedByPowerOfTwo(exponent: number): BigInteger {\n    // Compute the powers up until the requested exponent, where each value is computed from its\n    // predecessor. This is simple as `this.number * 2^(exponent - 1)` only has to be doubled (i.e.\n    // added to itself) to reach `this.number * 2^exponent`.\n    for (let i = this.powerOfTwos.length; i <= exponent; i++) {\n      const previousPower = this.powerOfTwos[i - 1];\n      this.powerOfTwos[i] = previousPower.add(previousPower);\n    }\n    return this.powerOfTwos[exponent];\n  }\n}\n\n/**\n * Represents an exponentiation operation for the provided base, of which exponents are computed and\n * memoized. The results are represented by a `BigIntForMultiplication` which is tailored for\n * multiplication operations by memoizing the power-of-twos. This effectively results in a matrix\n * representation that is lazily computed upon request.\n */\nexport class BigIntExponentiation {\n  private readonly exponents = [new BigIntForMultiplication(BigInteger.one())];\n\n  constructor(private readonly base: number) {}\n\n  /**\n   * Compute the value for `this.base^exponent`, resulting in a big integer that is optimized for\n   * further multiplication operations.\n   */\n  toThePowerOf(exponent: number): BigIntForMultiplication {\n    // Compute the results up until the requested exponent, where every value is computed from its\n    // predecessor. This is because `this.base^(exponent - 1)` only has to be multiplied by `base`\n    // to reach `this.base^exponent`.\n    for (let i = this.exponents.length; i <= exponent; i++) {\n      const value = this.exponents[i - 1].multiplyBy(this.base);\n      this.exponents[i] = new BigIntForMultiplication(value);\n    }\n    return this.exponents[exponent];\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Byte, newArray, utf8Encode} from '../util';\nimport {BigIntExponentiation} from './big_integer';\n\nimport * as i18n from './i18n_ast';\n\n/**\n * Return the message id or compute it using the XLIFF1 digest.\n */\nexport function digest(message: i18n.Message): string {\n  return message.id || computeDigest(message);\n}\n\n/**\n * Compute the message id using the XLIFF1 digest.\n */\nexport function computeDigest(message: i18n.Message): string {\n  return sha1(serializeNodes(message.nodes).join('') + `[${message.meaning}]`);\n}\n\n/**\n * Return the message id or compute it using the XLIFF2/XMB/$localize digest.\n */\nexport function decimalDigest(message: i18n.Message): string {\n  return message.id || computeDecimalDigest(message);\n}\n\n/**\n * Compute the message id using the XLIFF2/XMB/$localize digest.\n */\nexport function computeDecimalDigest(message: i18n.Message): string {\n  const visitor = new _SerializerIgnoreIcuExpVisitor();\n  const parts = message.nodes.map(a => a.visit(visitor, null));\n  return computeMsgId(parts.join(''), message.meaning);\n}\n\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * @internal\n */\nclass _SerializerVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context: any): any {\n    return text.value;\n  }\n\n  visitContainer(container: i18n.Container, context: any): any {\n    return `[${container.children.map(child => child.visit(this)).join(', ')}]`;\n  }\n\n  visitIcu(icu: i18n.Icu, context: any): any {\n    const strCases =\n        Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.expression}, ${icu.type}, ${strCases.join(', ')}}`;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context: any): any {\n    return ph.isVoid ?\n        `<ph tag name=\"${ph.startName}\"/>` :\n        `<ph tag name=\"${ph.startName}\">${\n            ph.children.map(child => child.visit(this)).join(', ')}</ph name=\"${ph.closeName}\">`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context: any): any {\n    return ph.value ? `<ph name=\"${ph.name}\">${ph.value}</ph>` : `<ph name=\"${ph.name}\"/>`;\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    return `<ph icu name=\"${ph.name}\">${ph.value.visit(this)}</ph>`;\n  }\n}\n\nconst serializerVisitor = new _SerializerVisitor();\n\nexport function serializeNodes(nodes: i18n.Node[]): string[] {\n  return nodes.map(a => a.visit(serializerVisitor, null));\n}\n\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * @internal\n */\nclass _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {\n  override visitIcu(icu: i18n.Icu, context: any): any {\n    let strCases = Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    // Do not take the expression into account\n    return `{${icu.type}, ${strCases.join(', ')}}`;\n  }\n}\n\n/**\n * Compute the SHA1 of the given string\n *\n * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n */\nexport function sha1(str: string): string {\n  const utf8 = utf8Encode(str);\n  const words32 = bytesToWords32(utf8, Endian.Big);\n  const len = utf8.length * 8;\n\n  const w = newArray(80);\n  let a = 0x67452301, b = 0xefcdab89, c = 0x98badcfe, d = 0x10325476, e = 0xc3d2e1f0;\n\n  words32[len >> 5] |= 0x80 << (24 - len % 32);\n  words32[((len + 64 >> 9) << 4) + 15] = len;\n\n  for (let i = 0; i < words32.length; i += 16) {\n    const h0 = a, h1 = b, h2 = c, h3 = d, h4 = e;\n\n    for (let j = 0; j < 80; j++) {\n      if (j < 16) {\n        w[j] = words32[i + j];\n      } else {\n        w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n      }\n\n      const fkVal = fk(j, b, c, d);\n      const f = fkVal[0];\n      const k = fkVal[1];\n      const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n      e = d;\n      d = c;\n      c = rol32(b, 30);\n      b = a;\n      a = temp;\n    }\n    a = add32(a, h0);\n    b = add32(b, h1);\n    c = add32(c, h2);\n    d = add32(d, h3);\n    e = add32(e, h4);\n  }\n\n  return bytesToHexString(words32ToByteString([a, b, c, d, e]));\n}\n\nfunction fk(index: number, b: number, c: number, d: number): [number, number] {\n  if (index < 20) {\n    return [(b & c) | (~b & d), 0x5a827999];\n  }\n\n  if (index < 40) {\n    return [b ^ c ^ d, 0x6ed9eba1];\n  }\n\n  if (index < 60) {\n    return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n  }\n\n  return [b ^ c ^ d, 0xca62c1d6];\n}\n\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n */\nexport function fingerprint(str: string): [number, number] {\n  const utf8 = utf8Encode(str);\n\n  let hi = hash32(utf8, 0);\n  let lo = hash32(utf8, 102072);\n\n  if (hi == 0 && (lo == 0 || lo == 1)) {\n    hi = hi ^ 0x130f9bef;\n    lo = lo ^ -0x6b5f56d8;\n  }\n\n  return [hi, lo];\n}\n\nexport function computeMsgId(msg: string, meaning: string = ''): string {\n  let msgFingerprint = fingerprint(msg);\n\n  if (meaning) {\n    const meaningFingerprint = fingerprint(meaning);\n    msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);\n  }\n\n  const hi = msgFingerprint[0];\n  const lo = msgFingerprint[1];\n\n  return wordsToDecimalString(hi & 0x7fffffff, lo);\n}\n\nfunction hash32(bytes: Byte[], c: number): number {\n  let a = 0x9e3779b9, b = 0x9e3779b9;\n  let i: number;\n\n  const len = bytes.length;\n\n  for (i = 0; i + 12 <= len; i += 12) {\n    a = add32(a, wordAt(bytes, i, Endian.Little));\n    b = add32(b, wordAt(bytes, i + 4, Endian.Little));\n    c = add32(c, wordAt(bytes, i + 8, Endian.Little));\n    const res = mix(a, b, c);\n    a = res[0], b = res[1], c = res[2];\n  }\n\n  a = add32(a, wordAt(bytes, i, Endian.Little));\n  b = add32(b, wordAt(bytes, i + 4, Endian.Little));\n  // the first byte of c is reserved for the length\n  c = add32(c, len);\n  c = add32(c, wordAt(bytes, i + 8, Endian.Little) << 8);\n\n  return mix(a, b, c)[2];\n}\n\n// clang-format off\nfunction mix(a: number, b: number, c: number): [number, number, number] {\n  a = sub32(a, b); a = sub32(a, c); a ^= c >>> 13;\n  b = sub32(b, c); b = sub32(b, a); b ^= a << 8;\n  c = sub32(c, a); c = sub32(c, b); c ^= b >>> 13;\n  a = sub32(a, b); a = sub32(a, c); a ^= c >>> 12;\n  b = sub32(b, c); b = sub32(b, a); b ^= a << 16;\n  c = sub32(c, a); c = sub32(c, b); c ^= b >>> 5;\n  a = sub32(a, b); a = sub32(a, c); a ^= c >>> 3;\n  b = sub32(b, c); b = sub32(b, a); b ^= a << 10;\n  c = sub32(c, a); c = sub32(c, b); c ^= b >>> 15;\n  return [a, b, c];\n}\n// clang-format on\n\n// Utils\n\nenum Endian {\n  Little,\n  Big,\n}\n\nfunction add32(a: number, b: number): number {\n  return add32to64(a, b)[1];\n}\n\nfunction add32to64(a: number, b: number): [number, number] {\n  const low = (a & 0xffff) + (b & 0xffff);\n  const high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n  return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\n\nfunction add64(a: [number, number], b: [number, number]): [number, number] {\n  const ah = a[0], al = a[1];\n  const bh = b[0], bl = b[1];\n  const result = add32to64(al, bl);\n  const carry = result[0];\n  const l = result[1];\n  const h = add32(add32(ah, bh), carry);\n  return [h, l];\n}\n\nfunction sub32(a: number, b: number): number {\n  const low = (a & 0xffff) - (b & 0xffff);\n  const high = (a >> 16) - (b >> 16) + (low >> 16);\n  return (high << 16) | (low & 0xffff);\n}\n\n// Rotate a 32b number left `count` position\nfunction rol32(a: number, count: number): number {\n  return (a << count) | (a >>> (32 - count));\n}\n\n// Rotate a 64b number left `count` position\nfunction rol64(num: [number, number], count: number): [number, number] {\n  const hi = num[0], lo = num[1];\n  const h = (hi << count) | (lo >>> (32 - count));\n  const l = (lo << count) | (hi >>> (32 - count));\n  return [h, l];\n}\n\nfunction bytesToWords32(bytes: Byte[], endian: Endian): number[] {\n  const size = (bytes.length + 3) >>> 2;\n  const words32 = [];\n\n  for (let i = 0; i < size; i++) {\n    words32[i] = wordAt(bytes, i * 4, endian);\n  }\n\n  return words32;\n}\n\nfunction byteAt(bytes: Byte[], index: number): Byte {\n  return index >= bytes.length ? 0 : bytes[index];\n}\n\nfunction wordAt(bytes: Byte[], index: number, endian: Endian): number {\n  let word = 0;\n  if (endian === Endian.Big) {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << (24 - 8 * i);\n    }\n  } else {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << 8 * i;\n    }\n  }\n  return word;\n}\n\nfunction words32ToByteString(words32: number[]): Byte[] {\n  return words32.reduce((bytes, word) => bytes.concat(word32ToByteString(word)), [] as Byte[]);\n}\n\nfunction word32ToByteString(word: number): Byte[] {\n  let bytes: Byte[] = [];\n  for (let i = 0; i < 4; i++) {\n    bytes.push((word >>> 8 * (3 - i)) & 0xff);\n  }\n  return bytes;\n}\n\nfunction bytesToHexString(bytes: Byte[]): string {\n  let hex: string = '';\n  for (let i = 0; i < bytes.length; i++) {\n    const b = byteAt(bytes, i);\n    hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);\n  }\n  return hex.toLowerCase();\n}\n\n/**\n * Create a shared exponentiation pool for base-256 computations. This shared pool provides memoized\n * power-of-256 results with memoized power-of-two computations for efficient multiplication.\n *\n * For our purposes, this can be safely stored as a global without memory concerns. The reason is\n * that we encode two words, so only need the 0th (for the low word) and 4th (for the high word)\n * exponent.\n */\nconst base256 = new BigIntExponentiation(256);\n\n/**\n * Represents two 32-bit words as a single decimal number. This requires a big integer storage\n * model as JS numbers are not accurate enough to represent the 64-bit number.\n *\n * Based on https://www.danvk.org/hex2dec.html\n */\nfunction wordsToDecimalString(hi: number, lo: number): string {\n  // Encode the four bytes in lo in the lower digits of the decimal number.\n  // Note: the multiplication results in lo itself but represented by a big integer using its\n  // decimal digits.\n  const decimal = base256.toThePowerOf(0).multiplyBy(lo);\n\n  // Encode the four bytes in hi above the four lo bytes. lo is a maximum of (2^8)^4, which is why\n  // this multiplication factor is applied.\n  base256.toThePowerOf(4).multiplyByAndAddTo(hi, decimal);\n\n  return decimal.toString();\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {computeMsgId} from '../i18n/digest';\nimport {Message} from '../i18n/i18n_ast';\nimport {ParseSourceSpan} from '../parse_util';\nimport {I18nMeta} from '../render3/view/i18n/meta';\n\n//// Types\nexport enum TypeModifier {\n  None = 0,\n  Const = 1 << 0,\n}\n\nexport abstract class Type {\n  constructor(public modifiers: TypeModifier = TypeModifier.None) {}\n  abstract visitType(visitor: TypeVisitor, context: any): any;\n\n  hasModifier(modifier: TypeModifier): boolean {\n    return (this.modifiers & modifier) !== 0;\n  }\n}\n\nexport enum BuiltinTypeName {\n  Dynamic,\n  Bool,\n  String,\n  Int,\n  Number,\n  Function,\n  Inferred,\n  None,\n}\n\nexport class BuiltinType extends Type {\n  constructor(public name: BuiltinTypeName, modifiers?: TypeModifier) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitBuiltinType(this, context);\n  }\n}\n\nexport class ExpressionType extends Type {\n  constructor(\n      public value: Expression, modifiers?: TypeModifier, public typeParams: Type[]|null = null) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitExpressionType(this, context);\n  }\n}\n\n\nexport class ArrayType extends Type {\n  constructor(public of: Type, modifiers?: TypeModifier) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitArrayType(this, context);\n  }\n}\n\n\nexport class MapType extends Type {\n  public valueType: Type|null;\n  constructor(valueType: Type|null|undefined, modifiers?: TypeModifier) {\n    super(modifiers);\n    this.valueType = valueType || null;\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitMapType(this, context);\n  }\n}\n\nexport const DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nexport const INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nexport const BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nexport const INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nexport const NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nexport const STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nexport const FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nexport const NONE_TYPE = new BuiltinType(BuiltinTypeName.None);\n\nexport interface TypeVisitor {\n  visitBuiltinType(type: BuiltinType, context: any): any;\n  visitExpressionType(type: ExpressionType, context: any): any;\n  visitArrayType(type: ArrayType, context: any): any;\n  visitMapType(type: MapType, context: any): any;\n}\n\n///// Expressions\n\nexport enum UnaryOperator {\n  Minus,\n  Plus,\n}\n\nexport enum BinaryOperator {\n  Equals,\n  NotEquals,\n  Identical,\n  NotIdentical,\n  Minus,\n  Plus,\n  Divide,\n  Multiply,\n  Modulo,\n  And,\n  Or,\n  BitwiseAnd,\n  Lower,\n  LowerEquals,\n  Bigger,\n  BiggerEquals,\n  NullishCoalesce,\n}\n\nexport function nullSafeIsEquivalent<T extends {isEquivalent(other: T): boolean}>(\n    base: T|null, other: T|null) {\n  if (base == null || other == null) {\n    return base == other;\n  }\n  return base.isEquivalent(other);\n}\n\nfunction areAllEquivalentPredicate<T>(\n    base: T[], other: T[], equivalentPredicate: (baseElement: T, otherElement: T) => boolean) {\n  const len = base.length;\n  if (len !== other.length) {\n    return false;\n  }\n  for (let i = 0; i < len; i++) {\n    if (!equivalentPredicate(base[i], other[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function areAllEquivalent<T extends {isEquivalent(other: T): boolean}>(\n    base: T[], other: T[]) {\n  return areAllEquivalentPredicate(\n      base, other, (baseElement: T, otherElement: T) => baseElement.isEquivalent(otherElement));\n}\n\nexport abstract class Expression {\n  public type: Type|null;\n  public sourceSpan: ParseSourceSpan|null;\n\n  constructor(type: Type|null|undefined, sourceSpan?: ParseSourceSpan|null) {\n    this.type = type || null;\n    this.sourceSpan = sourceSpan || null;\n  }\n\n  abstract visitExpression(visitor: ExpressionVisitor, context: any): any;\n\n  /**\n   * Calculates whether this expression produces the same value as the given expression.\n   * Note: We don't check Types nor ParseSourceSpans nor function arguments.\n   */\n  abstract isEquivalent(e: Expression): boolean;\n\n  /**\n   * Return true if the expression is constant.\n   */\n  abstract isConstant(): boolean;\n\n  prop(name: string, sourceSpan?: ParseSourceSpan|null): ReadPropExpr {\n    return new ReadPropExpr(this, name, null, sourceSpan);\n  }\n\n  key(index: Expression, type?: Type|null, sourceSpan?: ParseSourceSpan|null): ReadKeyExpr {\n    return new ReadKeyExpr(this, index, type, sourceSpan);\n  }\n\n  callFn(params: Expression[], sourceSpan?: ParseSourceSpan|null, pure?: boolean):\n      InvokeFunctionExpr {\n    return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);\n  }\n\n  instantiate(params: Expression[], type?: Type|null, sourceSpan?: ParseSourceSpan|null):\n      InstantiateExpr {\n    return new InstantiateExpr(this, params, type, sourceSpan);\n  }\n\n  conditional(\n      trueCase: Expression, falseCase: Expression|null = null,\n      sourceSpan?: ParseSourceSpan|null): ConditionalExpr {\n    return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n  }\n\n  equals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n  }\n  notEquals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n  }\n  identical(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n  }\n  notIdentical(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n  }\n  minus(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n  }\n  plus(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n  }\n  divide(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n  }\n  multiply(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n  }\n  modulo(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n  }\n  and(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n  }\n  bitwiseAnd(rhs: Expression, sourceSpan?: ParseSourceSpan|null, parens: boolean = true):\n      BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);\n  }\n  or(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n  }\n  lower(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n  }\n  lowerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n  }\n  bigger(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n  }\n  biggerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n  }\n  isBlank(sourceSpan?: ParseSourceSpan|null): Expression {\n    // Note: We use equals by purpose here to compare to null and undefined in JS.\n    // We use the typed null to allow strictNullChecks to narrow types.\n    return this.equals(TYPED_NULL_EXPR, sourceSpan);\n  }\n  nullishCoalesce(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);\n  }\n\n  toStmt(): Statement {\n    return new ExpressionStatement(this, null);\n  }\n}\n\nexport class ReadVarExpr extends Expression {\n  constructor(public name: string, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ReadVarExpr && this.name === e.name;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadVarExpr(this, context);\n  }\n\n  set(value: Expression): WriteVarExpr {\n    return new WriteVarExpr(this.name, value, null, this.sourceSpan);\n  }\n}\n\nexport class TypeofExpr extends Expression {\n  constructor(public expr: Expression, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any) {\n    return visitor.visitTypeofExpr(this, context);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\n  }\n\n  override isConstant(): boolean {\n    return this.expr.isConstant();\n  }\n}\n\nexport class WrappedNodeExpr<T> extends Expression {\n  constructor(public node: T, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof WrappedNodeExpr && this.node === e.node;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWrappedNodeExpr(this, context);\n  }\n}\n\nexport class WriteVarExpr extends Expression {\n  public value: Expression;\n  constructor(\n      public name: string, value: Expression, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWriteVarExpr(this, context);\n  }\n\n  toDeclStmt(type?: Type|null, modifiers?: StmtModifier): DeclareVarStmt {\n    return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n  }\n\n  toConstDecl(): DeclareVarStmt {\n    return this.toDeclStmt(INFERRED_TYPE, StmtModifier.Final);\n  }\n}\n\n\nexport class WriteKeyExpr extends Expression {\n  public value: Expression;\n  constructor(\n      public receiver: Expression, public index: Expression, value: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWriteKeyExpr(this, context);\n  }\n}\n\n\nexport class WritePropExpr extends Expression {\n  public value: Expression;\n  constructor(\n      public receiver: Expression, public name: string, value: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.name === e.name && this.value.isEquivalent(e.value);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWritePropExpr(this, context);\n  }\n}\n\nexport class InvokeFunctionExpr extends Expression {\n  constructor(\n      public fn: Expression, public args: Expression[], type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public pure = false) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) &&\n        areAllEquivalent(this.args, e.args) && this.pure === e.pure;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitInvokeFunctionExpr(this, context);\n  }\n}\n\n\nexport class TaggedTemplateExpr extends Expression {\n  constructor(\n      public tag: Expression, public template: TemplateLiteral, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof TaggedTemplateExpr && this.tag.isEquivalent(e.tag) &&\n        areAllEquivalentPredicate(\n               this.template.elements, e.template.elements, (a, b) => a.text === b.text) &&\n        areAllEquivalent(this.template.expressions, e.template.expressions);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitTaggedTemplateExpr(this, context);\n  }\n}\n\n\nexport class InstantiateExpr extends Expression {\n  constructor(\n      public classExpr: Expression, public args: Expression[], type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) &&\n        areAllEquivalent(this.args, e.args);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitInstantiateExpr(this, context);\n  }\n}\n\n\nexport class LiteralExpr extends Expression {\n  constructor(\n      public value: number|string|boolean|null|undefined, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralExpr && this.value === e.value;\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralExpr(this, context);\n  }\n}\n\nexport class TemplateLiteral {\n  constructor(public elements: TemplateLiteralElement[], public expressions: Expression[]) {}\n}\nexport class TemplateLiteralElement {\n  rawText: string;\n  constructor(public text: string, public sourceSpan?: ParseSourceSpan, rawText?: string) {\n    // If `rawText` is not provided, try to extract the raw string from its\n    // associated `sourceSpan`. If that is also not available, \"fake\" the raw\n    // string instead by escaping the following control sequences:\n    // - \"\\\" would otherwise indicate that the next character is a control character.\n    // - \"`\" and \"${\" are template string control sequences that would otherwise prematurely\n    // indicate the end of the template literal element.\n    this.rawText =\n        rawText ?? sourceSpan?.toString() ?? escapeForTemplateLiteral(escapeSlashes(text));\n  }\n}\n\nexport class LiteralPiece {\n  constructor(public text: string, public sourceSpan: ParseSourceSpan) {}\n}\nexport class PlaceholderPiece {\n  /**\n   * Create a new instance of a `PlaceholderPiece`.\n   *\n   * @param text the name of this placeholder (e.g. `PH_1`).\n   * @param sourceSpan the location of this placeholder in its localized message the source code.\n   * @param associatedMessage reference to another message that this placeholder is associated with.\n   * The `associatedMessage` is mainly used to provide a relationship to an ICU message that has\n   * been extracted out from the message containing the placeholder.\n   */\n  constructor(\n      public text: string, public sourceSpan: ParseSourceSpan, public associatedMessage?: Message) {\n  }\n}\n\nexport type MessagePiece = LiteralPiece|PlaceholderPiece;\n\nconst MEANING_SEPARATOR = '|';\nconst ID_SEPARATOR = '@@';\nconst LEGACY_ID_INDICATOR = '\u241F';\n\nexport class LocalizedString extends Expression {\n  constructor(\n      readonly metaBlock: I18nMeta, readonly messageParts: LiteralPiece[],\n      readonly placeHolderNames: PlaceholderPiece[], readonly expressions: Expression[],\n      sourceSpan?: ParseSourceSpan|null) {\n    super(STRING_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    // return e instanceof LocalizedString && this.message === e.message;\n    return false;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLocalizedString(this, context);\n  }\n\n  /**\n   * Serialize the given `meta` and `messagePart` into \"cooked\" and \"raw\" strings that can be used\n   * in a `$localize` tagged string. The format of the metadata is the same as that parsed by\n   * `parseI18nMeta()`.\n   *\n   * @param meta The metadata to serialize\n   * @param messagePart The first part of the tagged string\n   */\n  serializeI18nHead(): CookedRawString {\n    let metaBlock = this.metaBlock.description || '';\n    if (this.metaBlock.meaning) {\n      metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR}${metaBlock}`;\n    }\n    if (this.metaBlock.customId) {\n      metaBlock = `${metaBlock}${ID_SEPARATOR}${this.metaBlock.customId}`;\n    }\n    if (this.metaBlock.legacyIds) {\n      this.metaBlock.legacyIds.forEach(legacyId => {\n        metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;\n      });\n    }\n    return createCookedRawString(\n        metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));\n  }\n\n  getMessagePartSourceSpan(i: number): ParseSourceSpan|null {\n    return this.messageParts[i]?.sourceSpan ?? this.sourceSpan;\n  }\n\n  getPlaceholderSourceSpan(i: number): ParseSourceSpan {\n    return this.placeHolderNames[i]?.sourceSpan ?? this.expressions[i]?.sourceSpan ??\n        this.sourceSpan;\n  }\n\n  /**\n   * Serialize the given `placeholderName` and `messagePart` into \"cooked\" and \"raw\" strings that\n   * can be used in a `$localize` tagged string.\n   *\n   * The format is `:<placeholder-name>[@@<associated-id>]:`.\n   *\n   * The `associated-id` is the message id of the (usually an ICU) message to which this placeholder\n   * refers.\n   *\n   * @param partIndex The index of the message part to serialize.\n   */\n  serializeI18nTemplatePart(partIndex: number): CookedRawString {\n    const placeholder = this.placeHolderNames[partIndex - 1];\n    const messagePart = this.messageParts[partIndex];\n    let metaBlock = placeholder.text;\n    if (placeholder.associatedMessage?.legacyIds.length === 0) {\n      metaBlock += `${ID_SEPARATOR}${\n          computeMsgId(\n              placeholder.associatedMessage.messageString, placeholder.associatedMessage.meaning)}`;\n    }\n    return createCookedRawString(\n        metaBlock, messagePart.text, this.getMessagePartSourceSpan(partIndex));\n  }\n}\n\n/**\n * A structure to hold the cooked and raw strings of a template literal element, along with its\n * source-span range.\n */\nexport interface CookedRawString {\n  cooked: string;\n  raw: string;\n  range: ParseSourceSpan|null;\n}\n\nconst escapeSlashes = (str: string): string => str.replace(/\\\\/g, '\\\\\\\\');\nconst escapeStartingColon = (str: string): string => str.replace(/^:/, '\\\\:');\nconst escapeColons = (str: string): string => str.replace(/:/g, '\\\\:');\nconst escapeForTemplateLiteral = (str: string): string =>\n    str.replace(/`/g, '\\\\`').replace(/\\${/g, '$\\\\{');\n\n/**\n * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.\n *\n * The `raw` text must have various character sequences escaped:\n * * \"\\\" would otherwise indicate that the next character is a control character.\n * * \"`\" and \"${\" are template string control sequences that would otherwise prematurely indicate\n *   the end of a message part.\n * * \":\" inside a metablock would prematurely indicate the end of the metablock.\n * * \":\" at the start of a messagePart with no metablock would erroneously indicate the start of a\n *   metablock.\n *\n * @param metaBlock Any metadata that should be prepended to the string\n * @param messagePart The message part of the string\n */\nfunction createCookedRawString(\n    metaBlock: string, messagePart: string, range: ParseSourceSpan|null): CookedRawString {\n  if (metaBlock === '') {\n    return {\n      cooked: messagePart,\n      raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),\n      range,\n    };\n  } else {\n    return {\n      cooked: `:${metaBlock}:${messagePart}`,\n      raw: escapeForTemplateLiteral(\n          `:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`),\n      range,\n    };\n  }\n}\n\nexport class ExternalExpr extends Expression {\n  constructor(\n      public value: ExternalReference, type?: Type|null, public typeParams: Type[]|null = null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ExternalExpr && this.value.name === e.value.name &&\n        this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitExternalExpr(this, context);\n  }\n}\n\nexport class ExternalReference {\n  constructor(public moduleName: string|null, public name: string|null, public runtime?: any|null) {\n  }\n  // Note: no isEquivalent method here as we use this as an interface too.\n}\n\nexport class ConditionalExpr extends Expression {\n  public trueCase: Expression;\n\n  constructor(\n      public condition: Expression, trueCase: Expression, public falseCase: Expression|null = null,\n      type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type || trueCase.type, sourceSpan);\n    this.trueCase = trueCase;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) &&\n        this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitConditionalExpr(this, context);\n  }\n}\n\n\nexport class NotExpr extends Expression {\n  constructor(public condition: Expression, sourceSpan?: ParseSourceSpan|null) {\n    super(BOOL_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitNotExpr(this, context);\n  }\n}\n\nexport class FnParam {\n  constructor(public name: string, public type: Type|null = null) {}\n\n  isEquivalent(param: FnParam): boolean {\n    return this.name === param.name;\n  }\n}\n\n\nexport class FunctionExpr extends Expression {\n  constructor(\n      public params: FnParam[], public statements: Statement[], type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public name?: string|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) &&\n        areAllEquivalent(this.statements, e.statements);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitFunctionExpr(this, context);\n  }\n\n  toDeclStmt(name: string, modifiers?: StmtModifier): DeclareFunctionStmt {\n    return new DeclareFunctionStmt(\n        name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n  }\n}\n\n\nexport class UnaryOperatorExpr extends Expression {\n  constructor(\n      public operator: UnaryOperator, public expr: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public parens: boolean = true) {\n    super(type || NUMBER_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof UnaryOperatorExpr && this.operator === e.operator &&\n        this.expr.isEquivalent(e.expr);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitUnaryOperatorExpr(this, context);\n  }\n}\n\n\nexport class BinaryOperatorExpr extends Expression {\n  public lhs: Expression;\n  constructor(\n      public operator: BinaryOperator, lhs: Expression, public rhs: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public parens: boolean = true) {\n    super(type || lhs.type, sourceSpan);\n    this.lhs = lhs;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof BinaryOperatorExpr && this.operator === e.operator &&\n        this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitBinaryOperatorExpr(this, context);\n  }\n}\n\n\nexport class ReadPropExpr extends Expression {\n  constructor(\n      public receiver: Expression, public name: string, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.name === e.name;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadPropExpr(this, context);\n  }\n\n  set(value: Expression): WritePropExpr {\n    return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\n  }\n}\n\n\nexport class ReadKeyExpr extends Expression {\n  constructor(\n      public receiver: Expression, public index: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.index.isEquivalent(e.index);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadKeyExpr(this, context);\n  }\n\n  set(value: Expression): WriteKeyExpr {\n    return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\n  }\n}\n\n\nexport class LiteralArrayExpr extends Expression {\n  public entries: Expression[];\n  constructor(entries: Expression[], type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n    this.entries = entries;\n  }\n\n  override isConstant() {\n    return this.entries.every(e => e.isConstant());\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n  }\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralArrayExpr(this, context);\n  }\n}\n\nexport class LiteralMapEntry {\n  constructor(public key: string, public value: Expression, public quoted: boolean) {}\n  isEquivalent(e: LiteralMapEntry): boolean {\n    return this.key === e.key && this.value.isEquivalent(e.value);\n  }\n}\n\nexport class LiteralMapExpr extends Expression {\n  public valueType: Type|null = null;\n  constructor(\n      public entries: LiteralMapEntry[], type?: MapType|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n    if (type) {\n      this.valueType = type.valueType;\n    }\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n  }\n\n  override isConstant() {\n    return this.entries.every(e => e.value.isConstant());\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralMapExpr(this, context);\n  }\n}\n\nexport class CommaExpr extends Expression {\n  constructor(public parts: Expression[], sourceSpan?: ParseSourceSpan|null) {\n    super(parts[parts.length - 1].type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitCommaExpr(this, context);\n  }\n}\n\nexport interface ExpressionVisitor {\n  visitReadVarExpr(ast: ReadVarExpr, context: any): any;\n  visitWriteVarExpr(expr: WriteVarExpr, context: any): any;\n  visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any;\n  visitWritePropExpr(expr: WritePropExpr, context: any): any;\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;\n  visitTaggedTemplateExpr(ast: TaggedTemplateExpr, context: any): any;\n  visitInstantiateExpr(ast: InstantiateExpr, context: any): any;\n  visitLiteralExpr(ast: LiteralExpr, context: any): any;\n  visitLocalizedString(ast: LocalizedString, context: any): any;\n  visitExternalExpr(ast: ExternalExpr, context: any): any;\n  visitConditionalExpr(ast: ConditionalExpr, context: any): any;\n  visitNotExpr(ast: NotExpr, context: any): any;\n  visitFunctionExpr(ast: FunctionExpr, context: any): any;\n  visitUnaryOperatorExpr(ast: UnaryOperatorExpr, context: any): any;\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any;\n  visitReadPropExpr(ast: ReadPropExpr, context: any): any;\n  visitReadKeyExpr(ast: ReadKeyExpr, context: any): any;\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any;\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any;\n  visitCommaExpr(ast: CommaExpr, context: any): any;\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any;\n  visitTypeofExpr(ast: TypeofExpr, context: any): any;\n}\n\nexport const NULL_EXPR = new LiteralExpr(null, null, null);\nexport const TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);\n\n//// Statements\nexport enum StmtModifier {\n  None = 0,\n  Final = 1 << 0,\n  Private = 1 << 1,\n  Exported = 1 << 2,\n  Static = 1 << 3,\n}\n\nexport class LeadingComment {\n  constructor(public text: string, public multiline: boolean, public trailingNewline: boolean) {}\n  toString() {\n    return this.multiline ? ` ${this.text} ` : this.text;\n  }\n}\nexport class JSDocComment extends LeadingComment {\n  constructor(public tags: JSDocTag[]) {\n    super('', /* multiline */ true, /* trailingNewline */ true);\n  }\n  override toString(): string {\n    return serializeTags(this.tags);\n  }\n}\n\nexport abstract class Statement {\n  constructor(\n      public modifiers: StmtModifier = StmtModifier.None,\n      public sourceSpan: ParseSourceSpan|null = null, public leadingComments?: LeadingComment[]) {}\n  /**\n   * Calculates whether this statement produces the same value as the given statement.\n   * Note: We don't check Types nor ParseSourceSpans nor function arguments.\n   */\n  abstract isEquivalent(stmt: Statement): boolean;\n\n  abstract visitStatement(visitor: StatementVisitor, context: any): any;\n\n  hasModifier(modifier: StmtModifier): boolean {\n    return (this.modifiers & modifier) !== 0;\n  }\n\n  addLeadingComment(leadingComment: LeadingComment): void {\n    this.leadingComments = this.leadingComments ?? [];\n    this.leadingComments.push(leadingComment);\n  }\n}\n\n\nexport class DeclareVarStmt extends Statement {\n  public type: Type|null;\n  constructor(\n      public name: string, public value?: Expression, type?: Type|null, modifiers?: StmtModifier,\n      sourceSpan?: ParseSourceSpan|null, leadingComments?: LeadingComment[]) {\n    super(modifiers, sourceSpan, leadingComments);\n    this.type = type || (value && value.type) || null;\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof DeclareVarStmt && this.name === stmt.name &&\n        (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitDeclareVarStmt(this, context);\n  }\n}\n\nexport class DeclareFunctionStmt extends Statement {\n  public type: Type|null;\n  constructor(\n      public name: string, public params: FnParam[], public statements: Statement[],\n      type?: Type|null, modifiers?: StmtModifier, sourceSpan?: ParseSourceSpan|null,\n      leadingComments?: LeadingComment[]) {\n    super(modifiers, sourceSpan, leadingComments);\n    this.type = type || null;\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) &&\n        areAllEquivalent(this.statements, stmt.statements);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitDeclareFunctionStmt(this, context);\n  }\n}\n\nexport class ExpressionStatement extends Statement {\n  constructor(\n      public expr: Expression, sourceSpan?: ParseSourceSpan|null,\n      leadingComments?: LeadingComment[]) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitExpressionStmt(this, context);\n  }\n}\n\n\nexport class ReturnStatement extends Statement {\n  constructor(\n      public value: Expression, sourceSpan: ParseSourceSpan|null = null,\n      leadingComments?: LeadingComment[]) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitReturnStmt(this, context);\n  }\n}\n\nexport class IfStmt extends Statement {\n  constructor(\n      public condition: Expression, public trueCase: Statement[],\n      public falseCase: Statement[] = [], sourceSpan?: ParseSourceSpan|null,\n      leadingComments?: LeadingComment[]) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) &&\n        areAllEquivalent(this.trueCase, stmt.trueCase) &&\n        areAllEquivalent(this.falseCase, stmt.falseCase);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitIfStmt(this, context);\n  }\n}\n\nexport interface StatementVisitor {\n  visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any;\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any;\n  visitExpressionStmt(stmt: ExpressionStatement, context: any): any;\n  visitReturnStmt(stmt: ReturnStatement, context: any): any;\n  visitIfStmt(stmt: IfStmt, context: any): any;\n}\n\nexport class RecursiveAstVisitor implements StatementVisitor, ExpressionVisitor {\n  visitType(ast: Type, context: any): any {\n    return ast;\n  }\n  visitExpression(ast: Expression, context: any): any {\n    if (ast.type) {\n      ast.type.visitType(this, context);\n    }\n    return ast;\n  }\n  visitBuiltinType(type: BuiltinType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitExpressionType(type: ExpressionType, context: any): any {\n    type.value.visitExpression(this, context);\n    if (type.typeParams !== null) {\n      type.typeParams.forEach(param => this.visitType(param, context));\n    }\n    return this.visitType(type, context);\n  }\n  visitArrayType(type: ArrayType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitMapType(type: MapType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any {\n    return ast;\n  }\n  visitTypeofExpr(ast: TypeofExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitReadVarExpr(ast: ReadVarExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitWriteVarExpr(ast: WriteVarExpr, context: any): any {\n    ast.value.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitWriteKeyExpr(ast: WriteKeyExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    ast.index.visitExpression(this, context);\n    ast.value.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitWritePropExpr(ast: WritePropExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    ast.value.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any {\n    ast.fn.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTaggedTemplateExpr(ast: TaggedTemplateExpr, context: any): any {\n    ast.tag.visitExpression(this, context);\n    this.visitAllExpressions(ast.template.expressions, context);\n    return this.visitExpression(ast, context);\n  }\n  visitInstantiateExpr(ast: InstantiateExpr, context: any): any {\n    ast.classExpr.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralExpr(ast: LiteralExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitLocalizedString(ast: LocalizedString, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitExternalExpr(ast: ExternalExpr, context: any): any {\n    if (ast.typeParams) {\n      ast.typeParams.forEach(type => type.visitType(this, context));\n    }\n    return this.visitExpression(ast, context);\n  }\n  visitConditionalExpr(ast: ConditionalExpr, context: any): any {\n    ast.condition.visitExpression(this, context);\n    ast.trueCase.visitExpression(this, context);\n    ast.falseCase!.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitNotExpr(ast: NotExpr, context: any): any {\n    ast.condition.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitFunctionExpr(ast: FunctionExpr, context: any): any {\n    this.visitAllStatements(ast.statements, context);\n    return this.visitExpression(ast, context);\n  }\n  visitUnaryOperatorExpr(ast: UnaryOperatorExpr, context: any): any {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any {\n    ast.lhs.visitExpression(this, context);\n    ast.rhs.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadPropExpr(ast: ReadPropExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadKeyExpr(ast: ReadKeyExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    ast.index.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any {\n    this.visitAllExpressions(ast.entries, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any {\n    ast.entries.forEach((entry) => entry.value.visitExpression(this, context));\n    return this.visitExpression(ast, context);\n  }\n  visitCommaExpr(ast: CommaExpr, context: any): any {\n    this.visitAllExpressions(ast.parts, context);\n    return this.visitExpression(ast, context);\n  }\n  visitAllExpressions(exprs: Expression[], context: any): void {\n    exprs.forEach(expr => expr.visitExpression(this, context));\n  }\n\n  visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any {\n    if (stmt.value) {\n      stmt.value.visitExpression(this, context);\n    }\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any {\n    this.visitAllStatements(stmt.statements, context);\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitExpressionStmt(stmt: ExpressionStatement, context: any): any {\n    stmt.expr.visitExpression(this, context);\n    return stmt;\n  }\n  visitReturnStmt(stmt: ReturnStatement, context: any): any {\n    stmt.value.visitExpression(this, context);\n    return stmt;\n  }\n  visitIfStmt(stmt: IfStmt, context: any): any {\n    stmt.condition.visitExpression(this, context);\n    this.visitAllStatements(stmt.trueCase, context);\n    this.visitAllStatements(stmt.falseCase, context);\n    return stmt;\n  }\n  visitAllStatements(stmts: Statement[], context: any): void {\n    stmts.forEach(stmt => stmt.visitStatement(this, context));\n  }\n}\n\nexport function leadingComment(\n    text: string, multiline: boolean = false, trailingNewline: boolean = true): LeadingComment {\n  return new LeadingComment(text, multiline, trailingNewline);\n}\n\nexport function jsDocComment(tags: JSDocTag[] = []): JSDocComment {\n  return new JSDocComment(tags);\n}\n\nexport function variable(\n    name: string, type?: Type|null, sourceSpan?: ParseSourceSpan|null): ReadVarExpr {\n  return new ReadVarExpr(name, type, sourceSpan);\n}\n\nexport function importExpr(\n    id: ExternalReference, typeParams: Type[]|null = null,\n    sourceSpan?: ParseSourceSpan|null): ExternalExpr {\n  return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\n\nexport function importType(\n    id: ExternalReference, typeParams?: Type[]|null, typeModifiers?: TypeModifier): ExpressionType|\n    null {\n  return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\n\nexport function expressionType(\n    expr: Expression, typeModifiers?: TypeModifier, typeParams?: Type[]|null): ExpressionType {\n  return new ExpressionType(expr, typeModifiers, typeParams);\n}\n\nexport function typeofExpr(expr: Expression) {\n  return new TypeofExpr(expr);\n}\n\nexport function literalArr(\n    values: Expression[], type?: Type|null, sourceSpan?: ParseSourceSpan|null): LiteralArrayExpr {\n  return new LiteralArrayExpr(values, type, sourceSpan);\n}\n\nexport function literalMap(\n    values: {key: string, quoted: boolean, value: Expression}[],\n    type: MapType|null = null): LiteralMapExpr {\n  return new LiteralMapExpr(\n      values.map(e => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);\n}\n\nexport function unary(\n    operator: UnaryOperator, expr: Expression, type?: Type,\n    sourceSpan?: ParseSourceSpan|null): UnaryOperatorExpr {\n  return new UnaryOperatorExpr(operator, expr, type, sourceSpan);\n}\n\nexport function not(expr: Expression, sourceSpan?: ParseSourceSpan|null): NotExpr {\n  return new NotExpr(expr, sourceSpan);\n}\n\nexport function fn(\n    params: FnParam[], body: Statement[], type?: Type|null, sourceSpan?: ParseSourceSpan|null,\n    name?: string|null): FunctionExpr {\n  return new FunctionExpr(params, body, type, sourceSpan, name);\n}\n\nexport function ifStmt(\n    condition: Expression, thenClause: Statement[], elseClause?: Statement[],\n    sourceSpan?: ParseSourceSpan, leadingComments?: LeadingComment[]) {\n  return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);\n}\n\nexport function taggedTemplate(\n    tag: Expression, template: TemplateLiteral, type?: Type|null,\n    sourceSpan?: ParseSourceSpan|null): TaggedTemplateExpr {\n  return new TaggedTemplateExpr(tag, template, type, sourceSpan);\n}\n\nexport function literal(\n    value: any, type?: Type|null, sourceSpan?: ParseSourceSpan|null): LiteralExpr {\n  return new LiteralExpr(value, type, sourceSpan);\n}\n\nexport function localizedString(\n    metaBlock: I18nMeta, messageParts: LiteralPiece[], placeholderNames: PlaceholderPiece[],\n    expressions: Expression[], sourceSpan?: ParseSourceSpan|null): LocalizedString {\n  return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);\n}\n\nexport function isNull(exp: Expression): boolean {\n  return exp instanceof LiteralExpr && exp.value === null;\n}\n\n// The list of JSDoc tags that we currently support. Extend it if needed.\nexport const enum JSDocTagName {\n  Desc = 'desc',\n  Id = 'id',\n  Meaning = 'meaning',\n  Suppress = 'suppress',\n}\n\n/*\n * TypeScript has an API for JSDoc already, but it's not exposed.\n * https://github.com/Microsoft/TypeScript/issues/7393\n * For now we create types that are similar to theirs so that migrating\n * to their API will be easier. See e.g. `ts.JSDocTag` and `ts.JSDocComment`.\n */\nexport type JSDocTag = {\n  // `tagName` is e.g. \"param\" in an `@param` declaration\n  tagName: JSDocTagName|string,\n  // Any remaining text on the tag, e.g. the description\n  text?: string,\n}|{\n  // no `tagName` for plain text documentation that occurs before any `@param` lines\n  tagName?: undefined, text: string,\n};\n\n/*\n * Serializes a `Tag` into a string.\n * Returns a string like \" @foo {bar} baz\" (note the leading whitespace before `@foo`).\n */\nfunction tagToString(tag: JSDocTag): string {\n  let out = '';\n  if (tag.tagName) {\n    out += ` @${tag.tagName}`;\n  }\n  if (tag.text) {\n    if (tag.text.match(/\\/\\*|\\*\\//)) {\n      throw new Error('JSDoc text cannot contain \"/*\" and \"*/\"');\n    }\n    out += ' ' + tag.text.replace(/@/g, '\\\\@');\n  }\n  return out;\n}\n\nfunction serializeTags(tags: JSDocTag[]): string {\n  if (tags.length === 0) return '';\n\n  if (tags.length === 1 && tags[0].tagName && !tags[0].text) {\n    // The JSDOC comment is a single simple tag: e.g `/** @tagname */`.\n    return `*${tagToString(tags[0])} `;\n  }\n\n  let out = '*\\n';\n  for (const tag of tags) {\n    out += ' *';\n    // If the tagToString is multi-line, insert \" * \" prefixes on lines.\n    out += tagToString(tag).replace(/\\n/g, '\\n * ');\n    out += '\\n';\n  }\n  out += ' ';\n  return out;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from './output/output_ast';\n\nconst CONSTANT_PREFIX = '_c';\n\n/**\n * `ConstantPool` tries to reuse literal factories when two or more literals are identical.\n * We determine whether literals are identical by creating a key out of their AST using the\n * `KeyVisitor`. This constant is used to replace dynamic expressions which can't be safely\n * converted into a key. E.g. given an expression `{foo: bar()}`, since we don't know what\n * the result of `bar` will be, we create a key that looks like `{foo: <unknown>}`. Note\n * that we use a variable, rather than something like `null` in order to avoid collisions.\n */\nconst UNKNOWN_VALUE_KEY = o.variable('<unknown>');\n\n/**\n * Context to use when producing a key.\n *\n * This ensures we see the constant not the reference variable when producing\n * a key.\n */\nconst KEY_CONTEXT = {};\n\n/**\n * Generally all primitive values are excluded from the `ConstantPool`, but there is an exclusion\n * for strings that reach a certain length threshold. This constant defines the length threshold for\n * strings.\n */\nconst POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;\n\n/**\n * A node that is a place-holder that allows the node to be replaced when the actual\n * node is known.\n *\n * This allows the constant pool to change an expression from a direct reference to\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\n * change the referenced expression.\n */\nclass FixupExpression extends o.Expression {\n  private original: o.Expression;\n\n  // TODO(issue/24571): remove '!'.\n  shared!: boolean;\n\n  constructor(public resolved: o.Expression) {\n    super(resolved.type);\n    this.original = resolved;\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    if (context === KEY_CONTEXT) {\n      // When producing a key we want to traverse the constant not the\n      // variable used to refer to it.\n      return this.original.visitExpression(visitor, context);\n    } else {\n      return this.resolved.visitExpression(visitor, context);\n    }\n  }\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  fixup(expression: o.Expression) {\n    this.resolved = expression;\n    this.shared = true;\n  }\n}\n\n/**\n * A constant pool allows a code emitter to share constant in an output context.\n *\n * The constant pool also supports sharing access to ivy definitions references.\n */\nexport class ConstantPool {\n  statements: o.Statement[] = [];\n  private literals = new Map<string, FixupExpression>();\n  private literalFactories = new Map<string, o.Expression>();\n\n  private nextNameIndex = 0;\n\n  constructor(private readonly isClosureCompilerEnabled: boolean = false) {}\n\n  getConstLiteral(literal: o.Expression, forceShared?: boolean): o.Expression {\n    if ((literal instanceof o.LiteralExpr && !isLongStringLiteral(literal)) ||\n        literal instanceof FixupExpression) {\n      // Do no put simple literals into the constant pool or try to produce a constant for a\n      // reference to a constant.\n      return literal;\n    }\n    const key = this.keyOf(literal);\n    let fixup = this.literals.get(key);\n    let newValue = false;\n    if (!fixup) {\n      fixup = new FixupExpression(literal);\n      this.literals.set(key, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      // Replace the expression with a variable\n      const name = this.freshName();\n      let definition: o.WriteVarExpr;\n      let usage: o.Expression;\n      if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {\n        // For string literals, Closure will **always** inline the string at\n        // **all** usages, duplicating it each time. For large strings, this\n        // unnecessarily bloats bundle size. To work around this restriction, we\n        // wrap the string in a function, and call that function for each usage.\n        // This tricks Closure into using inline logic for functions instead of\n        // string literals. Function calls are only inlined if the body is small\n        // enough to be worth it. By doing this, very large strings will be\n        // shared across multiple usages, rather than duplicating the string at\n        // each usage site.\n        //\n        // const myStr = function() { return \"very very very long string\"; };\n        // const usage1 = myStr();\n        // const usage2 = myStr();\n        definition = o.variable(name).set(new o.FunctionExpr(\n            [],  // Params.\n            [\n              // Statements.\n              new o.ReturnStatement(literal),\n            ],\n            ));\n        usage = o.variable(name).callFn([]);\n      } else {\n        // Just declare and use the variable directly, without a function call\n        // indirection. This saves a few bytes and avoids an unnecessary call.\n        definition = o.variable(name).set(literal);\n        usage = o.variable(name);\n      }\n\n      this.statements.push(definition.toDeclStmt(o.INFERRED_TYPE, o.StmtModifier.Final));\n      fixup.fixup(usage);\n    }\n\n    return fixup;\n  }\n\n  getLiteralFactory(literal: o.LiteralArrayExpr|o.LiteralMapExpr):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    // Create a pure function that builds an array of a mix of constant and variable expressions\n    if (literal instanceof o.LiteralArrayExpr) {\n      const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : UNKNOWN_VALUE_KEY);\n      const key = this.keyOf(o.literalArr(argumentsForKey));\n      return this._getLiteralFactory(key, literal.entries, entries => o.literalArr(entries));\n    } else {\n      const expressionForKey = o.literalMap(\n          literal.entries.map(e => ({\n                                key: e.key,\n                                value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,\n                                quoted: e.quoted\n                              })));\n      const key = this.keyOf(expressionForKey);\n      return this._getLiteralFactory(\n          key, literal.entries.map(e => e.value),\n          entries => o.literalMap(entries.map((value, index) => ({\n                                                key: literal.entries[index].key,\n                                                value,\n                                                quoted: literal.entries[index].quoted\n                                              }))));\n    }\n  }\n\n  private _getLiteralFactory(\n      key: string, values: o.Expression[], resultMap: (parameters: o.Expression[]) => o.Expression):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    let literalFactory = this.literalFactories.get(key);\n    const literalFactoryArguments = values.filter((e => !e.isConstant()));\n    if (!literalFactory) {\n      const resultExpressions = values.map(\n          (e, index) => e.isConstant() ? this.getConstLiteral(e, true) : o.variable(`a${index}`));\n      const parameters =\n          resultExpressions.filter(isVariable).map(e => new o.FnParam(e.name!, o.DYNAMIC_TYPE));\n      const pureFunctionDeclaration =\n          o.fn(parameters, [new o.ReturnStatement(resultMap(resultExpressions))], o.INFERRED_TYPE);\n      const name = this.freshName();\n      this.statements.push(o.variable(name)\n                               .set(pureFunctionDeclaration)\n                               .toDeclStmt(o.INFERRED_TYPE, o.StmtModifier.Final));\n      literalFactory = o.variable(name);\n      this.literalFactories.set(key, literalFactory);\n    }\n    return {literalFactory, literalFactoryArguments};\n  }\n\n  /**\n   * Produce a unique name.\n   *\n   * The name might be unique among different prefixes if any of the prefixes end in\n   * a digit so the prefix should be a constant string (not based on user input) and\n   * must not end in a digit.\n   */\n  uniqueName(prefix: string): string {\n    return `${prefix}${this.nextNameIndex++}`;\n  }\n\n  private freshName(): string {\n    return this.uniqueName(CONSTANT_PREFIX);\n  }\n\n  private keyOf(expression: o.Expression) {\n    return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);\n  }\n}\n\n/**\n * Visitor used to determine if 2 expressions are equivalent and can be shared in the\n * `ConstantPool`.\n *\n * When the id (string) generated by the visitor is equal, expressions are considered equivalent.\n */\nclass KeyVisitor implements o.ExpressionVisitor {\n  visitLiteralExpr(ast: o.LiteralExpr): string {\n    return `${typeof ast.value === 'string' ? '\"' + ast.value + '\"' : ast.value}`;\n  }\n\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, context: object): string {\n    return `[${ast.entries.map(entry => entry.visitExpression(this, context)).join(',')}]`;\n  }\n\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, context: object): string {\n    const mapKey = (entry: o.LiteralMapEntry) => {\n      const quote = entry.quoted ? '\"' : '';\n      return `${quote}${entry.key}${quote}`;\n    };\n    const mapEntry = (entry: o.LiteralMapEntry) =>\n        `${mapKey(entry)}:${entry.value.visitExpression(this, context)}`;\n    return `{${ast.entries.map(mapEntry).join(',')}`;\n  }\n\n  visitExternalExpr(ast: o.ExternalExpr): string {\n    return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` :\n                                  `EX:${ast.value.runtime.name}`;\n  }\n\n  visitReadVarExpr(node: o.ReadVarExpr) {\n    return `VAR:${node.name}`;\n  }\n\n  visitTypeofExpr(node: o.TypeofExpr, context: any): string {\n    return `TYPEOF:${node.expr.visitExpression(this, context)}`;\n  }\n\n  visitWrappedNodeExpr = invalid;\n  visitWriteVarExpr = invalid;\n  visitWriteKeyExpr = invalid;\n  visitWritePropExpr = invalid;\n  visitInvokeFunctionExpr = invalid;\n  visitTaggedTemplateExpr = invalid;\n  visitInstantiateExpr = invalid;\n  visitConditionalExpr = invalid;\n  visitNotExpr = invalid;\n  visitAssertNotNullExpr = invalid;\n  visitCastExpr = invalid;\n  visitFunctionExpr = invalid;\n  visitUnaryOperatorExpr = invalid;\n  visitBinaryOperatorExpr = invalid;\n  visitReadPropExpr = invalid;\n  visitReadKeyExpr = invalid;\n  visitCommaExpr = invalid;\n  visitLocalizedString = invalid;\n}\n\nfunction invalid<T>(this: o.ExpressionVisitor, arg: o.Expression|o.Statement): never {\n  throw new Error(\n      `Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\n\nfunction isVariable(e: o.Expression): e is o.ReadVarExpr {\n  return e instanceof o.ReadVarExpr;\n}\n\nfunction isLongStringLiteral(expr: o.Expression): boolean {\n  return expr instanceof o.LiteralExpr && typeof expr.value === 'string' &&\n      expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../output/output_ast';\n\nconst CORE = '@angular/core';\n\nexport class Identifiers {\n  /* Methods */\n  static NEW_METHOD = 'factory';\n  static TRANSFORM_METHOD = 'transform';\n  static PATCH_DEPS = 'patchedDeps';\n\n  static core: o.ExternalReference = {name: null, moduleName: CORE};\n\n  /* Instructions */\n  static namespaceHTML: o.ExternalReference = {name: '\u0275\u0275namespaceHTML', moduleName: CORE};\n\n  static namespaceMathML: o.ExternalReference = {name: '\u0275\u0275namespaceMathML', moduleName: CORE};\n\n  static namespaceSVG: o.ExternalReference = {name: '\u0275\u0275namespaceSVG', moduleName: CORE};\n\n  static element: o.ExternalReference = {name: '\u0275\u0275element', moduleName: CORE};\n\n  static elementStart: o.ExternalReference = {name: '\u0275\u0275elementStart', moduleName: CORE};\n\n  static elementEnd: o.ExternalReference = {name: '\u0275\u0275elementEnd', moduleName: CORE};\n\n  static advance: o.ExternalReference = {name: '\u0275\u0275advance', moduleName: CORE};\n\n  static syntheticHostProperty:\n      o.ExternalReference = {name: '\u0275\u0275syntheticHostProperty', moduleName: CORE};\n\n  static syntheticHostListener:\n      o.ExternalReference = {name: '\u0275\u0275syntheticHostListener', moduleName: CORE};\n\n  static attribute: o.ExternalReference = {name: '\u0275\u0275attribute', moduleName: CORE};\n\n  static attributeInterpolate1:\n      o.ExternalReference = {name: '\u0275\u0275attributeInterpolate1', moduleName: CORE};\n  static attributeInterpolate2:\n      o.ExternalReference = {name: '\u0275\u0275attributeInterpolate2', moduleName: CORE};\n  static attributeInterpolate3:\n      o.ExternalReference = {name: '\u0275\u0275attributeInterpolate3', moduleName: CORE};\n  static attributeInterpolate4:\n      o.ExternalReference = {name: '\u0275\u0275attributeInterpolate4', moduleName: CORE};\n  static attributeInterpolate5:\n      o.ExternalReference = {name: '\u0275\u0275attributeInterpolate5', moduleName: CORE};\n  static attributeInterpolate6:\n      o.ExternalReference = {name: '\u0275\u0275attributeInterpolate6', moduleName: CORE};\n  static attributeInterpolate7:\n      o.ExternalReference = {name: '\u0275\u0275attributeInterpolate7', moduleName: CORE};\n  static attributeInterpolate8:\n      o.ExternalReference = {name: '\u0275\u0275attributeInterpolate8', moduleName: CORE};\n  static attributeInterpolateV:\n      o.ExternalReference = {name: '\u0275\u0275attributeInterpolateV', moduleName: CORE};\n\n  static classProp: o.ExternalReference = {name: '\u0275\u0275classProp', moduleName: CORE};\n\n  static elementContainerStart:\n      o.ExternalReference = {name: '\u0275\u0275elementContainerStart', moduleName: CORE};\n\n  static elementContainerEnd:\n      o.ExternalReference = {name: '\u0275\u0275elementContainerEnd', moduleName: CORE};\n\n  static elementContainer: o.ExternalReference = {name: '\u0275\u0275elementContainer', moduleName: CORE};\n\n  static styleMap: o.ExternalReference = {name: '\u0275\u0275styleMap', moduleName: CORE};\n\n  static styleMapInterpolate1:\n      o.ExternalReference = {name: '\u0275\u0275styleMapInterpolate1', moduleName: CORE};\n  static styleMapInterpolate2:\n      o.ExternalReference = {name: '\u0275\u0275styleMapInterpolate2', moduleName: CORE};\n  static styleMapInterpolate3:\n      o.ExternalReference = {name: '\u0275\u0275styleMapInterpolate3', moduleName: CORE};\n  static styleMapInterpolate4:\n      o.ExternalReference = {name: '\u0275\u0275styleMapInterpolate4', moduleName: CORE};\n  static styleMapInterpolate5:\n      o.ExternalReference = {name: '\u0275\u0275styleMapInterpolate5', moduleName: CORE};\n  static styleMapInterpolate6:\n      o.ExternalReference = {name: '\u0275\u0275styleMapInterpolate6', moduleName: CORE};\n  static styleMapInterpolate7:\n      o.ExternalReference = {name: '\u0275\u0275styleMapInterpolate7', moduleName: CORE};\n  static styleMapInterpolate8:\n      o.ExternalReference = {name: '\u0275\u0275styleMapInterpolate8', moduleName: CORE};\n  static styleMapInterpolateV:\n      o.ExternalReference = {name: '\u0275\u0275styleMapInterpolateV', moduleName: CORE};\n\n  static classMap: o.ExternalReference = {name: '\u0275\u0275classMap', moduleName: CORE};\n\n  static classMapInterpolate1:\n      o.ExternalReference = {name: '\u0275\u0275classMapInterpolate1', moduleName: CORE};\n  static classMapInterpolate2:\n      o.ExternalReference = {name: '\u0275\u0275classMapInterpolate2', moduleName: CORE};\n  static classMapInterpolate3:\n      o.ExternalReference = {name: '\u0275\u0275classMapInterpolate3', moduleName: CORE};\n  static classMapInterpolate4:\n      o.ExternalReference = {name: '\u0275\u0275classMapInterpolate4', moduleName: CORE};\n  static classMapInterpolate5:\n      o.ExternalReference = {name: '\u0275\u0275classMapInterpolate5', moduleName: CORE};\n  static classMapInterpolate6:\n      o.ExternalReference = {name: '\u0275\u0275classMapInterpolate6', moduleName: CORE};\n  static classMapInterpolate7:\n      o.ExternalReference = {name: '\u0275\u0275classMapInterpolate7', moduleName: CORE};\n  static classMapInterpolate8:\n      o.ExternalReference = {name: '\u0275\u0275classMapInterpolate8', moduleName: CORE};\n  static classMapInterpolateV:\n      o.ExternalReference = {name: '\u0275\u0275classMapInterpolateV', moduleName: CORE};\n\n  static styleProp: o.ExternalReference = {name: '\u0275\u0275styleProp', moduleName: CORE};\n\n  static stylePropInterpolate1:\n      o.ExternalReference = {name: '\u0275\u0275stylePropInterpolate1', moduleName: CORE};\n  static stylePropInterpolate2:\n      o.ExternalReference = {name: '\u0275\u0275stylePropInterpolate2', moduleName: CORE};\n  static stylePropInterpolate3:\n      o.ExternalReference = {name: '\u0275\u0275stylePropInterpolate3', moduleName: CORE};\n  static stylePropInterpolate4:\n      o.ExternalReference = {name: '\u0275\u0275stylePropInterpolate4', moduleName: CORE};\n  static stylePropInterpolate5:\n      o.ExternalReference = {name: '\u0275\u0275stylePropInterpolate5', moduleName: CORE};\n  static stylePropInterpolate6:\n      o.ExternalReference = {name: '\u0275\u0275stylePropInterpolate6', moduleName: CORE};\n  static stylePropInterpolate7:\n      o.ExternalReference = {name: '\u0275\u0275stylePropInterpolate7', moduleName: CORE};\n  static stylePropInterpolate8:\n      o.ExternalReference = {name: '\u0275\u0275stylePropInterpolate8', moduleName: CORE};\n  static stylePropInterpolateV:\n      o.ExternalReference = {name: '\u0275\u0275stylePropInterpolateV', moduleName: CORE};\n\n  static nextContext: o.ExternalReference = {name: '\u0275\u0275nextContext', moduleName: CORE};\n\n  static resetView: o.ExternalReference = {name: '\u0275\u0275resetView', moduleName: CORE};\n\n  static templateCreate: o.ExternalReference = {name: '\u0275\u0275template', moduleName: CORE};\n\n  static text: o.ExternalReference = {name: '\u0275\u0275text', moduleName: CORE};\n\n  static enableBindings: o.ExternalReference = {name: '\u0275\u0275enableBindings', moduleName: CORE};\n\n  static disableBindings: o.ExternalReference = {name: '\u0275\u0275disableBindings', moduleName: CORE};\n\n  static getCurrentView: o.ExternalReference = {name: '\u0275\u0275getCurrentView', moduleName: CORE};\n\n  static textInterpolate: o.ExternalReference = {name: '\u0275\u0275textInterpolate', moduleName: CORE};\n  static textInterpolate1: o.ExternalReference = {name: '\u0275\u0275textInterpolate1', moduleName: CORE};\n  static textInterpolate2: o.ExternalReference = {name: '\u0275\u0275textInterpolate2', moduleName: CORE};\n  static textInterpolate3: o.ExternalReference = {name: '\u0275\u0275textInterpolate3', moduleName: CORE};\n  static textInterpolate4: o.ExternalReference = {name: '\u0275\u0275textInterpolate4', moduleName: CORE};\n  static textInterpolate5: o.ExternalReference = {name: '\u0275\u0275textInterpolate5', moduleName: CORE};\n  static textInterpolate6: o.ExternalReference = {name: '\u0275\u0275textInterpolate6', moduleName: CORE};\n  static textInterpolate7: o.ExternalReference = {name: '\u0275\u0275textInterpolate7', moduleName: CORE};\n  static textInterpolate8: o.ExternalReference = {name: '\u0275\u0275textInterpolate8', moduleName: CORE};\n  static textInterpolateV: o.ExternalReference = {name: '\u0275\u0275textInterpolateV', moduleName: CORE};\n\n  static restoreView: o.ExternalReference = {name: '\u0275\u0275restoreView', moduleName: CORE};\n\n  static pureFunction0: o.ExternalReference = {name: '\u0275\u0275pureFunction0', moduleName: CORE};\n  static pureFunction1: o.ExternalReference = {name: '\u0275\u0275pureFunction1', moduleName: CORE};\n  static pureFunction2: o.ExternalReference = {name: '\u0275\u0275pureFunction2', moduleName: CORE};\n  static pureFunction3: o.ExternalReference = {name: '\u0275\u0275pureFunction3', moduleName: CORE};\n  static pureFunction4: o.ExternalReference = {name: '\u0275\u0275pureFunction4', moduleName: CORE};\n  static pureFunction5: o.ExternalReference = {name: '\u0275\u0275pureFunction5', moduleName: CORE};\n  static pureFunction6: o.ExternalReference = {name: '\u0275\u0275pureFunction6', moduleName: CORE};\n  static pureFunction7: o.ExternalReference = {name: '\u0275\u0275pureFunction7', moduleName: CORE};\n  static pureFunction8: o.ExternalReference = {name: '\u0275\u0275pureFunction8', moduleName: CORE};\n  static pureFunctionV: o.ExternalReference = {name: '\u0275\u0275pureFunctionV', moduleName: CORE};\n\n  static pipeBind1: o.ExternalReference = {name: '\u0275\u0275pipeBind1', moduleName: CORE};\n  static pipeBind2: o.ExternalReference = {name: '\u0275\u0275pipeBind2', moduleName: CORE};\n  static pipeBind3: o.ExternalReference = {name: '\u0275\u0275pipeBind3', moduleName: CORE};\n  static pipeBind4: o.ExternalReference = {name: '\u0275\u0275pipeBind4', moduleName: CORE};\n  static pipeBindV: o.ExternalReference = {name: '\u0275\u0275pipeBindV', moduleName: CORE};\n\n  static hostProperty: o.ExternalReference = {name: '\u0275\u0275hostProperty', moduleName: CORE};\n\n  static property: o.ExternalReference = {name: '\u0275\u0275property', moduleName: CORE};\n\n  static propertyInterpolate:\n      o.ExternalReference = {name: '\u0275\u0275propertyInterpolate', moduleName: CORE};\n  static propertyInterpolate1:\n      o.ExternalReference = {name: '\u0275\u0275propertyInterpolate1', moduleName: CORE};\n  static propertyInterpolate2:\n      o.ExternalReference = {name: '\u0275\u0275propertyInterpolate2', moduleName: CORE};\n  static propertyInterpolate3:\n      o.ExternalReference = {name: '\u0275\u0275propertyInterpolate3', moduleName: CORE};\n  static propertyInterpolate4:\n      o.ExternalReference = {name: '\u0275\u0275propertyInterpolate4', moduleName: CORE};\n  static propertyInterpolate5:\n      o.ExternalReference = {name: '\u0275\u0275propertyInterpolate5', moduleName: CORE};\n  static propertyInterpolate6:\n      o.ExternalReference = {name: '\u0275\u0275propertyInterpolate6', moduleName: CORE};\n  static propertyInterpolate7:\n      o.ExternalReference = {name: '\u0275\u0275propertyInterpolate7', moduleName: CORE};\n  static propertyInterpolate8:\n      o.ExternalReference = {name: '\u0275\u0275propertyInterpolate8', moduleName: CORE};\n  static propertyInterpolateV:\n      o.ExternalReference = {name: '\u0275\u0275propertyInterpolateV', moduleName: CORE};\n\n  static i18n: o.ExternalReference = {name: '\u0275\u0275i18n', moduleName: CORE};\n  static i18nAttributes: o.ExternalReference = {name: '\u0275\u0275i18nAttributes', moduleName: CORE};\n  static i18nExp: o.ExternalReference = {name: '\u0275\u0275i18nExp', moduleName: CORE};\n  static i18nStart: o.ExternalReference = {name: '\u0275\u0275i18nStart', moduleName: CORE};\n  static i18nEnd: o.ExternalReference = {name: '\u0275\u0275i18nEnd', moduleName: CORE};\n  static i18nApply: o.ExternalReference = {name: '\u0275\u0275i18nApply', moduleName: CORE};\n  static i18nPostprocess: o.ExternalReference = {name: '\u0275\u0275i18nPostprocess', moduleName: CORE};\n\n  static pipe: o.ExternalReference = {name: '\u0275\u0275pipe', moduleName: CORE};\n\n  static projection: o.ExternalReference = {name: '\u0275\u0275projection', moduleName: CORE};\n  static projectionDef: o.ExternalReference = {name: '\u0275\u0275projectionDef', moduleName: CORE};\n\n  static reference: o.ExternalReference = {name: '\u0275\u0275reference', moduleName: CORE};\n\n  static inject: o.ExternalReference = {name: '\u0275\u0275inject', moduleName: CORE};\n\n  static injectAttribute: o.ExternalReference = {name: '\u0275\u0275injectAttribute', moduleName: CORE};\n\n  static directiveInject: o.ExternalReference = {name: '\u0275\u0275directiveInject', moduleName: CORE};\n  static invalidFactory: o.ExternalReference = {name: '\u0275\u0275invalidFactory', moduleName: CORE};\n  static invalidFactoryDep: o.ExternalReference = {name: '\u0275\u0275invalidFactoryDep', moduleName: CORE};\n\n  static templateRefExtractor:\n      o.ExternalReference = {name: '\u0275\u0275templateRefExtractor', moduleName: CORE};\n\n  static forwardRef: o.ExternalReference = {name: 'forwardRef', moduleName: CORE};\n  static resolveForwardRef: o.ExternalReference = {name: 'resolveForwardRef', moduleName: CORE};\n\n  static \u0275\u0275defineInjectable: o.ExternalReference = {name: '\u0275\u0275defineInjectable', moduleName: CORE};\n  static declareInjectable: o.ExternalReference = {name: '\u0275\u0275ngDeclareInjectable', moduleName: CORE};\n  static InjectableDeclaration:\n      o.ExternalReference = {name: '\u0275\u0275InjectableDeclaration', moduleName: CORE};\n\n  static resolveWindow: o.ExternalReference = {name: '\u0275\u0275resolveWindow', moduleName: CORE};\n  static resolveDocument: o.ExternalReference = {name: '\u0275\u0275resolveDocument', moduleName: CORE};\n  static resolveBody: o.ExternalReference = {name: '\u0275\u0275resolveBody', moduleName: CORE};\n\n  static defineComponent: o.ExternalReference = {name: '\u0275\u0275defineComponent', moduleName: CORE};\n  static declareComponent: o.ExternalReference = {name: '\u0275\u0275ngDeclareComponent', moduleName: CORE};\n\n  static setComponentScope: o.ExternalReference = {name: '\u0275\u0275setComponentScope', moduleName: CORE};\n\n  static ChangeDetectionStrategy: o.ExternalReference = {\n    name: 'ChangeDetectionStrategy',\n    moduleName: CORE,\n  };\n  static ViewEncapsulation: o.ExternalReference = {\n    name: 'ViewEncapsulation',\n    moduleName: CORE,\n  };\n\n  static ComponentDeclaration: o.ExternalReference = {\n    name: '\u0275\u0275ComponentDeclaration',\n    moduleName: CORE,\n  };\n\n  static FactoryDeclaration: o.ExternalReference = {\n    name: '\u0275\u0275FactoryDeclaration',\n    moduleName: CORE,\n  };\n  static declareFactory: o.ExternalReference = {name: '\u0275\u0275ngDeclareFactory', moduleName: CORE};\n  static FactoryTarget: o.ExternalReference = {name: '\u0275\u0275FactoryTarget', moduleName: CORE};\n\n  static defineDirective: o.ExternalReference = {name: '\u0275\u0275defineDirective', moduleName: CORE};\n  static declareDirective: o.ExternalReference = {name: '\u0275\u0275ngDeclareDirective', moduleName: CORE};\n\n  static DirectiveDeclaration: o.ExternalReference = {\n    name: '\u0275\u0275DirectiveDeclaration',\n    moduleName: CORE,\n  };\n\n  static InjectorDef: o.ExternalReference = {name: '\u0275\u0275InjectorDef', moduleName: CORE};\n  static InjectorDeclaration:\n      o.ExternalReference = {name: '\u0275\u0275InjectorDeclaration', moduleName: CORE};\n\n  static defineInjector: o.ExternalReference = {name: '\u0275\u0275defineInjector', moduleName: CORE};\n  static declareInjector: o.ExternalReference = {name: '\u0275\u0275ngDeclareInjector', moduleName: CORE};\n\n  static NgModuleDeclaration: o.ExternalReference = {\n    name: '\u0275\u0275NgModuleDeclaration',\n    moduleName: CORE,\n  };\n\n  static ModuleWithProviders: o.ExternalReference = {\n    name: 'ModuleWithProviders',\n    moduleName: CORE,\n  };\n\n  static defineNgModule: o.ExternalReference = {name: '\u0275\u0275defineNgModule', moduleName: CORE};\n  static declareNgModule: o.ExternalReference = {name: '\u0275\u0275ngDeclareNgModule', moduleName: CORE};\n  static setNgModuleScope: o.ExternalReference = {name: '\u0275\u0275setNgModuleScope', moduleName: CORE};\n  static registerNgModuleType:\n      o.ExternalReference = {name: '\u0275\u0275registerNgModuleType', moduleName: CORE};\n\n\n  static PipeDeclaration: o.ExternalReference = {name: '\u0275\u0275PipeDeclaration', moduleName: CORE};\n\n  static definePipe: o.ExternalReference = {name: '\u0275\u0275definePipe', moduleName: CORE};\n  static declarePipe: o.ExternalReference = {name: '\u0275\u0275ngDeclarePipe', moduleName: CORE};\n\n  static declareClassMetadata:\n      o.ExternalReference = {name: '\u0275\u0275ngDeclareClassMetadata', moduleName: CORE};\n  static setClassMetadata: o.ExternalReference = {name: '\u0275setClassMetadata', moduleName: CORE};\n\n  static queryRefresh: o.ExternalReference = {name: '\u0275\u0275queryRefresh', moduleName: CORE};\n  static viewQuery: o.ExternalReference = {name: '\u0275\u0275viewQuery', moduleName: CORE};\n  static loadQuery: o.ExternalReference = {name: '\u0275\u0275loadQuery', moduleName: CORE};\n  static contentQuery: o.ExternalReference = {name: '\u0275\u0275contentQuery', moduleName: CORE};\n\n  static NgOnChangesFeature: o.ExternalReference = {name: '\u0275\u0275NgOnChangesFeature', moduleName: CORE};\n\n  static InheritDefinitionFeature:\n      o.ExternalReference = {name: '\u0275\u0275InheritDefinitionFeature', moduleName: CORE};\n\n  static CopyDefinitionFeature:\n      o.ExternalReference = {name: '\u0275\u0275CopyDefinitionFeature', moduleName: CORE};\n\n  static StandaloneFeature: o.ExternalReference = {name: '\u0275\u0275StandaloneFeature', moduleName: CORE};\n\n  static ProvidersFeature: o.ExternalReference = {name: '\u0275\u0275ProvidersFeature', moduleName: CORE};\n\n  static HostDirectivesFeature:\n      o.ExternalReference = {name: '\u0275\u0275HostDirectivesFeature', moduleName: CORE};\n\n  static listener: o.ExternalReference = {name: '\u0275\u0275listener', moduleName: CORE};\n\n  static getInheritedFactory: o.ExternalReference = {\n    name: '\u0275\u0275getInheritedFactory',\n    moduleName: CORE,\n  };\n\n  // sanitization-related functions\n  static sanitizeHtml: o.ExternalReference = {name: '\u0275\u0275sanitizeHtml', moduleName: CORE};\n  static sanitizeStyle: o.ExternalReference = {name: '\u0275\u0275sanitizeStyle', moduleName: CORE};\n  static sanitizeResourceUrl:\n      o.ExternalReference = {name: '\u0275\u0275sanitizeResourceUrl', moduleName: CORE};\n  static sanitizeScript: o.ExternalReference = {name: '\u0275\u0275sanitizeScript', moduleName: CORE};\n  static sanitizeUrl: o.ExternalReference = {name: '\u0275\u0275sanitizeUrl', moduleName: CORE};\n  static sanitizeUrlOrResourceUrl:\n      o.ExternalReference = {name: '\u0275\u0275sanitizeUrlOrResourceUrl', moduleName: CORE};\n  static trustConstantHtml: o.ExternalReference = {name: '\u0275\u0275trustConstantHtml', moduleName: CORE};\n  static trustConstantResourceUrl:\n      o.ExternalReference = {name: '\u0275\u0275trustConstantResourceUrl', moduleName: CORE};\n  static validateIframeAttribute:\n      o.ExternalReference = {name: '\u0275\u0275validateIframeAttribute', moduleName: CORE};\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {utf8Encode} from '../util';\n\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\nconst VERSION = 3;\n\nconst JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\n\ntype Segment = {\n  col0: number,\n  sourceUrl?: string,\n  sourceLine0?: number,\n  sourceCol0?: number,\n};\n\nexport type SourceMap = {\n  version: number,\n  file?: string,\n      sourceRoot: string,\n      sources: string[],\n      sourcesContent: (string|null)[],\n      mappings: string,\n};\n\nexport class SourceMapGenerator {\n  private sourcesContent: Map<string, string|null> = new Map();\n  private lines: Segment[][] = [];\n  private lastCol0: number = 0;\n  private hasMappings = false;\n\n  constructor(private file: string|null = null) {}\n\n  // The content is `null` when the content is expected to be loaded using the URL\n  addSource(url: string, content: string|null = null): this {\n    if (!this.sourcesContent.has(url)) {\n      this.sourcesContent.set(url, content);\n    }\n    return this;\n  }\n\n  addLine(): this {\n    this.lines.push([]);\n    this.lastCol0 = 0;\n    return this;\n  }\n\n  addMapping(col0: number, sourceUrl?: string, sourceLine0?: number, sourceCol0?: number): this {\n    if (!this.currentLine) {\n      throw new Error(`A line must be added before mappings can be added`);\n    }\n    if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n      throw new Error(`Unknown source file \"${sourceUrl}\"`);\n    }\n    if (col0 == null) {\n      throw new Error(`The column in the generated code must be provided`);\n    }\n    if (col0 < this.lastCol0) {\n      throw new Error(`Mapping should be added in output order`);\n    }\n    if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n      throw new Error(`The source location must be provided when a source url is provided`);\n    }\n\n    this.hasMappings = true;\n    this.lastCol0 = col0;\n    this.currentLine.push({col0, sourceUrl, sourceLine0, sourceCol0});\n    return this;\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get currentLine(): Segment[]|null {\n    return this.lines.slice(-1)[0];\n  }\n\n  toJSON(): SourceMap|null {\n    if (!this.hasMappings) {\n      return null;\n    }\n\n    const sourcesIndex = new Map<string, number>();\n    const sources: string[] = [];\n    const sourcesContent: (string|null)[] = [];\n\n    Array.from(this.sourcesContent.keys()).forEach((url: string, i: number) => {\n      sourcesIndex.set(url, i);\n      sources.push(url);\n      sourcesContent.push(this.sourcesContent.get(url) || null);\n    });\n\n    let mappings: string = '';\n    let lastCol0: number = 0;\n    let lastSourceIndex: number = 0;\n    let lastSourceLine0: number = 0;\n    let lastSourceCol0: number = 0;\n\n    this.lines.forEach(segments => {\n      lastCol0 = 0;\n\n      mappings += segments\n                      .map(segment => {\n                        // zero-based starting column of the line in the generated code\n                        let segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n                        lastCol0 = segment.col0;\n\n                        if (segment.sourceUrl != null) {\n                          // zero-based index into the \u201Csources\u201D list\n                          segAsStr +=\n                              toBase64VLQ(sourcesIndex.get(segment.sourceUrl)! - lastSourceIndex);\n                          lastSourceIndex = sourcesIndex.get(segment.sourceUrl)!;\n                          // the zero-based starting line in the original source\n                          segAsStr += toBase64VLQ(segment.sourceLine0! - lastSourceLine0);\n                          lastSourceLine0 = segment.sourceLine0!;\n                          // the zero-based starting column in the original source\n                          segAsStr += toBase64VLQ(segment.sourceCol0! - lastSourceCol0);\n                          lastSourceCol0 = segment.sourceCol0!;\n                        }\n\n                        return segAsStr;\n                      })\n                      .join(',');\n      mappings += ';';\n    });\n\n    mappings = mappings.slice(0, -1);\n\n    return {\n      'file': this.file || '',\n      'version': VERSION,\n      'sourceRoot': '',\n      'sources': sources,\n      'sourcesContent': sourcesContent,\n      'mappings': mappings,\n    };\n  }\n\n  toJsComment(): string {\n    return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :\n                              '';\n  }\n}\n\nexport function toBase64String(value: string): string {\n  let b64 = '';\n  const encoded = utf8Encode(value);\n  for (let i = 0; i < encoded.length;) {\n    const i1 = encoded[i++];\n    const i2 = i < encoded.length ? encoded[i++] : null;\n    const i3 = i < encoded.length ? encoded[i++] : null;\n    b64 += toBase64Digit(i1 >> 2);\n    b64 += toBase64Digit(((i1 & 3) << 4) | (i2 === null ? 0 : i2 >> 4));\n    b64 += i2 === null ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 === null ? 0 : i3 >> 6));\n    b64 += i2 === null || i3 === null ? '=' : toBase64Digit(i3 & 63);\n  }\n\n  return b64;\n}\n\nfunction toBase64VLQ(value: number): string {\n  value = value < 0 ? ((-value) << 1) + 1 : value << 1;\n\n  let out = '';\n  do {\n    let digit = value & 31;\n    value = value >> 5;\n    if (value > 0) {\n      digit = digit | 32;\n    }\n    out += toBase64Digit(digit);\n  } while (value > 0);\n\n  return out;\n}\n\nconst B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfunction toBase64Digit(value: number): string {\n  if (value < 0 || value >= 64) {\n    throw new Error(`Can only encode value in the range [0, 63]`);\n  }\n\n  return B64_DIGITS[value];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '../parse_util';\n\nimport * as o from './output_ast';\nimport {SourceMapGenerator} from './source_map';\n\nconst _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nconst _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst _INDENT_WITH = '  ';\n\nclass _EmittedLine {\n  partsLength = 0;\n  parts: string[] = [];\n  srcSpans: (ParseSourceSpan|null)[] = [];\n  constructor(public indent: number) {}\n}\n\nexport class EmitterVisitorContext {\n  static createRoot(): EmitterVisitorContext {\n    return new EmitterVisitorContext(0);\n  }\n\n  private _lines: _EmittedLine[];\n\n  constructor(private _indent: number) {\n    this._lines = [new _EmittedLine(_indent)];\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get _currentLine(): _EmittedLine {\n    return this._lines[this._lines.length - 1];\n  }\n\n  println(from?: {sourceSpan: ParseSourceSpan|null}|null, lastPart: string = ''): void {\n    this.print(from || null, lastPart, true);\n  }\n\n  lineIsEmpty(): boolean {\n    return this._currentLine.parts.length === 0;\n  }\n\n  lineLength(): number {\n    return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n  }\n\n  print(from: {sourceSpan: ParseSourceSpan|null}|null, part: string, newLine: boolean = false) {\n    if (part.length > 0) {\n      this._currentLine.parts.push(part);\n      this._currentLine.partsLength += part.length;\n      this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n    }\n    if (newLine) {\n      this._lines.push(new _EmittedLine(this._indent));\n    }\n  }\n\n  removeEmptyLastLine() {\n    if (this.lineIsEmpty()) {\n      this._lines.pop();\n    }\n  }\n\n  incIndent() {\n    this._indent++;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  decIndent() {\n    this._indent--;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  toSource(): string {\n    return this.sourceLines\n        .map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '')\n        .join('\\n');\n  }\n\n  toSourceMapGenerator(genFilePath: string, startsAtLine: number = 0): SourceMapGenerator {\n    const map = new SourceMapGenerator(genFilePath);\n\n    let firstOffsetMapped = false;\n    const mapFirstOffsetIfNeeded = () => {\n      if (!firstOffsetMapped) {\n        // Add a single space so that tools won't try to load the file from disk.\n        // Note: We are using virtual urls like `ng:///`, so we have to\n        // provide a content here.\n        map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n        firstOffsetMapped = true;\n      }\n    };\n\n    for (let i = 0; i < startsAtLine; i++) {\n      map.addLine();\n      mapFirstOffsetIfNeeded();\n    }\n\n    this.sourceLines.forEach((line, lineIdx) => {\n      map.addLine();\n\n      const spans = line.srcSpans;\n      const parts = line.parts;\n      let col0 = line.indent * _INDENT_WITH.length;\n      let spanIdx = 0;\n      // skip leading parts without source spans\n      while (spanIdx < spans.length && !spans[spanIdx]) {\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n      }\n      if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n        firstOffsetMapped = true;\n      } else {\n        mapFirstOffsetIfNeeded();\n      }\n\n      while (spanIdx < spans.length) {\n        const span = spans[spanIdx]!;\n        const source = span.start.file;\n        const sourceLine = span.start.line;\n        const sourceCol = span.start.col;\n        map.addSource(source.url, source.content)\n            .addMapping(col0, source.url, sourceLine, sourceCol);\n\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n\n        // assign parts without span or the same span to the previous segment\n        while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n          col0 += parts[spanIdx].length;\n          spanIdx++;\n        }\n      }\n    });\n\n    return map;\n  }\n\n  spanOf(line: number, column: number): ParseSourceSpan|null {\n    const emittedLine = this._lines[line];\n    if (emittedLine) {\n      let columnsLeft = column - _createIndent(emittedLine.indent).length;\n      for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n        const part = emittedLine.parts[partIndex];\n        if (part.length > columnsLeft) {\n          return emittedLine.srcSpans[partIndex];\n        }\n        columnsLeft -= part.length;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get sourceLines(): _EmittedLine[] {\n    if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n      return this._lines.slice(0, -1);\n    }\n    return this._lines;\n  }\n}\n\nexport abstract class AbstractEmitterVisitor implements o.StatementVisitor, o.ExpressionVisitor {\n  constructor(private _escapeDollarInStrings: boolean) {}\n\n  protected printLeadingComments(stmt: o.Statement, ctx: EmitterVisitorContext): void {\n    if (stmt.leadingComments === undefined) {\n      return;\n    }\n    for (const comment of stmt.leadingComments) {\n      if (comment instanceof o.JSDocComment) {\n        ctx.print(stmt, `/*${comment.toString()}*/`, comment.trailingNewline);\n      } else {\n        if (comment.multiline) {\n          ctx.print(stmt, `/* ${comment.text} */`, comment.trailingNewline);\n        } else {\n          comment.text.split('\\n').forEach((line) => {\n            ctx.println(stmt, `// ${line}`);\n          });\n        }\n      }\n    }\n  }\n\n  visitExpressionStmt(stmt: o.ExpressionStatement, ctx: EmitterVisitorContext): any {\n    this.printLeadingComments(stmt, ctx);\n    stmt.expr.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  visitReturnStmt(stmt: o.ReturnStatement, ctx: EmitterVisitorContext): any {\n    this.printLeadingComments(stmt, ctx);\n    ctx.print(stmt, `return `);\n    stmt.value.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  visitIfStmt(stmt: o.IfStmt, ctx: EmitterVisitorContext): any {\n    this.printLeadingComments(stmt, ctx);\n    ctx.print(stmt, `if (`);\n    stmt.condition.visitExpression(this, ctx);\n    ctx.print(stmt, `) {`);\n    const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n    if (stmt.trueCase.length <= 1 && !hasElseCase) {\n      ctx.print(stmt, ` `);\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.removeEmptyLastLine();\n      ctx.print(stmt, ` `);\n    } else {\n      ctx.println();\n      ctx.incIndent();\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.decIndent();\n      if (hasElseCase) {\n        ctx.println(stmt, `} else {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.falseCase, ctx);\n        ctx.decIndent();\n      }\n    }\n    ctx.println(stmt, `}`);\n    return null;\n  }\n\n  abstract visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any;\n\n  visitWriteVarExpr(expr: o.WriteVarExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    ctx.print(expr, `${expr.name} = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitWriteKeyExpr(expr: o.WriteKeyExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    expr.receiver.visitExpression(this, ctx);\n    ctx.print(expr, `[`);\n    expr.index.visitExpression(this, ctx);\n    ctx.print(expr, `] = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitWritePropExpr(expr: o.WritePropExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    expr.receiver.visitExpression(this, ctx);\n    ctx.print(expr, `.${expr.name} = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n\n  visitInvokeFunctionExpr(expr: o.InvokeFunctionExpr, ctx: EmitterVisitorContext): any {\n    expr.fn.visitExpression(this, ctx);\n    ctx.print(expr, `(`);\n    this.visitAllExpressions(expr.args, ctx, ',');\n    ctx.print(expr, `)`);\n    return null;\n  }\n  visitTaggedTemplateExpr(expr: o.TaggedTemplateExpr, ctx: EmitterVisitorContext): any {\n    expr.tag.visitExpression(this, ctx);\n    ctx.print(expr, '`' + expr.template.elements[0].rawText);\n    for (let i = 1; i < expr.template.elements.length; i++) {\n      ctx.print(expr, '${');\n      expr.template.expressions[i - 1].visitExpression(this, ctx);\n      ctx.print(expr, `}${expr.template.elements[i].rawText}`);\n    }\n    ctx.print(expr, '`');\n    return null;\n  }\n  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n  }\n  visitTypeofExpr(expr: o.TypeofExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(expr, 'typeof ');\n    expr.expr.visitExpression(this, ctx);\n  }\n  visitReadVarExpr(ast: o.ReadVarExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitInstantiateExpr(ast: o.InstantiateExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `new `);\n    ast.classExpr.visitExpression(this, ctx);\n    ctx.print(ast, `(`);\n    this.visitAllExpressions(ast.args, ctx, ',');\n    ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitLiteralExpr(ast: o.LiteralExpr, ctx: EmitterVisitorContext): any {\n    const value = ast.value;\n    if (typeof value === 'string') {\n      ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n    } else {\n      ctx.print(ast, `${value}`);\n    }\n    return null;\n  }\n\n  visitLocalizedString(ast: o.LocalizedString, ctx: EmitterVisitorContext): any {\n    const head = ast.serializeI18nHead();\n    ctx.print(ast, '$localize `' + head.raw);\n    for (let i = 1; i < ast.messageParts.length; i++) {\n      ctx.print(ast, '${');\n      ast.expressions[i - 1].visitExpression(this, ctx);\n      ctx.print(ast, `}${ast.serializeI18nTemplatePart(i).raw}`);\n    }\n    ctx.print(ast, '`');\n    return null;\n  }\n\n  abstract visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any;\n\n  visitConditionalExpr(ast: o.ConditionalExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `(`);\n    ast.condition.visitExpression(this, ctx);\n    ctx.print(ast, '? ');\n    ast.trueCase.visitExpression(this, ctx);\n    ctx.print(ast, ': ');\n    ast.falseCase!.visitExpression(this, ctx);\n    ctx.print(ast, `)`);\n    return null;\n  }\n  visitNotExpr(ast: o.NotExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '!');\n    ast.condition.visitExpression(this, ctx);\n    return null;\n  }\n  abstract visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any;\n  abstract visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, context: any): any;\n\n  visitUnaryOperatorExpr(ast: o.UnaryOperatorExpr, ctx: EmitterVisitorContext): any {\n    let opStr: string;\n    switch (ast.operator) {\n      case o.UnaryOperator.Plus:\n        opStr = '+';\n        break;\n      case o.UnaryOperator.Minus:\n        opStr = '-';\n        break;\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    if (ast.parens) ctx.print(ast, `(`);\n    ctx.print(ast, opStr);\n    ast.expr.visitExpression(this, ctx);\n    if (ast.parens) ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, ctx: EmitterVisitorContext): any {\n    let opStr: string;\n    switch (ast.operator) {\n      case o.BinaryOperator.Equals:\n        opStr = '==';\n        break;\n      case o.BinaryOperator.Identical:\n        opStr = '===';\n        break;\n      case o.BinaryOperator.NotEquals:\n        opStr = '!=';\n        break;\n      case o.BinaryOperator.NotIdentical:\n        opStr = '!==';\n        break;\n      case o.BinaryOperator.And:\n        opStr = '&&';\n        break;\n      case o.BinaryOperator.BitwiseAnd:\n        opStr = '&';\n        break;\n      case o.BinaryOperator.Or:\n        opStr = '||';\n        break;\n      case o.BinaryOperator.Plus:\n        opStr = '+';\n        break;\n      case o.BinaryOperator.Minus:\n        opStr = '-';\n        break;\n      case o.BinaryOperator.Divide:\n        opStr = '/';\n        break;\n      case o.BinaryOperator.Multiply:\n        opStr = '*';\n        break;\n      case o.BinaryOperator.Modulo:\n        opStr = '%';\n        break;\n      case o.BinaryOperator.Lower:\n        opStr = '<';\n        break;\n      case o.BinaryOperator.LowerEquals:\n        opStr = '<=';\n        break;\n      case o.BinaryOperator.Bigger:\n        opStr = '>';\n        break;\n      case o.BinaryOperator.BiggerEquals:\n        opStr = '>=';\n        break;\n      case o.BinaryOperator.NullishCoalesce:\n        opStr = '??';\n        break;\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    if (ast.parens) ctx.print(ast, `(`);\n    ast.lhs.visitExpression(this, ctx);\n    ctx.print(ast, ` ${opStr} `);\n    ast.rhs.visitExpression(this, ctx);\n    if (ast.parens) ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitReadPropExpr(ast: o.ReadPropExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `.`);\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitReadKeyExpr(ast: o.ReadKeyExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `[`);\n    ast.index.visitExpression(this, ctx);\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `[`);\n    this.visitAllExpressions(ast.entries, ctx, ',');\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `{`);\n    this.visitAllObjects(entry => {\n      ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);\n      entry.value.visitExpression(this, ctx);\n    }, ast.entries, ctx, ',');\n    ctx.print(ast, `}`);\n    return null;\n  }\n  visitCommaExpr(ast: o.CommaExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '(');\n    this.visitAllExpressions(ast.parts, ctx, ',');\n    ctx.print(ast, ')');\n    return null;\n  }\n  visitAllExpressions(expressions: o.Expression[], ctx: EmitterVisitorContext, separator: string):\n      void {\n    this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);\n  }\n\n  visitAllObjects<T>(\n      handler: (t: T) => void, expressions: T[], ctx: EmitterVisitorContext,\n      separator: string): void {\n    let incrementedIndent = false;\n    for (let i = 0; i < expressions.length; i++) {\n      if (i > 0) {\n        if (ctx.lineLength() > 80) {\n          ctx.print(null, separator, true);\n          if (!incrementedIndent) {\n            // continuation are marked with double indent.\n            ctx.incIndent();\n            ctx.incIndent();\n            incrementedIndent = true;\n          }\n        } else {\n          ctx.print(null, separator, false);\n        }\n      }\n      handler(expressions[i]);\n    }\n    if (incrementedIndent) {\n      // continuation are marked with double indent.\n      ctx.decIndent();\n      ctx.decIndent();\n    }\n  }\n\n  visitAllStatements(statements: o.Statement[], ctx: EmitterVisitorContext): void {\n    statements.forEach((stmt) => stmt.visitStatement(this, ctx));\n  }\n}\n\nexport function escapeIdentifier(\n    input: string, escapeDollar: boolean, alwaysQuote: boolean = true): any {\n  if (input == null) {\n    return null;\n  }\n  const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match: string[]) => {\n    if (match[0] == '$') {\n      return escapeDollar ? '\\\\$' : '$';\n    } else if (match[0] == '\\n') {\n      return '\\\\n';\n    } else if (match[0] == '\\r') {\n      return '\\\\r';\n    } else {\n      return `\\\\${match[0]}`;\n    }\n  });\n  const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n  return requiresQuotes ? `'${body}'` : body;\n}\n\nfunction _createIndent(count: number): string {\n  let res = '';\n  for (let i = 0; i < count; i++) {\n    res += _INDENT_WITH;\n  }\n  return res;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {escapeIdentifier} from '../output/abstract_emitter';\nimport * as o from '../output/output_ast';\n\nimport {Identifiers} from './r3_identifiers';\n\nexport function typeWithParameters(type: o.Expression, numParams: number): o.ExpressionType {\n  if (numParams === 0) {\n    return o.expressionType(type);\n  }\n  const params: o.Type[] = [];\n  for (let i = 0; i < numParams; i++) {\n    params.push(o.DYNAMIC_TYPE);\n  }\n  return o.expressionType(type, undefined, params);\n}\n\nexport interface R3Reference {\n  value: o.Expression;\n  type: o.Expression;\n}\n\n/**\n * Result of compilation of a render3 code unit, e.g. component, directive, pipe, etc.\n */\nexport interface R3CompiledExpression {\n  expression: o.Expression;\n  type: o.Type;\n  statements: o.Statement[];\n}\n\nconst ANIMATE_SYMBOL_PREFIX = '@';\nexport function prepareSyntheticPropertyName(name: string) {\n  return `${ANIMATE_SYMBOL_PREFIX}${name}`;\n}\n\nexport function prepareSyntheticListenerName(name: string, phase: string) {\n  return `${ANIMATE_SYMBOL_PREFIX}${name}.${phase}`;\n}\n\nexport function getSafePropertyAccessString(accessor: string, name: string): string {\n  const escapedName = escapeIdentifier(name, false, false);\n  return escapedName !== name ? `${accessor}[${escapedName}]` : `${accessor}.${name}`;\n}\n\nexport function prepareSyntheticListenerFunctionName(name: string, phase: string) {\n  return `animation_${name}_${phase}`;\n}\n\nexport function jitOnlyGuardedExpression(expr: o.Expression): o.Expression {\n  return guardedExpression('ngJitMode', expr);\n}\n\nexport function devOnlyGuardedExpression(expr: o.Expression): o.Expression {\n  return guardedExpression('ngDevMode', expr);\n}\n\nexport function guardedExpression(guard: string, expr: o.Expression): o.Expression {\n  const guardExpr = new o.ExternalExpr({name: guard, moduleName: null});\n  const guardNotDefined = new o.BinaryOperatorExpr(\n      o.BinaryOperator.Identical, new o.TypeofExpr(guardExpr), o.literal('undefined'));\n  const guardUndefinedOrTrue = new o.BinaryOperatorExpr(\n      o.BinaryOperator.Or, guardNotDefined, guardExpr, /* type */ undefined,\n      /* sourceSpan */ undefined, true);\n  return new o.BinaryOperatorExpr(o.BinaryOperator.And, guardUndefinedOrTrue, expr);\n}\n\nexport function wrapReference(value: any): R3Reference {\n  const wrapped = new o.WrappedNodeExpr(value);\n  return {value: wrapped, type: wrapped};\n}\n\nexport function refsToArray(refs: R3Reference[], shouldForwardDeclare: boolean): o.Expression {\n  const values = o.literalArr(refs.map(ref => ref.value));\n  return shouldForwardDeclare ? o.fn([], [new o.ReturnStatement(values)]) : values;\n}\n\n\n/**\n * Describes an expression that may have been wrapped in a `forwardRef()` guard.\n *\n * This is used when describing expressions that can refer to types that may eagerly reference types\n * that have not yet been defined.\n */\nexport interface MaybeForwardRefExpression<T extends o.Expression = o.Expression> {\n  /**\n   * The unwrapped expression.\n   */\n  expression: T;\n  /**\n   * Specified whether the `expression` contains a reference to something that has not yet been\n   * defined, and whether the expression is still wrapped in a `forwardRef()` call.\n   *\n   * If this value is `ForwardRefHandling.None` then the `expression` is safe to use as-is.\n   *\n   * Otherwise the `expression` was wrapped in a call to `forwardRef()` and must not be eagerly\n   * evaluated. Instead it must be wrapped in a function closure that will be evaluated lazily to\n   * allow the definition of the expression to be evaluated first.\n   *\n   * In full AOT compilation it can be safe to unwrap the `forwardRef()` call up front if the\n   * expression will actually be evaluated lazily inside a function call after the value of\n   * `expression` has been defined.\n   *\n   * But in other cases, such as partial AOT compilation or JIT compilation the expression will be\n   * evaluated eagerly in top level code so will need to continue to be wrapped in a `forwardRef()`\n   * call.\n   *\n   */\n  forwardRef: ForwardRefHandling;\n}\n\nexport function createMayBeForwardRefExpression<T extends o.Expression>(\n    expression: T, forwardRef: ForwardRefHandling): MaybeForwardRefExpression<T> {\n  return {expression, forwardRef};\n}\n\n/**\n * Convert a `MaybeForwardRefExpression` to an `Expression`, possibly wrapping its expression in a\n * `forwardRef()` call.\n *\n * If `MaybeForwardRefExpression.forwardRef` is `ForwardRefHandling.Unwrapped` then the expression\n * was originally wrapped in a `forwardRef()` call to prevent the value from being eagerly evaluated\n * in the code.\n *\n * See `packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts` and\n * `packages/compiler/src/jit_compiler_facade.ts` for more information.\n */\nexport function convertFromMaybeForwardRefExpression(\n    {expression, forwardRef}: MaybeForwardRefExpression): o.Expression {\n  switch (forwardRef) {\n    case ForwardRefHandling.None:\n    case ForwardRefHandling.Wrapped:\n      return expression;\n    case ForwardRefHandling.Unwrapped:\n      return generateForwardRef(expression);\n  }\n}\n\n/**\n * Generate an expression that has the given `expr` wrapped in the following form:\n *\n * ```\n * forwardRef(() => expr)\n * ```\n */\nexport function generateForwardRef(expr: o.Expression): o.Expression {\n  return o.importExpr(Identifiers.forwardRef).callFn([o.fn([], [new o.ReturnStatement(expr)])]);\n}\n\n/**\n * Specifies how a forward ref has been handled in a MaybeForwardRefExpression\n */\nexport const enum ForwardRefHandling {\n  /** The expression was not wrapped in a `forwardRef()` call in the first place. */\n  None,\n  /** The expression is still wrapped in a `forwardRef()` call. */\n  Wrapped,\n  /** The expression was wrapped in a `forwardRef()` call but has since been unwrapped. */\n  Unwrapped,\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {InjectFlags} from '../core';\nimport * as o from '../output/output_ast';\nimport {Identifiers as R3} from '../render3/r3_identifiers';\nimport {R3CompiledExpression, R3Reference, typeWithParameters} from './util';\n\n\n/**\n * Metadata required by the factory generator to generate a `factory` function for a type.\n */\nexport interface R3ConstructorFactoryMetadata {\n  /**\n   * String name of the type being generated (used to name the factory function).\n   */\n  name: string;\n\n  /**\n   * An expression representing the interface type being constructed.\n   */\n  type: R3Reference;\n\n  /**\n   * An expression representing the constructor type, intended for use within a class definition\n   * itself.\n   *\n   * This can differ from the outer `type` if the class is being compiled by ngcc and is inside\n   * an IIFE structure that uses a different name internally.\n   */\n  internalType: o.Expression;\n\n  /** Number of arguments for the `type`. */\n  typeArgumentCount: number;\n\n  /**\n   * Regardless of whether `fnOrClass` is a constructor function or a user-defined factory, it\n   * may have 0 or more parameters, which will be injected according to the `R3DependencyMetadata`\n   * for those parameters. If this is `null`, then the type's constructor is nonexistent and will\n   * be inherited from `fnOrClass` which is interpreted as the current type. If this is `'invalid'`,\n   * then one or more of the parameters wasn't resolvable and any attempt to use these deps will\n   * result in a runtime error.\n   */\n  deps: R3DependencyMetadata[]|'invalid'|null;\n\n  /**\n   * Type of the target being created by the factory.\n   */\n  target: FactoryTarget;\n}\n\nexport enum R3FactoryDelegateType {\n  Class = 0,\n  Function = 1,\n}\n\nexport interface R3DelegatedFnOrClassMetadata extends R3ConstructorFactoryMetadata {\n  delegate: o.Expression;\n  delegateType: R3FactoryDelegateType;\n  delegateDeps: R3DependencyMetadata[];\n}\n\nexport interface R3ExpressionFactoryMetadata extends R3ConstructorFactoryMetadata {\n  expression: o.Expression;\n}\n\nexport type R3FactoryMetadata =\n    R3ConstructorFactoryMetadata|R3DelegatedFnOrClassMetadata|R3ExpressionFactoryMetadata;\n\nexport enum FactoryTarget {\n  Directive = 0,\n  Component = 1,\n  Injectable = 2,\n  Pipe = 3,\n  NgModule = 4,\n}\n\nexport interface R3DependencyMetadata {\n  /**\n   * An expression representing the token or value to be injected.\n   * Or `null` if the dependency could not be resolved - making it invalid.\n   */\n  token: o.Expression|null;\n\n  /**\n   * If an @Attribute decorator is present, this is the literal type of the attribute name, or\n   * the unknown type if no literal type is available (e.g. the attribute name is an expression).\n   * Otherwise it is null;\n   */\n  attributeNameType: o.Expression|null;\n\n  /**\n   * Whether the dependency has an @Host qualifier.\n   */\n  host: boolean;\n\n  /**\n   * Whether the dependency has an @Optional qualifier.\n   */\n  optional: boolean;\n\n  /**\n   * Whether the dependency has an @Self qualifier.\n   */\n  self: boolean;\n\n  /**\n   * Whether the dependency has an @SkipSelf qualifier.\n   */\n  skipSelf: boolean;\n}\n\n/**\n * Construct a factory function expression for the given `R3FactoryMetadata`.\n */\nexport function compileFactoryFunction(meta: R3FactoryMetadata): R3CompiledExpression {\n  const t = o.variable('t');\n  let baseFactoryVar: o.ReadVarExpr|null = null;\n\n  // The type to instantiate via constructor invocation. If there is no delegated factory, meaning\n  // this type is always created by constructor invocation, then this is the type-to-create\n  // parameter provided by the user (t) if specified, or the current type if not. If there is a\n  // delegated factory (which is used to create the current type) then this is only the type-to-\n  // create parameter (t).\n  const typeForCtor = !isDelegatedFactoryMetadata(meta) ?\n      new o.BinaryOperatorExpr(o.BinaryOperator.Or, t, meta.internalType) :\n      t;\n\n  let ctorExpr: o.Expression|null = null;\n  if (meta.deps !== null) {\n    // There is a constructor (either explicitly or implicitly defined).\n    if (meta.deps !== 'invalid') {\n      ctorExpr = new o.InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.target));\n    }\n  } else {\n    // There is no constructor, use the base class' factory to construct typeForCtor.\n    baseFactoryVar = o.variable(`\u0275${meta.name}_BaseFactory`);\n    ctorExpr = baseFactoryVar.callFn([typeForCtor]);\n  }\n\n  const body: o.Statement[] = [];\n  let retExpr: o.Expression|null = null;\n\n  function makeConditionalFactory(nonCtorExpr: o.Expression): o.ReadVarExpr {\n    const r = o.variable('r');\n    body.push(r.set(o.NULL_EXPR).toDeclStmt());\n    const ctorStmt = ctorExpr !== null ? r.set(ctorExpr).toStmt() :\n                                         o.importExpr(R3.invalidFactory).callFn([]).toStmt();\n    body.push(o.ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));\n    return r;\n  }\n\n  if (isDelegatedFactoryMetadata(meta)) {\n    // This type is created with a delegated factory. If a type parameter is not specified, call\n    // the factory instead.\n    const delegateArgs = injectDependencies(meta.delegateDeps, meta.target);\n    // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.\n    const factoryExpr = new (\n        meta.delegateType === R3FactoryDelegateType.Class ?\n            o.InstantiateExpr :\n            o.InvokeFunctionExpr)(meta.delegate, delegateArgs);\n    retExpr = makeConditionalFactory(factoryExpr);\n  } else if (isExpressionFactoryMetadata(meta)) {\n    // TODO(alxhub): decide whether to lower the value here or in the caller\n    retExpr = makeConditionalFactory(meta.expression);\n  } else {\n    retExpr = ctorExpr;\n  }\n\n\n  if (retExpr === null) {\n    // The expression cannot be formed so render an `\u0275\u0275invalidFactory()` call.\n    body.push(o.importExpr(R3.invalidFactory).callFn([]).toStmt());\n  } else if (baseFactoryVar !== null) {\n    // This factory uses a base factory, so call `\u0275\u0275getInheritedFactory()` to compute it.\n    const getInheritedFactoryCall =\n        o.importExpr(R3.getInheritedFactory).callFn([meta.internalType]);\n    // Memoize the base factoryFn: `baseFactory || (baseFactory = \u0275\u0275getInheritedFactory(...))`\n    const baseFactory = new o.BinaryOperatorExpr(\n        o.BinaryOperator.Or, baseFactoryVar, baseFactoryVar.set(getInheritedFactoryCall));\n    body.push(new o.ReturnStatement(baseFactory.callFn([typeForCtor])));\n  } else {\n    // This is straightforward factory, just return it.\n    body.push(new o.ReturnStatement(retExpr));\n  }\n\n  let factoryFn: o.Expression = o.fn(\n      [new o.FnParam('t', o.DYNAMIC_TYPE)], body, o.INFERRED_TYPE, undefined,\n      `${meta.name}_Factory`);\n\n  if (baseFactoryVar !== null) {\n    // There is a base factory variable so wrap its declaration along with the factory function into\n    // an IIFE.\n    factoryFn = o.fn([], [\n                   new o.DeclareVarStmt(baseFactoryVar.name!), new o.ReturnStatement(factoryFn)\n                 ]).callFn([], /* sourceSpan */ undefined, /* pure */ true);\n  }\n\n  return {\n    expression: factoryFn,\n    statements: [],\n    type: createFactoryType(meta),\n  };\n}\n\nexport function createFactoryType(meta: R3FactoryMetadata) {\n  const ctorDepsType =\n      meta.deps !== null && meta.deps !== 'invalid' ? createCtorDepsType(meta.deps) : o.NONE_TYPE;\n  return o.expressionType(o.importExpr(\n      R3.FactoryDeclaration,\n      [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]));\n}\n\nfunction injectDependencies(deps: R3DependencyMetadata[], target: FactoryTarget): o.Expression[] {\n  return deps.map((dep, index) => compileInjectDependency(dep, target, index));\n}\n\nfunction compileInjectDependency(\n    dep: R3DependencyMetadata, target: FactoryTarget, index: number): o.Expression {\n  // Interpret the dependency according to its resolved type.\n  if (dep.token === null) {\n    return o.importExpr(R3.invalidFactoryDep).callFn([o.literal(index)]);\n  } else if (dep.attributeNameType === null) {\n    // Build up the injection flags according to the metadata.\n    const flags = InjectFlags.Default | (dep.self ? InjectFlags.Self : 0) |\n        (dep.skipSelf ? InjectFlags.SkipSelf : 0) | (dep.host ? InjectFlags.Host : 0) |\n        (dep.optional ? InjectFlags.Optional : 0) |\n        (target === FactoryTarget.Pipe ? InjectFlags.ForPipe : 0);\n\n    // If this dependency is optional or otherwise has non-default flags, then additional\n    // parameters describing how to inject the dependency must be passed to the inject function\n    // that's being used.\n    let flagsParam: o.LiteralExpr|null =\n        (flags !== InjectFlags.Default || dep.optional) ? o.literal(flags) : null;\n\n    // Build up the arguments to the injectFn call.\n    const injectArgs = [dep.token];\n    if (flagsParam) {\n      injectArgs.push(flagsParam);\n    }\n    const injectFn = getInjectFn(target);\n    return o.importExpr(injectFn).callFn(injectArgs);\n  } else {\n    // The `dep.attributeTypeName` value is defined, which indicates that this is an `@Attribute()`\n    // type dependency. For the generated JS we still want to use the `dep.token` value in case the\n    // name given for the attribute is not a string literal. For example given `@Attribute(foo())`,\n    // we want to generate `\u0275\u0275injectAttribute(foo())`.\n    //\n    // The `dep.attributeTypeName` is only actually used (in `createCtorDepType()`) to generate\n    // typings.\n    return o.importExpr(R3.injectAttribute).callFn([dep.token]);\n  }\n}\n\nfunction createCtorDepsType(deps: R3DependencyMetadata[]): o.Type {\n  let hasTypes = false;\n  const attributeTypes = deps.map(dep => {\n    const type = createCtorDepType(dep);\n    if (type !== null) {\n      hasTypes = true;\n      return type;\n    } else {\n      return o.literal(null);\n    }\n  });\n\n  if (hasTypes) {\n    return o.expressionType(o.literalArr(attributeTypes));\n  } else {\n    return o.NONE_TYPE;\n  }\n}\n\nfunction createCtorDepType(dep: R3DependencyMetadata): o.LiteralMapExpr|null {\n  const entries: {key: string, quoted: boolean, value: o.Expression}[] = [];\n\n  if (dep.attributeNameType !== null) {\n    entries.push({key: 'attribute', value: dep.attributeNameType, quoted: false});\n  }\n  if (dep.optional) {\n    entries.push({key: 'optional', value: o.literal(true), quoted: false});\n  }\n  if (dep.host) {\n    entries.push({key: 'host', value: o.literal(true), quoted: false});\n  }\n  if (dep.self) {\n    entries.push({key: 'self', value: o.literal(true), quoted: false});\n  }\n  if (dep.skipSelf) {\n    entries.push({key: 'skipSelf', value: o.literal(true), quoted: false});\n  }\n\n  return entries.length > 0 ? o.literalMap(entries) : null;\n}\n\nexport function isDelegatedFactoryMetadata(meta: R3FactoryMetadata):\n    meta is R3DelegatedFnOrClassMetadata {\n  return (meta as any).delegateType !== undefined;\n}\n\nexport function isExpressionFactoryMetadata(meta: R3FactoryMetadata):\n    meta is R3ExpressionFactoryMetadata {\n  return (meta as any).expression !== undefined;\n}\n\nfunction getInjectFn(target: FactoryTarget): o.ExternalReference {\n  switch (target) {\n    case FactoryTarget.Component:\n    case FactoryTarget.Directive:\n    case FactoryTarget.Pipe:\n      return R3.directiveInject;\n    case FactoryTarget.NgModule:\n    case FactoryTarget.Injectable:\n    default:\n      return R3.inject;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '../core';\nimport {AST, BindingType, BoundElementProperty, ParsedEvent, ParsedEventType} from '../expression_parser/ast';\nimport {I18nMeta} from '../i18n/i18n_ast';\nimport {ParseSourceSpan} from '../parse_util';\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan;\n  visit<Result>(visitor: Visitor<Result>): Result;\n}\n\n/**\n * This is an R3 `Node`-like wrapper for a raw `html.Comment` node. We do not currently\n * require the implementation of a visitor for Comments as they are only collected at\n * the top-level of the R3 AST, and only if `Render3ParseOptions['collectCommentNodes']`\n * is true.\n */\nexport class Comment implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n  visit<Result>(_visitor: Visitor<Result>): Result {\n    throw new Error('visit() not implemented for Comment');\n  }\n}\n\nexport class Text implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitText(this);\n  }\n}\n\nexport class BoundText implements Node {\n  constructor(public value: AST, public sourceSpan: ParseSourceSpan, public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitBoundText(this);\n  }\n}\n\n/**\n * Represents a text attribute in the template.\n *\n * `valueSpan` may not be present in cases where there is no value `<div a></div>`.\n * `keySpan` may also not be present for synthetic attributes from ICU expansions.\n */\nexport class TextAttribute implements Node {\n  constructor(\n      public name: string, public value: string, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan|undefined, public valueSpan?: ParseSourceSpan,\n      public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitTextAttribute(this);\n  }\n}\n\nexport class BoundAttribute implements Node {\n  constructor(\n      public name: string, public type: BindingType, public securityContext: SecurityContext,\n      public value: AST, public unit: string|null, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan, public valueSpan: ParseSourceSpan|undefined,\n      public i18n: I18nMeta|undefined) {}\n\n  static fromBoundElementProperty(prop: BoundElementProperty, i18n?: I18nMeta): BoundAttribute {\n    if (prop.keySpan === undefined) {\n      throw new Error(\n          `Unexpected state: keySpan must be defined for bound attributes but was not for ${\n              prop.name}: ${prop.sourceSpan}`);\n    }\n    return new BoundAttribute(\n        prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan,\n        prop.keySpan, prop.valueSpan, i18n);\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitBoundAttribute(this);\n  }\n}\n\nexport class BoundEvent implements Node {\n  constructor(\n      public name: string, public type: ParsedEventType, public handler: AST,\n      public target: string|null, public phase: string|null, public sourceSpan: ParseSourceSpan,\n      public handlerSpan: ParseSourceSpan, readonly keySpan: ParseSourceSpan) {}\n\n  static fromParsedEvent(event: ParsedEvent) {\n    const target: string|null = event.type === ParsedEventType.Regular ? event.targetOrPhase : null;\n    const phase: string|null =\n        event.type === ParsedEventType.Animation ? event.targetOrPhase : null;\n    if (event.keySpan === undefined) {\n      throw new Error(`Unexpected state: keySpan must be defined for bound event but was not for ${\n          event.name}: ${event.sourceSpan}`);\n    }\n    return new BoundEvent(\n        event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan,\n        event.keySpan);\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitBoundEvent(this);\n  }\n}\n\nexport class Element implements Node {\n  constructor(\n      public name: string, public attributes: TextAttribute[], public inputs: BoundAttribute[],\n      public outputs: BoundEvent[], public children: Node[], public references: Reference[],\n      public sourceSpan: ParseSourceSpan, public startSourceSpan: ParseSourceSpan,\n      public endSourceSpan: ParseSourceSpan|null, public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitElement(this);\n  }\n}\n\nexport class Template implements Node {\n  constructor(\n      // tagName is the name of the container element, if applicable.\n      // `null` is a special case for when there is a structural directive on an `ng-template` so\n      // the renderer can differentiate between the synthetic template and the one written in the\n      // file.\n      public tagName: string|null,\n      public attributes: TextAttribute[],\n      public inputs: BoundAttribute[],\n      public outputs: BoundEvent[],\n      public templateAttrs: (BoundAttribute|TextAttribute)[],\n      public children: Node[],\n      public references: Reference[],\n      public variables: Variable[],\n      public sourceSpan: ParseSourceSpan,\n      public startSourceSpan: ParseSourceSpan,\n      public endSourceSpan: ParseSourceSpan|null,\n      public i18n?: I18nMeta,\n  ) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitTemplate(this);\n  }\n}\n\nexport class Content implements Node {\n  readonly name = 'ng-content';\n\n  constructor(\n      public selector: string, public attributes: TextAttribute[],\n      public sourceSpan: ParseSourceSpan, public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitContent(this);\n  }\n}\n\nexport class Variable implements Node {\n  constructor(\n      public name: string, public value: string, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan, public valueSpan?: ParseSourceSpan) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitVariable(this);\n  }\n}\n\nexport class Reference implements Node {\n  constructor(\n      public name: string, public value: string, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan, public valueSpan?: ParseSourceSpan) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitReference(this);\n  }\n}\n\nexport class Icu implements Node {\n  constructor(\n      public vars: {[name: string]: BoundText},\n      public placeholders: {[name: string]: Text|BoundText}, public sourceSpan: ParseSourceSpan,\n      public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitIcu(this);\n  }\n}\n\nexport interface Visitor<Result = any> {\n  // Returning a truthy value from `visit()` will prevent `visitAll()` from the call to the typed\n  // method and result returned will become the result included in `visitAll()`s result array.\n  visit?(node: Node): Result;\n\n  visitElement(element: Element): Result;\n  visitTemplate(template: Template): Result;\n  visitContent(content: Content): Result;\n  visitVariable(variable: Variable): Result;\n  visitReference(reference: Reference): Result;\n  visitTextAttribute(attribute: TextAttribute): Result;\n  visitBoundAttribute(attribute: BoundAttribute): Result;\n  visitBoundEvent(attribute: BoundEvent): Result;\n  visitText(text: Text): Result;\n  visitBoundText(text: BoundText): Result;\n  visitIcu(icu: Icu): Result;\n}\n\nexport class NullVisitor implements Visitor<void> {\n  visitElement(element: Element): void {}\n  visitTemplate(template: Template): void {}\n  visitContent(content: Content): void {}\n  visitVariable(variable: Variable): void {}\n  visitReference(reference: Reference): void {}\n  visitTextAttribute(attribute: TextAttribute): void {}\n  visitBoundAttribute(attribute: BoundAttribute): void {}\n  visitBoundEvent(attribute: BoundEvent): void {}\n  visitText(text: Text): void {}\n  visitBoundText(text: BoundText): void {}\n  visitIcu(icu: Icu): void {}\n}\n\nexport class RecursiveVisitor implements Visitor<void> {\n  visitElement(element: Element): void {\n    visitAll(this, element.attributes);\n    visitAll(this, element.inputs);\n    visitAll(this, element.outputs);\n    visitAll(this, element.children);\n    visitAll(this, element.references);\n  }\n  visitTemplate(template: Template): void {\n    visitAll(this, template.attributes);\n    visitAll(this, template.inputs);\n    visitAll(this, template.outputs);\n    visitAll(this, template.children);\n    visitAll(this, template.references);\n    visitAll(this, template.variables);\n  }\n  visitContent(content: Content): void {}\n  visitVariable(variable: Variable): void {}\n  visitReference(reference: Reference): void {}\n  visitTextAttribute(attribute: TextAttribute): void {}\n  visitBoundAttribute(attribute: BoundAttribute): void {}\n  visitBoundEvent(attribute: BoundEvent): void {}\n  visitText(text: Text): void {}\n  visitBoundText(text: BoundText): void {}\n  visitIcu(icu: Icu): void {}\n}\n\nexport class TransformVisitor implements Visitor<Node> {\n  visitElement(element: Element): Node {\n    const newAttributes = transformAll(this, element.attributes);\n    const newInputs = transformAll(this, element.inputs);\n    const newOutputs = transformAll(this, element.outputs);\n    const newChildren = transformAll(this, element.children);\n    const newReferences = transformAll(this, element.references);\n    if (newAttributes != element.attributes || newInputs != element.inputs ||\n        newOutputs != element.outputs || newChildren != element.children ||\n        newReferences != element.references) {\n      return new Element(\n          element.name, newAttributes, newInputs, newOutputs, newChildren, newReferences,\n          element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n    }\n    return element;\n  }\n\n  visitTemplate(template: Template): Node {\n    const newAttributes = transformAll(this, template.attributes);\n    const newInputs = transformAll(this, template.inputs);\n    const newOutputs = transformAll(this, template.outputs);\n    const newTemplateAttrs = transformAll(this, template.templateAttrs);\n    const newChildren = transformAll(this, template.children);\n    const newReferences = transformAll(this, template.references);\n    const newVariables = transformAll(this, template.variables);\n    if (newAttributes != template.attributes || newInputs != template.inputs ||\n        newOutputs != template.outputs || newTemplateAttrs != template.templateAttrs ||\n        newChildren != template.children || newReferences != template.references ||\n        newVariables != template.variables) {\n      return new Template(\n          template.tagName, newAttributes, newInputs, newOutputs, newTemplateAttrs, newChildren,\n          newReferences, newVariables, template.sourceSpan, template.startSourceSpan,\n          template.endSourceSpan);\n    }\n    return template;\n  }\n\n  visitContent(content: Content): Node {\n    return content;\n  }\n\n  visitVariable(variable: Variable): Node {\n    return variable;\n  }\n  visitReference(reference: Reference): Node {\n    return reference;\n  }\n  visitTextAttribute(attribute: TextAttribute): Node {\n    return attribute;\n  }\n  visitBoundAttribute(attribute: BoundAttribute): Node {\n    return attribute;\n  }\n  visitBoundEvent(attribute: BoundEvent): Node {\n    return attribute;\n  }\n  visitText(text: Text): Node {\n    return text;\n  }\n  visitBoundText(text: BoundText): Node {\n    return text;\n  }\n  visitIcu(icu: Icu): Node {\n    return icu;\n  }\n}\n\nexport function visitAll<Result>(visitor: Visitor<Result>, nodes: Node[]): Result[] {\n  const result: Result[] = [];\n  if (visitor.visit) {\n    for (const node of nodes) {\n      const newNode = visitor.visit(node) || node.visit(visitor);\n    }\n  } else {\n    for (const node of nodes) {\n      const newNode = node.visit(visitor);\n      if (newNode) {\n        result.push(newNode);\n      }\n    }\n  }\n  return result;\n}\n\nexport function transformAll<Result extends Node>(\n    visitor: Visitor<Node>, nodes: Result[]): Result[] {\n  const result: Result[] = [];\n  let changed = false;\n  for (const node of nodes) {\n    const newNode = node.visit(visitor);\n    if (newNode) {\n      result.push(newNode as Result);\n    }\n    changed = changed || newNode != node;\n  }\n  return changed ? result : nodes;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '../parse_util';\n\n/**\n * Describes the text contents of a placeholder as it appears in an ICU expression, including its\n * source span information.\n */\nexport interface MessagePlaceholder {\n  /** The text contents of the placeholder */\n  text: string;\n\n  /** The source span of the placeholder */\n  sourceSpan: ParseSourceSpan;\n}\n\nexport class Message {\n  sources: MessageSpan[];\n  id: string = this.customId;\n  /** The ids to use if there are no custom id and if `i18nLegacyMessageIdFormat` is not empty */\n  legacyIds: string[] = [];\n\n  messageString = serializeMessage(this.nodes);\n\n  /**\n   * @param nodes message AST\n   * @param placeholders maps placeholder names to static content and their source spans\n   * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n   * @param meaning\n   * @param description\n   * @param customId\n   */\n  constructor(\n      public nodes: Node[], public placeholders: {[phName: string]: MessagePlaceholder},\n      public placeholderToMessage: {[phName: string]: Message}, public meaning: string,\n      public description: string, public customId: string) {\n    if (nodes.length) {\n      this.sources = [{\n        filePath: nodes[0].sourceSpan.start.file.url,\n        startLine: nodes[0].sourceSpan.start.line + 1,\n        startCol: nodes[0].sourceSpan.start.col + 1,\n        endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n        endCol: nodes[0].sourceSpan.start.col + 1\n      }];\n    } else {\n      this.sources = [];\n    }\n  }\n}\n\n// line and columns indexes are 1 based\nexport interface MessageSpan {\n  filePath: string;\n  startLine: number;\n  startCol: number;\n  endLine: number;\n  endCol: number;\n}\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan;\n  visit(visitor: Visitor, context?: any): any;\n}\n\nexport class Text implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitText(this, context);\n  }\n}\n\n// TODO(vicb): do we really need this node (vs an array) ?\nexport class Container implements Node {\n  constructor(public children: Node[], public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitContainer(this, context);\n  }\n}\n\nexport class Icu implements Node {\n  // TODO(issue/24571): remove '!'.\n  public expressionPlaceholder!: string;\n  constructor(\n      public expression: string, public type: string, public cases: {[k: string]: Node},\n      public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitIcu(this, context);\n  }\n}\n\nexport class TagPlaceholder implements Node {\n  constructor(\n      public tag: string, public attrs: {[k: string]: string}, public startName: string,\n      public closeName: string, public children: Node[], public isVoid: boolean,\n      // TODO sourceSpan should cover all (we need a startSourceSpan and endSourceSpan)\n      public sourceSpan: ParseSourceSpan, public startSourceSpan: ParseSourceSpan|null,\n      public endSourceSpan: ParseSourceSpan|null) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitTagPlaceholder(this, context);\n  }\n}\n\nexport class Placeholder implements Node {\n  constructor(public value: string, public name: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitPlaceholder(this, context);\n  }\n}\n\nexport class IcuPlaceholder implements Node {\n  /** Used to capture a message computed from a previous processing pass (see `setI18nRefs()`). */\n  previousMessage?: Message;\n  constructor(public value: Icu, public name: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitIcuPlaceholder(this, context);\n  }\n}\n\n/**\n * Each HTML node that is affect by an i18n tag will also have an `i18n` property that is of type\n * `I18nMeta`.\n * This information is either a `Message`, which indicates it is the root of an i18n message, or a\n * `Node`, which indicates is it part of a containing `Message`.\n */\nexport type I18nMeta = Message|Node;\n\nexport interface Visitor {\n  visitText(text: Text, context?: any): any;\n  visitContainer(container: Container, context?: any): any;\n  visitIcu(icu: Icu, context?: any): any;\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): any;\n  visitPlaceholder(ph: Placeholder, context?: any): any;\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any;\n}\n\n// Clone the AST\nexport class CloneVisitor implements Visitor {\n  visitText(text: Text, context?: any): Text {\n    return new Text(text.value, text.sourceSpan);\n  }\n\n  visitContainer(container: Container, context?: any): Container {\n    const children = container.children.map(n => n.visit(this, context));\n    return new Container(children, container.sourceSpan);\n  }\n\n  visitIcu(icu: Icu, context?: any): Icu {\n    const cases: {[k: string]: Node} = {};\n    Object.keys(icu.cases).forEach(key => cases[key] = icu.cases[key].visit(this, context));\n    const msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan);\n    msg.expressionPlaceholder = icu.expressionPlaceholder;\n    return msg;\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): TagPlaceholder {\n    const children = ph.children.map(n => n.visit(this, context));\n    return new TagPlaceholder(\n        ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan,\n        ph.startSourceSpan, ph.endSourceSpan);\n  }\n\n  visitPlaceholder(ph: Placeholder, context?: any): Placeholder {\n    return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n  }\n\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): IcuPlaceholder {\n    return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n  }\n}\n\n// Visit all the nodes recursively\nexport class RecurseVisitor implements Visitor {\n  visitText(text: Text, context?: any): any {}\n\n  visitContainer(container: Container, context?: any): any {\n    container.children.forEach(child => child.visit(this));\n  }\n\n  visitIcu(icu: Icu, context?: any): any {\n    Object.keys(icu.cases).forEach(k => {\n      icu.cases[k].visit(this);\n    });\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): any {\n    ph.children.forEach(child => child.visit(this));\n  }\n\n  visitPlaceholder(ph: Placeholder, context?: any): any {}\n\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any {}\n}\n\n\n/**\n * Serialize the message to the Localize backtick string format that would appear in compiled code.\n */\nfunction serializeMessage(messageNodes: Node[]): string {\n  const visitor = new LocalizeMessageStringVisitor();\n  const str = messageNodes.map(n => n.visit(visitor)).join('');\n  return str;\n}\n\nclass LocalizeMessageStringVisitor implements Visitor {\n  visitText(text: Text): any {\n    return text.value;\n  }\n\n  visitContainer(container: Container): any {\n    return container.children.map(child => child.visit(this)).join('');\n  }\n\n  visitIcu(icu: Icu): any {\n    const strCases =\n        Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder): any {\n    const children = ph.children.map(child => child.visit(this)).join('');\n    return `{$${ph.startName}}${children}{$${ph.closeName}}`;\n  }\n\n  visitPlaceholder(ph: Placeholder): any {\n    return `{$${ph.name}}`;\n  }\n\n  visitIcuPlaceholder(ph: IcuPlaceholder): any {\n    return `{$${ph.name}}`;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as i18n from '../i18n_ast';\n\nexport abstract class Serializer {\n  // - The `placeholders` and `placeholderToMessage` properties are irrelevant in the input messages\n  // - The `id` contains the message id that the serializer is expected to use\n  // - Placeholder names are already map to public names using the provided mapper\n  abstract write(messages: i18n.Message[], locale: string|null): string;\n\n  abstract load(content: string, url: string):\n      {locale: string|null, i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}};\n\n  abstract digest(message: i18n.Message): string;\n\n  // Creates a name mapper, see `PlaceholderMapper`\n  // Returning `null` means that no name mapping is used.\n  createNameMapper(message: i18n.Message): PlaceholderMapper|null {\n    return null;\n  }\n}\n\n/**\n * A `PlaceholderMapper` converts placeholder names from internal to serialized representation and\n * back.\n *\n * It should be used for serialization format that put constraints on the placeholder names.\n */\nexport interface PlaceholderMapper {\n  toPublicName(internalName: string): string|null;\n\n  toInternalName(publicName: string): string|null;\n}\n\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\nexport class SimplePlaceholderMapper extends i18n.RecurseVisitor implements PlaceholderMapper {\n  private internalToPublic: {[k: string]: string} = {};\n  private publicToNextId: {[k: string]: number} = {};\n  private publicToInternal: {[k: string]: string} = {};\n\n  // create a mapping from the message\n  constructor(message: i18n.Message, private mapName: (name: string) => string) {\n    super();\n    message.nodes.forEach(node => node.visit(this));\n  }\n\n  toPublicName(internalName: string): string|null {\n    return this.internalToPublic.hasOwnProperty(internalName) ?\n        this.internalToPublic[internalName] :\n        null;\n  }\n\n  toInternalName(publicName: string): string|null {\n    return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] :\n                                                              null;\n  }\n\n  override visitText(text: i18n.Text, context?: any): any {\n    return null;\n  }\n\n  override visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.startName);\n    super.visitTagPlaceholder(ph, context);\n    this.visitPlaceholderName(ph.closeName);\n  }\n\n  override visitPlaceholder(ph: i18n.Placeholder, context?: any): any {\n    this.visitPlaceholderName(ph.name);\n  }\n\n  override visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.name);\n  }\n\n  // XMB placeholders could only contains A-Z, 0-9 and _\n  private visitPlaceholderName(internalName: string): void {\n    if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n      return;\n    }\n\n    let publicName = this.mapName(internalName);\n\n    if (this.publicToInternal.hasOwnProperty(publicName)) {\n      // Create a new XMB when it has already been used\n      const nextId = this.publicToNextId[publicName];\n      this.publicToNextId[publicName] = nextId + 1;\n      publicName = `${publicName}_${nextId}`;\n    } else {\n      this.publicToNextId[publicName] = 1;\n    }\n\n    this.internalToPublic[internalName] = publicName;\n    this.publicToInternal[publicName] = internalName;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport interface IVisitor {\n  visitTag(tag: Tag): any;\n  visitText(text: Text): any;\n  visitDeclaration(decl: Declaration): any;\n  visitDoctype(doctype: Doctype): any;\n}\n\nclass _Visitor implements IVisitor {\n  visitTag(tag: Tag): string {\n    const strAttrs = this._serializeAttributes(tag.attrs);\n\n    if (tag.children.length == 0) {\n      return `<${tag.name}${strAttrs}/>`;\n    }\n\n    const strChildren = tag.children.map(node => node.visit(this));\n    return `<${tag.name}${strAttrs}>${strChildren.join('')}</${tag.name}>`;\n  }\n\n  visitText(text: Text): string {\n    return text.value;\n  }\n\n  visitDeclaration(decl: Declaration): string {\n    return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;\n  }\n\n  private _serializeAttributes(attrs: {[k: string]: string}) {\n    const strAttrs = Object.keys(attrs).map((name: string) => `${name}=\"${attrs[name]}\"`).join(' ');\n    return strAttrs.length > 0 ? ' ' + strAttrs : '';\n  }\n\n  visitDoctype(doctype: Doctype): any {\n    return `<!DOCTYPE ${doctype.rootTag} [\\n${doctype.dtd}\\n]>`;\n  }\n}\n\nconst _visitor = new _Visitor();\n\nexport function serialize(nodes: Node[]): string {\n  return nodes.map((node: Node): string => node.visit(_visitor)).join('');\n}\n\nexport interface Node {\n  visit(visitor: IVisitor): any;\n}\n\nexport class Declaration implements Node {\n  public attrs: {[k: string]: string} = {};\n\n  constructor(unescapedAttrs: {[k: string]: string}) {\n    Object.keys(unescapedAttrs).forEach((k: string) => {\n      this.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n\n  visit(visitor: IVisitor): any {\n    return visitor.visitDeclaration(this);\n  }\n}\n\nexport class Doctype implements Node {\n  constructor(public rootTag: string, public dtd: string) {}\n\n  visit(visitor: IVisitor): any {\n    return visitor.visitDoctype(this);\n  }\n}\n\nexport class Tag implements Node {\n  public attrs: {[k: string]: string} = {};\n\n  constructor(\n      public name: string, unescapedAttrs: {[k: string]: string} = {},\n      public children: Node[] = []) {\n    Object.keys(unescapedAttrs).forEach((k: string) => {\n      this.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n\n  visit(visitor: IVisitor): any {\n    return visitor.visitTag(this);\n  }\n}\n\nexport class Text implements Node {\n  value: string;\n  constructor(unescapedValue: string) {\n    this.value = escapeXml(unescapedValue);\n  }\n\n  visit(visitor: IVisitor): any {\n    return visitor.visitText(this);\n  }\n}\n\nexport class CR extends Text {\n  constructor(ws: number = 0) {\n    super(`\\n${new Array(ws + 1).join(' ')}`);\n  }\n}\n\nconst _ESCAPED_CHARS: [RegExp, string][] = [\n  [/&/g, '&amp;'],\n  [/\"/g, '&quot;'],\n  [/'/g, '&apos;'],\n  [/</g, '&lt;'],\n  [/>/g, '&gt;'],\n];\n\n// Escape `_ESCAPED_CHARS` characters in the given text with encoded entities\nexport function escapeXml(text: string): string {\n  return _ESCAPED_CHARS.reduce(\n      (text: string, entry: [RegExp, string]) => text.replace(entry[0], entry[1]), text);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {decimalDigest} from '../digest';\nimport * as i18n from '../i18n_ast';\n\nimport {PlaceholderMapper, Serializer, SimplePlaceholderMapper} from './serializer';\nimport * as xml from './xml_helper';\n\nconst _MESSAGES_TAG = 'messagebundle';\nconst _MESSAGE_TAG = 'msg';\nconst _PLACEHOLDER_TAG = 'ph';\nconst _EXAMPLE_TAG = 'ex';\nconst _SOURCE_TAG = 'source';\n\nconst _DOCTYPE = `<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>`;\n\nexport class Xmb extends Serializer {\n  override write(messages: i18n.Message[], locale: string|null): string {\n    const exampleVisitor = new ExampleVisitor();\n    const visitor = new _Visitor();\n    let rootNode = new xml.Tag(_MESSAGES_TAG);\n\n    messages.forEach(message => {\n      const attrs: {[k: string]: string} = {id: message.id};\n\n      if (message.description) {\n        attrs['desc'] = message.description;\n      }\n\n      if (message.meaning) {\n        attrs['meaning'] = message.meaning;\n      }\n\n      let sourceTags: xml.Tag[] = [];\n      message.sources.forEach((source: i18n.MessageSpan) => {\n        sourceTags.push(new xml.Tag(\n            _SOURCE_TAG, {},\n            [new xml.Text(`${source.filePath}:${source.startLine}${\n                source.endLine !== source.startLine ? ',' + source.endLine : ''}`)]));\n      });\n\n      rootNode.children.push(\n          new xml.CR(2),\n          new xml.Tag(_MESSAGE_TAG, attrs, [...sourceTags, ...visitor.serialize(message.nodes)]));\n    });\n\n    rootNode.children.push(new xml.CR());\n\n    return xml.serialize([\n      new xml.Declaration({version: '1.0', encoding: 'UTF-8'}),\n      new xml.CR(),\n      new xml.Doctype(_MESSAGES_TAG, _DOCTYPE),\n      new xml.CR(),\n      exampleVisitor.addDefaultExamples(rootNode),\n      new xml.CR(),\n    ]);\n  }\n\n  override load(content: string, url: string):\n      {locale: string, i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}} {\n    throw new Error('Unsupported');\n  }\n\n  override digest(message: i18n.Message): string {\n    return digest(message);\n  }\n\n\n  override createNameMapper(message: i18n.Message): PlaceholderMapper {\n    return new SimplePlaceholderMapper(message, toPublicName);\n  }\n}\n\nclass _Visitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context?: any): xml.Node[] {\n    return [new xml.Text(text.value)];\n  }\n\n  visitContainer(container: i18n.Container, context: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const startTagAsText = new xml.Text(`<${ph.tag}>`);\n    const startEx = new xml.Tag(_EXAMPLE_TAG, {}, [startTagAsText]);\n    // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n    const startTagPh =\n        new xml.Tag(_PLACEHOLDER_TAG, {name: ph.startName}, [startEx, startTagAsText]);\n    if (ph.isVoid) {\n      // void tags have no children nor closing tags\n      return [startTagPh];\n    }\n\n    const closeTagAsText = new xml.Text(`</${ph.tag}>`);\n    const closeEx = new xml.Tag(_EXAMPLE_TAG, {}, [closeTagAsText]);\n    // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n    const closeTagPh =\n        new xml.Tag(_PLACEHOLDER_TAG, {name: ph.closeName}, [closeEx, closeTagAsText]);\n\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    const interpolationAsText = new xml.Text(`{{${ph.value}}}`);\n    // Example tag needs to be not-empty for TC.\n    const exTag = new xml.Tag(_EXAMPLE_TAG, {}, [interpolationAsText]);\n    return [\n      // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n      new xml.Tag(_PLACEHOLDER_TAG, {name: ph.name}, [exTag, interpolationAsText])\n    ];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const icuExpression = ph.value.expression;\n    const icuType = ph.value.type;\n    const icuCases = Object.keys(ph.value.cases).map((value: string) => value + ' {...}').join(' ');\n    const icuAsText = new xml.Text(`{${icuExpression}, ${icuType}, ${icuCases}}`);\n    const exTag = new xml.Tag(_EXAMPLE_TAG, {}, [icuAsText]);\n    return [\n      // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n      new xml.Tag(_PLACEHOLDER_TAG, {name: ph.name}, [exTag, icuAsText])\n    ];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\n\nexport function digest(message: i18n.Message): string {\n  return decimalDigest(message);\n}\n\n// TC requires at least one non-empty example on placeholders\nclass ExampleVisitor implements xml.IVisitor {\n  addDefaultExamples(node: xml.Node): xml.Node {\n    node.visit(this);\n    return node;\n  }\n\n  visitTag(tag: xml.Tag): void {\n    if (tag.name === _PLACEHOLDER_TAG) {\n      if (!tag.children || tag.children.length == 0) {\n        const exText = new xml.Text(tag.attrs['name'] || '...');\n        tag.children = [new xml.Tag(_EXAMPLE_TAG, {}, [exText])];\n      }\n    } else if (tag.children) {\n      tag.children.forEach(node => node.visit(this));\n    }\n  }\n\n  visitText(text: xml.Text): void {}\n  visitDeclaration(decl: xml.Declaration): void {}\n  visitDoctype(doctype: xml.Doctype): void {}\n}\n\n// XMB/XTB placeholders can only contain A-Z, 0-9 and _\nexport function toPublicName(internalName: string): string {\n  return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as i18n from '../../../i18n/i18n_ast';\nimport {toPublicName} from '../../../i18n/serializers/xmb';\nimport * as html from '../../../ml_parser/ast';\nimport * as o from '../../../output/output_ast';\nimport * as t from '../../r3_ast';\n\n/* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */\nconst CLOSURE_TRANSLATION_VAR_PREFIX = 'MSG_';\n\n/**\n * Prefix for non-`goog.getMsg` i18n-related vars.\n * Note: the prefix uses lowercase characters intentionally due to a Closure behavior that\n * considers variables like `I18N_0` as constants and throws an error when their value changes.\n */\nexport const TRANSLATION_VAR_PREFIX = 'i18n_';\n\n/** Name of the i18n attributes **/\nexport const I18N_ATTR = 'i18n';\nexport const I18N_ATTR_PREFIX = 'i18n-';\n\n/** Prefix of var expressions used in ICUs */\nexport const I18N_ICU_VAR_PREFIX = 'VAR_';\n\n/** Prefix of ICU expressions for post processing */\nexport const I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\n\n/** Placeholder wrapper for i18n expressions **/\nexport const I18N_PLACEHOLDER_SYMBOL = '\uFFFD';\n\nexport function isI18nAttribute(name: string): boolean {\n  return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);\n}\n\nexport function isI18nRootNode(meta?: i18n.I18nMeta): meta is i18n.Message {\n  return meta instanceof i18n.Message;\n}\n\nexport function isSingleI18nIcu(meta?: i18n.I18nMeta): boolean {\n  return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof i18n.Icu;\n}\n\nexport function hasI18nMeta(node: t.Node&{i18n?: i18n.I18nMeta}): boolean {\n  return !!node.i18n;\n}\n\nexport function hasI18nAttrs(element: html.Element): boolean {\n  return element.attrs.some((attr: html.Attribute) => isI18nAttribute(attr.name));\n}\n\nexport function icuFromI18nMessage(message: i18n.Message) {\n  return message.nodes[0] as i18n.IcuPlaceholder;\n}\n\nexport function wrapI18nPlaceholder(content: string|number, contextId: number = 0): string {\n  const blockId = contextId > 0 ? `:${contextId}` : '';\n  return `${I18N_PLACEHOLDER_SYMBOL}${content}${blockId}${I18N_PLACEHOLDER_SYMBOL}`;\n}\n\nexport function assembleI18nBoundString(\n    strings: string[], bindingStartIndex: number = 0, contextId: number = 0): string {\n  if (!strings.length) return '';\n  let acc = '';\n  const lastIdx = strings.length - 1;\n  for (let i = 0; i < lastIdx; i++) {\n    acc += `${strings[i]}${wrapI18nPlaceholder(bindingStartIndex + i, contextId)}`;\n  }\n  acc += strings[lastIdx];\n  return acc;\n}\n\nexport function getSeqNumberGenerator(startsAt: number = 0): () => number {\n  let current = startsAt;\n  return () => current++;\n}\n\nexport function placeholdersToParams(placeholders: Map<string, string[]>):\n    {[name: string]: o.LiteralExpr} {\n  const params: {[name: string]: o.LiteralExpr} = {};\n  placeholders.forEach((values: string[], key: string) => {\n    params[key] = o.literal(values.length > 1 ? `[${values.join('|')}]` : values[0]);\n  });\n  return params;\n}\n\nexport function updatePlaceholderMap(map: Map<string, any[]>, name: string, ...values: any[]) {\n  const current = map.get(name) || [];\n  current.push(...values);\n  map.set(name, current);\n}\n\nexport function assembleBoundTextPlaceholders(\n    meta: i18n.I18nMeta, bindingStartIndex: number = 0, contextId: number = 0): Map<string, any[]> {\n  const startIdx = bindingStartIndex;\n  const placeholders = new Map<string, any>();\n  const node =\n      meta instanceof i18n.Message ? meta.nodes.find(node => node instanceof i18n.Container) : meta;\n  if (node) {\n    (node as i18n.Container)\n        .children\n        .filter((child: i18n.Node): child is i18n.Placeholder => child instanceof i18n.Placeholder)\n        .forEach((child: i18n.Placeholder, idx: number) => {\n          const content = wrapI18nPlaceholder(startIdx + idx, contextId);\n          updatePlaceholderMap(placeholders, child.name, content);\n        });\n  }\n  return placeholders;\n}\n\n/**\n * Format the placeholder names in a map of placeholders to expressions.\n *\n * The placeholder names are converted from \"internal\" format (e.g. `START_TAG_DIV_1`) to \"external\"\n * format (e.g. `startTagDiv_1`).\n *\n * @param params A map of placeholder names to expressions.\n * @param useCamelCase whether to camelCase the placeholder name when formatting.\n * @returns A new map of formatted placeholder names to expressions.\n */\nexport function formatI18nPlaceholderNamesInMap(\n    params: {[name: string]: o.Expression} = {}, useCamelCase: boolean) {\n  const _params: {[key: string]: o.Expression} = {};\n  if (params && Object.keys(params).length) {\n    Object.keys(params).forEach(\n        key => _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]);\n  }\n  return _params;\n}\n\n/**\n * Converts internal placeholder names to public-facing format\n * (for example to use in goog.getMsg call).\n * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.\n *\n * @param name The placeholder name that should be formatted\n * @returns Formatted placeholder name\n */\nexport function formatI18nPlaceholderName(name: string, useCamelCase: boolean = true): string {\n  const publicName = toPublicName(name);\n  if (!useCamelCase) {\n    return publicName;\n  }\n  const chunks = publicName.split('_');\n  if (chunks.length === 1) {\n    // if no \"_\" found - just lowercase the value\n    return name.toLowerCase();\n  }\n  let postfix;\n  // eject last element if it's a number\n  if (/^\\d+$/.test(chunks[chunks.length - 1])) {\n    postfix = chunks.pop();\n  }\n  let raw = chunks.shift()!.toLowerCase();\n  if (chunks.length) {\n    raw += chunks.map(c => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join('');\n  }\n  return postfix ? `${raw}_${postfix}` : raw;\n}\n\n/**\n * Generates a prefix for translation const name.\n *\n * @param extra Additional local prefix that should be injected into translation var name\n * @returns Complete translation const prefix\n */\nexport function getTranslationConstPrefix(extra: string): string {\n  return `${CLOSURE_TRANSLATION_VAR_PREFIX}${extra}`.toUpperCase();\n}\n\n/**\n * Generate AST to declare a variable. E.g. `var I18N_1;`.\n * @param variable the name of the variable to declare.\n */\nexport function declareI18nVariable(variable: o.ReadVarExpr): o.Statement {\n  return new o.DeclareVarStmt(\n      variable.name!, undefined, o.INFERRED_TYPE, undefined, variable.sourceSpan);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool} from '../../constant_pool';\nimport {Interpolation} from '../../expression_parser/ast';\nimport * as o from '../../output/output_ast';\nimport {ParseSourceSpan} from '../../parse_util';\nimport {splitAtColon} from '../../util';\nimport * as t from '../r3_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {ForwardRefHandling} from '../util';\n\nimport {R3QueryMetadata} from './api';\nimport {isI18nAttribute} from './i18n/util';\n\n\n/**\n * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in\n * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may\n * bot work in some cases when object keys are mangled by minifier.\n *\n * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with\n * inputs that contain potentially unsafe chars.\n */\nconst UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;\n\n/** Name of the temporary to use during data binding */\nexport const TEMPORARY_NAME = '_t';\n\n/** Name of the context parameter passed into a template function */\nexport const CONTEXT_NAME = 'ctx';\n\n/** Name of the RenderFlag passed into a template function */\nexport const RENDER_FLAGS = 'rf';\n\n/** The prefix reference variables */\nexport const REFERENCE_PREFIX = '_r';\n\n/** The name of the implicit context reference */\nexport const IMPLICIT_REFERENCE = '$implicit';\n\n/** Non bindable attribute name **/\nexport const NON_BINDABLE_ATTR = 'ngNonBindable';\n\n/** Name for the variable keeping track of the context returned by `\u0275\u0275restoreView`. */\nexport const RESTORED_VIEW_CONTEXT_NAME = 'restoredCtx';\n\n/**\n * Maximum length of a single instruction chain. Because our output AST uses recursion, we're\n * limited in how many expressions we can nest before we reach the call stack limit. This\n * length is set very conservatively in order to reduce the chance of problems.\n */\nconst MAX_CHAIN_LENGTH = 500;\n\n/** Instructions that support chaining. */\nconst CHAINABLE_INSTRUCTIONS = new Set([\n  R3.element,\n  R3.elementStart,\n  R3.elementEnd,\n  R3.elementContainer,\n  R3.elementContainerStart,\n  R3.elementContainerEnd,\n  R3.i18nExp,\n  R3.listener,\n  R3.classProp,\n  R3.syntheticHostListener,\n  R3.hostProperty,\n  R3.syntheticHostProperty,\n  R3.property,\n  R3.propertyInterpolate1,\n  R3.propertyInterpolate2,\n  R3.propertyInterpolate3,\n  R3.propertyInterpolate4,\n  R3.propertyInterpolate5,\n  R3.propertyInterpolate6,\n  R3.propertyInterpolate7,\n  R3.propertyInterpolate8,\n  R3.propertyInterpolateV,\n  R3.attribute,\n  R3.attributeInterpolate1,\n  R3.attributeInterpolate2,\n  R3.attributeInterpolate3,\n  R3.attributeInterpolate4,\n  R3.attributeInterpolate5,\n  R3.attributeInterpolate6,\n  R3.attributeInterpolate7,\n  R3.attributeInterpolate8,\n  R3.attributeInterpolateV,\n  R3.styleProp,\n  R3.stylePropInterpolate1,\n  R3.stylePropInterpolate2,\n  R3.stylePropInterpolate3,\n  R3.stylePropInterpolate4,\n  R3.stylePropInterpolate5,\n  R3.stylePropInterpolate6,\n  R3.stylePropInterpolate7,\n  R3.stylePropInterpolate8,\n  R3.stylePropInterpolateV,\n  R3.textInterpolate,\n  R3.textInterpolate1,\n  R3.textInterpolate2,\n  R3.textInterpolate3,\n  R3.textInterpolate4,\n  R3.textInterpolate5,\n  R3.textInterpolate6,\n  R3.textInterpolate7,\n  R3.textInterpolate8,\n  R3.textInterpolateV,\n]);\n\n/**\n * Possible types that can be used to generate the parameters of an instruction call.\n * If the parameters are a function, the function will be invoked at the time the instruction\n * is generated.\n */\nexport type InstructionParams = (o.Expression|o.Expression[])|(() => (o.Expression|o.Expression[]));\n\n/** Necessary information to generate a call to an instruction function. */\nexport interface Instruction {\n  span: ParseSourceSpan|null;\n  reference: o.ExternalReference;\n  paramsOrFn?: InstructionParams;\n}\n\n/** Generates a call to a single instruction. */\nexport function invokeInstruction(\n    span: ParseSourceSpan|null, reference: o.ExternalReference,\n    params: o.Expression[]): o.Expression {\n  return o.importExpr(reference, null, span).callFn(params, span);\n}\n\n/**\n * Creates an allocator for a temporary variable.\n *\n * A variable declaration is added to the statements the first time the allocator is invoked.\n */\nexport function temporaryAllocator(statements: o.Statement[], name: string): () => o.ReadVarExpr {\n  let temp: o.ReadVarExpr|null = null;\n  return () => {\n    if (!temp) {\n      statements.push(new o.DeclareVarStmt(TEMPORARY_NAME, undefined, o.DYNAMIC_TYPE));\n      temp = o.variable(name);\n    }\n    return temp;\n  };\n}\n\n\nexport function invalid<T>(this: t.Visitor, arg: o.Expression|o.Statement|t.Node): never {\n  throw new Error(\n      `Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\n\nexport function asLiteral(value: any): o.Expression {\n  if (Array.isArray(value)) {\n    return o.literalArr(value.map(asLiteral));\n  }\n  return o.literal(value, o.INFERRED_TYPE);\n}\n\nexport function conditionallyCreateMapObjectLiteral(\n    keys: {[key: string]: string|string[]}, keepDeclared?: boolean): o.Expression|null {\n  if (Object.getOwnPropertyNames(keys).length > 0) {\n    return mapToExpression(keys, keepDeclared);\n  }\n  return null;\n}\n\nfunction mapToExpression(\n    map: {[key: string]: string|string[]}, keepDeclared?: boolean): o.Expression {\n  return o.literalMap(Object.getOwnPropertyNames(map).map(key => {\n    // canonical syntax: `dirProp: publicProp`\n    const value = map[key];\n    let declaredName: string;\n    let publicName: string;\n    let minifiedName: string;\n    let needsDeclaredName: boolean;\n    if (Array.isArray(value)) {\n      [publicName, declaredName] = value;\n      minifiedName = key;\n      needsDeclaredName = publicName !== declaredName;\n    } else {\n      minifiedName = declaredName = key;\n      publicName = value;\n      needsDeclaredName = false;\n    }\n    return {\n      key: minifiedName,\n      // put quotes around keys that contain potentially unsafe characters\n      quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),\n      value: (keepDeclared && needsDeclaredName) ?\n          o.literalArr([asLiteral(publicName), asLiteral(declaredName)]) :\n          asLiteral(publicName)\n    };\n  }));\n}\n\n/**\n *  Remove trailing null nodes as they are implied.\n */\nexport function trimTrailingNulls(parameters: o.Expression[]): o.Expression[] {\n  while (o.isNull(parameters[parameters.length - 1])) {\n    parameters.pop();\n  }\n  return parameters;\n}\n\nexport function getQueryPredicate(\n    query: R3QueryMetadata, constantPool: ConstantPool): o.Expression {\n  if (Array.isArray(query.predicate)) {\n    let predicate: o.Expression[] = [];\n    query.predicate.forEach((selector: string): void => {\n      // Each item in predicates array may contain strings with comma-separated refs\n      // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them\n      // as separate array entities\n      const selectors = selector.split(',').map(token => o.literal(token.trim()));\n      predicate.push(...selectors);\n    });\n    return constantPool.getConstLiteral(o.literalArr(predicate), true);\n  } else {\n    // The original predicate may have been wrapped in a `forwardRef()` call.\n    switch (query.predicate.forwardRef) {\n      case ForwardRefHandling.None:\n      case ForwardRefHandling.Unwrapped:\n        return query.predicate.expression;\n      case ForwardRefHandling.Wrapped:\n        return o.importExpr(R3.resolveForwardRef).callFn([query.predicate.expression]);\n    }\n  }\n}\n\n/**\n * A representation for an object literal used during codegen of definition objects. The generic\n * type `T` allows to reference a documented type of the generated structure, such that the\n * property names that are set can be resolved to their documented declaration.\n */\nexport class DefinitionMap<T = any> {\n  values: {key: string, quoted: boolean, value: o.Expression}[] = [];\n\n  set(key: keyof T, value: o.Expression|null): void {\n    if (value) {\n      this.values.push({key: key as string, value, quoted: false});\n    }\n  }\n\n  toLiteralMap(): o.LiteralMapExpr {\n    return o.literalMap(this.values);\n  }\n}\n\n/**\n * Extract a map of properties to values for a given element or template node, which can be used\n * by the directive matching machinery.\n *\n * @param elOrTpl the element or template in question\n * @return an object set up for directive matching. For attributes on the element/template, this\n * object maps a property name to its (static) value. For any bindings, this map simply maps the\n * property name to an empty string.\n */\nexport function getAttrsForDirectiveMatching(elOrTpl: t.Element|\n                                             t.Template): {[name: string]: string} {\n  const attributesMap: {[name: string]: string} = {};\n\n\n  if (elOrTpl instanceof t.Template && elOrTpl.tagName !== 'ng-template') {\n    elOrTpl.templateAttrs.forEach(a => attributesMap[a.name] = '');\n  } else {\n    elOrTpl.attributes.forEach(a => {\n      if (!isI18nAttribute(a.name)) {\n        attributesMap[a.name] = a.value;\n      }\n    });\n\n    elOrTpl.inputs.forEach(i => {\n      attributesMap[i.name] = '';\n    });\n    elOrTpl.outputs.forEach(o => {\n      attributesMap[o.name] = '';\n    });\n  }\n\n  return attributesMap;\n}\n\n/**\n * Gets the number of arguments expected to be passed to a generated instruction in the case of\n * interpolation instructions.\n * @param interpolation An interpolation ast\n */\nexport function getInterpolationArgsLength(interpolation: Interpolation) {\n  const {expressions, strings} = interpolation;\n  if (expressions.length === 1 && strings.length === 2 && strings[0] === '' && strings[1] === '') {\n    // If the interpolation has one interpolated value, but the prefix and suffix are both empty\n    // strings, we only pass one argument, to a special instruction like `propertyInterpolate` or\n    // `textInterpolate`.\n    return 1;\n  } else {\n    return expressions.length + strings.length;\n  }\n}\n\n/**\n * Generates the final instruction call statements based on the passed in configuration.\n * Will try to chain instructions as much as possible, if chaining is supported.\n */\nexport function getInstructionStatements(instructions: Instruction[]): o.Statement[] {\n  const statements: o.Statement[] = [];\n  let pendingExpression: o.Expression|null = null;\n  let pendingExpressionType: o.ExternalReference|null = null;\n  let chainLength = 0;\n\n  for (const current of instructions) {\n    const resolvedParams =\n        (typeof current.paramsOrFn === 'function' ? current.paramsOrFn() : current.paramsOrFn) ??\n        [];\n    const params = Array.isArray(resolvedParams) ? resolvedParams : [resolvedParams];\n\n    // If the current instruction is the same as the previous one\n    // and it can be chained, add another call to the chain.\n    if (chainLength < MAX_CHAIN_LENGTH && pendingExpressionType === current.reference &&\n        CHAINABLE_INSTRUCTIONS.has(pendingExpressionType)) {\n      // We'll always have a pending expression when there's a pending expression type.\n      pendingExpression = pendingExpression!.callFn(params, pendingExpression!.sourceSpan);\n      chainLength++;\n    } else {\n      if (pendingExpression !== null) {\n        statements.push(pendingExpression.toStmt());\n      }\n      pendingExpression = invokeInstruction(current.span, current.reference, params);\n      pendingExpressionType = current.reference;\n      chainLength = 0;\n    }\n  }\n\n  // Since the current instruction adds the previous one to the statements,\n  // we may be left with the final one at the end that is still pending.\n  if (pendingExpression !== null) {\n    statements.push(pendingExpression.toStmt());\n  }\n\n  return statements;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from './output/output_ast';\nimport {compileFactoryFunction, FactoryTarget, R3DependencyMetadata, R3FactoryDelegateType, R3FactoryMetadata} from './render3/r3_factory';\nimport {Identifiers} from './render3/r3_identifiers';\nimport {convertFromMaybeForwardRefExpression, ForwardRefHandling, generateForwardRef, MaybeForwardRefExpression, R3CompiledExpression, R3Reference, typeWithParameters} from './render3/util';\nimport {DefinitionMap} from './render3/view/util';\n\nexport interface R3InjectableMetadata {\n  name: string;\n  type: R3Reference;\n  internalType: o.Expression;\n  typeArgumentCount: number;\n  providedIn: MaybeForwardRefExpression;\n  useClass?: MaybeForwardRefExpression;\n  useFactory?: o.Expression;\n  useExisting?: MaybeForwardRefExpression;\n  useValue?: MaybeForwardRefExpression;\n  deps?: R3DependencyMetadata[];\n}\n\nexport function compileInjectable(\n    meta: R3InjectableMetadata, resolveForwardRefs: boolean): R3CompiledExpression {\n  let result: {expression: o.Expression, statements: o.Statement[]}|null = null;\n\n  const factoryMeta: R3FactoryMetadata = {\n    name: meta.name,\n    type: meta.type,\n    internalType: meta.internalType,\n    typeArgumentCount: meta.typeArgumentCount,\n    deps: [],\n    target: FactoryTarget.Injectable,\n  };\n\n  if (meta.useClass !== undefined) {\n    // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is\n    // used to instantiate the class with dependencies injected, or deps are not specified and\n    // the factory of the class is used to instantiate it.\n    //\n    // A special case exists for useClass: Type where Type is the injectable type itself and no\n    // deps are specified, in which case 'useClass' is effectively ignored.\n\n    const useClassOnSelf = meta.useClass.expression.isEquivalent(meta.internalType);\n    let deps: R3DependencyMetadata[]|undefined = undefined;\n    if (meta.deps !== undefined) {\n      deps = meta.deps;\n    }\n\n    if (deps !== undefined) {\n      // factory: () => new meta.useClass(...deps)\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useClass.expression,\n        delegateDeps: deps,\n        delegateType: R3FactoryDelegateType.Class,\n      });\n    } else if (useClassOnSelf) {\n      result = compileFactoryFunction(factoryMeta);\n    } else {\n      result = {\n        statements: [],\n        expression: delegateToFactory(\n            meta.type.value as o.WrappedNodeExpr<any>,\n            meta.useClass.expression as o.WrappedNodeExpr<any>, resolveForwardRefs)\n      };\n    }\n  } else if (meta.useFactory !== undefined) {\n    if (meta.deps !== undefined) {\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useFactory,\n        delegateDeps: meta.deps || [],\n        delegateType: R3FactoryDelegateType.Function,\n      });\n    } else {\n      result = {\n        statements: [],\n        expression: o.fn([], [new o.ReturnStatement(meta.useFactory.callFn([]))])\n      };\n    }\n  } else if (meta.useValue !== undefined) {\n    // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for\n    // client code because meta.useValue is an Expression which will be defined even if the actual\n    // value is undefined.\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: meta.useValue.expression,\n    });\n  } else if (meta.useExisting !== undefined) {\n    // useExisting is an `inject` call on the existing token.\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: o.importExpr(Identifiers.inject).callFn([meta.useExisting.expression]),\n    });\n  } else {\n    result = {\n      statements: [],\n      expression: delegateToFactory(\n          meta.type.value as o.WrappedNodeExpr<any>, meta.internalType as o.WrappedNodeExpr<any>,\n          resolveForwardRefs)\n    };\n  }\n\n  const token = meta.internalType;\n\n  const injectableProps =\n      new DefinitionMap<{token: o.Expression, factory: o.Expression, providedIn: o.Expression}>();\n  injectableProps.set('token', token);\n  injectableProps.set('factory', result.expression);\n\n  // Only generate providedIn property if it has a non-null value\n  if ((meta.providedIn.expression as o.LiteralExpr).value !== null) {\n    injectableProps.set('providedIn', convertFromMaybeForwardRefExpression(meta.providedIn));\n  }\n\n  const expression = o.importExpr(Identifiers.\u0275\u0275defineInjectable)\n                         .callFn([injectableProps.toLiteralMap()], undefined, true);\n  return {\n    expression,\n    type: createInjectableType(meta),\n    statements: result.statements,\n  };\n}\n\nexport function createInjectableType(meta: R3InjectableMetadata) {\n  return new o.ExpressionType(o.importExpr(\n      Identifiers.InjectableDeclaration,\n      [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));\n}\n\nfunction delegateToFactory(\n    type: o.WrappedNodeExpr<any>, internalType: o.WrappedNodeExpr<any>,\n    unwrapForwardRefs: boolean): o.Expression {\n  if (type.node === internalType.node) {\n    // The types are the same, so we can simply delegate directly to the type's factory.\n    // ```\n    // factory: type.\u0275fac\n    // ```\n    return internalType.prop('\u0275fac');\n  }\n\n  if (!unwrapForwardRefs) {\n    // The type is not wrapped in a `forwardRef()`, so we create a simple factory function that\n    // accepts a sub-type as an argument.\n    // ```\n    // factory: function(t) { return internalType.\u0275fac(t); }\n    // ```\n    return createFactoryFunction(internalType);\n  }\n\n  // The internalType is actually wrapped in a `forwardRef()` so we need to resolve that before\n  // calling its factory.\n  // ```\n  // factory: function(t) { return core.resolveForwardRef(type).\u0275fac(t); }\n  // ```\n  const unwrappedType = o.importExpr(Identifiers.resolveForwardRef).callFn([internalType]);\n  return createFactoryFunction(unwrappedType);\n}\n\nfunction createFactoryFunction(type: o.Expression): o.FunctionExpr {\n  return o.fn(\n      [new o.FnParam('t', o.DYNAMIC_TYPE)],\n      [new o.ReturnStatement(type.prop('\u0275fac').callFn([o.variable('t')]))]);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst UNUSABLE_INTERPOLATION_REGEXPS = [\n  /^\\s*$/,        // empty\n  /[<>]/,         // html tag\n  /^[{}]$/,       // i18n expansion\n  /&(#|[a-z])/i,  // character reference,\n  /^\\/\\//,        // comment\n];\n\nexport function assertInterpolationSymbols(identifier: string, value: any): void {\n  if (value != null && !(Array.isArray(value) && value.length == 2)) {\n    throw new Error(`Expected '${identifier}' to be an array, [start, end].`);\n  } else if (value != null) {\n    const start = value[0] as string;\n    const end = value[1] as string;\n    // Check for unusable interpolation symbols\n    UNUSABLE_INTERPOLATION_REGEXPS.forEach(regexp => {\n      if (regexp.test(start) || regexp.test(end)) {\n        throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);\n      }\n    });\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertInterpolationSymbols} from '../assertions';\n\nexport class InterpolationConfig {\n  static fromArray(markers: [string, string]|null): InterpolationConfig {\n    if (!markers) {\n      return DEFAULT_INTERPOLATION_CONFIG;\n    }\n\n    assertInterpolationSymbols('interpolation', markers);\n    return new InterpolationConfig(markers[0], markers[1]);\n  }\n\n  constructor(public start: string, public end: string) {}\n}\n\nexport const DEFAULT_INTERPOLATION_CONFIG: InterpolationConfig =\n    new InterpolationConfig('{{', '}}');\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const $EOF = 0;\nexport const $BSPACE = 8;\nexport const $TAB = 9;\nexport const $LF = 10;\nexport const $VTAB = 11;\nexport const $FF = 12;\nexport const $CR = 13;\nexport const $SPACE = 32;\nexport const $BANG = 33;\nexport const $DQ = 34;\nexport const $HASH = 35;\nexport const $$ = 36;\nexport const $PERCENT = 37;\nexport const $AMPERSAND = 38;\nexport const $SQ = 39;\nexport const $LPAREN = 40;\nexport const $RPAREN = 41;\nexport const $STAR = 42;\nexport const $PLUS = 43;\nexport const $COMMA = 44;\nexport const $MINUS = 45;\nexport const $PERIOD = 46;\nexport const $SLASH = 47;\nexport const $COLON = 58;\nexport const $SEMICOLON = 59;\nexport const $LT = 60;\nexport const $EQ = 61;\nexport const $GT = 62;\nexport const $QUESTION = 63;\n\nexport const $0 = 48;\nexport const $7 = 55;\nexport const $9 = 57;\n\nexport const $A = 65;\nexport const $E = 69;\nexport const $F = 70;\nexport const $X = 88;\nexport const $Z = 90;\n\nexport const $LBRACKET = 91;\nexport const $BACKSLASH = 92;\nexport const $RBRACKET = 93;\nexport const $CARET = 94;\nexport const $_ = 95;\n\nexport const $a = 97;\nexport const $b = 98;\nexport const $e = 101;\nexport const $f = 102;\nexport const $n = 110;\nexport const $r = 114;\nexport const $t = 116;\nexport const $u = 117;\nexport const $v = 118;\nexport const $x = 120;\nexport const $z = 122;\n\nexport const $LBRACE = 123;\nexport const $BAR = 124;\nexport const $RBRACE = 125;\nexport const $NBSP = 160;\n\nexport const $PIPE = 124;\nexport const $TILDA = 126;\nexport const $AT = 64;\n\nexport const $BT = 96;\n\nexport function isWhitespace(code: number): boolean {\n  return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\n\nexport function isDigit(code: number): boolean {\n  return $0 <= code && code <= $9;\n}\n\nexport function isAsciiLetter(code: number): boolean {\n  return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\n\nexport function isAsciiHexDigit(code: number): boolean {\n  return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\n\nexport function isNewLine(code: number): boolean {\n  return code === $LF || code === $CR;\n}\n\nexport function isOctalDigit(code: number): boolean {\n  return $0 <= code && code <= $7;\n}\n\nexport function isQuote(code: number): boolean {\n  return code === $SQ || code === $DQ || code === $BT;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as chars from './chars';\nimport {stringify} from './util';\n\nexport class ParseLocation {\n  constructor(\n      public file: ParseSourceFile, public offset: number, public line: number,\n      public col: number) {}\n\n  toString(): string {\n    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;\n  }\n\n  moveBy(delta: number): ParseLocation {\n    const source = this.file.content;\n    const len = source.length;\n    let offset = this.offset;\n    let line = this.line;\n    let col = this.col;\n    while (offset > 0 && delta < 0) {\n      offset--;\n      delta++;\n      const ch = source.charCodeAt(offset);\n      if (ch == chars.$LF) {\n        line--;\n        const priorLine =\n            source.substring(0, offset - 1).lastIndexOf(String.fromCharCode(chars.$LF));\n        col = priorLine > 0 ? offset - priorLine : offset;\n      } else {\n        col--;\n      }\n    }\n    while (offset < len && delta > 0) {\n      const ch = source.charCodeAt(offset);\n      offset++;\n      delta--;\n      if (ch == chars.$LF) {\n        line++;\n        col = 0;\n      } else {\n        col++;\n      }\n    }\n    return new ParseLocation(this.file, offset, line, col);\n  }\n\n  // Return the source around the location\n  // Up to `maxChars` or `maxLines` on each side of the location\n  getContext(maxChars: number, maxLines: number): {before: string, after: string}|null {\n    const content = this.file.content;\n    let startOffset = this.offset;\n\n    if (startOffset != null) {\n      if (startOffset > content.length - 1) {\n        startOffset = content.length - 1;\n      }\n      let endOffset = startOffset;\n      let ctxChars = 0;\n      let ctxLines = 0;\n\n      while (ctxChars < maxChars && startOffset > 0) {\n        startOffset--;\n        ctxChars++;\n        if (content[startOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n\n      ctxChars = 0;\n      ctxLines = 0;\n      while (ctxChars < maxChars && endOffset < content.length - 1) {\n        endOffset++;\n        ctxChars++;\n        if (content[endOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n\n      return {\n        before: content.substring(startOffset, this.offset),\n        after: content.substring(this.offset, endOffset + 1),\n      };\n    }\n\n    return null;\n  }\n}\n\nexport class ParseSourceFile {\n  constructor(public content: string, public url: string) {}\n}\n\nexport class ParseSourceSpan {\n  /**\n   * Create an object that holds information about spans of tokens/nodes captured during\n   * lexing/parsing of text.\n   *\n   * @param start\n   * The location of the start of the span (having skipped leading trivia).\n   * Skipping leading trivia makes source-spans more \"user friendly\", since things like HTML\n   * elements will appear to begin at the start of the opening tag, rather than at the start of any\n   * leading trivia, which could include newlines.\n   *\n   * @param end\n   * The location of the end of the span.\n   *\n   * @param fullStart\n   * The start of the token without skipping the leading trivia.\n   * This is used by tooling that splits tokens further, such as extracting Angular interpolations\n   * from text tokens. Such tooling creates new source-spans relative to the original token's\n   * source-span. If leading trivia characters have been skipped then the new source-spans may be\n   * incorrectly offset.\n   *\n   * @param details\n   * Additional information (such as identifier names) that should be associated with the span.\n   */\n  constructor(\n      public start: ParseLocation, public end: ParseLocation,\n      public fullStart: ParseLocation = start, public details: string|null = null) {}\n\n  toString(): string {\n    return this.start.file.content.substring(this.start.offset, this.end.offset);\n  }\n}\n\nexport enum ParseErrorLevel {\n  WARNING,\n  ERROR,\n}\n\nexport class ParseError {\n  constructor(\n      public span: ParseSourceSpan, public msg: string,\n      public level: ParseErrorLevel = ParseErrorLevel.ERROR) {}\n\n  contextualMessage(): string {\n    const ctx = this.span.start.getContext(100, 3);\n    return ctx ? `${this.msg} (\"${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}\")` :\n                 this.msg;\n  }\n\n  toString(): string {\n    const details = this.span.details ? `, ${this.span.details}` : '';\n    return `${this.contextualMessage()}: ${this.span.start}${details}`;\n  }\n}\n\n/**\n * Generates Source Span object for a given R3 Type for JIT mode.\n *\n * @param kind Component or Directive.\n * @param typeName name of the Component or Directive.\n * @param sourceUrl reference to Component or Directive source.\n * @returns instance of ParseSourceSpan that represent a given Component or Directive.\n */\nexport function r3JitTypeSourceSpan(\n    kind: string, typeName: string, sourceUrl: string): ParseSourceSpan {\n  const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;\n  const sourceFile = new ParseSourceFile('', sourceFileName);\n  return new ParseSourceSpan(\n      new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\n\nlet _anonymousTypeIndex = 0;\n\nexport function identifierName(compileIdentifier: CompileIdentifierMetadata|null|undefined): string|\n    null {\n  if (!compileIdentifier || !compileIdentifier.reference) {\n    return null;\n  }\n  const ref = compileIdentifier.reference;\n  if (ref['__anonymousType']) {\n    return ref['__anonymousType'];\n  }\n  if (ref['__forward_ref__']) {\n    // We do not want to try to stringify a `forwardRef()` function because that would cause the\n    // inner function to be evaluated too early, defeating the whole point of the `forwardRef`.\n    return '__forward_ref__';\n  }\n  let identifier = stringify(ref);\n  if (identifier.indexOf('(') >= 0) {\n    // case: anonymous functions!\n    identifier = `anonymous_${_anonymousTypeIndex++}`;\n    ref['__anonymousType'] = identifier;\n  } else {\n    identifier = sanitizeIdentifier(identifier);\n  }\n  return identifier;\n}\n\nexport interface CompileIdentifierMetadata {\n  reference: any;\n}\n\nexport function sanitizeIdentifier(name: string): string {\n  return name.replace(/\\W/g, '_');\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {AbstractEmitterVisitor, EmitterVisitorContext, escapeIdentifier} from './abstract_emitter';\nimport * as o from './output_ast';\n\n/**\n * In TypeScript, tagged template functions expect a \"template object\", which is an array of\n * \"cooked\" strings plus a `raw` property that contains an array of \"raw\" strings. This is\n * typically constructed with a function called `__makeTemplateObject(cooked, raw)`, but it may not\n * be available in all environments.\n *\n * This is a JavaScript polyfill that uses __makeTemplateObject when it's available, but otherwise\n * creates an inline helper with the same functionality.\n *\n * In the inline function, if `Object.defineProperty` is available we use that to attach the `raw`\n * array.\n */\nconst makeTemplateObjectPolyfill =\n    '(this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,\"raw\",{value:t}):e.raw=t,e})';\n\nexport abstract class AbstractJsEmitterVisitor extends AbstractEmitterVisitor {\n  constructor() {\n    super(false);\n  }\n\n  override visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');\n  }\n\n  override visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `var ${stmt.name}`);\n    if (stmt.value) {\n      ctx.print(stmt, ' = ');\n      stmt.value.visitExpression(this, ctx);\n    }\n    ctx.println(stmt, `;`);\n    return null;\n  }\n  override visitTaggedTemplateExpr(ast: o.TaggedTemplateExpr, ctx: EmitterVisitorContext): any {\n    // The following convoluted piece of code is effectively the downlevelled equivalent of\n    // ```\n    // tag`...`\n    // ```\n    // which is effectively like:\n    // ```\n    // tag(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n    // ```\n    const elements = ast.template.elements;\n    ast.tag.visitExpression(this, ctx);\n    ctx.print(ast, `(${makeTemplateObjectPolyfill}(`);\n    ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.text, false)).join(', ')}], `);\n    ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.rawText, false)).join(', ')}])`);\n    ast.template.expressions.forEach(expression => {\n      ctx.print(ast, ', ');\n      expression.visitExpression(this, ctx);\n    });\n    ctx.print(ast, ')');\n    return null;\n  }\n  override visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `function${ast.name ? ' ' + ast.name : ''}(`);\n    this._visitParams(ast.params, ctx);\n    ctx.println(ast, `) {`);\n    ctx.incIndent();\n    this.visitAllStatements(ast.statements, ctx);\n    ctx.decIndent();\n    ctx.print(ast, `}`);\n    return null;\n  }\n  override visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `function ${stmt.name}(`);\n    this._visitParams(stmt.params, ctx);\n    ctx.println(stmt, `) {`);\n    ctx.incIndent();\n    this.visitAllStatements(stmt.statements, ctx);\n    ctx.decIndent();\n    ctx.println(stmt, `}`);\n    return null;\n  }\n  override visitLocalizedString(ast: o.LocalizedString, ctx: EmitterVisitorContext): any {\n    // The following convoluted piece of code is effectively the downlevelled equivalent of\n    // ```\n    // $localize `...`\n    // ```\n    // which is effectively like:\n    // ```\n    // $localize(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n    // ```\n    ctx.print(ast, `$localize(${makeTemplateObjectPolyfill}(`);\n    const parts = [ast.serializeI18nHead()];\n    for (let i = 1; i < ast.messageParts.length; i++) {\n      parts.push(ast.serializeI18nTemplatePart(i));\n    }\n    ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.cooked, false)).join(', ')}], `);\n    ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.raw, false)).join(', ')}])`);\n    ast.expressions.forEach(expression => {\n      ctx.print(ast, ', ');\n      expression.visitExpression(this, ctx);\n    });\n    ctx.print(ast, ')');\n    return null;\n  }\n\n  private _visitParams(params: o.FnParam[], ctx: EmitterVisitorContext): void {\n    this.visitAllObjects(param => ctx.print(null, param.name), params, ctx, ',');\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview\n * A module to facilitate use of a Trusted Types policy within the JIT\n * compiler. It lazily constructs the Trusted Types policy, providing helper\n * utilities for promoting strings to Trusted Types. When Trusted Types are not\n * available, strings are used as a fallback.\n * @security All use of this module is security-sensitive and should go through\n * security review.\n */\n\nimport {global} from '../util';\n\n/**\n * While Angular only uses Trusted Types internally for the time being,\n * references to Trusted Types could leak into our core.d.ts, which would force\n * anyone compiling against @angular/core to provide the @types/trusted-types\n * package in their compilation unit.\n *\n * Until https://github.com/microsoft/TypeScript/issues/30024 is resolved, we\n * will keep Angular's public API surface free of references to Trusted Types.\n * For internal and semi-private APIs that need to reference Trusted Types, the\n * minimal type definitions for the Trusted Types API provided by this module\n * should be used instead. They are marked as \"declare\" to prevent them from\n * being renamed by compiler optimization.\n *\n * Adapted from\n * https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/trusted-types/index.d.ts\n * but restricted to the API surface used within Angular.\n */\n\nexport declare interface TrustedScript {\n  __brand__: 'TrustedScript';\n}\n\nexport declare interface TrustedTypePolicyFactory {\n  createPolicy(policyName: string, policyOptions: {\n    createScript?: (input: string) => string,\n  }): TrustedTypePolicy;\n}\n\nexport declare interface TrustedTypePolicy {\n  createScript(input: string): TrustedScript;\n}\n\n\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy: TrustedTypePolicy|null|undefined;\n\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy(): TrustedTypePolicy|null {\n  if (policy === undefined) {\n    policy = null;\n    if (global.trustedTypes) {\n      try {\n        policy =\n            (global.trustedTypes as TrustedTypePolicyFactory).createPolicy('angular#unsafe-jit', {\n              createScript: (s: string) => s,\n            });\n      } catch {\n        // trustedTypes.createPolicy throws if called with a name that is\n        // already registered, even in report-only mode. Until the API changes,\n        // catch the error not to break the applications functionally. In such\n        // cases, the code will fall back to using strings.\n      }\n    }\n  }\n  return policy;\n}\n\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security In particular, it must be assured that the provided string will\n * never cause an XSS vulnerability if used in a context that will be\n * interpreted and executed as a script by a browser, e.g. when calling eval.\n */\nfunction trustedScriptFromString(script: string): TrustedScript|string {\n  return getPolicy()?.createScript(script) || script;\n}\n\n/**\n * Unsafely call the Function constructor with the given string arguments.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only called from the JIT compiler, as use in other code can lead to XSS\n * vulnerabilities.\n */\nexport function newTrustedFunctionForJIT(...args: string[]): Function {\n  if (!global.trustedTypes) {\n    // In environments that don't support Trusted Types, fall back to the most\n    // straightforward implementation:\n    return new Function(...args);\n  }\n\n  // Chrome currently does not support passing TrustedScript to the Function\n  // constructor. The following implements the workaround proposed on the page\n  // below, where the Chromium bug is also referenced:\n  // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n  const fnArgs = args.slice(0, -1).join(',');\n  const fnBody = args[args.length - 1];\n  const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`;\n\n  // Using eval directly confuses the compiler and prevents this module from\n  // being stripped out of JS binaries even if not used. The global['eval']\n  // indirection fixes that.\n  const fn = global['eval'](trustedScriptFromString(body) as string) as Function;\n  if (fn.bind === undefined) {\n    // Workaround for a browser bug that only exists in Chrome 83, where passing\n    // a TrustedScript to eval just returns the TrustedScript back without\n    // evaluating it. In that case, fall back to the most straightforward\n    // implementation:\n    return new Function(...args);\n  }\n\n  // To completely mimic the behavior of calling \"new Function\", two more\n  // things need to happen:\n  // 1. Stringifying the resulting function should return its source code\n  fn.toString = () => body;\n  // 2. When calling the resulting function, `this` should refer to `global`\n  return fn.bind(global);\n\n  // When Trusted Types support in Function constructors is widely available,\n  // the implementation of this function can be simplified to:\n  // return new Function(...args.map(a => trustedScriptFromString(a)));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {identifierName} from '../parse_util';\n\nimport {EmitterVisitorContext} from './abstract_emitter';\nimport {AbstractJsEmitterVisitor} from './abstract_js_emitter';\nimport * as o from './output_ast';\nimport {newTrustedFunctionForJIT} from './output_jit_trusted_types';\n\nexport interface ExternalReferenceResolver {\n  resolveExternalReference(ref: o.ExternalReference): unknown;\n}\n\n/**\n * A helper class to manage the evaluation of JIT generated code.\n */\nexport class JitEvaluator {\n  /**\n   *\n   * @param sourceUrl The URL of the generated code.\n   * @param statements An array of Angular statement AST nodes to be evaluated.\n   * @param refResolver Resolves `o.ExternalReference`s into values.\n   * @param createSourceMaps If true then create a source-map for the generated code and include it\n   * inline as a source-map comment.\n   * @returns A map of all the variables in the generated code.\n   */\n  evaluateStatements(\n      sourceUrl: string, statements: o.Statement[], refResolver: ExternalReferenceResolver,\n      createSourceMaps: boolean): {[key: string]: any} {\n    const converter = new JitEmitterVisitor(refResolver);\n    const ctx = EmitterVisitorContext.createRoot();\n    // Ensure generated code is in strict mode\n    if (statements.length > 0 && !isUseStrictStatement(statements[0])) {\n      statements = [\n        o.literal('use strict').toStmt(),\n        ...statements,\n      ];\n    }\n    converter.visitAllStatements(statements, ctx);\n    converter.createReturnStmt(ctx);\n    return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);\n  }\n\n  /**\n   * Evaluate a piece of JIT generated code.\n   * @param sourceUrl The URL of this generated code.\n   * @param ctx A context object that contains an AST of the code to be evaluated.\n   * @param vars A map containing the names and values of variables that the evaluated code might\n   * reference.\n   * @param createSourceMap If true then create a source-map for the generated code and include it\n   * inline as a source-map comment.\n   * @returns The result of evaluating the code.\n   */\n  evaluateCode(\n      sourceUrl: string, ctx: EmitterVisitorContext, vars: {[key: string]: any},\n      createSourceMap: boolean): any {\n    let fnBody = `\"use strict\";${ctx.toSource()}\\n//# sourceURL=${sourceUrl}`;\n    const fnArgNames: string[] = [];\n    const fnArgValues: any[] = [];\n    for (const argName in vars) {\n      fnArgValues.push(vars[argName]);\n      fnArgNames.push(argName);\n    }\n    if (createSourceMap) {\n      // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\n      // E.g. ```\n      // function anonymous(a,b,c\n      // /**/) { ... }```\n      // We don't want to hard code this fact, so we auto detect it via an empty function first.\n      const emptyFn = newTrustedFunctionForJIT(...fnArgNames.concat('return null;')).toString();\n      const headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n      fnBody += `\\n${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;\n    }\n    const fn = newTrustedFunctionForJIT(...fnArgNames.concat(fnBody));\n    return this.executeFunction(fn, fnArgValues);\n  }\n\n  /**\n   * Execute a JIT generated function by calling it.\n   *\n   * This method can be overridden in tests to capture the functions that are generated\n   * by this `JitEvaluator` class.\n   *\n   * @param fn A function to execute.\n   * @param args The arguments to pass to the function being executed.\n   * @returns The return value of the executed function.\n   */\n  executeFunction(fn: Function, args: any[]) {\n    return fn(...args);\n  }\n}\n\n/**\n * An Angular AST visitor that converts AST nodes into executable JavaScript code.\n */\nexport class JitEmitterVisitor extends AbstractJsEmitterVisitor {\n  private _evalArgNames: string[] = [];\n  private _evalArgValues: any[] = [];\n  private _evalExportedVars: string[] = [];\n\n  constructor(private refResolver: ExternalReferenceResolver) {\n    super();\n  }\n\n  createReturnStmt(ctx: EmitterVisitorContext) {\n    const stmt = new o.ReturnStatement(new o.LiteralMapExpr(this._evalExportedVars.map(\n        resultVar => new o.LiteralMapEntry(resultVar, o.variable(resultVar), false))));\n    stmt.visitStatement(this, ctx);\n  }\n\n  getArgs(): {[key: string]: any} {\n    const result: {[key: string]: any} = {};\n    for (let i = 0; i < this._evalArgNames.length; i++) {\n      result[this._evalArgNames[i]] = this._evalArgValues[i];\n    }\n    return result;\n  }\n\n  override visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any {\n    this._emitReferenceToExternal(ast, this.refResolver.resolveExternalReference(ast.value), ctx);\n    return null;\n  }\n\n  override visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    this._emitReferenceToExternal(ast, ast.node, ctx);\n    return null;\n  }\n\n  override visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareVarStmt(stmt, ctx);\n  }\n\n  override visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareFunctionStmt(stmt, ctx);\n  }\n\n  private _emitReferenceToExternal(ast: o.Expression, value: any, ctx: EmitterVisitorContext):\n      void {\n    let id = this._evalArgValues.indexOf(value);\n    if (id === -1) {\n      id = this._evalArgValues.length;\n      this._evalArgValues.push(value);\n      const name = identifierName({reference: value}) || 'val';\n      this._evalArgNames.push(`jit_${name}_${id}`);\n    }\n    ctx.print(ast, this._evalArgNames[id]);\n  }\n}\n\n\nfunction isUseStrictStatement(statement: o.Statement): boolean {\n  return statement.isEquivalent(o.literal('use strict').toStmt());\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../output/output_ast';\nimport {Identifiers as R3} from './r3_identifiers';\nimport {R3CompiledExpression, R3Reference} from './util';\nimport {DefinitionMap} from './view/util';\n\nexport interface R3InjectorMetadata {\n  name: string;\n  type: R3Reference;\n  internalType: o.Expression;\n  providers: o.Expression|null;\n  imports: o.Expression[];\n}\n\nexport function compileInjector(meta: R3InjectorMetadata): R3CompiledExpression {\n  const definitionMap = new DefinitionMap<{providers: o.Expression; imports: o.Expression;}>();\n\n  if (meta.providers !== null) {\n    definitionMap.set('providers', meta.providers);\n  }\n\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', o.literalArr(meta.imports));\n  }\n\n  const expression =\n      o.importExpr(R3.defineInjector).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createInjectorType(meta);\n  return {expression, type, statements: []};\n}\n\nexport function createInjectorType(meta: R3InjectorMetadata): o.Type {\n  return new o.ExpressionType(\n      o.importExpr(R3.InjectorDeclaration, [new o.ExpressionType(meta.type.type)]));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../output/output_ast';\nimport {ExternalReferenceResolver} from '../output/output_jit';\n\n/**\n * Implementation of `CompileReflector` which resolves references to @angular/core\n * symbols at runtime, according to a consumer-provided mapping.\n *\n * Only supports `resolveExternalReference`, all other methods throw.\n */\nexport class R3JitReflector implements ExternalReferenceResolver {\n  constructor(private context: {[key: string]: unknown}) {}\n\n  resolveExternalReference(ref: o.ExternalReference): unknown {\n    // This reflector only handles @angular/core imports.\n    if (ref.moduleName !== '@angular/core') {\n      throw new Error(`Cannot resolve external reference to ${\n          ref.moduleName}, only references to @angular/core are supported.`);\n    }\n    if (!this.context.hasOwnProperty(ref.name!)) {\n      throw new Error(`No value provided for @angular/core symbol '${ref.name!}'.`);\n    }\n    return this.context[ref.name!];\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {R3DeclareNgModuleFacade} from '../compiler_facade_interface';\nimport * as o from '../output/output_ast';\n\nimport {Identifiers as R3} from './r3_identifiers';\nimport {jitOnlyGuardedExpression, R3CompiledExpression, R3Reference, refsToArray} from './util';\nimport {DefinitionMap} from './view/util';\n\n/**\n * How the selector scope of an NgModule (its declarations, imports, and exports) should be emitted\n * as a part of the NgModule definition.\n */\nexport enum R3SelectorScopeMode {\n  /**\n   * Emit the declarations inline into the module definition.\n   *\n   * This option is useful in certain contexts where it's known that JIT support is required. The\n   * tradeoff here is that this emit style prevents directives and pipes from being tree-shaken if\n   * they are unused, but the NgModule is used.\n   */\n  Inline,\n\n  /**\n   * Emit the declarations using a side effectful function call, `\u0275\u0275setNgModuleScope`, that is\n   * guarded with the `ngJitMode` flag.\n   *\n   * This form of emit supports JIT and can be optimized away if the `ngJitMode` flag is set to\n   * false, which allows unused directives and pipes to be tree-shaken.\n   */\n  SideEffect,\n\n  /**\n   * Don't generate selector scopes at all.\n   *\n   * This is useful for contexts where JIT support is known to be unnecessary.\n   */\n  Omit,\n}\n\n/**\n * Metadata required by the module compiler to generate a module def (`\u0275mod`) for a type.\n */\nexport interface R3NgModuleMetadata {\n  /**\n   * An expression representing the module type being compiled.\n   */\n  type: R3Reference;\n\n  /**\n   * An expression representing the module type being compiled, intended for use within a class\n   * definition itself.\n   *\n   * This can differ from the outer `type` if the class is being compiled by ngcc and is inside\n   * an IIFE structure that uses a different name internally.\n   */\n  internalType: o.Expression;\n\n  /**\n   * An expression intended for use by statements that are adjacent (i.e. tightly coupled) to but\n   * not internal to a class definition.\n   *\n   * This can differ from the outer `type` if the class is being compiled by ngcc and is inside\n   * an IIFE structure that uses a different name internally.\n   */\n  adjacentType: o.Expression;\n\n  /**\n   * An array of expressions representing the bootstrap components specified by the module.\n   */\n  bootstrap: R3Reference[];\n\n  /**\n   * An array of expressions representing the directives and pipes declared by the module.\n   */\n  declarations: R3Reference[];\n\n  /**\n   * Those declarations which should be visible to downstream consumers. If not specified, all\n   * declarations are made visible to downstream consumers.\n   */\n  publicDeclarationTypes: o.Expression[]|null;\n\n  /**\n   * An array of expressions representing the imports of the module.\n   */\n  imports: R3Reference[];\n\n  /**\n   * Whether or not to include `imports` in generated type declarations.\n   */\n  includeImportTypes: boolean;\n\n  /**\n   * An array of expressions representing the exports of the module.\n   */\n  exports: R3Reference[];\n\n  /**\n   * How to emit the selector scope values (declarations, imports, exports).\n   */\n  selectorScopeMode: R3SelectorScopeMode;\n\n  /**\n   * Whether to generate closure wrappers for bootstrap, declarations, imports, and exports.\n   */\n  containsForwardDecls: boolean;\n\n  /**\n   * The set of schemas that declare elements to be allowed in the NgModule.\n   */\n  schemas: R3Reference[]|null;\n\n  /** Unique ID or expression representing the unique ID of an NgModule. */\n  id: o.Expression|null;\n}\n\n/**\n * The shape of the object literal that is passed to the `\u0275\u0275defineNgModule()` call.\n */\ninterface R3NgModuleDefMap {\n  /**\n   * An expression representing the module type being compiled.\n   */\n  type: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the bootstrap components\n   * specified by the module.\n   */\n  bootstrap?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the directives and pipes\n   * declared by the module.\n   */\n  declarations?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the imports of the module.\n   */\n  imports?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the exports of the module.\n   */\n  exports?: o.Expression;\n  /**\n   * A literal array expression containing the schemas that declare elements to be allowed in the\n   * NgModule.\n   */\n  schemas?: o.LiteralArrayExpr;\n  /**\n   * An expression evaluating to the unique ID of an NgModule.\n   * */\n  id?: o.Expression;\n}\n\n/**\n * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\n */\nexport function compileNgModule(meta: R3NgModuleMetadata): R3CompiledExpression {\n  const {\n    adjacentType,\n    internalType,\n    bootstrap,\n    declarations,\n    imports,\n    exports,\n    schemas,\n    containsForwardDecls,\n    selectorScopeMode,\n    id\n  } = meta;\n\n  const statements: o.Statement[] = [];\n  const definitionMap = new DefinitionMap<R3NgModuleDefMap>();\n  definitionMap.set('type', internalType);\n\n  if (bootstrap.length > 0) {\n    definitionMap.set('bootstrap', refsToArray(bootstrap, containsForwardDecls));\n  }\n\n  if (selectorScopeMode === R3SelectorScopeMode.Inline) {\n    // If requested to emit scope information inline, pass the `declarations`, `imports` and\n    // `exports` to the `\u0275\u0275defineNgModule()` call directly.\n\n    if (declarations.length > 0) {\n      definitionMap.set('declarations', refsToArray(declarations, containsForwardDecls));\n    }\n\n    if (imports.length > 0) {\n      definitionMap.set('imports', refsToArray(imports, containsForwardDecls));\n    }\n\n    if (exports.length > 0) {\n      definitionMap.set('exports', refsToArray(exports, containsForwardDecls));\n    }\n  } else if (selectorScopeMode === R3SelectorScopeMode.SideEffect) {\n    // In this mode, scope information is not passed into `\u0275\u0275defineNgModule` as it\n    // would prevent tree-shaking of the declarations, imports and exports references. Instead, it's\n    // patched onto the NgModule definition with a `\u0275\u0275setNgModuleScope` call that's guarded by the\n    // `ngJitMode` flag.\n    const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\n    if (setNgModuleScopeCall !== null) {\n      statements.push(setNgModuleScopeCall);\n    }\n  } else {\n    // Selector scope emit was not requested, so skip it.\n  }\n\n  if (schemas !== null && schemas.length > 0) {\n    definitionMap.set('schemas', o.literalArr(schemas.map(ref => ref.value)));\n  }\n\n  if (id !== null) {\n    definitionMap.set('id', id);\n\n    // Generate a side-effectful call to register this NgModule by its id, as per the semantics of\n    // NgModule ids.\n    statements.push(o.importExpr(R3.registerNgModuleType).callFn([adjacentType, id]).toStmt());\n  }\n\n  const expression =\n      o.importExpr(R3.defineNgModule).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createNgModuleType(meta);\n\n  return {expression, type, statements};\n}\n\n/**\n * This function is used in JIT mode to generate the call to `\u0275\u0275defineNgModule()` from a call to\n * `\u0275\u0275ngDeclareNgModule()`.\n */\nexport function compileNgModuleDeclarationExpression(meta: R3DeclareNgModuleFacade): o.Expression {\n  const definitionMap = new DefinitionMap<R3NgModuleDefMap>();\n  definitionMap.set('type', new o.WrappedNodeExpr(meta.type));\n  if (meta.bootstrap !== undefined) {\n    definitionMap.set('bootstrap', new o.WrappedNodeExpr(meta.bootstrap));\n  }\n  if (meta.declarations !== undefined) {\n    definitionMap.set('declarations', new o.WrappedNodeExpr(meta.declarations));\n  }\n  if (meta.imports !== undefined) {\n    definitionMap.set('imports', new o.WrappedNodeExpr(meta.imports));\n  }\n  if (meta.exports !== undefined) {\n    definitionMap.set('exports', new o.WrappedNodeExpr(meta.exports));\n  }\n  if (meta.schemas !== undefined) {\n    definitionMap.set('schemas', new o.WrappedNodeExpr(meta.schemas));\n  }\n  if (meta.id !== undefined) {\n    definitionMap.set('id', new o.WrappedNodeExpr(meta.id));\n  }\n  return o.importExpr(R3.defineNgModule).callFn([definitionMap.toLiteralMap()]);\n}\n\nexport function createNgModuleType(\n    {type: moduleType, declarations, exports, imports, includeImportTypes, publicDeclarationTypes}:\n        R3NgModuleMetadata): o.ExpressionType {\n  return new o.ExpressionType(o.importExpr(R3.NgModuleDeclaration, [\n    new o.ExpressionType(moduleType.type),\n    publicDeclarationTypes === null ? tupleTypeOf(declarations) :\n                                      tupleOfTypes(publicDeclarationTypes),\n    includeImportTypes ? tupleTypeOf(imports) : o.NONE_TYPE,\n    tupleTypeOf(exports),\n  ]));\n}\n\n/**\n * Generates a function call to `\u0275\u0275setNgModuleScope` with all necessary information so that the\n * transitive module scope can be computed during runtime in JIT mode. This call is marked pure\n * such that the references to declarations, imports and exports may be elided causing these\n * symbols to become tree-shakeable.\n */\nfunction generateSetNgModuleScopeCall(meta: R3NgModuleMetadata): o.Statement|null {\n  const {adjacentType: moduleType, declarations, imports, exports, containsForwardDecls} = meta;\n\n  const scopeMap = new DefinitionMap<\n      {declarations: o.Expression, imports: o.Expression, exports: o.Expression}>();\n\n  if (declarations.length > 0) {\n    scopeMap.set('declarations', refsToArray(declarations, containsForwardDecls));\n  }\n\n  if (imports.length > 0) {\n    scopeMap.set('imports', refsToArray(imports, containsForwardDecls));\n  }\n\n  if (exports.length > 0) {\n    scopeMap.set('exports', refsToArray(exports, containsForwardDecls));\n  }\n\n  if (Object.keys(scopeMap.values).length === 0) {\n    return null;\n  }\n\n  // setNgModuleScope(...)\n  const fnCall = new o.InvokeFunctionExpr(\n      /* fn */ o.importExpr(R3.setNgModuleScope),\n      /* args */[moduleType, scopeMap.toLiteralMap()]);\n\n  // (ngJitMode guard) && setNgModuleScope(...)\n  const guardedCall = jitOnlyGuardedExpression(fnCall);\n\n  // function() { (ngJitMode guard) && setNgModuleScope(...); }\n  const iife = new o.FunctionExpr(\n      /* params */[],\n      /* statements */[guardedCall.toStmt()]);\n\n  // (function() { (ngJitMode guard) && setNgModuleScope(...); })()\n  const iifeCall = new o.InvokeFunctionExpr(\n      /* fn */ iife,\n      /* args */[]);\n\n  return iifeCall.toStmt();\n}\n\nfunction tupleTypeOf(exp: R3Reference[]): o.Type {\n  const types = exp.map(ref => o.typeofExpr(ref.type));\n  return exp.length > 0 ? o.expressionType(o.literalArr(types)) : o.NONE_TYPE;\n}\n\nfunction tupleOfTypes(types: o.Expression[]): o.Type {\n  const typeofTypes = types.map(type => o.typeofExpr(type));\n  return types.length > 0 ? o.expressionType(o.literalArr(typeofTypes)) : o.NONE_TYPE;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../output/output_ast';\n\nimport {R3DependencyMetadata} from './r3_factory';\nimport {Identifiers as R3} from './r3_identifiers';\nimport {R3CompiledExpression, R3Reference, typeWithParameters} from './util';\n\nexport interface R3PipeMetadata {\n  /**\n   * Name of the pipe type.\n   */\n  name: string;\n\n  /**\n   * An expression representing a reference to the pipe itself.\n   */\n  type: R3Reference;\n\n  /**\n   * An expression representing the pipe being compiled, intended for use within a class definition\n   * itself.\n   *\n   * This can differ from the outer `type` if the class is being compiled by ngcc and is inside an\n   * IIFE structure that uses a different name internally.\n   */\n  internalType: o.Expression;\n\n  /**\n   * Number of generic type parameters of the type itself.\n   */\n  typeArgumentCount: number;\n\n  /**\n   * Name of the pipe.\n   */\n  pipeName: string;\n\n  /**\n   * Dependencies of the pipe's constructor.\n   */\n  deps: R3DependencyMetadata[]|null;\n\n  /**\n   * Whether the pipe is marked as pure.\n   */\n  pure: boolean;\n\n  /**\n   * Whether the pipe is standalone.\n   */\n  isStandalone: boolean;\n}\n\nexport function compilePipeFromMetadata(metadata: R3PipeMetadata): R3CompiledExpression {\n  const definitionMapValues: {key: string, quoted: boolean, value: o.Expression}[] = [];\n\n  // e.g. `name: 'myPipe'`\n  definitionMapValues.push({key: 'name', value: o.literal(metadata.pipeName), quoted: false});\n\n  // e.g. `type: MyPipe`\n  definitionMapValues.push({key: 'type', value: metadata.type.value, quoted: false});\n\n  // e.g. `pure: true`\n  definitionMapValues.push({key: 'pure', value: o.literal(metadata.pure), quoted: false});\n\n  if (metadata.isStandalone) {\n    definitionMapValues.push({key: 'standalone', value: o.literal(true), quoted: false});\n  }\n\n  const expression =\n      o.importExpr(R3.definePipe).callFn([o.literalMap(definitionMapValues)], undefined, true);\n  const type = createPipeType(metadata);\n\n  return {expression, type, statements: []};\n}\n\nexport function createPipeType(metadata: R3PipeMetadata): o.Type {\n  return new o.ExpressionType(o.importExpr(R3.PipeDeclaration, [\n    typeWithParameters(metadata.type.type, metadata.typeArgumentCount),\n    new o.ExpressionType(new o.LiteralExpr(metadata.pipeName)),\n    new o.ExpressionType(new o.LiteralExpr(metadata.isStandalone)),\n  ]));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectionStrategy, ViewEncapsulation} from '../../core';\nimport {InterpolationConfig} from '../../ml_parser/interpolation_config';\nimport * as o from '../../output/output_ast';\nimport {ParseSourceSpan} from '../../parse_util';\nimport * as t from '../r3_ast';\nimport {R3DependencyMetadata} from '../r3_factory';\nimport {MaybeForwardRefExpression, R3Reference} from '../util';\n\n\n/**\n * Information needed to compile a directive for the render3 runtime.\n */\nexport interface R3DirectiveMetadata {\n  /**\n   * Name of the directive type.\n   */\n  name: string;\n\n  /**\n   * An expression representing a reference to the directive itself.\n   */\n  type: R3Reference;\n\n  /**\n   * An expression representing a reference to the directive being compiled, intended for use within\n   * a class definition itself.\n   *\n   * This can differ from the outer `type` if the class is being compiled by ngcc and is inside\n   * an IIFE structure that uses a different name internally.\n   */\n  internalType: o.Expression;\n\n  /**\n   * Number of generic type parameters of the type itself.\n   */\n  typeArgumentCount: number;\n\n  /**\n   * A source span for the directive type.\n   */\n  typeSourceSpan: ParseSourceSpan;\n\n  /**\n   * Dependencies of the directive's constructor.\n   */\n  deps: R3DependencyMetadata[]|'invalid'|null;\n\n  /**\n   * Unparsed selector of the directive, or `null` if there was no selector.\n   */\n  selector: string|null;\n\n  /**\n   * Information about the content queries made by the directive.\n   */\n  queries: R3QueryMetadata[];\n\n  /**\n   * Information about the view queries made by the directive.\n   */\n  viewQueries: R3QueryMetadata[];\n\n  /**\n   * Mappings indicating how the directive interacts with its host element (host bindings,\n   * listeners, etc).\n   */\n  host: R3HostMetadata;\n\n  /**\n   * Information about usage of specific lifecycle events which require special treatment in the\n   * code generator.\n   */\n  lifecycle: {\n    /**\n     * Whether the directive uses NgOnChanges.\n     */\n    usesOnChanges: boolean;\n  };\n\n  /**\n   * A mapping of inputs from class property names to binding property names, or to a tuple of\n   * binding property name and class property name if the names are different.\n   */\n  inputs: {[field: string]: string|[string, string]};\n\n  /**\n   * A mapping of outputs from class property names to binding property names, or to a tuple of\n   * binding property name and class property name if the names are different.\n   */\n  outputs: {[field: string]: string};\n\n  /**\n   * Whether or not the component or directive inherits from another class\n   */\n  usesInheritance: boolean;\n\n  /**\n   * Whether or not the component or directive inherits its entire decorator from its base class.\n   */\n  fullInheritance: boolean;\n\n  /**\n   * Reference name under which to export the directive's type in a template,\n   * if any.\n   */\n  exportAs: string[]|null;\n\n  /**\n   * The list of providers defined in the directive.\n   */\n  providers: o.Expression|null;\n\n  /**\n   * Whether or not the component or directive is standalone.\n   */\n  isStandalone: boolean;\n\n  /**\n   * Additional directives applied to the directive host.\n   */\n  hostDirectives: R3HostDirectiveMetadata[]|null;\n}\n\n/**\n * Specifies how a list of declaration type references should be emitted into the generated code.\n */\nexport const enum DeclarationListEmitMode {\n  /**\n   * The list of declarations is emitted into the generated code as is.\n   *\n   * ```\n   * directives: [MyDir],\n   * ```\n   */\n  Direct,\n\n  /**\n   * The list of declarations is emitted into the generated code wrapped inside a closure, which\n   * is needed when at least one declaration is a forward reference.\n   *\n   * ```\n   * directives: function () { return [MyDir, ForwardDir]; },\n   * ```\n   */\n  Closure,\n\n  /**\n   * Similar to `Closure`, with the addition that the list of declarations can contain individual\n   * items that are themselves forward references. This is relevant for JIT compilations, as\n   * unwrapping the forwardRef cannot be done statically so must be deferred. This mode emits\n   * the declaration list using a mapping transform through `resolveForwardRef` to ensure that\n   * any forward references within the list are resolved when the outer closure is invoked.\n   *\n   * Consider the case where the runtime has captured two declarations in two distinct values:\n   * ```\n   * const dirA = MyDir;\n   * const dirB = forwardRef(function() { return ForwardRef; });\n   * ```\n   *\n   * This mode would emit the declarations captured in `dirA` and `dirB` as follows:\n   * ```\n   * directives: function () { return [dirA, dirB].map(ng.resolveForwardRef); },\n   * ```\n   */\n  ClosureResolved,\n}\n\n/**\n * Information needed to compile a component for the render3 runtime.\n */\nexport interface R3ComponentMetadata<DeclarationT extends R3TemplateDependency> extends\n    R3DirectiveMetadata {\n  /**\n   * Information about the component's template.\n   */\n  template: {\n    /**\n     * Parsed nodes of the template.\n     */\n    nodes: t.Node[];\n\n    /**\n     * Any ng-content selectors extracted from the template. Contains `*` when an ng-content\n     * element without selector is present.\n     */\n    ngContentSelectors: string[];\n  };\n\n  declarations: DeclarationT[];\n\n  /**\n   * Specifies how the 'directives' and/or `pipes` array, if generated, need to be emitted.\n   */\n  declarationListEmitMode: DeclarationListEmitMode;\n\n  /**\n   * A collection of styling data that will be applied and scoped to the component.\n   */\n  styles: string[];\n\n  /**\n   * An encapsulation policy for the component's styling.\n   * Possible values:\n   * - `ViewEncapsulation.Emulated`: Apply modified component styles in order to emulate\n   *                                 a native Shadow DOM CSS encapsulation behavior.\n   * - `ViewEncapsulation.None`: Apply component styles globally without any sort of encapsulation.\n   * - `ViewEncapsulation.ShadowDom`: Use the browser's native Shadow DOM API to encapsulate styles.\n   */\n  encapsulation: ViewEncapsulation;\n\n  /**\n   * A collection of animation triggers that will be used in the component template.\n   */\n  animations: o.Expression|null;\n\n  /**\n   * The list of view providers defined in the component.\n   */\n  viewProviders: o.Expression|null;\n\n  /**\n   * Path to the .ts file in which this template's generated code will be included, relative to\n   * the compilation root. This will be used to generate identifiers that need to be globally\n   * unique in certain contexts (such as g3).\n   */\n  relativeContextFilePath: string;\n\n  /**\n   * Whether translation variable name should contain external message id\n   * (used by Closure Compiler's output of `goog.getMsg` for transition period).\n   */\n  i18nUseExternalIds: boolean;\n\n  /**\n   * Overrides the default interpolation start and end delimiters ({{ and }}).\n   */\n  interpolation: InterpolationConfig;\n\n  /**\n   * Strategy used for detecting changes in the component.\n   */\n  changeDetection?: ChangeDetectionStrategy;\n}\n\n\nexport enum R3TemplateDependencyKind {\n  Directive = 0,\n  Pipe = 1,\n  NgModule = 2,\n}\n\n/**\n * A dependency that's used within a component template.\n */\nexport interface R3TemplateDependency {\n  kind: R3TemplateDependencyKind;\n\n  /**\n   * The type of the dependency as an expression.\n   */\n  type: o.Expression;\n}\n\n/**\n * A dependency that's used within a component template\n */\nexport type R3TemplateDependencyMetadata =\n    R3DirectiveDependencyMetadata|R3PipeDependencyMetadata|R3NgModuleDependencyMetadata;\n\n/**\n * Information about a directive that is used in a component template. Only the stable, public\n * facing information of the directive is stored here.\n */\nexport interface R3DirectiveDependencyMetadata extends R3TemplateDependency {\n  kind: R3TemplateDependencyKind.Directive;\n\n  /**\n   * The selector of the directive.\n   */\n  selector: string;\n\n  /**\n   * The binding property names of the inputs of the directive.\n   */\n  inputs: string[];\n\n  /**\n   * The binding property names of the outputs of the directive.\n   */\n  outputs: string[];\n\n  /**\n   * Name under which the directive is exported, if any (exportAs in Angular). Null otherwise.\n   */\n  exportAs: string[]|null;\n\n  /**\n   * If true then this directive is actually a component; otherwise it is not.\n   */\n  isComponent: boolean;\n}\n\nexport interface R3PipeDependencyMetadata extends R3TemplateDependency {\n  kind: R3TemplateDependencyKind.Pipe;\n\n  name: string;\n}\n\nexport interface R3NgModuleDependencyMetadata extends R3TemplateDependency {\n  kind: R3TemplateDependencyKind.NgModule;\n}\n\n/**\n * Information needed to compile a query (view or content).\n */\nexport interface R3QueryMetadata {\n  /**\n   * Name of the property on the class to update with query results.\n   */\n  propertyName: string;\n\n  /**\n   * Whether to read only the first matching result, or an array of results.\n   */\n  first: boolean;\n\n  /**\n   * Either an expression representing a type or `InjectionToken` for the query\n   * predicate, or a set of string selectors.\n   */\n  predicate: MaybeForwardRefExpression|string[];\n\n  /**\n   * Whether to include only direct children or all descendants.\n   */\n  descendants: boolean;\n\n  /**\n   * If the `QueryList` should fire change event only if actual change to query was computed (vs old\n   * behavior where the change was fired whenever the query was recomputed, even if the recomputed\n   * query resulted in the same list.)\n   */\n  emitDistinctChangesOnly: boolean;\n\n  /**\n   * An expression representing a type to read from each matched node, or null if the default value\n   * for a given node is to be returned.\n   */\n  read: o.Expression|null;\n\n  /**\n   * Whether or not this query should collect only static results.\n   *\n   * If static is true, the query's results will be set on the component after nodes are created,\n   * but before change detection runs. This means that any results that relied upon change detection\n   * to run (e.g. results inside *ngIf or *ngFor views) will not be collected. Query results are\n   * available in the ngOnInit hook.\n   *\n   * If static is false, the query's results will be set on the component after change detection\n   * runs. This means that the query results can contain nodes inside *ngIf or *ngFor views, but\n   * the results will not be available in the ngOnInit hook (only in the ngAfterContentInit for\n   * content hooks and ngAfterViewInit for view hooks).\n   */\n  static: boolean;\n}\n\n/**\n * Mappings indicating how the class interacts with its\n * host element (host bindings, listeners, etc).\n */\nexport interface R3HostMetadata {\n  /**\n   * A mapping of attribute binding keys to `o.Expression`s.\n   */\n  attributes: {[key: string]: o.Expression};\n\n  /**\n   * A mapping of event binding keys to unparsed expressions.\n   */\n  listeners: {[key: string]: string};\n\n  /**\n   * A mapping of property binding keys to unparsed expressions.\n   */\n  properties: {[key: string]: string};\n\n  specialAttributes: {styleAttr?: string; classAttr?: string;};\n}\n\n/**\n * Information needed to compile a host directive for the render3 runtime.\n */\nexport interface R3HostDirectiveMetadata {\n  /** An expression representing the host directive class itself. */\n  directive: R3Reference;\n\n  /** Whether the expression referring to the host directive is a forward reference. */\n  isForwardReference: boolean;\n\n  /** Inputs from the host directive that will be exposed on the host. */\n  inputs: {[publicName: string]: string}|null;\n\n  /** Outputs from the host directive that will be exposed on the host. */\n  outputs: {[publicName: string]: string}|null;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '../core';\nimport {ParseSourceSpan} from '../parse_util';\n\nexport class ParserError {\n  public message: string;\n  constructor(\n      message: string, public input: string, public errLocation: string, public ctxLocation?: any) {\n    this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;\n  }\n}\n\nexport class ParseSpan {\n  constructor(public start: number, public end: number) {}\n  toAbsolute(absoluteOffset: number): AbsoluteSourceSpan {\n    return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);\n  }\n}\n\nexport abstract class AST {\n  constructor(\n      public span: ParseSpan,\n      /**\n       * Absolute location of the expression AST in a source code file.\n       */\n      public sourceSpan: AbsoluteSourceSpan) {}\n\n  abstract visit(visitor: AstVisitor, context?: any): any;\n\n  toString(): string {\n    return 'AST';\n  }\n}\n\nexport abstract class ASTWithName extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public nameSpan: AbsoluteSourceSpan) {\n    super(span, sourceSpan);\n  }\n}\n\nexport class EmptyExpr extends AST {\n  override visit(visitor: AstVisitor, context: any = null) {\n    // do nothing\n  }\n}\n\nexport class ImplicitReceiver extends AST {\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitImplicitReceiver(this, context);\n  }\n}\n\n/**\n * Receiver when something is accessed through `this` (e.g. `this.foo`). Note that this class\n * inherits from `ImplicitReceiver`, because accessing something through `this` is treated the\n * same as accessing it implicitly inside of an Angular template (e.g. `[attr.title]=\"this.title\"`\n * is the same as `[attr.title]=\"title\"`.). Inheriting allows for the `this` accesses to be treated\n * the same as implicit ones, except for a couple of exceptions like `$event` and `$any`.\n * TODO: we should find a way for this class not to extend from `ImplicitReceiver` in the future.\n */\nexport class ThisReceiver extends ImplicitReceiver {\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitThisReceiver?.(this, context);\n  }\n}\n\n/**\n * Multiple expressions separated by a semicolon.\n */\nexport class Chain extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expressions: any[]) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitChain(this, context);\n  }\n}\n\nexport class Conditional extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public condition: AST, public trueExp: AST,\n      public falseExp: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitConditional(this, context);\n  }\n}\n\nexport class PropertyRead extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, nameSpan: AbsoluteSourceSpan,\n      public receiver: AST, public name: string) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPropertyRead(this, context);\n  }\n}\n\nexport class PropertyWrite extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, nameSpan: AbsoluteSourceSpan,\n      public receiver: AST, public name: string, public value: AST) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPropertyWrite(this, context);\n  }\n}\n\nexport class SafePropertyRead extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, nameSpan: AbsoluteSourceSpan,\n      public receiver: AST, public name: string) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafePropertyRead(this, context);\n  }\n}\n\nexport class KeyedRead extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public key: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitKeyedRead(this, context);\n  }\n}\n\nexport class SafeKeyedRead extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public key: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafeKeyedRead(this, context);\n  }\n}\n\nexport class KeyedWrite extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public key: AST,\n      public value: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitKeyedWrite(this, context);\n  }\n}\n\nexport class BindingPipe extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public exp: AST, public name: string,\n      public args: any[], nameSpan: AbsoluteSourceSpan) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPipe(this, context);\n  }\n}\n\nexport class LiteralPrimitive extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public value: any) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralPrimitive(this, context);\n  }\n}\n\nexport class LiteralArray extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expressions: any[]) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralArray(this, context);\n  }\n}\n\nexport type LiteralMapKey = {\n  key: string; quoted: boolean;\n};\n\nexport class LiteralMap extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public keys: LiteralMapKey[],\n      public values: any[]) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralMap(this, context);\n  }\n}\n\nexport class Interpolation extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public strings: any[],\n      public expressions: any[]) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitInterpolation(this, context);\n  }\n}\n\nexport class Binary extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public operation: string, public left: AST,\n      public right: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitBinary(this, context);\n  }\n}\n\n/**\n * For backwards compatibility reasons, `Unary` inherits from `Binary` and mimics the binary AST\n * node that was originally used. This inheritance relation can be deleted in some future major,\n * after consumers have been given a chance to fully support Unary.\n */\nexport class Unary extends Binary {\n  // Redeclare the properties that are inherited from `Binary` as `never`, as consumers should not\n  // depend on these fields when operating on `Unary`.\n  override left: never = null as never;\n  override right: never = null as never;\n  override operation: never = null as never;\n\n  /**\n   * Creates a unary minus expression \"-x\", represented as `Binary` using \"0 - x\".\n   */\n  static createMinus(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, expr: AST): Unary {\n    return new Unary(\n        span, sourceSpan, '-', expr, '-', new LiteralPrimitive(span, sourceSpan, 0), expr);\n  }\n\n  /**\n   * Creates a unary plus expression \"+x\", represented as `Binary` using \"x - 0\".\n   */\n  static createPlus(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, expr: AST): Unary {\n    return new Unary(\n        span, sourceSpan, '+', expr, '-', expr, new LiteralPrimitive(span, sourceSpan, 0));\n  }\n\n  /**\n   * During the deprecation period this constructor is private, to avoid consumers from creating\n   * a `Unary` with the fallback properties for `Binary`.\n   */\n  private constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public operator: string, public expr: AST,\n      binaryOp: string, binaryLeft: AST, binaryRight: AST) {\n    super(span, sourceSpan, binaryOp, binaryLeft, binaryRight);\n  }\n\n  override visit(visitor: AstVisitor, context: any = null): any {\n    if (visitor.visitUnary !== undefined) {\n      return visitor.visitUnary(this, context);\n    }\n    return visitor.visitBinary(this, context);\n  }\n}\n\nexport class PrefixNot extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expression: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPrefixNot(this, context);\n  }\n}\n\nexport class NonNullAssert extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expression: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitNonNullAssert(this, context);\n  }\n}\n\nexport class Call extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public args: AST[],\n      public argumentSpan: AbsoluteSourceSpan) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitCall(this, context);\n  }\n}\n\nexport class SafeCall extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public args: AST[],\n      public argumentSpan: AbsoluteSourceSpan) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafeCall(this, context);\n  }\n}\n\n\n/**\n * Records the absolute position of a text span in a source file, where `start` and `end` are the\n * starting and ending byte offsets, respectively, of the text span in a source file.\n */\nexport class AbsoluteSourceSpan {\n  constructor(public readonly start: number, public readonly end: number) {}\n}\n\nexport class ASTWithSource extends AST {\n  constructor(\n      public ast: AST, public source: string|null, public location: string, absoluteOffset: number,\n      public errors: ParserError[]) {\n    super(\n        new ParseSpan(0, source === null ? 0 : source.length),\n        new AbsoluteSourceSpan(\n            absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    if (visitor.visitASTWithSource) {\n      return visitor.visitASTWithSource(this, context);\n    }\n    return this.ast.visit(visitor, context);\n  }\n  override toString(): string {\n    return `${this.source} in ${this.location}`;\n  }\n}\n\n/**\n * TemplateBinding refers to a particular key-value pair in a microsyntax\n * expression. A few examples are:\n *\n *   |---------------------|--------------|---------|--------------|\n *   |     expression      |     key      |  value  | binding type |\n *   |---------------------|--------------|---------|--------------|\n *   | 1. let item         |    item      |  null   |   variable   |\n *   | 2. of items         |   ngForOf    |  items  |  expression  |\n *   | 3. let x = y        |      x       |    y    |   variable   |\n *   | 4. index as i       |      i       |  index  |   variable   |\n *   | 5. trackBy: func    | ngForTrackBy |   func  |  expression  |\n *   | 6. *ngIf=\"cond\"     |     ngIf     |   cond  |  expression  |\n *   |---------------------|--------------|---------|--------------|\n *\n * (6) is a notable exception because it is a binding from the template key in\n * the LHS of a HTML attribute to the expression in the RHS. All other bindings\n * in the example above are derived solely from the RHS.\n */\nexport type TemplateBinding = VariableBinding|ExpressionBinding;\n\nexport class VariableBinding {\n  /**\n   * @param sourceSpan entire span of the binding.\n   * @param key name of the LHS along with its span.\n   * @param value optional value for the RHS along with its span.\n   */\n  constructor(\n      public readonly sourceSpan: AbsoluteSourceSpan,\n      public readonly key: TemplateBindingIdentifier,\n      public readonly value: TemplateBindingIdentifier|null) {}\n}\n\nexport class ExpressionBinding {\n  /**\n   * @param sourceSpan entire span of the binding.\n   * @param key binding name, like ngForOf, ngForTrackBy, ngIf, along with its\n   * span. Note that the length of the span may not be the same as\n   * `key.source.length`. For example,\n   * 1. key.source = ngFor, key.span is for \"ngFor\"\n   * 2. key.source = ngForOf, key.span is for \"of\"\n   * 3. key.source = ngForTrackBy, key.span is for \"trackBy\"\n   * @param value optional expression for the RHS.\n   */\n  constructor(\n      public readonly sourceSpan: AbsoluteSourceSpan,\n      public readonly key: TemplateBindingIdentifier, public readonly value: ASTWithSource|null) {}\n}\n\nexport interface TemplateBindingIdentifier {\n  source: string;\n  span: AbsoluteSourceSpan;\n}\n\nexport interface AstVisitor {\n  /**\n   * The `visitUnary` method is declared as optional for backwards compatibility. In an upcoming\n   * major release, this method will be made required.\n   */\n  visitUnary?(ast: Unary, context: any): any;\n  visitBinary(ast: Binary, context: any): any;\n  visitChain(ast: Chain, context: any): any;\n  visitConditional(ast: Conditional, context: any): any;\n  /**\n   * The `visitThisReceiver` method is declared as optional for backwards compatibility.\n   * In an upcoming major release, this method will be made required.\n   */\n  visitThisReceiver?(ast: ThisReceiver, context: any): any;\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;\n  visitInterpolation(ast: Interpolation, context: any): any;\n  visitKeyedRead(ast: KeyedRead, context: any): any;\n  visitKeyedWrite(ast: KeyedWrite, context: any): any;\n  visitLiteralArray(ast: LiteralArray, context: any): any;\n  visitLiteralMap(ast: LiteralMap, context: any): any;\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;\n  visitPipe(ast: BindingPipe, context: any): any;\n  visitPrefixNot(ast: PrefixNot, context: any): any;\n  visitNonNullAssert(ast: NonNullAssert, context: any): any;\n  visitPropertyRead(ast: PropertyRead, context: any): any;\n  visitPropertyWrite(ast: PropertyWrite, context: any): any;\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any;\n  visitSafeKeyedRead(ast: SafeKeyedRead, context: any): any;\n  visitCall(ast: Call, context: any): any;\n  visitSafeCall(ast: SafeCall, context: any): any;\n  visitASTWithSource?(ast: ASTWithSource, context: any): any;\n  /**\n   * This function is optionally defined to allow classes that implement this\n   * interface to selectively decide if the specified `ast` should be visited.\n   * @param ast node to visit\n   * @param context context that gets passed to the node and all its children\n   */\n  visit?(ast: AST, context?: any): any;\n}\n\nexport class RecursiveAstVisitor implements AstVisitor {\n  visit(ast: AST, context?: any): any {\n    // The default implementation just visits every node.\n    // Classes that extend RecursiveAstVisitor should override this function\n    // to selectively visit the specified node.\n    ast.visit(this, context);\n  }\n  visitUnary(ast: Unary, context: any): any {\n    this.visit(ast.expr, context);\n  }\n  visitBinary(ast: Binary, context: any): any {\n    this.visit(ast.left, context);\n    this.visit(ast.right, context);\n  }\n  visitChain(ast: Chain, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitConditional(ast: Conditional, context: any): any {\n    this.visit(ast.condition, context);\n    this.visit(ast.trueExp, context);\n    this.visit(ast.falseExp, context);\n  }\n  visitPipe(ast: BindingPipe, context: any): any {\n    this.visit(ast.exp, context);\n    this.visitAll(ast.args, context);\n  }\n  visitImplicitReceiver(ast: ThisReceiver, context: any): any {}\n  visitThisReceiver(ast: ThisReceiver, context: any): any {}\n  visitInterpolation(ast: Interpolation, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitKeyedRead(ast: KeyedRead, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n  }\n  visitKeyedWrite(ast: KeyedWrite, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n    this.visit(ast.value, context);\n  }\n  visitLiteralArray(ast: LiteralArray, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitLiteralMap(ast: LiteralMap, context: any): any {\n    this.visitAll(ast.values, context);\n  }\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any {}\n  visitPrefixNot(ast: PrefixNot, context: any): any {\n    this.visit(ast.expression, context);\n  }\n  visitNonNullAssert(ast: NonNullAssert, context: any): any {\n    this.visit(ast.expression, context);\n  }\n  visitPropertyRead(ast: PropertyRead, context: any): any {\n    this.visit(ast.receiver, context);\n  }\n  visitPropertyWrite(ast: PropertyWrite, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.value, context);\n  }\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n    this.visit(ast.receiver, context);\n  }\n  visitSafeKeyedRead(ast: SafeKeyedRead, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n  }\n  visitCall(ast: Call, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visitAll(ast.args, context);\n  }\n  visitSafeCall(ast: SafeCall, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visitAll(ast.args, context);\n  }\n  // This is not part of the AstVisitor interface, just a helper method\n  visitAll(asts: AST[], context: any): any {\n    for (const ast of asts) {\n      this.visit(ast, context);\n    }\n  }\n}\n\nexport class AstTransformer implements AstVisitor {\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitThisReceiver(ast: ThisReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitInterpolation(ast: Interpolation, context: any): AST {\n    return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));\n  }\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST {\n    return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);\n  }\n\n  visitPropertyRead(ast: PropertyRead, context: any): AST {\n    return new PropertyRead(\n        ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n  }\n\n  visitPropertyWrite(ast: PropertyWrite, context: any): AST {\n    return new PropertyWrite(\n        ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name,\n        ast.value.visit(this));\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): AST {\n    return new SafePropertyRead(\n        ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n  }\n\n  visitLiteralArray(ast: LiteralArray, context: any): AST {\n    return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n  }\n\n  visitLiteralMap(ast: LiteralMap, context: any): AST {\n    return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));\n  }\n\n  visitUnary(ast: Unary, context: any): AST {\n    switch (ast.operator) {\n      case '+':\n        return Unary.createPlus(ast.span, ast.sourceSpan, ast.expr.visit(this));\n      case '-':\n        return Unary.createMinus(ast.span, ast.sourceSpan, ast.expr.visit(this));\n      default:\n        throw new Error(`Unknown unary operator ${ast.operator}`);\n    }\n  }\n\n  visitBinary(ast: Binary, context: any): AST {\n    return new Binary(\n        ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));\n  }\n\n  visitPrefixNot(ast: PrefixNot, context: any): AST {\n    return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));\n  }\n\n  visitNonNullAssert(ast: NonNullAssert, context: any): AST {\n    return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));\n  }\n\n  visitConditional(ast: Conditional, context: any): AST {\n    return new Conditional(\n        ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this),\n        ast.falseExp.visit(this));\n  }\n\n  visitPipe(ast: BindingPipe, context: any): AST {\n    return new BindingPipe(\n        ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args),\n        ast.nameSpan);\n  }\n\n  visitKeyedRead(ast: KeyedRead, context: any): AST {\n    return new KeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));\n  }\n\n  visitKeyedWrite(ast: KeyedWrite, context: any): AST {\n    return new KeyedWrite(\n        ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this),\n        ast.value.visit(this));\n  }\n\n  visitCall(ast: Call, context: any): AST {\n    return new Call(\n        ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args),\n        ast.argumentSpan);\n  }\n\n  visitSafeCall(ast: SafeCall, context: any): AST {\n    return new SafeCall(\n        ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args),\n        ast.argumentSpan);\n  }\n\n  visitAll(asts: any[]): any[] {\n    const res = [];\n    for (let i = 0; i < asts.length; ++i) {\n      res[i] = asts[i].visit(this);\n    }\n    return res;\n  }\n\n  visitChain(ast: Chain, context: any): AST {\n    return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n  }\n\n  visitSafeKeyedRead(ast: SafeKeyedRead, context: any): AST {\n    return new SafeKeyedRead(\n        ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));\n  }\n}\n\n// A transformer that only creates new nodes if the transformer makes a change or\n// a change is made a child node.\nexport class AstMemoryEfficientTransformer implements AstVisitor {\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitThisReceiver(ast: ThisReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitInterpolation(ast: Interpolation, context: any): Interpolation {\n    const expressions = this.visitAll(ast.expressions);\n    if (expressions !== ast.expressions)\n      return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);\n    return ast;\n  }\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST {\n    return ast;\n  }\n\n  visitPropertyRead(ast: PropertyRead, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    if (receiver !== ast.receiver) {\n      return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n    }\n    return ast;\n  }\n\n  visitPropertyWrite(ast: PropertyWrite, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    const value = ast.value.visit(this);\n    if (receiver !== ast.receiver || value !== ast.value) {\n      return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, value);\n    }\n    return ast;\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    if (receiver !== ast.receiver) {\n      return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n    }\n    return ast;\n  }\n\n  visitLiteralArray(ast: LiteralArray, context: any): AST {\n    const expressions = this.visitAll(ast.expressions);\n    if (expressions !== ast.expressions) {\n      return new LiteralArray(ast.span, ast.sourceSpan, expressions);\n    }\n    return ast;\n  }\n\n  visitLiteralMap(ast: LiteralMap, context: any): AST {\n    const values = this.visitAll(ast.values);\n    if (values !== ast.values) {\n      return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);\n    }\n    return ast;\n  }\n\n  visitUnary(ast: Unary, context: any): AST {\n    const expr = ast.expr.visit(this);\n    if (expr !== ast.expr) {\n      switch (ast.operator) {\n        case '+':\n          return Unary.createPlus(ast.span, ast.sourceSpan, expr);\n        case '-':\n          return Unary.createMinus(ast.span, ast.sourceSpan, expr);\n        default:\n          throw new Error(`Unknown unary operator ${ast.operator}`);\n      }\n    }\n    return ast;\n  }\n\n  visitBinary(ast: Binary, context: any): AST {\n    const left = ast.left.visit(this);\n    const right = ast.right.visit(this);\n    if (left !== ast.left || right !== ast.right) {\n      return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);\n    }\n    return ast;\n  }\n\n  visitPrefixNot(ast: PrefixNot, context: any): AST {\n    const expression = ast.expression.visit(this);\n    if (expression !== ast.expression) {\n      return new PrefixNot(ast.span, ast.sourceSpan, expression);\n    }\n    return ast;\n  }\n\n  visitNonNullAssert(ast: NonNullAssert, context: any): AST {\n    const expression = ast.expression.visit(this);\n    if (expression !== ast.expression) {\n      return new NonNullAssert(ast.span, ast.sourceSpan, expression);\n    }\n    return ast;\n  }\n\n  visitConditional(ast: Conditional, context: any): AST {\n    const condition = ast.condition.visit(this);\n    const trueExp = ast.trueExp.visit(this);\n    const falseExp = ast.falseExp.visit(this);\n    if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {\n      return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);\n    }\n    return ast;\n  }\n\n  visitPipe(ast: BindingPipe, context: any): AST {\n    const exp = ast.exp.visit(this);\n    const args = this.visitAll(ast.args);\n    if (exp !== ast.exp || args !== ast.args) {\n      return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);\n    }\n    return ast;\n  }\n\n  visitKeyedRead(ast: KeyedRead, context: any): AST {\n    const obj = ast.receiver.visit(this);\n    const key = ast.key.visit(this);\n    if (obj !== ast.receiver || key !== ast.key) {\n      return new KeyedRead(ast.span, ast.sourceSpan, obj, key);\n    }\n    return ast;\n  }\n\n  visitKeyedWrite(ast: KeyedWrite, context: any): AST {\n    const obj = ast.receiver.visit(this);\n    const key = ast.key.visit(this);\n    const value = ast.value.visit(this);\n    if (obj !== ast.receiver || key !== ast.key || value !== ast.value) {\n      return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);\n    }\n    return ast;\n  }\n\n  visitAll(asts: any[]): any[] {\n    const res = [];\n    let modified = false;\n    for (let i = 0; i < asts.length; ++i) {\n      const original = asts[i];\n      const value = original.visit(this);\n      res[i] = value;\n      modified = modified || value !== original;\n    }\n    return modified ? res : asts;\n  }\n\n  visitChain(ast: Chain, context: any): AST {\n    const expressions = this.visitAll(ast.expressions);\n    if (expressions !== ast.expressions) {\n      return new Chain(ast.span, ast.sourceSpan, expressions);\n    }\n    return ast;\n  }\n\n\n  visitCall(ast: Call, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    const args = this.visitAll(ast.args);\n    if (receiver !== ast.receiver || args !== ast.args) {\n      return new Call(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);\n    }\n    return ast;\n  }\n\n  visitSafeCall(ast: SafeCall, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    const args = this.visitAll(ast.args);\n    if (receiver !== ast.receiver || args !== ast.args) {\n      return new SafeCall(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);\n    }\n    return ast;\n  }\n\n  visitSafeKeyedRead(ast: SafeKeyedRead, context: any): AST {\n    const obj = ast.receiver.visit(this);\n    const key = ast.key.visit(this);\n    if (obj !== ast.receiver || key !== ast.key) {\n      return new SafeKeyedRead(ast.span, ast.sourceSpan, obj, key);\n    }\n    return ast;\n  }\n}\n\n// Bindings\n\nexport class ParsedProperty {\n  public readonly isLiteral: boolean;\n  public readonly isAnimation: boolean;\n\n  constructor(\n      public name: string, public expression: ASTWithSource, public type: ParsedPropertyType,\n      public sourceSpan: ParseSourceSpan, readonly keySpan: ParseSourceSpan,\n      public valueSpan: ParseSourceSpan|undefined) {\n    this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;\n    this.isAnimation = this.type === ParsedPropertyType.ANIMATION;\n  }\n}\n\nexport enum ParsedPropertyType {\n  DEFAULT,\n  LITERAL_ATTR,\n  ANIMATION\n}\n\nexport const enum ParsedEventType {\n  // DOM or Directive event\n  Regular,\n  // Animation specific event\n  Animation,\n}\n\nexport class ParsedEvent {\n  // Regular events have a target\n  // Animation events have a phase\n  constructor(\n      public name: string, public targetOrPhase: string, public type: ParsedEventType,\n      public handler: ASTWithSource, public sourceSpan: ParseSourceSpan,\n      public handlerSpan: ParseSourceSpan, readonly keySpan: ParseSourceSpan) {}\n}\n\n/**\n * ParsedVariable represents a variable declaration in a microsyntax expression.\n */\nexport class ParsedVariable {\n  constructor(\n      public readonly name: string, public readonly value: string,\n      public readonly sourceSpan: ParseSourceSpan, public readonly keySpan: ParseSourceSpan,\n      public readonly valueSpan?: ParseSourceSpan) {}\n}\n\nexport const enum BindingType {\n  // A regular binding to a property (e.g. `[property]=\"expression\"`).\n  Property,\n  // A binding to an element attribute (e.g. `[attr.name]=\"expression\"`).\n  Attribute,\n  // A binding to a CSS class (e.g. `[class.name]=\"condition\"`).\n  Class,\n  // A binding to a style rule (e.g. `[style.rule]=\"expression\"`).\n  Style,\n  // A binding to an animation reference (e.g. `[animate.key]=\"expression\"`).\n  Animation,\n}\n\nexport class BoundElementProperty {\n  constructor(\n      public name: string, public type: BindingType, public securityContext: SecurityContext,\n      public value: ASTWithSource, public unit: string|null, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan|undefined, public valueSpan: ParseSourceSpan|undefined) {}\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as cdAst from '../expression_parser/ast';\nimport * as o from '../output/output_ast';\nimport {ParseSourceSpan} from '../parse_util';\n\nexport class EventHandlerVars {\n  static event = o.variable('$event');\n}\n\nexport interface LocalResolver {\n  getLocal(name: string): o.Expression|null;\n  notifyImplicitReceiverUse(): void;\n  globals?: Set<string>;\n  maybeRestoreView(): void;\n}\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n */\nexport function convertActionBinding(\n    localResolver: LocalResolver|null, implicitReceiver: o.Expression, action: cdAst.AST,\n    bindingId: string, baseSourceSpan?: ParseSourceSpan, implicitReceiverAccesses?: Set<string>,\n    globals?: Set<string>): o.Statement[] {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver(globals);\n  }\n  const actionWithoutBuiltins = convertPropertyBindingBuiltins(\n      {\n        createLiteralArrayConverter: (argCount: number) => {\n          // Note: no caching for literal arrays in actions.\n          return (args: o.Expression[]) => o.literalArr(args);\n        },\n        createLiteralMapConverter: (keys: {key: string, quoted: boolean}[]) => {\n          // Note: no caching for literal maps in actions.\n          return (values: o.Expression[]) => {\n            const entries = keys.map((k, i) => ({\n                                       key: k.key,\n                                       value: values[i],\n                                       quoted: k.quoted,\n                                     }));\n            return o.literalMap(entries);\n          };\n        },\n        createPipeConverter: (name: string) => {\n          throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);\n        }\n      },\n      action);\n\n  const visitor = new _AstToIrVisitor(\n      localResolver, implicitReceiver, bindingId, /* supportsInterpolation */ false, baseSourceSpan,\n      implicitReceiverAccesses);\n  const actionStmts: o.Statement[] = [];\n  flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n  prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  const lastIndex = actionStmts.length - 1;\n  if (lastIndex >= 0) {\n    const lastStatement = actionStmts[lastIndex];\n    // Ensure that the value of the last expression statement is returned\n    if (lastStatement instanceof o.ExpressionStatement) {\n      actionStmts[lastIndex] = new o.ReturnStatement(lastStatement.expr);\n    }\n  }\n  return actionStmts;\n}\n\nexport interface BuiltinConverter {\n  (args: o.Expression[]): o.Expression;\n}\n\nexport interface BuiltinConverterFactory {\n  createLiteralArrayConverter(argCount: number): BuiltinConverter;\n  createLiteralMapConverter(keys: {key: string, quoted: boolean}[]): BuiltinConverter;\n  createPipeConverter(name: string, argCount: number): BuiltinConverter;\n}\n\nexport function convertPropertyBindingBuiltins(\n    converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  return convertBuiltins(converterFactory, ast);\n}\n\nexport class ConvertPropertyBindingResult {\n  constructor(public stmts: o.Statement[], public currValExpr: o.Expression) {}\n}\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n */\nexport function convertPropertyBinding(\n    localResolver: LocalResolver|null, implicitReceiver: o.Expression,\n    expressionWithoutBuiltins: cdAst.AST, bindingId: string): ConvertPropertyBindingResult {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver();\n  }\n  const visitor = new _AstToIrVisitor(\n      localResolver, implicitReceiver, bindingId, /* supportsInterpolation */ false);\n  const outputExpr: o.Expression = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n  const stmts: o.Statement[] = getStatementsFromVisitor(visitor, bindingId);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  return new ConvertPropertyBindingResult(stmts, outputExpr);\n}\n\n/**\n * Given some expression, such as a binding or interpolation expression, and a context expression to\n * look values up on, visit each facet of the given expression resolving values from the context\n * expression such that a list of arguments can be derived from the found values that can be used as\n * arguments to an external update instruction.\n *\n * @param localResolver The resolver to use to look up expressions by name appropriately\n * @param contextVariableExpression The expression representing the context variable used to create\n * the final argument expressions\n * @param expressionWithArgumentsToExtract The expression to visit to figure out what values need to\n * be resolved and what arguments list to build.\n * @param bindingId A name prefix used to create temporary variable names if they're needed for the\n * arguments generated\n * @returns An array of expressions that can be passed as arguments to instruction expressions like\n * `o.importExpr(R3.propertyInterpolate).callFn(result)`\n */\nexport function convertUpdateArguments(\n    localResolver: LocalResolver, contextVariableExpression: o.Expression,\n    expressionWithArgumentsToExtract: cdAst.Interpolation, bindingId: string) {\n  const visitor = new _AstToIrVisitor(\n      localResolver, contextVariableExpression, bindingId, /* supportsInterpolation */ true);\n  const outputExpr = visitor.visitInterpolation(expressionWithArgumentsToExtract, _Mode.Expression);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  const stmts = getStatementsFromVisitor(visitor, bindingId);\n  const args = outputExpr.args;\n  return {stmts, args};\n}\n\nfunction getStatementsFromVisitor(visitor: _AstToIrVisitor, bindingId: string) {\n  const stmts: o.Statement[] = [];\n  for (let i = 0; i < visitor.temporaryCount; i++) {\n    stmts.push(temporaryDeclaration(bindingId, i));\n  }\n  return stmts;\n}\n\nfunction convertBuiltins(converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  const visitor = new _BuiltinAstConverter(converterFactory);\n  return ast.visit(visitor);\n}\n\nfunction temporaryName(bindingId: string, temporaryNumber: number): string {\n  return `tmp_${bindingId}_${temporaryNumber}`;\n}\n\nfunction temporaryDeclaration(bindingId: string, temporaryNumber: number): o.Statement {\n  return new o.DeclareVarStmt(temporaryName(bindingId, temporaryNumber));\n}\n\nfunction prependTemporaryDecls(\n    temporaryCount: number, bindingId: string, statements: o.Statement[]) {\n  for (let i = temporaryCount - 1; i >= 0; i--) {\n    statements.unshift(temporaryDeclaration(bindingId, i));\n  }\n}\n\nenum _Mode {\n  Statement,\n  Expression\n}\n\nfunction ensureStatementMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Statement) {\n    throw new Error(`Expected a statement, but saw ${ast}`);\n  }\n}\n\nfunction ensureExpressionMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Expression) {\n    throw new Error(`Expected an expression, but saw ${ast}`);\n  }\n}\n\nfunction convertToStatementIfNeeded(mode: _Mode, expr: o.Expression): o.Expression|o.Statement {\n  if (mode === _Mode.Statement) {\n    return expr.toStmt();\n  } else {\n    return expr;\n  }\n}\n\nclass _BuiltinAstConverter extends cdAst.AstTransformer {\n  constructor(private _converterFactory: BuiltinConverterFactory) {\n    super();\n  }\n  override visitPipe(ast: cdAst.BindingPipe, context: any): any {\n    const args = [ast.exp, ...ast.args].map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, ast.sourceSpan, args,\n        this._converterFactory.createPipeConverter(ast.name, args.length));\n  }\n  override visitLiteralArray(ast: cdAst.LiteralArray, context: any): any {\n    const args = ast.expressions.map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, ast.sourceSpan, args,\n        this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n  }\n  override visitLiteralMap(ast: cdAst.LiteralMap, context: any): any {\n    const args = ast.values.map(ast => ast.visit(this, context));\n\n    return new BuiltinFunctionCall(\n        ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n  }\n}\n\nclass _AstToIrVisitor implements cdAst.AstVisitor {\n  private _nodeMap = new Map<cdAst.AST, cdAst.AST>();\n  private _resultMap = new Map<cdAst.AST, o.Expression>();\n  private _currentTemporary: number = 0;\n  public temporaryCount: number = 0;\n  public usesImplicitReceiver: boolean = false;\n\n  constructor(\n      private _localResolver: LocalResolver, private _implicitReceiver: o.Expression,\n      private bindingId: string, private supportsInterpolation: boolean,\n      private baseSourceSpan?: ParseSourceSpan, private implicitReceiverAccesses?: Set<string>) {}\n\n  visitUnary(ast: cdAst.Unary, mode: _Mode): any {\n    let op: o.UnaryOperator;\n    switch (ast.operator) {\n      case '+':\n        op = o.UnaryOperator.Plus;\n        break;\n      case '-':\n        op = o.UnaryOperator.Minus;\n        break;\n      default:\n        throw new Error(`Unsupported operator ${ast.operator}`);\n    }\n\n    return convertToStatementIfNeeded(\n        mode,\n        new o.UnaryOperatorExpr(\n            op, this._visit(ast.expr, _Mode.Expression), undefined,\n            this.convertSourceSpan(ast.span)));\n  }\n\n  visitBinary(ast: cdAst.Binary, mode: _Mode): any {\n    let op: o.BinaryOperator;\n    switch (ast.operation) {\n      case '+':\n        op = o.BinaryOperator.Plus;\n        break;\n      case '-':\n        op = o.BinaryOperator.Minus;\n        break;\n      case '*':\n        op = o.BinaryOperator.Multiply;\n        break;\n      case '/':\n        op = o.BinaryOperator.Divide;\n        break;\n      case '%':\n        op = o.BinaryOperator.Modulo;\n        break;\n      case '&&':\n        op = o.BinaryOperator.And;\n        break;\n      case '||':\n        op = o.BinaryOperator.Or;\n        break;\n      case '==':\n        op = o.BinaryOperator.Equals;\n        break;\n      case '!=':\n        op = o.BinaryOperator.NotEquals;\n        break;\n      case '===':\n        op = o.BinaryOperator.Identical;\n        break;\n      case '!==':\n        op = o.BinaryOperator.NotIdentical;\n        break;\n      case '<':\n        op = o.BinaryOperator.Lower;\n        break;\n      case '>':\n        op = o.BinaryOperator.Bigger;\n        break;\n      case '<=':\n        op = o.BinaryOperator.LowerEquals;\n        break;\n      case '>=':\n        op = o.BinaryOperator.BiggerEquals;\n        break;\n      case '??':\n        return this.convertNullishCoalesce(ast, mode);\n      default:\n        throw new Error(`Unsupported operation ${ast.operation}`);\n    }\n\n    return convertToStatementIfNeeded(\n        mode,\n        new o.BinaryOperatorExpr(\n            op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression),\n            undefined, this.convertSourceSpan(ast.span)));\n  }\n\n  visitChain(ast: cdAst.Chain, mode: _Mode): any {\n    ensureStatementMode(mode, ast);\n    return this.visitAll(ast.expressions, mode);\n  }\n\n  visitConditional(ast: cdAst.Conditional, mode: _Mode): any {\n    const value: o.Expression = this._visit(ast.condition, _Mode.Expression);\n    return convertToStatementIfNeeded(\n        mode,\n        value.conditional(\n            this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression),\n            this.convertSourceSpan(ast.span)));\n  }\n\n  visitPipe(ast: cdAst.BindingPipe, mode: _Mode): any {\n    throw new Error(\n        `Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);\n  }\n\n  visitImplicitReceiver(ast: cdAst.ImplicitReceiver, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    this.usesImplicitReceiver = true;\n    return this._implicitReceiver;\n  }\n\n  visitThisReceiver(ast: cdAst.ThisReceiver, mode: _Mode): any {\n    return this.visitImplicitReceiver(ast, mode);\n  }\n\n  visitInterpolation(ast: cdAst.Interpolation, mode: _Mode): InterpolationExpression {\n    if (!this.supportsInterpolation) {\n      throw new Error('Unexpected interpolation');\n    }\n\n    ensureExpressionMode(mode, ast);\n    let args: o.Expression[] = [];\n    for (let i = 0; i < ast.strings.length - 1; i++) {\n      args.push(o.literal(ast.strings[i]));\n      args.push(this._visit(ast.expressions[i], _Mode.Expression));\n    }\n    args.push(o.literal(ast.strings[ast.strings.length - 1]));\n\n    // If we're dealing with an interpolation of 1 value with an empty prefix and suffix, reduce the\n    // args returned to just the value, because we're going to pass it to a special instruction.\n    const strings = ast.strings;\n    if (strings.length === 2 && strings[0] === '' && strings[1] === '') {\n      // Single argument interpolate instructions.\n      args = [args[1]];\n    } else if (ast.expressions.length >= 9) {\n      // 9 or more arguments must be passed to the `interpolateV`-style instructions, which accept\n      // an array of arguments\n      args = [o.literalArr(args)];\n    }\n\n    return new InterpolationExpression(args);\n  }\n\n  visitKeyedRead(ast: cdAst.KeyedRead, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      return convertToStatementIfNeeded(\n          mode,\n          this._visit(ast.receiver, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n    }\n  }\n\n  visitKeyedWrite(ast: cdAst.KeyedWrite, mode: _Mode): any {\n    const obj: o.Expression = this._visit(ast.receiver, _Mode.Expression);\n    const key: o.Expression = this._visit(ast.key, _Mode.Expression);\n    const value: o.Expression = this._visit(ast.value, _Mode.Expression);\n\n    if (obj === this._implicitReceiver) {\n      this._localResolver.maybeRestoreView();\n    }\n\n    return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n  }\n\n  visitLiteralArray(ast: cdAst.LiteralArray, mode: _Mode): any {\n    throw new Error(`Illegal State: literal arrays should have been converted into functions`);\n  }\n\n  visitLiteralMap(ast: cdAst.LiteralMap, mode: _Mode): any {\n    throw new Error(`Illegal State: literal maps should have been converted into functions`);\n  }\n\n  visitLiteralPrimitive(ast: cdAst.LiteralPrimitive, mode: _Mode): any {\n    // For literal values of null, undefined, true, or false allow type interference\n    // to infer the type.\n    const type =\n        ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ?\n        o.INFERRED_TYPE :\n        undefined;\n    return convertToStatementIfNeeded(\n        mode, o.literal(ast.value, type, this.convertSourceSpan(ast.span)));\n  }\n\n  private _getLocal(name: string, receiver: cdAst.AST): o.Expression|null {\n    if (this._localResolver.globals?.has(name) && receiver instanceof cdAst.ThisReceiver) {\n      return null;\n    }\n\n    return this._localResolver.getLocal(name);\n  }\n\n  visitPrefixNot(ast: cdAst.PrefixNot, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, o.not(this._visit(ast.expression, _Mode.Expression)));\n  }\n\n  visitNonNullAssert(ast: cdAst.NonNullAssert, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, this._visit(ast.expression, _Mode.Expression));\n  }\n\n  visitPropertyRead(ast: cdAst.PropertyRead, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      let result: any = null;\n      const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n      const receiver = this._visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        result = this._getLocal(ast.name, ast.receiver);\n        if (result) {\n          // Restore the previous \"usesImplicitReceiver\" state since the implicit\n          // receiver has been replaced with a resolved local expression.\n          this.usesImplicitReceiver = prevUsesImplicitReceiver;\n          this.addImplicitReceiverAccess(ast.name);\n        }\n      }\n      if (result == null) {\n        result = receiver.prop(ast.name, this.convertSourceSpan(ast.span));\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n\n  visitPropertyWrite(ast: cdAst.PropertyWrite, mode: _Mode): any {\n    const receiver: o.Expression = this._visit(ast.receiver, _Mode.Expression);\n    const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n\n    let varExpr: o.ReadPropExpr|null = null;\n    if (receiver === this._implicitReceiver) {\n      const localExpr = this._getLocal(ast.name, ast.receiver);\n      if (localExpr) {\n        if (localExpr instanceof o.ReadPropExpr) {\n          // If the local variable is a property read expression, it's a reference\n          // to a 'context.property' value and will be used as the target of the\n          // write expression.\n          varExpr = localExpr;\n          // Restore the previous \"usesImplicitReceiver\" state since the implicit\n          // receiver has been replaced with a resolved local expression.\n          this.usesImplicitReceiver = prevUsesImplicitReceiver;\n          this.addImplicitReceiverAccess(ast.name);\n        } else {\n          // Otherwise it's an error.\n          const receiver = ast.name;\n          const value = (ast.value instanceof cdAst.PropertyRead) ? ast.value.name : undefined;\n          throw new Error(`Cannot assign value \"${value}\" to template variable \"${\n              receiver}\". Template variables are read-only.`);\n        }\n      }\n    }\n    // If no local expression could be produced, use the original receiver's\n    // property as the target.\n    if (varExpr === null) {\n      varExpr = receiver.prop(ast.name, this.convertSourceSpan(ast.span));\n    }\n    return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));\n  }\n\n  visitSafePropertyRead(ast: cdAst.SafePropertyRead, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitSafeKeyedRead(ast: cdAst.SafeKeyedRead, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitAll(asts: cdAst.AST[], mode: _Mode): any {\n    return asts.map(ast => this._visit(ast, mode));\n  }\n\n  visitCall(ast: cdAst.Call, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    }\n\n    const convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n\n    if (ast instanceof BuiltinFunctionCall) {\n      return convertToStatementIfNeeded(mode, ast.converter(convertedArgs));\n    }\n\n    const receiver = ast.receiver;\n    if (receiver instanceof cdAst.PropertyRead &&\n        receiver.receiver instanceof cdAst.ImplicitReceiver &&\n        !(receiver.receiver instanceof cdAst.ThisReceiver) && receiver.name === '$any') {\n      if (convertedArgs.length !== 1) {\n        throw new Error(`Invalid call to $any, expected 1 argument but received ${\n            convertedArgs.length || 'none'}`);\n      }\n      return convertToStatementIfNeeded(mode, convertedArgs[0] as o.Expression);\n    }\n\n    const call = this._visit(receiver, _Mode.Expression)\n                     .callFn(convertedArgs, this.convertSourceSpan(ast.span));\n    return convertToStatementIfNeeded(mode, call);\n  }\n\n  visitSafeCall(ast: cdAst.SafeCall, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  private _visit(ast: cdAst.AST, mode: _Mode): any {\n    const result = this._resultMap.get(ast);\n    if (result) return result;\n    return (this._nodeMap.get(ast) || ast).visit(this, mode);\n  }\n\n  private convertSafeAccess(\n      ast: cdAst.AST, leftMostSafe: cdAst.SafePropertyRead|cdAst.SafeKeyedRead|cdAst.SafeCall,\n      mode: _Mode): any {\n    // If the expression contains a safe access node on the left it needs to be converted to\n    // an expression that guards the access to the member by checking the receiver for blank. As\n    // execution proceeds from left to right, the left most part of the expression must be guarded\n    // first but, because member access is left associative, the right side of the expression is at\n    // the top of the AST. The desired result requires lifting a copy of the left part of the\n    // expression up to test it for blank before generating the unguarded version.\n\n    // Consider, for example the following expression: a?.b.c?.d.e\n\n    // This results in the ast:\n    //         .\n    //        / \\\n    //       ?.   e\n    //      /  \\\n    //     .    d\n    //    / \\\n    //   ?.  c\n    //  /  \\\n    // a    b\n\n    // The following tree should be generated:\n    //\n    //        /---- ? ----\\\n    //       /      |      \\\n    //     a   /--- ? ---\\  null\n    //        /     |     \\\n    //       .      .     null\n    //      / \\    / \\\n    //     .  c   .   e\n    //    / \\    / \\\n    //   a   b  .   d\n    //         / \\\n    //        .   c\n    //       / \\\n    //      a   b\n    //\n    // Notice that the first guard condition is the left hand of the left most safe access node\n    // which comes in as leftMostSafe to this routine.\n\n    let guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\n    let temporary: o.ReadVarExpr|undefined = undefined;\n    if (this.needsTemporaryInSafeAccess(leftMostSafe.receiver)) {\n      // If the expression has method calls or pipes then we need to save the result into a\n      // temporary variable to avoid calling stateful or impure code more than once.\n      temporary = this.allocateTemporary();\n\n      // Preserve the result in the temporary variable\n      guardedExpression = temporary.set(guardedExpression);\n\n      // Ensure all further references to the guarded expression refer to the temporary instead.\n      this._resultMap.set(leftMostSafe.receiver, temporary);\n    }\n    const condition = guardedExpression.isBlank();\n\n    // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n    // leftMostNode with its unguarded version in the call to `this.visit()`.\n    if (leftMostSafe instanceof cdAst.SafeCall) {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.Call(\n              leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.args,\n              leftMostSafe.argumentSpan));\n    } else if (leftMostSafe instanceof cdAst.SafeKeyedRead) {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.KeyedRead(\n              leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.key));\n    } else {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.PropertyRead(\n              leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan,\n              leftMostSafe.receiver, leftMostSafe.name));\n    }\n\n    // Recursively convert the node now without the guarded member access.\n    const access = this._visit(ast, _Mode.Expression);\n\n    // Remove the mapping. This is not strictly required as the converter only traverses each node\n    // once but is safer if the conversion is changed to traverse the nodes more than once.\n    this._nodeMap.delete(leftMostSafe);\n\n    // If we allocated a temporary, release it.\n    if (temporary) {\n      this.releaseTemporary(temporary);\n    }\n\n    // Produce the conditional\n    return convertToStatementIfNeeded(mode, condition.conditional(o.NULL_EXPR, access));\n  }\n\n  private convertNullishCoalesce(ast: cdAst.Binary, mode: _Mode): any {\n    const left: o.Expression = this._visit(ast.left, _Mode.Expression);\n    const right: o.Expression = this._visit(ast.right, _Mode.Expression);\n    const temporary = this.allocateTemporary();\n    this.releaseTemporary(temporary);\n\n    // Generate the following expression. It is identical to how TS\n    // transpiles binary expressions with a nullish coalescing operator.\n    // let temp;\n    // (temp = a) !== null && temp !== undefined ? temp : b;\n    return convertToStatementIfNeeded(\n        mode,\n        temporary.set(left)\n            .notIdentical(o.NULL_EXPR)\n            .and(temporary.notIdentical(o.literal(undefined)))\n            .conditional(temporary, right));\n  }\n\n  // Given an expression of the form a?.b.c?.d.e then the left most safe node is\n  // the (a?.b). The . and ?. are left associative thus can be rewritten as:\n  // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or\n  // safe method call as this needs to be transformed initially to:\n  //   a == null ? null : a.c.b.c?.d.e\n  // then to:\n  //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\n  private leftMostSafeNode(ast: cdAst.AST): cdAst.SafePropertyRead|cdAst.SafeKeyedRead {\n    const visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): any => {\n      return (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    return ast.visit({\n      visitUnary(ast: cdAst.Unary) {\n        return null;\n      },\n      visitBinary(ast: cdAst.Binary) {\n        return null;\n      },\n      visitChain(ast: cdAst.Chain) {\n        return null;\n      },\n      visitConditional(ast: cdAst.Conditional) {\n        return null;\n      },\n      visitCall(ast: cdAst.Call) {\n        return visit(this, ast.receiver);\n      },\n      visitSafeCall(ast: cdAst.SafeCall) {\n        return visit(this, ast.receiver) || ast;\n      },\n      visitImplicitReceiver(ast: cdAst.ImplicitReceiver) {\n        return null;\n      },\n      visitThisReceiver(ast: cdAst.ThisReceiver) {\n        return null;\n      },\n      visitInterpolation(ast: cdAst.Interpolation) {\n        return null;\n      },\n      visitKeyedRead(ast: cdAst.KeyedRead) {\n        return visit(this, ast.receiver);\n      },\n      visitKeyedWrite(ast: cdAst.KeyedWrite) {\n        return null;\n      },\n      visitLiteralArray(ast: cdAst.LiteralArray) {\n        return null;\n      },\n      visitLiteralMap(ast: cdAst.LiteralMap) {\n        return null;\n      },\n      visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) {\n        return null;\n      },\n      visitPipe(ast: cdAst.BindingPipe) {\n        return null;\n      },\n      visitPrefixNot(ast: cdAst.PrefixNot) {\n        return null;\n      },\n      visitNonNullAssert(ast: cdAst.NonNullAssert) {\n        return null;\n      },\n      visitPropertyRead(ast: cdAst.PropertyRead) {\n        return visit(this, ast.receiver);\n      },\n      visitPropertyWrite(ast: cdAst.PropertyWrite) {\n        return null;\n      },\n      visitSafePropertyRead(ast: cdAst.SafePropertyRead) {\n        return visit(this, ast.receiver) || ast;\n      },\n      visitSafeKeyedRead(ast: cdAst.SafeKeyedRead) {\n        return visit(this, ast.receiver) || ast;\n      }\n    });\n  }\n\n  // Returns true of the AST includes a method or a pipe indicating that, if the\n  // expression is used as the target of a safe property or method access then\n  // the expression should be stored into a temporary variable.\n  private needsTemporaryInSafeAccess(ast: cdAst.AST): boolean {\n    const visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): boolean => {\n      return ast && (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    const visitSome = (visitor: cdAst.AstVisitor, ast: cdAst.AST[]): boolean => {\n      return ast.some(ast => visit(visitor, ast));\n    };\n    return ast.visit({\n      visitUnary(ast: cdAst.Unary): boolean {\n        return visit(this, ast.expr);\n      },\n      visitBinary(ast: cdAst.Binary): boolean {\n        return visit(this, ast.left) || visit(this, ast.right);\n      },\n      visitChain(ast: cdAst.Chain) {\n        return false;\n      },\n      visitConditional(ast: cdAst.Conditional): boolean {\n        return visit(this, ast.condition) || visit(this, ast.trueExp) || visit(this, ast.falseExp);\n      },\n      visitCall(ast: cdAst.Call) {\n        return true;\n      },\n      visitSafeCall(ast: cdAst.SafeCall) {\n        return true;\n      },\n      visitImplicitReceiver(ast: cdAst.ImplicitReceiver) {\n        return false;\n      },\n      visitThisReceiver(ast: cdAst.ThisReceiver) {\n        return false;\n      },\n      visitInterpolation(ast: cdAst.Interpolation) {\n        return visitSome(this, ast.expressions);\n      },\n      visitKeyedRead(ast: cdAst.KeyedRead) {\n        return false;\n      },\n      visitKeyedWrite(ast: cdAst.KeyedWrite) {\n        return false;\n      },\n      visitLiteralArray(ast: cdAst.LiteralArray) {\n        return true;\n      },\n      visitLiteralMap(ast: cdAst.LiteralMap) {\n        return true;\n      },\n      visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) {\n        return false;\n      },\n      visitPipe(ast: cdAst.BindingPipe) {\n        return true;\n      },\n      visitPrefixNot(ast: cdAst.PrefixNot) {\n        return visit(this, ast.expression);\n      },\n      visitNonNullAssert(ast: cdAst.PrefixNot) {\n        return visit(this, ast.expression);\n      },\n      visitPropertyRead(ast: cdAst.PropertyRead) {\n        return false;\n      },\n      visitPropertyWrite(ast: cdAst.PropertyWrite) {\n        return false;\n      },\n      visitSafePropertyRead(ast: cdAst.SafePropertyRead) {\n        return false;\n      },\n      visitSafeKeyedRead(ast: cdAst.SafeKeyedRead) {\n        return false;\n      }\n    });\n  }\n\n  private allocateTemporary(): o.ReadVarExpr {\n    const tempNumber = this._currentTemporary++;\n    this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n    return new o.ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n  }\n\n  private releaseTemporary(temporary: o.ReadVarExpr) {\n    this._currentTemporary--;\n    if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n      throw new Error(`Temporary ${temporary.name} released out of order`);\n    }\n  }\n\n  /**\n   * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.\n   *\n   * `ParseSpan` objects are relative to the start of the expression.\n   * This method converts these to full `ParseSourceSpan` objects that\n   * show where the span is within the overall source file.\n   *\n   * @param span the relative span to convert.\n   * @returns a `ParseSourceSpan` for the given span or null if no\n   * `baseSourceSpan` was provided to this class.\n   */\n  private convertSourceSpan(span: cdAst.ParseSpan) {\n    if (this.baseSourceSpan) {\n      const start = this.baseSourceSpan.start.moveBy(span.start);\n      const end = this.baseSourceSpan.start.moveBy(span.end);\n      const fullStart = this.baseSourceSpan.fullStart.moveBy(span.start);\n      return new ParseSourceSpan(start, end, fullStart);\n    } else {\n      return null;\n    }\n  }\n\n  /** Adds the name of an AST to the list of implicit receiver accesses. */\n  private addImplicitReceiverAccess(name: string) {\n    if (this.implicitReceiverAccesses) {\n      this.implicitReceiverAccesses.add(name);\n    }\n  }\n}\n\nfunction flattenStatements(arg: any, output: o.Statement[]) {\n  if (Array.isArray(arg)) {\n    (<any[]>arg).forEach((entry) => flattenStatements(entry, output));\n  } else {\n    output.push(arg);\n  }\n}\n\nfunction unsupported(): never {\n  throw new Error('Unsupported operation');\n}\n\nclass InterpolationExpression extends o.Expression {\n  constructor(public args: o.Expression[]) {\n    super(null, null);\n  }\n\n  override isConstant = unsupported;\n  override isEquivalent = unsupported;\n  override visitExpression = unsupported;\n}\n\nclass DefaultLocalResolver implements LocalResolver {\n  constructor(public globals?: Set<string>) {}\n  notifyImplicitReceiverUse(): void {}\n  maybeRestoreView(): void {}\n  getLocal(name: string): o.Expression|null {\n    if (name === EventHandlerVars.event.name) {\n      return EventHandlerVars.event;\n    }\n    return null;\n  }\n}\n\nexport class BuiltinFunctionCall extends cdAst.Call {\n  constructor(\n      span: cdAst.ParseSpan, sourceSpan: cdAst.AbsoluteSourceSpan, args: cdAst.AST[],\n      public converter: BuiltinConverter) {\n    super(span, sourceSpan, new cdAst.EmptyExpr(span, sourceSpan), args, null!);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '../core';\n\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!\n//                               Reach out to mprobst for details.\n//\n// =================================================================================================\n\n/** Map from tagName|propertyName to SecurityContext. Properties applying to all tags use '*'. */\nlet _SECURITY_SCHEMA!: {[k: string]: SecurityContext};\n\nexport function SECURITY_SCHEMA(): {[k: string]: SecurityContext} {\n  if (!_SECURITY_SCHEMA) {\n    _SECURITY_SCHEMA = {};\n    // Case is insignificant below, all element and attribute names are lower-cased for lookup.\n\n    registerContext(SecurityContext.HTML, [\n      'iframe|srcdoc',\n      '*|innerHTML',\n      '*|outerHTML',\n    ]);\n    registerContext(SecurityContext.STYLE, ['*|style']);\n    // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.\n    registerContext(SecurityContext.URL, [\n      '*|formAction',\n      'area|href',\n      'area|ping',\n      'audio|src',\n      'a|href',\n      'a|ping',\n      'blockquote|cite',\n      'body|background',\n      'del|cite',\n      'form|action',\n      'img|src',\n      'input|src',\n      'ins|cite',\n      'q|cite',\n      'source|src',\n      'track|src',\n      'video|poster',\n      'video|src',\n    ]);\n    registerContext(SecurityContext.RESOURCE_URL, [\n      'applet|code',\n      'applet|codebase',\n      'base|href',\n      'embed|src',\n      'frame|src',\n      'head|profile',\n      'html|manifest',\n      'iframe|src',\n      'link|href',\n      'media|src',\n      'object|codebase',\n      'object|data',\n      'script|src',\n    ]);\n  }\n  return _SECURITY_SCHEMA;\n}\n\nfunction registerContext(ctx: SecurityContext, specs: string[]) {\n  for (const spec of specs) _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\n}\n\n/**\n * The set of security-sensitive attributes of an `<iframe>` that *must* be\n * applied as a static attribute only. This ensures that all security-sensitive\n * attributes are taken into account while creating an instance of an `<iframe>`\n * at runtime.\n *\n * Note: avoid using this set directly, use the `isIframeSecuritySensitiveAttr` function\n * in the code instead.\n */\nexport const IFRAME_SECURITY_SENSITIVE_ATTRS =\n    new Set(['sandbox', 'allow', 'allowfullscreen', 'referrerpolicy', 'csp', 'fetchpriority']);\n\n/**\n * Checks whether a given attribute name might represent a security-sensitive\n * attribute of an <iframe>.\n */\nexport function isIframeSecuritySensitiveAttr(attrName: string): boolean {\n  // The `setAttribute` DOM API is case-insensitive, so we lowercase the value\n  // before checking it against a known security-sensitive attributes.\n  return IFRAME_SECURITY_SENSITIVE_ATTRS.has(attrName.toLowerCase());\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The following set contains all keywords that can be used in the animation css shorthand\n * property and is used during the scoping of keyframes to make sure such keywords\n * are not modified.\n */\nconst animationKeywords = new Set([\n  // global values\n  'inherit', 'initial', 'revert', 'unset',\n  // animation-direction\n  'alternate', 'alternate-reverse', 'normal', 'reverse',\n  // animation-fill-mode\n  'backwards', 'both', 'forwards', 'none',\n  // animation-play-state\n  'paused', 'running',\n  // animation-timing-function\n  'ease', 'ease-in', 'ease-in-out', 'ease-out', 'linear', 'step-start', 'step-end',\n  // `steps()` function\n  'end', 'jump-both', 'jump-end', 'jump-none', 'jump-start', 'start'\n]);\n\n/**\n * The following class is a port of shadowCSS from webcomponents.js to TypeScript.\n *\n * Please make sure to keep to edits in sync with the source file.\n *\n * Source:\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\n *\n * The original file level comment is reproduced below\n */\n\n/*\n  This is a limited shim for ShadowDOM css styling.\n  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles\n\n  The intention here is to support only the styling features which can be\n  relatively simply implemented. The goal is to allow users to avoid the\n  most obvious pitfalls and do so without compromising performance significantly.\n  For ShadowDOM styling that's not covered here, a set of best practices\n  can be provided that should allow users to accomplish more complex styling.\n\n  The following is a list of specific ShadowDOM styling features and a brief\n  discussion of the approach used to shim.\n\n  Shimmed features:\n\n  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host\n  element using the :host rule. To shim this feature, the :host styles are\n  reformatted and prefixed with a given scope name and promoted to a\n  document level stylesheet.\n  For example, given a scope name of .foo, a rule like this:\n\n    :host {\n        background: red;\n      }\n    }\n\n  becomes:\n\n    .foo {\n      background: red;\n    }\n\n  * encapsulation: Styles defined within ShadowDOM, apply only to\n  dom inside the ShadowDOM. Polymer uses one of two techniques to implement\n  this feature.\n\n  By default, rules are prefixed with the host element tag name\n  as a descendant selector. This ensures styling does not leak out of the 'top'\n  of the element's ShadowDOM. For example,\n\n  div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n  x-foo div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n\n  Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then\n  selectors are scoped by adding an attribute selector suffix to each\n  simple selector that contains the host element tag name. Each element\n  in the element's ShadowDOM template is also given the scope attribute.\n  Thus, these rules match only elements that have the scope attribute.\n  For example, given a scope name of x-foo, a rule like this:\n\n    div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n    div[x-foo] {\n      font-weight: bold;\n    }\n\n  Note that elements that are dynamically added to a scope must have the scope\n  selector added to them manually.\n\n  * upper/lower bound encapsulation: Styles which are defined outside a\n  shadowRoot should not cross the ShadowDOM boundary and should not apply\n  inside a shadowRoot.\n\n  This styling behavior is not emulated. Some possible ways to do this that\n  were rejected due to complexity and/or performance concerns include: (1) reset\n  every possible property for every possible selector for a given scope name;\n  (2) re-implement css in javascript.\n\n  As an alternative, users should make sure to use selectors\n  specific to the scope in which they are working.\n\n  * ::distributed: This behavior is not emulated. It's often not necessary\n  to style the contents of a specific insertion point and instead, descendants\n  of the host element can be styled selectively. Users can also create an\n  extra node around an insertion point and style that node's contents\n  via descendent selectors. For example, with a shadowRoot like this:\n\n    <style>\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <content></content>\n\n  could become:\n\n    <style>\n      / *@polyfill .content-container div * /\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <div class=\"content-container\">\n      <content></content>\n    </div>\n\n  Note the use of @polyfill in the comment above a ShadowDOM specific style\n  declaration. This is a directive to the styling shim to use the selector\n  in comments in lieu of the next selector when running under polyfill.\n*/\nexport class ShadowCss {\n  strictStyling: boolean = true;\n\n  /*\n   * Shim some cssText with the given selector. Returns cssText that can\n   * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).\n   *\n   * When strictStyling is true:\n   * - selector is the attribute added to all elements inside the host,\n   * - hostSelector is the attribute added to the host itself.\n   */\n  shimCssText(cssText: string, selector: string, hostSelector: string = ''): string {\n    const commentsWithHash = extractCommentsWithHash(cssText);\n    cssText = stripComments(cssText);\n    cssText = this._insertDirectives(cssText);\n\n    const scopedCssText = this._scopeCssText(cssText, selector, hostSelector);\n    return [scopedCssText, ...commentsWithHash].join('\\n');\n  }\n\n  private _insertDirectives(cssText: string): string {\n    cssText = this._insertPolyfillDirectivesInCssText(cssText);\n    return this._insertPolyfillRulesInCssText(cssText);\n  }\n\n  /**\n   * Process styles to add scope to keyframes.\n   *\n   * Modify both the names of the keyframes defined in the component styles and also the css\n   * animation rules using them.\n   *\n   * Animation rules using keyframes defined elsewhere are not modified to allow for globally\n   * defined keyframes.\n   *\n   * For example, we convert this css:\n   *\n   * ```\n   * .box {\n   *   animation: box-animation 1s forwards;\n   * }\n   *\n   * @keyframes box-animation {\n   *   to {\n   *     background-color: green;\n   *   }\n   * }\n   * ```\n   *\n   * to this:\n   *\n   * ```\n   * .box {\n   *   animation: scopeName_box-animation 1s forwards;\n   * }\n   *\n   * @keyframes scopeName_box-animation {\n   *   to {\n   *     background-color: green;\n   *   }\n   * }\n   * ```\n   *\n   * @param cssText the component's css text that needs to be scoped.\n   * @param scopeSelector the component's scope selector.\n   *\n   * @returns the scoped css text.\n   */\n  private _scopeKeyframesRelatedCss(cssText: string, scopeSelector: string): string {\n    const unscopedKeyframesSet = new Set<string>();\n    const scopedKeyframesCssText = processRules(\n        cssText,\n        rule => this._scopeLocalKeyframeDeclarations(rule, scopeSelector, unscopedKeyframesSet));\n    return processRules(\n        scopedKeyframesCssText,\n        rule => this._scopeAnimationRule(rule, scopeSelector, unscopedKeyframesSet));\n  }\n\n  /**\n   * Scopes local keyframes names, returning the updated css rule and it also\n   * adds the original keyframe name to a provided set to collect all keyframes names\n   * so that it can later be used to scope the animation rules.\n   *\n   * For example, it takes a rule such as:\n   *\n   * ```\n   * @keyframes box-animation {\n   *   to {\n   *     background-color: green;\n   *   }\n   * }\n   * ```\n   *\n   * and returns:\n   *\n   * ```\n   * @keyframes scopeName_box-animation {\n   *   to {\n   *     background-color: green;\n   *   }\n   * }\n   * ```\n   * and as a side effect it adds \"box-animation\" to the `unscopedKeyframesSet` set\n   *\n   * @param cssRule the css rule to process.\n   * @param scopeSelector the component's scope selector.\n   * @param unscopedKeyframesSet the set of unscoped keyframes names (which can be\n   * modified as a side effect)\n   *\n   * @returns the css rule modified with the scoped keyframes name.\n   */\n  private _scopeLocalKeyframeDeclarations(\n      rule: CssRule, scopeSelector: string, unscopedKeyframesSet: Set<string>): CssRule {\n    return {\n      ...rule,\n      selector: rule.selector.replace(\n          /(^@(?:-webkit-)?keyframes(?:\\s+))(['\"]?)(.+)\\2(\\s*)$/,\n          (_, start, quote, keyframeName, endSpaces) => {\n            unscopedKeyframesSet.add(unescapeQuotes(keyframeName, quote));\n            return `${start}${quote}${scopeSelector}_${keyframeName}${quote}${endSpaces}`;\n          }),\n    };\n  }\n\n  /**\n   * Function used to scope a keyframes name (obtained from an animation declaration)\n   * using an existing set of unscopedKeyframes names to discern if the scoping needs to be\n   * performed (keyframes names of keyframes not defined in the component's css need not to be\n   * scoped).\n   *\n   * @param keyframe the keyframes name to check.\n   * @param scopeSelector the component's scope selector.\n   * @param unscopedKeyframesSet the set of unscoped keyframes names.\n   *\n   * @returns the scoped name of the keyframe, or the original name is the name need not to be\n   * scoped.\n   */\n  private _scopeAnimationKeyframe(\n      keyframe: string, scopeSelector: string, unscopedKeyframesSet: ReadonlySet<string>): string {\n    return keyframe.replace(/^(\\s*)(['\"]?)(.+?)\\2(\\s*)$/, (_, spaces1, quote, name, spaces2) => {\n      name = `${unscopedKeyframesSet.has(unescapeQuotes(name, quote)) ? scopeSelector + '_' : ''}${\n          name}`;\n      return `${spaces1}${quote}${name}${quote}${spaces2}`;\n    });\n  }\n\n  /**\n   * Regular expression used to extrapolate the possible keyframes from an\n   * animation declaration (with possibly multiple animation definitions)\n   *\n   * The regular expression can be divided in three parts\n   *  - (^|\\s+)\n   *    simply captures how many (if any) leading whitespaces are present\n   *  - (?:(?:(['\"])((?:\\\\\\\\|\\\\\\2|(?!\\2).)+)\\2)|(-?[A-Za-z][\\w\\-]*))\n   *    captures two different possible keyframes, ones which are quoted or ones which are valid css\n   * idents (custom properties excluded)\n   *  - (?=[,\\s;]|$)\n   *    simply matches the end of the possible keyframe, valid endings are: a comma, a space, a\n   * semicolon or the end of the string\n   */\n  private _animationDeclarationKeyframesRe =\n      /(^|\\s+)(?:(?:(['\"])((?:\\\\\\\\|\\\\\\2|(?!\\2).)+)\\2)|(-?[A-Za-z][\\w\\-]*))(?=[,\\s]|$)/g;\n\n  /**\n   * Scope an animation rule so that the keyframes mentioned in such rule\n   * are scoped if defined in the component's css and left untouched otherwise.\n   *\n   * It can scope values of both the 'animation' and 'animation-name' properties.\n   *\n   * @param rule css rule to scope.\n   * @param scopeSelector the component's scope selector.\n   * @param unscopedKeyframesSet the set of unscoped keyframes names.\n   *\n   * @returns the updated css rule.\n   **/\n  private _scopeAnimationRule(\n      rule: CssRule, scopeSelector: string, unscopedKeyframesSet: ReadonlySet<string>): CssRule {\n    let content = rule.content.replace(\n        /((?:^|\\s+|;)(?:-webkit-)?animation(?:\\s*):(?:\\s*))([^;]+)/g,\n        (_, start, animationDeclarations) => start +\n            animationDeclarations.replace(\n                this._animationDeclarationKeyframesRe,\n                (original: string, leadingSpaces: string, quote = '', quotedName: string,\n                 nonQuotedName: string) => {\n                  if (quotedName) {\n                    return `${leadingSpaces}${\n                        this._scopeAnimationKeyframe(\n                            `${quote}${quotedName}${quote}`, scopeSelector, unscopedKeyframesSet)}`;\n                  } else {\n                    return animationKeywords.has(nonQuotedName) ?\n                        original :\n                        `${leadingSpaces}${\n                            this._scopeAnimationKeyframe(\n                                nonQuotedName, scopeSelector, unscopedKeyframesSet)}`;\n                  }\n                }));\n    content = content.replace(\n        /((?:^|\\s+|;)(?:-webkit-)?animation-name(?:\\s*):(?:\\s*))([^;]+)/g,\n        (_match, start, commaSeparatedKeyframes) => `${start}${\n            commaSeparatedKeyframes.split(',')\n                .map(\n                    (keyframe: string) =>\n                        this._scopeAnimationKeyframe(keyframe, scopeSelector, unscopedKeyframesSet))\n                .join(',')}`);\n    return {...rule, content};\n  }\n\n  /*\n   * Process styles to convert native ShadowDOM rules that will trip\n   * up the css parser; we rely on decorating the stylesheet with inert rules.\n   *\n   * For example, we convert this rule:\n   *\n   * polyfill-next-selector { content: ':host menu-item'; }\n   * ::content menu-item {\n   *\n   * to this:\n   *\n   * scopeName menu-item {\n   *\n   **/\n  private _insertPolyfillDirectivesInCssText(cssText: string): string {\n    // Difference with webcomponents.js: does not handle comments\n    return cssText.replace(_cssContentNextSelectorRe, function(...m: string[]) {\n      return m[2] + '{';\n    });\n  }\n\n  /*\n   * Process styles to add rules which will only apply under the polyfill\n   *\n   * For example, we convert this rule:\n   *\n   * polyfill-rule {\n   *   content: ':host menu-item';\n   * ...\n   * }\n   *\n   * to this:\n   *\n   * scopeName menu-item {...}\n   *\n   **/\n  private _insertPolyfillRulesInCssText(cssText: string): string {\n    // Difference with webcomponents.js: does not handle comments\n    return cssText.replace(_cssContentRuleRe, (...m: string[]) => {\n      const rule = m[0].replace(m[1], '').replace(m[2], '');\n      return m[4] + rule;\n    });\n  }\n\n  /* Ensure styles are scoped. Pseudo-scoping takes a rule like:\n   *\n   *  .foo {... }\n   *\n   *  and converts this to\n   *\n   *  scopeName .foo { ... }\n   */\n  private _scopeCssText(cssText: string, scopeSelector: string, hostSelector: string): string {\n    const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\n    // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\n    cssText = this._insertPolyfillHostInCssText(cssText);\n    cssText = this._convertColonHost(cssText);\n    cssText = this._convertColonHostContext(cssText);\n    cssText = this._convertShadowDOMSelectors(cssText);\n    if (scopeSelector) {\n      cssText = this._scopeKeyframesRelatedCss(cssText, scopeSelector);\n      cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n    }\n    cssText = cssText + '\\n' + unscopedRules;\n    return cssText.trim();\n  }\n\n  /*\n   * Process styles to add rules which will only apply under the polyfill\n   * and do not process via CSSOM. (CSSOM is destructive to rules on rare\n   * occasions, e.g. -webkit-calc on Safari.)\n   * For example, we convert this rule:\n   *\n   * @polyfill-unscoped-rule {\n   *   content: 'menu-item';\n   * ... }\n   *\n   * to this:\n   *\n   * menu-item {...}\n   *\n   **/\n  private _extractUnscopedRulesFromCssText(cssText: string): string {\n    // Difference with webcomponents.js: does not handle comments\n    let r = '';\n    let m: RegExpExecArray|null;\n    _cssContentUnscopedRuleRe.lastIndex = 0;\n    while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n      const rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n      r += rule + '\\n\\n';\n    }\n    return r;\n  }\n\n  /*\n   * convert a rule like :host(.foo) > .bar { }\n   *\n   * to\n   *\n   * .foo<scopeName> > .bar\n   */\n  private _convertColonHost(cssText: string): string {\n    return cssText.replace(_cssColonHostRe, (_, hostSelectors: string, otherSelectors: string) => {\n      if (hostSelectors) {\n        const convertedSelectors: string[] = [];\n        const hostSelectorArray = hostSelectors.split(',').map(p => p.trim());\n        for (const hostSelector of hostSelectorArray) {\n          if (!hostSelector) break;\n          const convertedSelector =\n              _polyfillHostNoCombinator + hostSelector.replace(_polyfillHost, '') + otherSelectors;\n          convertedSelectors.push(convertedSelector);\n        }\n        return convertedSelectors.join(',');\n      } else {\n        return _polyfillHostNoCombinator + otherSelectors;\n      }\n    });\n  }\n\n  /*\n   * convert a rule like :host-context(.foo) > .bar { }\n   *\n   * to\n   *\n   * .foo<scopeName> > .bar, .foo <scopeName> > .bar { }\n   *\n   * and\n   *\n   * :host-context(.foo:host) .bar { ... }\n   *\n   * to\n   *\n   * .foo<scopeName> .bar { ... }\n   */\n  private _convertColonHostContext(cssText: string): string {\n    return cssText.replace(_cssColonHostContextReGlobal, selectorText => {\n      // We have captured a selector that contains a `:host-context` rule.\n\n      // For backward compatibility `:host-context` may contain a comma separated list of selectors.\n      // Each context selector group will contain a list of host-context selectors that must match\n      // an ancestor of the host.\n      // (Normally `contextSelectorGroups` will only contain a single array of context selectors.)\n      const contextSelectorGroups: string[][] = [[]];\n\n      // There may be more than `:host-context` in this selector so `selectorText` could look like:\n      // `:host-context(.one):host-context(.two)`.\n      // Execute `_cssColonHostContextRe` over and over until we have extracted all the\n      // `:host-context` selectors from this selector.\n      let match: RegExpExecArray|null;\n      while (match = _cssColonHostContextRe.exec(selectorText)) {\n        // `match` = [':host-context(<selectors>)<rest>', <selectors>, <rest>]\n\n        // The `<selectors>` could actually be a comma separated list: `:host-context(.one, .two)`.\n        const newContextSelectors =\n            (match[1] ?? '').trim().split(',').map(m => m.trim()).filter(m => m !== '');\n\n        // We must duplicate the current selector group for each of these new selectors.\n        // For example if the current groups are:\n        // ```\n        // [\n        //   ['a', 'b', 'c'],\n        //   ['x', 'y', 'z'],\n        // ]\n        // ```\n        // And we have a new set of comma separated selectors: `:host-context(m,n)` then the new\n        // groups are:\n        // ```\n        // [\n        //   ['a', 'b', 'c', 'm'],\n        //   ['x', 'y', 'z', 'm'],\n        //   ['a', 'b', 'c', 'n'],\n        //   ['x', 'y', 'z', 'n'],\n        // ]\n        // ```\n        const contextSelectorGroupsLength = contextSelectorGroups.length;\n        repeatGroups(contextSelectorGroups, newContextSelectors.length);\n        for (let i = 0; i < newContextSelectors.length; i++) {\n          for (let j = 0; j < contextSelectorGroupsLength; j++) {\n            contextSelectorGroups[j + (i * contextSelectorGroupsLength)].push(\n                newContextSelectors[i]);\n          }\n        }\n\n        // Update the `selectorText` and see repeat to see if there are more `:host-context`s.\n        selectorText = match[2];\n      }\n\n      // The context selectors now must be combined with each other to capture all the possible\n      // selectors that `:host-context` can match. See `combineHostContextSelectors()` for more\n      // info about how this is done.\n      return contextSelectorGroups\n          .map(contextSelectors => combineHostContextSelectors(contextSelectors, selectorText))\n          .join(', ');\n    });\n  }\n\n  /*\n   * Convert combinators like ::shadow and pseudo-elements like ::content\n   * by replacing with space.\n   */\n  private _convertShadowDOMSelectors(cssText: string): string {\n    return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);\n  }\n\n  // change a selector like 'div' to 'name div'\n  private _scopeSelectors(cssText: string, scopeSelector: string, hostSelector: string): string {\n    return processRules(cssText, (rule: CssRule) => {\n      let selector = rule.selector;\n      let content = rule.content;\n      if (rule.selector[0] !== '@') {\n        selector =\n            this._scopeSelector(rule.selector, scopeSelector, hostSelector, this.strictStyling);\n      } else if (\n          rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||\n          rule.selector.startsWith('@document') || rule.selector.startsWith('@layer')) {\n        content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);\n      } else if (rule.selector.startsWith('@font-face') || rule.selector.startsWith('@page')) {\n        content = this._stripScopingSelectors(rule.content);\n      }\n      return new CssRule(selector, content);\n    });\n  }\n\n  /**\n   * Handle a css text that is within a rule that should not contain scope selectors by simply\n   * removing them! An example of such a rule is `@font-face`.\n   *\n   * `@font-face` rules cannot contain nested selectors. Nor can they be nested under a selector.\n   * Normally this would be a syntax error by the author of the styles. But in some rare cases, such\n   * as importing styles from a library, and applying `:host ::ng-deep` to the imported styles, we\n   * can end up with broken css if the imported styles happen to contain @font-face rules.\n   *\n   * For example:\n   *\n   * ```\n   * :host ::ng-deep {\n   *   import 'some/lib/containing/font-face';\n   * }\n   *\n   * Similar logic applies to `@page` rules which can contain a particular set of properties,\n   * as well as some specific at-rules. Since they can't be encapsulated, we have to strip\n   * any scoping selectors from them. For more information: https://www.w3.org/TR/css-page-3\n   * ```\n   */\n  private _stripScopingSelectors(cssText: string): string {\n    return processRules(cssText, rule => {\n      const selector = rule.selector.replace(_shadowDeepSelectors, ' ')\n                           .replace(_polyfillHostNoCombinatorRe, ' ');\n      return new CssRule(selector, rule.content);\n    });\n  }\n\n  private _scopeSelector(\n      selector: string, scopeSelector: string, hostSelector: string, strict: boolean): string {\n    return selector.split(',')\n        .map(part => part.trim().split(_shadowDeepSelectors))\n        .map((deepParts) => {\n          const [shallowPart, ...otherParts] = deepParts;\n          const applyScope = (shallowPart: string) => {\n            if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n              return strict ?\n                  this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :\n                  this._applySelectorScope(shallowPart, scopeSelector, hostSelector);\n            } else {\n              return shallowPart;\n            }\n          };\n          return [applyScope(shallowPart), ...otherParts].join(' ');\n        })\n        .join(', ');\n  }\n\n  private _selectorNeedsScoping(selector: string, scopeSelector: string): boolean {\n    const re = this._makeScopeMatcher(scopeSelector);\n    return !re.test(selector);\n  }\n\n  private _makeScopeMatcher(scopeSelector: string): RegExp {\n    const lre = /\\[/g;\n    const rre = /\\]/g;\n    scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n    return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n  }\n\n  private _applySelectorScope(selector: string, scopeSelector: string, hostSelector: string):\n      string {\n    // Difference from webcomponents.js: scopeSelector could not be an array\n    return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);\n  }\n\n  // scope via name and [is=name]\n  private _applySimpleSelectorScope(selector: string, scopeSelector: string, hostSelector: string):\n      string {\n    // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n    _polyfillHostRe.lastIndex = 0;\n    if (_polyfillHostRe.test(selector)) {\n      const replaceBy = this.strictStyling ? `[${hostSelector}]` : scopeSelector;\n      return selector\n          .replace(\n              _polyfillHostNoCombinatorRe,\n              (hnc, selector) => {\n                return selector.replace(\n                    /([^:]*)(:*)(.*)/,\n                    (_: string, before: string, colon: string, after: string) => {\n                      return before + replaceBy + colon + after;\n                    });\n              })\n          .replace(_polyfillHostRe, replaceBy + ' ');\n    }\n\n    return scopeSelector + ' ' + selector;\n  }\n\n  // return a selector with [name] suffix on each simple selector\n  // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */\n  private _applyStrictSelectorScope(selector: string, scopeSelector: string, hostSelector: string):\n      string {\n    const isRe = /\\[is=([^\\]]*)\\]/g;\n    scopeSelector = scopeSelector.replace(isRe, (_: string, ...parts: string[]) => parts[0]);\n\n    const attrName = '[' + scopeSelector + ']';\n\n    const _scopeSelectorPart = (p: string) => {\n      let scopedP = p.trim();\n\n      if (!scopedP) {\n        return '';\n      }\n\n      if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n        scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n      } else {\n        // remove :host since it should be unnecessary\n        const t = p.replace(_polyfillHostRe, '');\n        if (t.length > 0) {\n          const matches = t.match(/([^:]*)(:*)(.*)/);\n          if (matches) {\n            scopedP = matches[1] + attrName + matches[2] + matches[3];\n          }\n        }\n      }\n\n      return scopedP;\n    };\n\n    const safeContent = new SafeSelector(selector);\n    selector = safeContent.content();\n\n    let scopedSelector = '';\n    let startIndex = 0;\n    let res: RegExpExecArray|null;\n    const sep = /( |>|\\+|~(?!=))\\s*/g;\n\n    // If a selector appears before :host it should not be shimmed as it\n    // matches on ancestor elements and not on elements in the host's shadow\n    // `:host-context(div)` is transformed to\n    // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`\n    // the `div` is not part of the component in the 2nd selectors and should not be scoped.\n    // Historically `component-tag:host` was matching the component so we also want to preserve\n    // this behavior to avoid breaking legacy apps (it should not match).\n    // The behavior should be:\n    // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)\n    // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a\n    //   `:host-context(tag)`)\n    const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;\n    // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present\n    let shouldScope = !hasHost;\n\n    while ((res = sep.exec(selector)) !== null) {\n      const separator = res[1];\n      const part = selector.slice(startIndex, res.index).trim();\n      shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n      const scopedPart = shouldScope ? _scopeSelectorPart(part) : part;\n      scopedSelector += `${scopedPart} ${separator} `;\n      startIndex = sep.lastIndex;\n    }\n\n    const part = selector.substring(startIndex);\n    shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n    scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;\n\n    // replace the placeholders with their original values\n    return safeContent.restore(scopedSelector);\n  }\n\n  private _insertPolyfillHostInCssText(selector: string): string {\n    return selector.replace(_colonHostContextRe, _polyfillHostContext)\n        .replace(_colonHostRe, _polyfillHost);\n  }\n}\n\nclass SafeSelector {\n  private placeholders: string[] = [];\n  private index = 0;\n  private _content: string;\n\n  constructor(selector: string) {\n    // Replaces attribute selectors with placeholders.\n    // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n    selector = this._escapeRegexMatches(selector, /(\\[[^\\]]*\\])/g);\n\n    // CSS allows for certain special characters to be used in selectors if they're escaped.\n    // E.g. `.foo:blue` won't match a class called `foo:blue`, because the colon denotes a\n    // pseudo-class, but writing `.foo\\:blue` will match, because the colon was escaped.\n    // Replace all escape sequences (`\\` followed by a character) with a placeholder so\n    // that our handling of pseudo-selectors doesn't mess with them.\n    selector = this._escapeRegexMatches(selector, /(\\\\.)/g);\n\n    // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n    // WS and \"+\" would otherwise be interpreted as selector separators.\n    this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, (_, pseudo, exp) => {\n      const replaceBy = `__ph-${this.index}__`;\n      this.placeholders.push(exp);\n      this.index++;\n      return pseudo + replaceBy;\n    });\n  }\n\n  restore(content: string): string {\n    return content.replace(/__ph-(\\d+)__/g, (_ph, index) => this.placeholders[+index]);\n  }\n\n  content(): string {\n    return this._content;\n  }\n\n  /**\n   * Replaces all of the substrings that match a regex within a\n   * special string (e.g. `__ph-0__`, `__ph-1__`, etc).\n   */\n  private _escapeRegexMatches(content: string, pattern: RegExp): string {\n    return content.replace(pattern, (_, keep) => {\n      const replaceBy = `__ph-${this.index}__`;\n      this.placeholders.push(keep);\n      this.index++;\n      return replaceBy;\n    });\n  }\n}\n\nconst _cssContentNextSelectorRe =\n    /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nconst _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _cssContentUnscopedRuleRe =\n    /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _polyfillHost = '-shadowcsshost';\n// note: :host-context pre-processed to -shadowcsshostcontext.\nconst _polyfillHostContext = '-shadowcsscontext';\nconst _parenSuffix = '(?:\\\\((' +\n    '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\n    ')\\\\))?([^,{]*)';\nconst _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix, 'gim');\nconst _cssColonHostContextReGlobal = new RegExp(_polyfillHostContext + _parenSuffix, 'gim');\nconst _cssColonHostContextRe = new RegExp(_polyfillHostContext + _parenSuffix, 'im');\nconst _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nconst _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nconst _shadowDOMSelectorsRe = [\n  /::shadow/g,\n  /::content/g,\n  // Deprecated selectors\n  /\\/shadow-deep\\//g,\n  /\\/shadow\\//g,\n];\n\n// The deep combinator is deprecated in the CSS spec\n// Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.\n// see https://github.com/angular/angular/pull/17677\nconst _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)|(?:::ng-deep)/g;\nconst _selectorReSuffix = '([>\\\\s~+[.,{:][\\\\s\\\\S]*)?$';\nconst _polyfillHostRe = /-shadowcsshost/gim;\nconst _colonHostRe = /:host/gim;\nconst _colonHostContextRe = /:host-context/gim;\n\nconst _commentRe = /\\/\\*[\\s\\S]*?\\*\\//g;\n\nfunction stripComments(input: string): string {\n  return input.replace(_commentRe, '');\n}\n\nconst _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=[\\s\\S]+?\\*\\//g;\n\nfunction extractCommentsWithHash(input: string): string[] {\n  return input.match(_commentWithHashRe) || [];\n}\n\nconst BLOCK_PLACEHOLDER = '%BLOCK%';\nconst _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nconst CONTENT_PAIRS = new Map([['{', '}']]);\n\nconst COMMA_IN_PLACEHOLDER = '%COMMA_IN_PLACEHOLDER%';\nconst SEMI_IN_PLACEHOLDER = '%SEMI_IN_PLACEHOLDER%';\nconst COLON_IN_PLACEHOLDER = '%COLON_IN_PLACEHOLDER%';\n\nconst _cssCommaInPlaceholderReGlobal = new RegExp(COMMA_IN_PLACEHOLDER, 'g');\nconst _cssSemiInPlaceholderReGlobal = new RegExp(SEMI_IN_PLACEHOLDER, 'g');\nconst _cssColonInPlaceholderReGlobal = new RegExp(COLON_IN_PLACEHOLDER, 'g');\n\nexport class CssRule {\n  constructor(public selector: string, public content: string) {}\n}\n\nexport function processRules(input: string, ruleCallback: (rule: CssRule) => CssRule): string {\n  const escaped = escapeInStrings(input);\n  const inputWithEscapedBlocks = escapeBlocks(escaped, CONTENT_PAIRS, BLOCK_PLACEHOLDER);\n  let nextBlockIndex = 0;\n  const escapedResult = inputWithEscapedBlocks.escapedString.replace(_ruleRe, (...m: string[]) => {\n    const selector = m[2];\n    let content = '';\n    let suffix = m[4];\n    let contentPrefix = '';\n    if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n      content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n      suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n      contentPrefix = '{';\n    }\n    const rule = ruleCallback(new CssRule(selector, content));\n    return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;\n  });\n  return unescapeInStrings(escapedResult);\n}\n\nclass StringWithEscapedBlocks {\n  constructor(public escapedString: string, public blocks: string[]) {}\n}\n\nfunction escapeBlocks(\n    input: string, charPairs: Map<string, string>, placeholder: string): StringWithEscapedBlocks {\n  const resultParts: string[] = [];\n  const escapedBlocks: string[] = [];\n  let openCharCount = 0;\n  let nonBlockStartIndex = 0;\n  let blockStartIndex = -1;\n  let openChar: string|undefined;\n  let closeChar: string|undefined;\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    if (char === '\\\\') {\n      i++;\n    } else if (char === closeChar) {\n      openCharCount--;\n      if (openCharCount === 0) {\n        escapedBlocks.push(input.substring(blockStartIndex, i));\n        resultParts.push(placeholder);\n        nonBlockStartIndex = i;\n        blockStartIndex = -1;\n        openChar = closeChar = undefined;\n      }\n    } else if (char === openChar) {\n      openCharCount++;\n    } else if (openCharCount === 0 && charPairs.has(char)) {\n      openChar = char;\n      closeChar = charPairs.get(char);\n      openCharCount = 1;\n      blockStartIndex = i + 1;\n      resultParts.push(input.substring(nonBlockStartIndex, blockStartIndex));\n    }\n  }\n  if (blockStartIndex !== -1) {\n    escapedBlocks.push(input.substring(blockStartIndex));\n    resultParts.push(placeholder);\n  } else {\n    resultParts.push(input.substring(nonBlockStartIndex));\n  }\n  return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\n\n/**\n * Object containing as keys characters that should be substituted by placeholders\n * when found in strings during the css text parsing, and as values the respective\n * placeholders\n */\nconst ESCAPE_IN_STRING_MAP: {[key: string]: string} = {\n  ';': SEMI_IN_PLACEHOLDER,\n  ',': COMMA_IN_PLACEHOLDER,\n  ':': COLON_IN_PLACEHOLDER\n};\n\n/**\n * Parse the provided css text and inside strings (meaning, inside pairs of unescaped single or\n * double quotes) replace specific characters with their respective placeholders as indicated\n * by the `ESCAPE_IN_STRING_MAP` map.\n *\n * For example convert the text\n *  `animation: \"my-anim:at\\\"ion\" 1s;`\n * to\n *  `animation: \"my-anim%COLON_IN_PLACEHOLDER%at\\\"ion\" 1s;`\n *\n * This is necessary in order to remove the meaning of some characters when found inside strings\n * (for example `;` indicates the end of a css declaration, `,` the sequence of values and `:` the\n * division between property and value during a declaration, none of these meanings apply when such\n * characters are within strings and so in order to prevent parsing issues they need to be replaced\n * with placeholder text for the duration of the css manipulation process).\n *\n * @param input the original css text.\n *\n * @returns the css text with specific characters in strings replaced by placeholders.\n **/\nfunction escapeInStrings(input: string): string {\n  let result = input;\n  let currentQuoteChar: string|null = null;\n  for (let i = 0; i < result.length; i++) {\n    const char = result[i];\n    if (char === '\\\\') {\n      i++;\n    } else {\n      if (currentQuoteChar !== null) {\n        // index i is inside a quoted sub-string\n        if (char === currentQuoteChar) {\n          currentQuoteChar = null;\n        } else {\n          const placeholder: string|undefined = ESCAPE_IN_STRING_MAP[char];\n          if (placeholder) {\n            result = `${result.substr(0, i)}${placeholder}${result.substr(i + 1)}`;\n            i += placeholder.length - 1;\n          }\n        }\n      } else if (char === '\\'' || char === '\"') {\n        currentQuoteChar = char;\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Replace in a string all occurrences of keys in the `ESCAPE_IN_STRING_MAP` map with their\n * original representation, this is simply used to revert the changes applied by the\n * escapeInStrings function.\n *\n * For example it reverts the text:\n *  `animation: \"my-anim%COLON_IN_PLACEHOLDER%at\\\"ion\" 1s;`\n * to it's original form of:\n *  `animation: \"my-anim:at\\\"ion\" 1s;`\n *\n * Note: For the sake of simplicity this function does not check that the placeholders are\n * actually inside strings as it would anyway be extremely unlikely to find them outside of strings.\n *\n * @param input the css text containing the placeholders.\n *\n * @returns the css text without the placeholders.\n */\nfunction unescapeInStrings(input: string): string {\n  let result = input.replace(_cssCommaInPlaceholderReGlobal, ',');\n  result = result.replace(_cssSemiInPlaceholderReGlobal, ';');\n  result = result.replace(_cssColonInPlaceholderReGlobal, ':');\n  return result;\n}\n\n/**\n * Unescape all quotes present in a string, but only if the string was actually already\n * quoted.\n *\n * This generates a \"canonical\" representation of strings which can be used to match strings\n * which would otherwise only differ because of differently escaped quotes.\n *\n * For example it converts the string (assumed to be quoted):\n *  `this \\\\\"is\\\\\" a \\\\'\\\\\\\\'test`\n * to:\n *  `this \"is\" a '\\\\\\\\'test`\n * (note that the latter backslashes are not removed as they are not actually escaping the single\n * quote)\n *\n *\n * @param input the string possibly containing escaped quotes.\n * @param isQuoted boolean indicating whether the string was quoted inside a bigger string (if not\n * then it means that it doesn't represent an inner string and thus no unescaping is required)\n *\n * @returns the string in the \"canonical\" representation without escaped quotes.\n */\nfunction unescapeQuotes(str: string, isQuoted: boolean): string {\n  return !isQuoted ? str : str.replace(/((?:^|[^\\\\])(?:\\\\\\\\)*)\\\\(?=['\"])/g, '$1');\n}\n\n/**\n * Combine the `contextSelectors` with the `hostMarker` and the `otherSelectors`\n * to create a selector that matches the same as `:host-context()`.\n *\n * Given a single context selector `A` we need to output selectors that match on the host and as an\n * ancestor of the host:\n *\n * ```\n * A <hostMarker>, A<hostMarker> {}\n * ```\n *\n * When there is more than one context selector we also have to create combinations of those\n * selectors with each other. For example if there are `A` and `B` selectors the output is:\n *\n * ```\n * AB<hostMarker>, AB <hostMarker>, A B<hostMarker>,\n * B A<hostMarker>, A B <hostMarker>, B A <hostMarker> {}\n * ```\n *\n * And so on...\n *\n * @param hostMarker the string that selects the host element.\n * @param contextSelectors an array of context selectors that will be combined.\n * @param otherSelectors the rest of the selectors that are not context selectors.\n */\nfunction combineHostContextSelectors(contextSelectors: string[], otherSelectors: string): string {\n  const hostMarker = _polyfillHostNoCombinator;\n  _polyfillHostRe.lastIndex = 0;  // reset the regex to ensure we get an accurate test\n  const otherSelectorsHasHost = _polyfillHostRe.test(otherSelectors);\n\n  // If there are no context selectors then just output a host marker\n  if (contextSelectors.length === 0) {\n    return hostMarker + otherSelectors;\n  }\n\n  const combined: string[] = [contextSelectors.pop() || ''];\n  while (contextSelectors.length > 0) {\n    const length = combined.length;\n    const contextSelector = contextSelectors.pop();\n    for (let i = 0; i < length; i++) {\n      const previousSelectors = combined[i];\n      // Add the new selector as a descendant of the previous selectors\n      combined[length * 2 + i] = previousSelectors + ' ' + contextSelector;\n      // Add the new selector as an ancestor of the previous selectors\n      combined[length + i] = contextSelector + ' ' + previousSelectors;\n      // Add the new selector to act on the same element as the previous selectors\n      combined[i] = contextSelector + previousSelectors;\n    }\n  }\n  // Finally connect the selector to the `hostMarker`s: either acting directly on the host\n  // (A<hostMarker>) or as an ancestor (A <hostMarker>).\n  return combined\n      .map(\n          s => otherSelectorsHasHost ?\n              `${s}${otherSelectors}` :\n              `${s}${hostMarker}${otherSelectors}, ${s} ${hostMarker}${otherSelectors}`)\n      .join(',');\n}\n\n/**\n * Mutate the given `groups` array so that there are `multiples` clones of the original array\n * stored.\n *\n * For example `repeatGroups([a, b], 3)` will result in `[a, b, a, b, a, b]` - but importantly the\n * newly added groups will be clones of the original.\n *\n * @param groups An array of groups of strings that will be repeated. This array is mutated\n *     in-place.\n * @param multiples The number of times the current groups should appear.\n */\nexport function repeatGroups(groups: string[][], multiples: number): void {\n  const length = groups.length;\n  for (let i = 1; i < multiples; i++) {\n    for (let j = 0; j < length; j++) {\n      groups[j + (i * length)] = groups[j].slice(0);\n    }\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst enum Char {\n  OpenParen = 40,\n  CloseParen = 41,\n  Colon = 58,\n  Semicolon = 59,\n  BackSlash = 92,\n  QuoteNone = 0,  // indicating we are not inside a quote\n  QuoteDouble = 34,\n  QuoteSingle = 39,\n}\n\n\n/**\n * Parses string representation of a style and converts it into object literal.\n *\n * @param value string representation of style as used in the `style` attribute in HTML.\n *   Example: `color: red; height: auto`.\n * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',\n * 'auto']`\n */\nexport function parse(value: string): string[] {\n  // we use a string array here instead of a string map\n  // because a string-map is not guaranteed to retain the\n  // order of the entries whereas a string array can be\n  // constructed in a [key, value, key, value] format.\n  const styles: string[] = [];\n\n  let i = 0;\n  let parenDepth = 0;\n  let quote: Char = Char.QuoteNone;\n  let valueStart = 0;\n  let propStart = 0;\n  let currentProp: string|null = null;\n  let valueHasQuotes = false;\n  while (i < value.length) {\n    const token = value.charCodeAt(i++) as Char;\n    switch (token) {\n      case Char.OpenParen:\n        parenDepth++;\n        break;\n      case Char.CloseParen:\n        parenDepth--;\n        break;\n      case Char.QuoteSingle:\n        // valueStart needs to be there since prop values don't\n        // have quotes in CSS\n        valueHasQuotes = valueHasQuotes || valueStart > 0;\n        if (quote === Char.QuoteNone) {\n          quote = Char.QuoteSingle;\n        } else if (quote === Char.QuoteSingle && value.charCodeAt(i - 1) !== Char.BackSlash) {\n          quote = Char.QuoteNone;\n        }\n        break;\n      case Char.QuoteDouble:\n        // same logic as above\n        valueHasQuotes = valueHasQuotes || valueStart > 0;\n        if (quote === Char.QuoteNone) {\n          quote = Char.QuoteDouble;\n        } else if (quote === Char.QuoteDouble && value.charCodeAt(i - 1) !== Char.BackSlash) {\n          quote = Char.QuoteNone;\n        }\n        break;\n      case Char.Colon:\n        if (!currentProp && parenDepth === 0 && quote === Char.QuoteNone) {\n          currentProp = hyphenate(value.substring(propStart, i - 1).trim());\n          valueStart = i;\n        }\n        break;\n      case Char.Semicolon:\n        if (currentProp && valueStart > 0 && parenDepth === 0 && quote === Char.QuoteNone) {\n          const styleVal = value.substring(valueStart, i - 1).trim();\n          styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);\n          propStart = i;\n          valueStart = 0;\n          currentProp = null;\n          valueHasQuotes = false;\n        }\n        break;\n    }\n  }\n\n  if (currentProp && valueStart) {\n    const styleVal = value.slice(valueStart).trim();\n    styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);\n  }\n\n  return styles;\n}\n\nexport function stripUnnecessaryQuotes(value: string): string {\n  const qS = value.charCodeAt(0);\n  const qE = value.charCodeAt(value.length - 1);\n  if (qS == qE && (qS == Char.QuoteSingle || qS == Char.QuoteDouble)) {\n    const tempValue = value.substring(1, value.length - 1);\n    // special case to avoid using a multi-quoted string that was just chomped\n    // (e.g. `font-family: \"Verdana\", \"sans-serif\"`)\n    if (tempValue.indexOf('\\'') == -1 && tempValue.indexOf('\"') == -1) {\n      value = tempValue;\n    }\n  }\n  return value;\n}\n\nexport function hyphenate(value: string): string {\n  return value\n      .replace(\n          /[a-z][A-Z]/g,\n          v => {\n            return v.charAt(0) + '-' + v.charAt(1);\n          })\n      .toLowerCase();\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AttributeMarker} from '../../core';\nimport {AST, ASTWithSource, BindingPipe, BindingType, EmptyExpr, Interpolation} from '../../expression_parser/ast';\nimport * as o from '../../output/output_ast';\nimport {ParseSourceSpan} from '../../parse_util';\nimport * as t from '../r3_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\n\nimport {hyphenate, parse as parseStyle} from './style_parser';\nimport {ValueConverter} from './template';\nimport {DefinitionMap, getInterpolationArgsLength} from './util';\n\nconst IMPORTANT_FLAG = '!important';\n\n/**\n * Minimum amount of binding slots required in the runtime for style/class bindings.\n *\n * Styling in Angular uses up two slots in the runtime LView/TData data structures to\n * record binding data, property information and metadata.\n *\n * When a binding is registered it will place the following information in the `LView`:\n *\n * slot 1) binding value\n * slot 2) cached value (all other values collected before it in string form)\n *\n * When a binding is registered it will place the following information in the `TData`:\n *\n * slot 1) prop name\n * slot 2) binding index that points to the previous style/class binding (and some extra config\n * values)\n *\n * Let's imagine we have a binding that looks like so:\n *\n * ```\n * <div [style.width]=\"x\" [style.height]=\"y\">\n * ```\n *\n * Our `LView` and `TData` data-structures look like so:\n *\n * ```typescript\n * LView = [\n *   // ...\n *   x, // value of x\n *   \"width: x\",\n *\n *   y, // value of y\n *   \"width: x; height: y\",\n *   // ...\n * ];\n *\n * TData = [\n *   // ...\n *   \"width\", // binding slot 20\n *   0,\n *\n *   \"height\",\n *   20,\n *   // ...\n * ];\n * ```\n *\n * */\nexport const MIN_STYLING_BINDING_SLOTS_REQUIRED = 2;\n\n/**\n * A styling expression summary that is to be processed by the compiler\n */\nexport interface StylingInstruction {\n  reference: o.ExternalReference;\n  /** Calls to individual styling instructions. Used when chaining calls to the same instruction. */\n  calls: StylingInstructionCall[];\n}\n\nexport interface StylingInstructionCall {\n  sourceSpan: ParseSourceSpan|null;\n  supportsInterpolation: boolean;\n  allocateBindingSlots: number;\n  params: ((convertFn: (value: any) => o.Expression | o.Expression[]) => o.Expression[]);\n}\n\n/**\n * An internal record of the input data for a styling binding\n */\ninterface BoundStylingEntry {\n  hasOverrideFlag: boolean;\n  name: string|null;\n  suffix: string|null;\n  sourceSpan: ParseSourceSpan;\n  value: AST;\n}\n\n/**\n * Produces creation/update instructions for all styling bindings (class and style)\n *\n * It also produces the creation instruction to register all initial styling values\n * (which are all the static class=\"...\" and style=\"...\" attribute values that exist\n * on an element within a template).\n *\n * The builder class below handles producing instructions for the following cases:\n *\n * - Static style/class attributes (style=\"...\" and class=\"...\")\n * - Dynamic style/class map bindings ([style]=\"map\" and [class]=\"map|string\")\n * - Dynamic style/class property bindings ([style.prop]=\"exp\" and [class.name]=\"exp\")\n *\n * Due to the complex relationship of all of these cases, the instructions generated\n * for these attributes/properties/bindings must be done so in the correct order. The\n * order which these must be generated is as follows:\n *\n * if (createMode) {\n *   styling(...)\n * }\n * if (updateMode) {\n *   styleMap(...)\n *   classMap(...)\n *   styleProp(...)\n *   classProp(...)\n * }\n *\n * The creation/update methods within the builder class produce these instructions.\n */\nexport class StylingBuilder {\n  /** Whether or not there are any static styling values present */\n  private _hasInitialValues = false;\n  /**\n   *  Whether or not there are any styling bindings present\n   *  (i.e. `[style]`, `[class]`, `[style.prop]` or `[class.name]`)\n   */\n  public hasBindings = false;\n  public hasBindingsWithPipes = false;\n\n  /** the input for [class] (if it exists) */\n  private _classMapInput: BoundStylingEntry|null = null;\n  /** the input for [style] (if it exists) */\n  private _styleMapInput: BoundStylingEntry|null = null;\n  /** an array of each [style.prop] input */\n  private _singleStyleInputs: BoundStylingEntry[]|null = null;\n  /** an array of each [class.name] input */\n  private _singleClassInputs: BoundStylingEntry[]|null = null;\n  private _lastStylingInput: BoundStylingEntry|null = null;\n  private _firstStylingInput: BoundStylingEntry|null = null;\n\n  // maps are used instead of hash maps because a Map will\n  // retain the ordering of the keys\n\n  /**\n   * Represents the location of each style binding in the template\n   * (e.g. `<div [style.width]=\"w\" [style.height]=\"h\">` implies\n   * that `width=0` and `height=1`)\n   */\n  private _stylesIndex = new Map<string, number>();\n\n  /**\n   * Represents the location of each class binding in the template\n   * (e.g. `<div [class.big]=\"b\" [class.hidden]=\"h\">` implies\n   * that `big=0` and `hidden=1`)\n   */\n  private _classesIndex = new Map<string, number>();\n  private _initialStyleValues: string[] = [];\n  private _initialClassValues: string[] = [];\n\n  constructor(private _directiveExpr: o.Expression|null) {}\n\n  /**\n   * Registers a given input to the styling builder to be later used when producing AOT code.\n   *\n   * The code below will only accept the input if it is somehow tied to styling (whether it be\n   * style/class bindings or static style/class attributes).\n   */\n  registerBoundInput(input: t.BoundAttribute): boolean {\n    // [attr.style] or [attr.class] are skipped in the code below,\n    // they should not be treated as styling-based bindings since\n    // they are intended to be written directly to the attr and\n    // will therefore skip all style/class resolution that is present\n    // with style=\"\", [style]=\"\" and [style.prop]=\"\", class=\"\",\n    // [class.prop]=\"\". [class]=\"\" assignments\n    let binding: BoundStylingEntry|null = null;\n    let name = input.name;\n    switch (input.type) {\n      case BindingType.Property:\n        binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);\n        break;\n      case BindingType.Style:\n        binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);\n        break;\n      case BindingType.Class:\n        binding = this.registerClassInput(name, false, input.value, input.sourceSpan);\n        break;\n    }\n    return binding ? true : false;\n  }\n\n  registerInputBasedOnName(name: string, expression: AST, sourceSpan: ParseSourceSpan) {\n    let binding: BoundStylingEntry|null = null;\n    const prefix = name.substring(0, 6);\n    const isStyle = name === 'style' || prefix === 'style.' || prefix === 'style!';\n    const isClass = !isStyle && (name === 'class' || prefix === 'class.' || prefix === 'class!');\n    if (isStyle || isClass) {\n      const isMapBased = name.charAt(5) !== '.';        // style.prop or class.prop makes this a no\n      const property = name.slice(isMapBased ? 5 : 6);  // the dot explains why there's a +1\n      if (isStyle) {\n        binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);\n      } else {\n        binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);\n      }\n    }\n    return binding;\n  }\n\n  registerStyleInput(\n      name: string, isMapBased: boolean, value: AST, sourceSpan: ParseSourceSpan,\n      suffix?: string|null): BoundStylingEntry|null {\n    if (isEmptyExpression(value)) {\n      return null;\n    }\n    // CSS custom properties are case-sensitive so we shouldn't normalize them.\n    // See: https://www.w3.org/TR/css-variables-1/#defining-variables\n    if (!isCssCustomProperty(name)) {\n      name = hyphenate(name);\n    }\n    const {property, hasOverrideFlag, suffix: bindingSuffix} = parseProperty(name);\n    suffix = typeof suffix === 'string' && suffix.length !== 0 ? suffix : bindingSuffix;\n    const entry:\n        BoundStylingEntry = {name: property, suffix: suffix, value, sourceSpan, hasOverrideFlag};\n    if (isMapBased) {\n      this._styleMapInput = entry;\n    } else {\n      (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);\n      registerIntoMap(this._stylesIndex, property);\n    }\n    this._lastStylingInput = entry;\n    this._firstStylingInput = this._firstStylingInput || entry;\n    this._checkForPipes(value);\n    this.hasBindings = true;\n    return entry;\n  }\n\n  registerClassInput(name: string, isMapBased: boolean, value: AST, sourceSpan: ParseSourceSpan):\n      BoundStylingEntry|null {\n    if (isEmptyExpression(value)) {\n      return null;\n    }\n    const {property, hasOverrideFlag} = parseProperty(name);\n    const entry:\n        BoundStylingEntry = {name: property, value, sourceSpan, hasOverrideFlag, suffix: null};\n    if (isMapBased) {\n      this._classMapInput = entry;\n    } else {\n      (this._singleClassInputs = this._singleClassInputs || []).push(entry);\n      registerIntoMap(this._classesIndex, property);\n    }\n    this._lastStylingInput = entry;\n    this._firstStylingInput = this._firstStylingInput || entry;\n    this._checkForPipes(value);\n    this.hasBindings = true;\n    return entry;\n  }\n\n  private _checkForPipes(value: AST) {\n    if ((value instanceof ASTWithSource) && (value.ast instanceof BindingPipe)) {\n      this.hasBindingsWithPipes = true;\n    }\n  }\n\n  /**\n   * Registers the element's static style string value to the builder.\n   *\n   * @param value the style string (e.g. `width:100px; height:200px;`)\n   */\n  registerStyleAttr(value: string) {\n    this._initialStyleValues = parseStyle(value);\n    this._hasInitialValues = true;\n  }\n\n  /**\n   * Registers the element's static class string value to the builder.\n   *\n   * @param value the className string (e.g. `disabled gold zoom`)\n   */\n  registerClassAttr(value: string) {\n    this._initialClassValues = value.trim().split(/\\s+/g);\n    this._hasInitialValues = true;\n  }\n\n  /**\n   * Appends all styling-related expressions to the provided attrs array.\n   *\n   * @param attrs an existing array where each of the styling expressions\n   * will be inserted into.\n   */\n  populateInitialStylingAttrs(attrs: o.Expression[]): void {\n    // [CLASS_MARKER, 'foo', 'bar', 'baz' ...]\n    if (this._initialClassValues.length) {\n      attrs.push(o.literal(AttributeMarker.Classes));\n      for (let i = 0; i < this._initialClassValues.length; i++) {\n        attrs.push(o.literal(this._initialClassValues[i]));\n      }\n    }\n\n    // [STYLE_MARKER, 'width', '200px', 'height', '100px', ...]\n    if (this._initialStyleValues.length) {\n      attrs.push(o.literal(AttributeMarker.Styles));\n      for (let i = 0; i < this._initialStyleValues.length; i += 2) {\n        attrs.push(\n            o.literal(this._initialStyleValues[i]), o.literal(this._initialStyleValues[i + 1]));\n      }\n    }\n  }\n\n  /**\n   * Builds an instruction with all the expressions and parameters for `elementHostAttrs`.\n   *\n   * The instruction generation code below is used for producing the AOT statement code which is\n   * responsible for registering initial styles (within a directive hostBindings' creation block),\n   * as well as any of the provided attribute values, to the directive host element.\n   */\n  assignHostAttrs(attrs: o.Expression[], definitionMap: DefinitionMap): void {\n    if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {\n      this.populateInitialStylingAttrs(attrs);\n      definitionMap.set('hostAttrs', o.literalArr(attrs));\n    }\n  }\n\n  /**\n   * Builds an instruction with all the expressions and parameters for `classMap`.\n   *\n   * The instruction data will contain all expressions for `classMap` to function\n   * which includes the `[class]` expression params.\n   */\n  buildClassMapInstruction(valueConverter: ValueConverter): StylingInstruction|null {\n    if (this._classMapInput) {\n      return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);\n    }\n    return null;\n  }\n\n  /**\n   * Builds an instruction with all the expressions and parameters for `styleMap`.\n   *\n   * The instruction data will contain all expressions for `styleMap` to function\n   * which includes the `[style]` expression params.\n   */\n  buildStyleMapInstruction(valueConverter: ValueConverter): StylingInstruction|null {\n    if (this._styleMapInput) {\n      return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);\n    }\n    return null;\n  }\n\n  private _buildMapBasedInstruction(\n      valueConverter: ValueConverter, isClassBased: boolean,\n      stylingInput: BoundStylingEntry): StylingInstruction {\n    // each styling binding value is stored in the LView\n    // map-based bindings allocate two slots: one for the\n    // previous binding value and another for the previous\n    // className or style attribute value.\n    let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;\n\n    // these values must be outside of the update block so that they can\n    // be evaluated (the AST visit call) during creation time so that any\n    // pipes can be picked up in time before the template is built\n    const mapValue = stylingInput.value.visit(valueConverter);\n    let reference: o.ExternalReference;\n    if (mapValue instanceof Interpolation) {\n      totalBindingSlotsRequired += mapValue.expressions.length;\n      reference = isClassBased ? getClassMapInterpolationExpression(mapValue) :\n                                 getStyleMapInterpolationExpression(mapValue);\n    } else {\n      reference = isClassBased ? R3.classMap : R3.styleMap;\n    }\n\n    return {\n      reference,\n      calls: [{\n        supportsInterpolation: true,\n        sourceSpan: stylingInput.sourceSpan,\n        allocateBindingSlots: totalBindingSlotsRequired,\n        params: (convertFn: (value: any) => o.Expression|o.Expression[]) => {\n          const convertResult = convertFn(mapValue);\n          const params = Array.isArray(convertResult) ? convertResult : [convertResult];\n          return params;\n        }\n      }]\n    };\n  }\n\n  private _buildSingleInputs(\n      reference: o.ExternalReference, inputs: BoundStylingEntry[], valueConverter: ValueConverter,\n      getInterpolationExpressionFn: ((value: Interpolation) => o.ExternalReference)|null,\n      isClassBased: boolean): StylingInstruction[] {\n    const instructions: StylingInstruction[] = [];\n\n    inputs.forEach(input => {\n      const previousInstruction: StylingInstruction|undefined =\n          instructions[instructions.length - 1];\n      const value = input.value.visit(valueConverter);\n      let referenceForCall = reference;\n\n      // each styling binding value is stored in the LView\n      // but there are two values stored for each binding:\n      //   1) the value itself\n      //   2) an intermediate value (concatenation of style up to this point).\n      //      We need to store the intermediate value so that we don't allocate\n      //      the strings on each CD.\n      let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;\n\n      if (value instanceof Interpolation) {\n        totalBindingSlotsRequired += value.expressions.length;\n\n        if (getInterpolationExpressionFn) {\n          referenceForCall = getInterpolationExpressionFn(value);\n        }\n      }\n\n      const call = {\n        sourceSpan: input.sourceSpan,\n        allocateBindingSlots: totalBindingSlotsRequired,\n        supportsInterpolation: !!getInterpolationExpressionFn,\n        params: (convertFn: (value: any) => o.Expression | o.Expression[]) => {\n          // params => stylingProp(propName, value, suffix)\n          const params: o.Expression[] = [];\n          params.push(o.literal(input.name));\n\n          const convertResult = convertFn(value);\n          if (Array.isArray(convertResult)) {\n            params.push(...convertResult);\n          } else {\n            params.push(convertResult);\n          }\n\n          // [style.prop] bindings may use suffix values (e.g. px, em, etc...), therefore,\n          // if that is detected then we need to pass that in as an optional param.\n          if (!isClassBased && input.suffix !== null) {\n            params.push(o.literal(input.suffix));\n          }\n\n          return params;\n        }\n      };\n\n      // If we ended up generating a call to the same instruction as the previous styling property\n      // we can chain the calls together safely to save some bytes, otherwise we have to generate\n      // a separate instruction call. This is primarily a concern with interpolation instructions\n      // where we may start off with one `reference`, but end up using another based on the\n      // number of interpolations.\n      if (previousInstruction && previousInstruction.reference === referenceForCall) {\n        previousInstruction.calls.push(call);\n      } else {\n        instructions.push({reference: referenceForCall, calls: [call]});\n      }\n    });\n\n    return instructions;\n  }\n\n  private _buildClassInputs(valueConverter: ValueConverter): StylingInstruction[] {\n    if (this._singleClassInputs) {\n      return this._buildSingleInputs(\n          R3.classProp, this._singleClassInputs, valueConverter, null, true);\n    }\n    return [];\n  }\n\n  private _buildStyleInputs(valueConverter: ValueConverter): StylingInstruction[] {\n    if (this._singleStyleInputs) {\n      return this._buildSingleInputs(\n          R3.styleProp, this._singleStyleInputs, valueConverter,\n          getStylePropInterpolationExpression, false);\n    }\n    return [];\n  }\n\n  /**\n   * Constructs all instructions which contain the expressions that will be placed\n   * into the update block of a template function or a directive hostBindings function.\n   */\n  buildUpdateLevelInstructions(valueConverter: ValueConverter) {\n    const instructions: StylingInstruction[] = [];\n    if (this.hasBindings) {\n      const styleMapInstruction = this.buildStyleMapInstruction(valueConverter);\n      if (styleMapInstruction) {\n        instructions.push(styleMapInstruction);\n      }\n      const classMapInstruction = this.buildClassMapInstruction(valueConverter);\n      if (classMapInstruction) {\n        instructions.push(classMapInstruction);\n      }\n      instructions.push(...this._buildStyleInputs(valueConverter));\n      instructions.push(...this._buildClassInputs(valueConverter));\n    }\n    return instructions;\n  }\n}\n\nfunction registerIntoMap(map: Map<string, number>, key: string) {\n  if (!map.has(key)) {\n    map.set(key, map.size);\n  }\n}\n\nexport function parseProperty(name: string):\n    {property: string, suffix: string|null, hasOverrideFlag: boolean} {\n  let hasOverrideFlag = false;\n  const overrideIndex = name.indexOf(IMPORTANT_FLAG);\n  if (overrideIndex !== -1) {\n    name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';\n    hasOverrideFlag = true;\n  }\n\n  let suffix: string|null = null;\n  let property = name;\n  const unitIndex = name.lastIndexOf('.');\n  if (unitIndex > 0) {\n    suffix = name.slice(unitIndex + 1);\n    property = name.substring(0, unitIndex);\n  }\n\n  return {property, suffix, hasOverrideFlag};\n}\n\n/**\n * Gets the instruction to generate for an interpolated class map.\n * @param interpolation An Interpolation AST\n */\nfunction getClassMapInterpolationExpression(interpolation: Interpolation): o.ExternalReference {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return R3.classMap;\n    case 3:\n      return R3.classMapInterpolate1;\n    case 5:\n      return R3.classMapInterpolate2;\n    case 7:\n      return R3.classMapInterpolate3;\n    case 9:\n      return R3.classMapInterpolate4;\n    case 11:\n      return R3.classMapInterpolate5;\n    case 13:\n      return R3.classMapInterpolate6;\n    case 15:\n      return R3.classMapInterpolate7;\n    case 17:\n      return R3.classMapInterpolate8;\n    default:\n      return R3.classMapInterpolateV;\n  }\n}\n\n/**\n * Gets the instruction to generate for an interpolated style map.\n * @param interpolation An Interpolation AST\n */\nfunction getStyleMapInterpolationExpression(interpolation: Interpolation): o.ExternalReference {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return R3.styleMap;\n    case 3:\n      return R3.styleMapInterpolate1;\n    case 5:\n      return R3.styleMapInterpolate2;\n    case 7:\n      return R3.styleMapInterpolate3;\n    case 9:\n      return R3.styleMapInterpolate4;\n    case 11:\n      return R3.styleMapInterpolate5;\n    case 13:\n      return R3.styleMapInterpolate6;\n    case 15:\n      return R3.styleMapInterpolate7;\n    case 17:\n      return R3.styleMapInterpolate8;\n    default:\n      return R3.styleMapInterpolateV;\n  }\n}\n\n/**\n * Gets the instruction to generate for an interpolated style prop.\n * @param interpolation An Interpolation AST\n */\nfunction getStylePropInterpolationExpression(interpolation: Interpolation) {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return R3.styleProp;\n    case 3:\n      return R3.stylePropInterpolate1;\n    case 5:\n      return R3.stylePropInterpolate2;\n    case 7:\n      return R3.stylePropInterpolate3;\n    case 9:\n      return R3.stylePropInterpolate4;\n    case 11:\n      return R3.stylePropInterpolate5;\n    case 13:\n      return R3.stylePropInterpolate6;\n    case 15:\n      return R3.stylePropInterpolate7;\n    case 17:\n      return R3.stylePropInterpolate8;\n    default:\n      return R3.stylePropInterpolateV;\n  }\n}\n\n/**\n * Checks whether property name is a custom CSS property.\n * See: https://www.w3.org/TR/css-variables-1\n */\nfunction isCssCustomProperty(name: string): boolean {\n  return name.startsWith('--');\n}\n\nfunction isEmptyExpression(ast: AST): boolean {\n  if (ast instanceof ASTWithSource) {\n    ast = ast.ast;\n  }\n  return ast instanceof EmptyExpr;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\n\nexport enum TokenType {\n  Character,\n  Identifier,\n  PrivateIdentifier,\n  Keyword,\n  String,\n  Operator,\n  Number,\n  Error\n}\n\nconst KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\n\nexport class Lexer {\n  tokenize(text: string): Token[] {\n    const scanner = new _Scanner(text);\n    const tokens: Token[] = [];\n    let token = scanner.scanToken();\n    while (token != null) {\n      tokens.push(token);\n      token = scanner.scanToken();\n    }\n    return tokens;\n  }\n}\n\nexport class Token {\n  constructor(\n      public index: number, public end: number, public type: TokenType, public numValue: number,\n      public strValue: string) {}\n\n  isCharacter(code: number): boolean {\n    return this.type == TokenType.Character && this.numValue == code;\n  }\n\n  isNumber(): boolean {\n    return this.type == TokenType.Number;\n  }\n\n  isString(): boolean {\n    return this.type == TokenType.String;\n  }\n\n  isOperator(operator: string): boolean {\n    return this.type == TokenType.Operator && this.strValue == operator;\n  }\n\n  isIdentifier(): boolean {\n    return this.type == TokenType.Identifier;\n  }\n\n  isPrivateIdentifier(): boolean {\n    return this.type == TokenType.PrivateIdentifier;\n  }\n\n  isKeyword(): boolean {\n    return this.type == TokenType.Keyword;\n  }\n\n  isKeywordLet(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'let';\n  }\n\n  isKeywordAs(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'as';\n  }\n\n  isKeywordNull(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'null';\n  }\n\n  isKeywordUndefined(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'undefined';\n  }\n\n  isKeywordTrue(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'true';\n  }\n\n  isKeywordFalse(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'false';\n  }\n\n  isKeywordThis(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'this';\n  }\n\n  isError(): boolean {\n    return this.type == TokenType.Error;\n  }\n\n  toNumber(): number {\n    return this.type == TokenType.Number ? this.numValue : -1;\n  }\n\n  toString(): string|null {\n    switch (this.type) {\n      case TokenType.Character:\n      case TokenType.Identifier:\n      case TokenType.Keyword:\n      case TokenType.Operator:\n      case TokenType.PrivateIdentifier:\n      case TokenType.String:\n      case TokenType.Error:\n        return this.strValue;\n      case TokenType.Number:\n        return this.numValue.toString();\n      default:\n        return null;\n    }\n  }\n}\n\nfunction newCharacterToken(index: number, end: number, code: number): Token {\n  return new Token(index, end, TokenType.Character, code, String.fromCharCode(code));\n}\n\nfunction newIdentifierToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.Identifier, 0, text);\n}\n\nfunction newPrivateIdentifierToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.PrivateIdentifier, 0, text);\n}\n\nfunction newKeywordToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.Keyword, 0, text);\n}\n\nfunction newOperatorToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.Operator, 0, text);\n}\n\nfunction newStringToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.String, 0, text);\n}\n\nfunction newNumberToken(index: number, end: number, n: number): Token {\n  return new Token(index, end, TokenType.Number, n, '');\n}\n\nfunction newErrorToken(index: number, end: number, message: string): Token {\n  return new Token(index, end, TokenType.Error, 0, message);\n}\n\nexport const EOF: Token = new Token(-1, -1, TokenType.Character, 0, '');\n\nclass _Scanner {\n  length: number;\n  peek: number = 0;\n  index: number = -1;\n\n  constructor(public input: string) {\n    this.length = input.length;\n    this.advance();\n  }\n\n  advance() {\n    this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n  }\n\n  scanToken(): Token|null {\n    const input = this.input, length = this.length;\n    let peek = this.peek, index = this.index;\n\n    // Skip whitespace.\n    while (peek <= chars.$SPACE) {\n      if (++index >= length) {\n        peek = chars.$EOF;\n        break;\n      } else {\n        peek = input.charCodeAt(index);\n      }\n    }\n\n    this.peek = peek;\n    this.index = index;\n\n    if (index >= length) {\n      return null;\n    }\n\n    // Handle identifiers and numbers.\n    if (isIdentifierStart(peek)) return this.scanIdentifier();\n    if (chars.isDigit(peek)) return this.scanNumber(index);\n\n    const start: number = index;\n    switch (peek) {\n      case chars.$PERIOD:\n        this.advance();\n        return chars.isDigit(this.peek) ? this.scanNumber(start) :\n                                          newCharacterToken(start, this.index, chars.$PERIOD);\n      case chars.$LPAREN:\n      case chars.$RPAREN:\n      case chars.$LBRACE:\n      case chars.$RBRACE:\n      case chars.$LBRACKET:\n      case chars.$RBRACKET:\n      case chars.$COMMA:\n      case chars.$COLON:\n      case chars.$SEMICOLON:\n        return this.scanCharacter(start, peek);\n      case chars.$SQ:\n      case chars.$DQ:\n        return this.scanString();\n      case chars.$HASH:\n        return this.scanPrivateIdentifier();\n      case chars.$PLUS:\n      case chars.$MINUS:\n      case chars.$STAR:\n      case chars.$SLASH:\n      case chars.$PERCENT:\n      case chars.$CARET:\n        return this.scanOperator(start, String.fromCharCode(peek));\n      case chars.$QUESTION:\n        return this.scanQuestion(start);\n      case chars.$LT:\n      case chars.$GT:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, '=');\n      case chars.$BANG:\n      case chars.$EQ:\n        return this.scanComplexOperator(\n            start, String.fromCharCode(peek), chars.$EQ, '=', chars.$EQ, '=');\n      case chars.$AMPERSAND:\n        return this.scanComplexOperator(start, '&', chars.$AMPERSAND, '&');\n      case chars.$BAR:\n        return this.scanComplexOperator(start, '|', chars.$BAR, '|');\n      case chars.$NBSP:\n        while (chars.isWhitespace(this.peek)) this.advance();\n        return this.scanToken();\n    }\n\n    this.advance();\n    return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n  }\n\n  scanCharacter(start: number, code: number): Token {\n    this.advance();\n    return newCharacterToken(start, this.index, code);\n  }\n\n\n  scanOperator(start: number, str: string): Token {\n    this.advance();\n    return newOperatorToken(start, this.index, str);\n  }\n\n  /**\n   * Tokenize a 2/3 char long operator\n   *\n   * @param start start index in the expression\n   * @param one first symbol (always part of the operator)\n   * @param twoCode code point for the second symbol\n   * @param two second symbol (part of the operator when the second code point matches)\n   * @param threeCode code point for the third symbol\n   * @param three third symbol (part of the operator when provided and matches source expression)\n   */\n  scanComplexOperator(\n      start: number, one: string, twoCode: number, two: string, threeCode?: number,\n      three?: string): Token {\n    this.advance();\n    let str: string = one;\n    if (this.peek == twoCode) {\n      this.advance();\n      str += two;\n    }\n    if (threeCode != null && this.peek == threeCode) {\n      this.advance();\n      str += three;\n    }\n    return newOperatorToken(start, this.index, str);\n  }\n\n  scanIdentifier(): Token {\n    const start: number = this.index;\n    this.advance();\n    while (isIdentifierPart(this.peek)) this.advance();\n    const str: string = this.input.substring(start, this.index);\n    return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) :\n                                        newIdentifierToken(start, this.index, str);\n  }\n\n  /** Scans an ECMAScript private identifier. */\n  scanPrivateIdentifier(): Token {\n    const start: number = this.index;\n    this.advance();\n    if (!isIdentifierStart(this.peek)) {\n      return this.error('Invalid character [#]', -1);\n    }\n    while (isIdentifierPart(this.peek)) this.advance();\n    const identifierName: string = this.input.substring(start, this.index);\n    return newPrivateIdentifierToken(start, this.index, identifierName);\n  }\n\n  scanNumber(start: number): Token {\n    let simple = (this.index === start);\n    let hasSeparators = false;\n    this.advance();  // Skip initial digit.\n    while (true) {\n      if (chars.isDigit(this.peek)) {\n        // Do nothing.\n      } else if (this.peek === chars.$_) {\n        // Separators are only valid when they're surrounded by digits. E.g. `1_0_1` is\n        // valid while `_101` and `101_` are not. The separator can't be next to the decimal\n        // point or another separator either. Note that it's unlikely that we'll hit a case where\n        // the underscore is at the start, because that's a valid identifier and it will be picked\n        // up earlier in the parsing. We validate for it anyway just in case.\n        if (!chars.isDigit(this.input.charCodeAt(this.index - 1)) ||\n            !chars.isDigit(this.input.charCodeAt(this.index + 1))) {\n          return this.error('Invalid numeric separator', 0);\n        }\n        hasSeparators = true;\n      } else if (this.peek === chars.$PERIOD) {\n        simple = false;\n      } else if (isExponentStart(this.peek)) {\n        this.advance();\n        if (isExponentSign(this.peek)) this.advance();\n        if (!chars.isDigit(this.peek)) return this.error('Invalid exponent', -1);\n        simple = false;\n      } else {\n        break;\n      }\n      this.advance();\n    }\n\n    let str = this.input.substring(start, this.index);\n    if (hasSeparators) {\n      str = str.replace(/_/g, '');\n    }\n    const value = simple ? parseIntAutoRadix(str) : parseFloat(str);\n    return newNumberToken(start, this.index, value);\n  }\n\n  scanString(): Token {\n    const start: number = this.index;\n    const quote: number = this.peek;\n    this.advance();  // Skip initial quote.\n\n    let buffer: string = '';\n    let marker: number = this.index;\n    const input: string = this.input;\n\n    while (this.peek != quote) {\n      if (this.peek == chars.$BACKSLASH) {\n        buffer += input.substring(marker, this.index);\n        this.advance();\n        let unescapedCode: number;\n        // Workaround for TS2.1-introduced type strictness\n        this.peek = this.peek;\n        if (this.peek == chars.$u) {\n          // 4 character hex code for unicode character.\n          const hex: string = input.substring(this.index + 1, this.index + 5);\n          if (/^[0-9a-f]+$/i.test(hex)) {\n            unescapedCode = parseInt(hex, 16);\n          } else {\n            return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n          }\n          for (let i: number = 0; i < 5; i++) {\n            this.advance();\n          }\n        } else {\n          unescapedCode = unescape(this.peek);\n          this.advance();\n        }\n        buffer += String.fromCharCode(unescapedCode);\n        marker = this.index;\n      } else if (this.peek == chars.$EOF) {\n        return this.error('Unterminated quote', 0);\n      } else {\n        this.advance();\n      }\n    }\n\n    const last: string = input.substring(marker, this.index);\n    this.advance();  // Skip terminating quote.\n\n    return newStringToken(start, this.index, buffer + last);\n  }\n\n  scanQuestion(start: number): Token {\n    this.advance();\n    let str: string = '?';\n    // Either `a ?? b` or 'a?.b'.\n    if (this.peek === chars.$QUESTION || this.peek === chars.$PERIOD) {\n      str += this.peek === chars.$PERIOD ? '.' : '?';\n      this.advance();\n    }\n    return newOperatorToken(start, this.index, str);\n  }\n\n  error(message: string, offset: number): Token {\n    const position: number = this.index + offset;\n    return newErrorToken(\n        position, this.index,\n        `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n  }\n}\n\nfunction isIdentifierStart(code: number): boolean {\n  return (chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) ||\n      (code == chars.$_) || (code == chars.$$);\n}\n\nexport function isIdentifier(input: string): boolean {\n  if (input.length == 0) return false;\n  const scanner = new _Scanner(input);\n  if (!isIdentifierStart(scanner.peek)) return false;\n  scanner.advance();\n  while (scanner.peek !== chars.$EOF) {\n    if (!isIdentifierPart(scanner.peek)) return false;\n    scanner.advance();\n  }\n  return true;\n}\n\nfunction isIdentifierPart(code: number): boolean {\n  return chars.isAsciiLetter(code) || chars.isDigit(code) || (code == chars.$_) ||\n      (code == chars.$$);\n}\n\nfunction isExponentStart(code: number): boolean {\n  return code == chars.$e || code == chars.$E;\n}\n\nfunction isExponentSign(code: number): boolean {\n  return code == chars.$MINUS || code == chars.$PLUS;\n}\n\nfunction unescape(code: number): number {\n  switch (code) {\n    case chars.$n:\n      return chars.$LF;\n    case chars.$f:\n      return chars.$FF;\n    case chars.$r:\n      return chars.$CR;\n    case chars.$t:\n      return chars.$TAB;\n    case chars.$v:\n      return chars.$VTAB;\n    default:\n      return code;\n  }\n}\n\nfunction parseIntAutoRadix(text: string): number {\n  const result: number = parseInt(text);\n  if (isNaN(result)) {\n    throw new Error('Invalid integer literal when parsing ' + text);\n  }\n  return result;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {InterpolatedAttributeToken, InterpolatedTextToken, TokenType as MlParserTokenType} from '../ml_parser/tokens';\n\nimport {AbsoluteSourceSpan, AST, ASTWithSource, Binary, BindingPipe, Call, Chain, Conditional, EmptyExpr, ExpressionBinding, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralMapKey, LiteralPrimitive, NonNullAssert, ParserError, ParseSpan, PrefixNot, PropertyRead, PropertyWrite, RecursiveAstVisitor, SafeCall, SafeKeyedRead, SafePropertyRead, TemplateBinding, TemplateBindingIdentifier, ThisReceiver, Unary, VariableBinding} from './ast';\nimport {EOF, Lexer, Token, TokenType} from './lexer';\n\nexport interface InterpolationPiece {\n  text: string;\n  start: number;\n  end: number;\n}\nexport class SplitInterpolation {\n  constructor(\n      public strings: InterpolationPiece[], public expressions: InterpolationPiece[],\n      public offsets: number[]) {}\n}\n\nexport class TemplateBindingParseResult {\n  constructor(\n      public templateBindings: TemplateBinding[], public warnings: string[],\n      public errors: ParserError[]) {}\n}\n\n/**\n * Represents the possible parse modes to be used as a bitmask.\n */\nexport const enum ParseFlags {\n  None = 0,\n\n  /**\n   * Whether an output binding is being parsed.\n   */\n  Action = 1 << 0,\n\n  /**\n   * Whether an assignment event is being parsed, i.e. an expression originating from\n   * two-way-binding aka banana-in-a-box syntax.\n   */\n  AssignmentEvent = 1 << 1,\n}\n\nexport class Parser {\n  private errors: ParserError[] = [];\n\n  constructor(private _lexer: Lexer) {}\n\n  parseAction(\n      input: string, isAssignmentEvent: boolean, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    let flags = ParseFlags.Action;\n    if (isAssignmentEvent) {\n      flags |= ParseFlags.AssignmentEvent;\n    }\n    const ast =\n        new _ParseAST(input, location, absoluteOffset, tokens, flags, this.errors, 0).parseChain();\n    return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n  }\n\n  parseBinding(\n      input: string, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n    return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n  }\n\n  private checkSimpleExpression(ast: AST): string[] {\n    const checker = new SimpleExpressionChecker();\n    ast.visit(checker);\n    return checker.errors;\n  }\n\n  parseSimpleBinding(\n      input: string, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n    const errors = this.checkSimpleExpression(ast);\n    if (errors.length > 0) {\n      this._reportError(\n          `Host binding expression cannot contain ${errors.join(' ')}`, input, location);\n    }\n    return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n  }\n\n  private _reportError(message: string, input: string, errLocation: string, ctxLocation?: string) {\n    this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n  }\n\n  private _parseBindingAst(\n      input: string, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig): AST {\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    return new _ParseAST(input, location, absoluteOffset, tokens, ParseFlags.None, this.errors, 0)\n        .parseChain();\n  }\n\n  /**\n   * Parse microsyntax template expression and return a list of bindings or\n   * parsing errors in case the given expression is invalid.\n   *\n   * For example,\n   * ```\n   *   <div *ngFor=\"let item of items\">\n   *         ^      ^ absoluteValueOffset for `templateValue`\n   *         absoluteKeyOffset for `templateKey`\n   * ```\n   * contains three bindings:\n   * 1. ngFor -> null\n   * 2. item -> NgForOfContext.$implicit\n   * 3. ngForOf -> items\n   *\n   * This is apparent from the de-sugared template:\n   * ```\n   *   <ng-template ngFor let-item [ngForOf]=\"items\">\n   * ```\n   *\n   * @param templateKey name of directive, without the * prefix. For example: ngIf, ngFor\n   * @param templateValue RHS of the microsyntax attribute\n   * @param templateUrl template filename if it's external, component filename if it's inline\n   * @param absoluteKeyOffset start of the `templateKey`\n   * @param absoluteValueOffset start of the `templateValue`\n   */\n  parseTemplateBindings(\n      templateKey: string, templateValue: string, templateUrl: string, absoluteKeyOffset: number,\n      absoluteValueOffset: number): TemplateBindingParseResult {\n    const tokens = this._lexer.tokenize(templateValue);\n    const parser = new _ParseAST(\n        templateValue, templateUrl, absoluteValueOffset, tokens, ParseFlags.None, this.errors,\n        0 /* relative offset */);\n    return parser.parseTemplateBindings({\n      source: templateKey,\n      span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length),\n    });\n  }\n\n  parseInterpolation(\n      input: string, location: string, absoluteOffset: number,\n      interpolatedTokens: InterpolatedAttributeToken[]|InterpolatedTextToken[]|null,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource|null {\n    const {strings, expressions, offsets} =\n        this.splitInterpolation(input, location, interpolatedTokens, interpolationConfig);\n    if (expressions.length === 0) return null;\n\n    const expressionNodes: AST[] = [];\n\n    for (let i = 0; i < expressions.length; ++i) {\n      const expressionText = expressions[i].text;\n      const sourceToLex = this._stripComments(expressionText);\n      const tokens = this._lexer.tokenize(sourceToLex);\n      const ast =\n          new _ParseAST(\n              input, location, absoluteOffset, tokens, ParseFlags.None, this.errors, offsets[i])\n              .parseChain();\n      expressionNodes.push(ast);\n    }\n\n    return this.createInterpolationAst(\n        strings.map(s => s.text), expressionNodes, input, location, absoluteOffset);\n  }\n\n  /**\n   * Similar to `parseInterpolation`, but treats the provided string as a single expression\n   * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\n   * This is used for parsing the switch expression in ICUs.\n   */\n  parseInterpolationExpression(expression: string, location: string, absoluteOffset: number):\n      ASTWithSource {\n    const sourceToLex = this._stripComments(expression);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    const ast =\n        new _ParseAST(expression, location, absoluteOffset, tokens, ParseFlags.None, this.errors, 0)\n            .parseChain();\n    const strings = ['', ''];  // The prefix and suffix strings are both empty\n    return this.createInterpolationAst(strings, [ast], expression, location, absoluteOffset);\n  }\n\n  private createInterpolationAst(\n      strings: string[], expressions: AST[], input: string, location: string,\n      absoluteOffset: number): ASTWithSource {\n    const span = new ParseSpan(0, input.length);\n    const interpolation =\n        new Interpolation(span, span.toAbsolute(absoluteOffset), strings, expressions);\n    return new ASTWithSource(interpolation, input, location, absoluteOffset, this.errors);\n  }\n\n  /**\n   * Splits a string of text into \"raw\" text segments and expressions present in interpolations in\n   * the string.\n   * Returns `null` if there are no interpolations, otherwise a\n   * `SplitInterpolation` with splits that look like\n   *   <raw text> <expression> <raw text> ... <raw text> <expression> <raw text>\n   */\n  splitInterpolation(\n      input: string, location: string,\n      interpolatedTokens: InterpolatedAttributeToken[]|InterpolatedTextToken[]|null,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): SplitInterpolation {\n    const strings: InterpolationPiece[] = [];\n    const expressions: InterpolationPiece[] = [];\n    const offsets: number[] = [];\n    const inputToTemplateIndexMap =\n        interpolatedTokens ? getIndexMapForOriginalTemplate(interpolatedTokens) : null;\n    let i = 0;\n    let atInterpolation = false;\n    let extendLastString = false;\n    let {start: interpStart, end: interpEnd} = interpolationConfig;\n    while (i < input.length) {\n      if (!atInterpolation) {\n        // parse until starting {{\n        const start = i;\n        i = input.indexOf(interpStart, i);\n        if (i === -1) {\n          i = input.length;\n        }\n        const text = input.substring(start, i);\n        strings.push({text, start, end: i});\n\n        atInterpolation = true;\n      } else {\n        // parse from starting {{ to ending }} while ignoring content inside quotes.\n        const fullStart = i;\n        const exprStart = fullStart + interpStart.length;\n        const exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);\n        if (exprEnd === -1) {\n          // Could not find the end of the interpolation; do not parse an expression.\n          // Instead we should extend the content on the last raw string.\n          atInterpolation = false;\n          extendLastString = true;\n          break;\n        }\n        const fullEnd = exprEnd + interpEnd.length;\n\n        const text = input.substring(exprStart, exprEnd);\n        if (text.trim().length === 0) {\n          this._reportError(\n              'Blank expressions are not allowed in interpolated strings', input,\n              `at column ${i} in`, location);\n        }\n        expressions.push({text, start: fullStart, end: fullEnd});\n        const startInOriginalTemplate = inputToTemplateIndexMap?.get(fullStart) ?? fullStart;\n        const offset = startInOriginalTemplate + interpStart.length;\n        offsets.push(offset);\n\n        i = fullEnd;\n        atInterpolation = false;\n      }\n    }\n    if (!atInterpolation) {\n      // If we are now at a text section, add the remaining content as a raw string.\n      if (extendLastString) {\n        const piece = strings[strings.length - 1];\n        piece.text += input.substring(i);\n        piece.end = input.length;\n      } else {\n        strings.push({text: input.substring(i), start: i, end: input.length});\n      }\n    }\n    return new SplitInterpolation(strings, expressions, offsets);\n  }\n\n  wrapLiteralPrimitive(input: string|null, location: string, absoluteOffset: number):\n      ASTWithSource {\n    const span = new ParseSpan(0, input == null ? 0 : input.length);\n    return new ASTWithSource(\n        new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location,\n        absoluteOffset, this.errors);\n  }\n\n  private _stripComments(input: string): string {\n    const i = this._commentStart(input);\n    return i != null ? input.substring(0, i) : input;\n  }\n\n  private _commentStart(input: string): number|null {\n    let outerQuote: number|null = null;\n    for (let i = 0; i < input.length - 1; i++) {\n      const char = input.charCodeAt(i);\n      const nextChar = input.charCodeAt(i + 1);\n\n      if (char === chars.$SLASH && nextChar == chars.$SLASH && outerQuote == null) return i;\n\n      if (outerQuote === char) {\n        outerQuote = null;\n      } else if (outerQuote == null && chars.isQuote(char)) {\n        outerQuote = char;\n      }\n    }\n    return null;\n  }\n\n  private _checkNoInterpolation(input: string, location: string, {start, end}: InterpolationConfig):\n      void {\n    let startIndex = -1;\n    let endIndex = -1;\n\n    for (const charIndex of this._forEachUnquotedChar(input, 0)) {\n      if (startIndex === -1) {\n        if (input.startsWith(start)) {\n          startIndex = charIndex;\n        }\n      } else {\n        endIndex = this._getInterpolationEndIndex(input, end, charIndex);\n        if (endIndex > -1) {\n          break;\n        }\n      }\n    }\n\n    if (startIndex > -1 && endIndex > -1) {\n      this._reportError(\n          `Got interpolation (${start}${end}) where expression was expected`, input,\n          `at column ${startIndex} in`, location);\n    }\n  }\n\n  /**\n   * Finds the index of the end of an interpolation expression\n   * while ignoring comments and quoted content.\n   */\n  private _getInterpolationEndIndex(input: string, expressionEnd: string, start: number): number {\n    for (const charIndex of this._forEachUnquotedChar(input, start)) {\n      if (input.startsWith(expressionEnd, charIndex)) {\n        return charIndex;\n      }\n\n      // Nothing else in the expression matters after we've\n      // hit a comment so look directly for the end token.\n      if (input.startsWith('//', charIndex)) {\n        return input.indexOf(expressionEnd, charIndex);\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Generator used to iterate over the character indexes of a string that are outside of quotes.\n   * @param input String to loop through.\n   * @param start Index within the string at which to start.\n   */\n  private * _forEachUnquotedChar(input: string, start: number) {\n    let currentQuote: string|null = null;\n    let escapeCount = 0;\n    for (let i = start; i < input.length; i++) {\n      const char = input[i];\n      // Skip the characters inside quotes. Note that we only care about the outer-most\n      // quotes matching up and we need to account for escape characters.\n      if (chars.isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) &&\n          escapeCount % 2 === 0) {\n        currentQuote = currentQuote === null ? char : null;\n      } else if (currentQuote === null) {\n        yield i;\n      }\n      escapeCount = char === '\\\\' ? escapeCount + 1 : 0;\n    }\n  }\n}\n\n/** Describes a stateful context an expression parser is in. */\nenum ParseContextFlags {\n  None = 0,\n  /**\n   * A Writable context is one in which a value may be written to an lvalue.\n   * For example, after we see a property access, we may expect a write to the\n   * property via the \"=\" operator.\n   *   prop\n   *        ^ possible \"=\" after\n   */\n  Writable = 1,\n}\n\nexport class _ParseAST {\n  private rparensExpected = 0;\n  private rbracketsExpected = 0;\n  private rbracesExpected = 0;\n  private context = ParseContextFlags.None;\n\n  // Cache of expression start and input indeces to the absolute source span they map to, used to\n  // prevent creating superfluous source spans in `sourceSpan`.\n  // A serial of the expression start and input index is used for mapping because both are stateful\n  // and may change for subsequent expressions visited by the parser.\n  private sourceSpanCache = new Map<string, AbsoluteSourceSpan>();\n\n  index: number = 0;\n\n  constructor(\n      public input: string, public location: string, public absoluteOffset: number,\n      public tokens: Token[], public parseFlags: ParseFlags, private errors: ParserError[],\n      private offset: number) {}\n\n  peek(offset: number): Token {\n    const i = this.index + offset;\n    return i < this.tokens.length ? this.tokens[i] : EOF;\n  }\n\n  get next(): Token {\n    return this.peek(0);\n  }\n\n  /** Whether all the parser input has been processed. */\n  get atEOF(): boolean {\n    return this.index >= this.tokens.length;\n  }\n\n  /**\n   * Index of the next token to be processed, or the end of the last token if all have been\n   * processed.\n   */\n  get inputIndex(): number {\n    return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;\n  }\n\n  /**\n   * End index of the last processed token, or the start of the first token if none have been\n   * processed.\n   */\n  get currentEndIndex(): number {\n    if (this.index > 0) {\n      const curToken = this.peek(-1);\n      return curToken.end + this.offset;\n    }\n    // No tokens have been processed yet; return the next token's start or the length of the input\n    // if there is no token.\n    if (this.tokens.length === 0) {\n      return this.input.length + this.offset;\n    }\n    return this.next.index + this.offset;\n  }\n\n  /**\n   * Returns the absolute offset of the start of the current token.\n   */\n  get currentAbsoluteOffset(): number {\n    return this.absoluteOffset + this.inputIndex;\n  }\n\n  /**\n   * Retrieve a `ParseSpan` from `start` to the current position (or to `artificialEndIndex` if\n   * provided).\n   *\n   * @param start Position from which the `ParseSpan` will start.\n   * @param artificialEndIndex Optional ending index to be used if provided (and if greater than the\n   *     natural ending index)\n   */\n  span(start: number, artificialEndIndex?: number): ParseSpan {\n    let endIndex = this.currentEndIndex;\n    if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {\n      endIndex = artificialEndIndex;\n    }\n\n    // In some unusual parsing scenarios (like when certain tokens are missing and an `EmptyExpr` is\n    // being created), the current token may already be advanced beyond the `currentEndIndex`. This\n    // appears to be a deep-seated parser bug.\n    //\n    // As a workaround for now, swap the start and end indices to ensure a valid `ParseSpan`.\n    // TODO(alxhub): fix the bug upstream in the parser state, and remove this workaround.\n    if (start > endIndex) {\n      const tmp = endIndex;\n      endIndex = start;\n      start = tmp;\n    }\n\n    return new ParseSpan(start, endIndex);\n  }\n\n  sourceSpan(start: number, artificialEndIndex?: number): AbsoluteSourceSpan {\n    const serial = `${start}@${this.inputIndex}:${artificialEndIndex}`;\n    if (!this.sourceSpanCache.has(serial)) {\n      this.sourceSpanCache.set(\n          serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));\n    }\n    return this.sourceSpanCache.get(serial)!;\n  }\n\n  advance() {\n    this.index++;\n  }\n\n  /**\n   * Executes a callback in the provided context.\n   */\n  private withContext<T>(context: ParseContextFlags, cb: () => T): T {\n    this.context |= context;\n    const ret = cb();\n    this.context ^= context;\n    return ret;\n  }\n\n  consumeOptionalCharacter(code: number): boolean {\n    if (this.next.isCharacter(code)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  peekKeywordLet(): boolean {\n    return this.next.isKeywordLet();\n  }\n  peekKeywordAs(): boolean {\n    return this.next.isKeywordAs();\n  }\n\n  /**\n   * Consumes an expected character, otherwise emits an error about the missing expected character\n   * and skips over the token stream until reaching a recoverable point.\n   *\n   * See `this.error` and `this.skip` for more details.\n   */\n  expectCharacter(code: number) {\n    if (this.consumeOptionalCharacter(code)) return;\n    this.error(`Missing expected ${String.fromCharCode(code)}`);\n  }\n\n  consumeOptionalOperator(op: string): boolean {\n    if (this.next.isOperator(op)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  expectOperator(operator: string) {\n    if (this.consumeOptionalOperator(operator)) return;\n    this.error(`Missing expected operator ${operator}`);\n  }\n\n  prettyPrintToken(tok: Token): string {\n    return tok === EOF ? 'end of input' : `token ${tok}`;\n  }\n\n  expectIdentifierOrKeyword(): string|null {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword()) {\n      if (n.isPrivateIdentifier()) {\n        this._reportErrorForPrivateIdentifier(n, 'expected identifier or keyword');\n      } else {\n        this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier or keyword`);\n      }\n      return null;\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  expectIdentifierOrKeywordOrString(): string {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n      if (n.isPrivateIdentifier()) {\n        this._reportErrorForPrivateIdentifier(n, 'expected identifier, keyword or string');\n      } else {\n        this.error(\n            `Unexpected ${this.prettyPrintToken(n)}, expected identifier, keyword, or string`);\n      }\n      return '';\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  parseChain(): AST {\n    const exprs: AST[] = [];\n    const start = this.inputIndex;\n    while (this.index < this.tokens.length) {\n      const expr = this.parsePipe();\n      exprs.push(expr);\n\n      if (this.consumeOptionalCharacter(chars.$SEMICOLON)) {\n        if (!(this.parseFlags & ParseFlags.Action)) {\n          this.error('Binding expression cannot contain chained expression');\n        }\n        while (this.consumeOptionalCharacter(chars.$SEMICOLON)) {\n        }  // read all semicolons\n      } else if (this.index < this.tokens.length) {\n        const errorIndex = this.index;\n        this.error(`Unexpected token '${this.next}'`);\n        // The `error` call above will skip ahead to the next recovery point in an attempt to\n        // recover part of the expression, but that might be the token we started from which will\n        // lead to an infinite loop. If that's the case, break the loop assuming that we can't\n        // parse further.\n        if (this.index === errorIndex) {\n          break;\n        }\n      }\n    }\n    if (exprs.length === 0) {\n      // We have no expressions so create an empty expression that spans the entire input length\n      const artificialStart = this.offset;\n      const artificialEnd = this.offset + this.input.length;\n      return new EmptyExpr(\n          this.span(artificialStart, artificialEnd),\n          this.sourceSpan(artificialStart, artificialEnd));\n    }\n    if (exprs.length == 1) return exprs[0];\n    return new Chain(this.span(start), this.sourceSpan(start), exprs);\n  }\n\n  parsePipe(): AST {\n    const start = this.inputIndex;\n    let result = this.parseExpression();\n    if (this.consumeOptionalOperator('|')) {\n      if (this.parseFlags & ParseFlags.Action) {\n        this.error('Cannot have a pipe in an action expression');\n      }\n\n      do {\n        const nameStart = this.inputIndex;\n        let nameId = this.expectIdentifierOrKeyword();\n        let nameSpan: AbsoluteSourceSpan;\n        let fullSpanEnd: number|undefined = undefined;\n        if (nameId !== null) {\n          nameSpan = this.sourceSpan(nameStart);\n        } else {\n          // No valid identifier was found, so we'll assume an empty pipe name ('').\n          nameId = '';\n\n          // However, there may have been whitespace present between the pipe character and the next\n          // token in the sequence (or the end of input). We want to track this whitespace so that\n          // the `BindingPipe` we produce covers not just the pipe character, but any trailing\n          // whitespace beyond it. Another way of thinking about this is that the zero-length name\n          // is assumed to be at the end of any whitespace beyond the pipe character.\n          //\n          // Therefore, we push the end of the `ParseSpan` for this pipe all the way up to the\n          // beginning of the next token, or until the end of input if the next token is EOF.\n          fullSpanEnd = this.next.index !== -1 ? this.next.index : this.input.length + this.offset;\n\n          // The `nameSpan` for an empty pipe name is zero-length at the end of any whitespace\n          // beyond the pipe character.\n          nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);\n        }\n\n        const args: AST[] = [];\n        while (this.consumeOptionalCharacter(chars.$COLON)) {\n          args.push(this.parseExpression());\n\n          // If there are additional expressions beyond the name, then the artificial end for the\n          // name is no longer relevant.\n        }\n        result = new BindingPipe(\n            this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, nameSpan);\n      } while (this.consumeOptionalOperator('|'));\n    }\n\n    return result;\n  }\n\n  parseExpression(): AST {\n    return this.parseConditional();\n  }\n\n  parseConditional(): AST {\n    const start = this.inputIndex;\n    const result = this.parseLogicalOr();\n\n    if (this.consumeOptionalOperator('?')) {\n      const yes = this.parsePipe();\n      let no: AST;\n      if (!this.consumeOptionalCharacter(chars.$COLON)) {\n        const end = this.inputIndex;\n        const expression = this.input.substring(start, end);\n        this.error(`Conditional expression ${expression} requires all 3 expressions`);\n        no = new EmptyExpr(this.span(start), this.sourceSpan(start));\n      } else {\n        no = this.parsePipe();\n      }\n      return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);\n    } else {\n      return result;\n    }\n  }\n\n  parseLogicalOr(): AST {\n    // '||'\n    const start = this.inputIndex;\n    let result = this.parseLogicalAnd();\n    while (this.consumeOptionalOperator('||')) {\n      const right = this.parseLogicalAnd();\n      result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);\n    }\n    return result;\n  }\n\n  parseLogicalAnd(): AST {\n    // '&&'\n    const start = this.inputIndex;\n    let result = this.parseNullishCoalescing();\n    while (this.consumeOptionalOperator('&&')) {\n      const right = this.parseNullishCoalescing();\n      result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);\n    }\n    return result;\n  }\n\n  parseNullishCoalescing(): AST {\n    // '??'\n    const start = this.inputIndex;\n    let result = this.parseEquality();\n    while (this.consumeOptionalOperator('??')) {\n      const right = this.parseEquality();\n      result = new Binary(this.span(start), this.sourceSpan(start), '??', result, right);\n    }\n    return result;\n  }\n\n  parseEquality(): AST {\n    // '==','!=','===','!=='\n    const start = this.inputIndex;\n    let result = this.parseRelational();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '==':\n        case '===':\n        case '!=':\n        case '!==':\n          this.advance();\n          const right = this.parseRelational();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseRelational(): AST {\n    // '<', '>', '<=', '>='\n    const start = this.inputIndex;\n    let result = this.parseAdditive();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n          this.advance();\n          const right = this.parseAdditive();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseAdditive(): AST {\n    // '+', '-'\n    const start = this.inputIndex;\n    let result = this.parseMultiplicative();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '+':\n        case '-':\n          this.advance();\n          let right = this.parseMultiplicative();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseMultiplicative(): AST {\n    // '*', '%', '/'\n    const start = this.inputIndex;\n    let result = this.parsePrefix();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '*':\n        case '%':\n        case '/':\n          this.advance();\n          let right = this.parsePrefix();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parsePrefix(): AST {\n    if (this.next.type == TokenType.Operator) {\n      const start = this.inputIndex;\n      const operator = this.next.strValue;\n      let result: AST;\n      switch (operator) {\n        case '+':\n          this.advance();\n          result = this.parsePrefix();\n          return Unary.createPlus(this.span(start), this.sourceSpan(start), result);\n        case '-':\n          this.advance();\n          result = this.parsePrefix();\n          return Unary.createMinus(this.span(start), this.sourceSpan(start), result);\n        case '!':\n          this.advance();\n          result = this.parsePrefix();\n          return new PrefixNot(this.span(start), this.sourceSpan(start), result);\n      }\n    }\n    return this.parseCallChain();\n  }\n\n  parseCallChain(): AST {\n    const start = this.inputIndex;\n    let result = this.parsePrimary();\n    while (true) {\n      if (this.consumeOptionalCharacter(chars.$PERIOD)) {\n        result = this.parseAccessMember(result, start, false);\n      } else if (this.consumeOptionalOperator('?.')) {\n        if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n          result = this.parseCall(result, start, true);\n        } else {\n          result = this.consumeOptionalCharacter(chars.$LBRACKET) ?\n              this.parseKeyedReadOrWrite(result, start, true) :\n              this.parseAccessMember(result, start, true);\n        }\n      } else if (this.consumeOptionalCharacter(chars.$LBRACKET)) {\n        result = this.parseKeyedReadOrWrite(result, start, false);\n      } else if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n        result = this.parseCall(result, start, false);\n      } else if (this.consumeOptionalOperator('!')) {\n        result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);\n\n      } else {\n        return result;\n      }\n    }\n  }\n\n  parsePrimary(): AST {\n    const start = this.inputIndex;\n    if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const result = this.parsePipe();\n      this.rparensExpected--;\n      this.expectCharacter(chars.$RPAREN);\n      return result;\n\n    } else if (this.next.isKeywordNull()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);\n\n    } else if (this.next.isKeywordUndefined()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);\n\n    } else if (this.next.isKeywordTrue()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);\n\n    } else if (this.next.isKeywordFalse()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);\n\n    } else if (this.next.isKeywordThis()) {\n      this.advance();\n      return new ThisReceiver(this.span(start), this.sourceSpan(start));\n    } else if (this.consumeOptionalCharacter(chars.$LBRACKET)) {\n      this.rbracketsExpected++;\n      const elements = this.parseExpressionList(chars.$RBRACKET);\n      this.rbracketsExpected--;\n      this.expectCharacter(chars.$RBRACKET);\n      return new LiteralArray(this.span(start), this.sourceSpan(start), elements);\n\n    } else if (this.next.isCharacter(chars.$LBRACE)) {\n      return this.parseLiteralMap();\n\n    } else if (this.next.isIdentifier()) {\n      return this.parseAccessMember(\n          new ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);\n    } else if (this.next.isNumber()) {\n      const value = this.next.toNumber();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);\n\n    } else if (this.next.isString()) {\n      const literalValue = this.next.toString();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);\n\n    } else if (this.next.isPrivateIdentifier()) {\n      this._reportErrorForPrivateIdentifier(this.next, null);\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n\n    } else if (this.index >= this.tokens.length) {\n      this.error(`Unexpected end of expression: ${this.input}`);\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n    } else {\n      this.error(`Unexpected token ${this.next}`);\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n    }\n  }\n\n  parseExpressionList(terminator: number): AST[] {\n    const result: AST[] = [];\n\n    do {\n      if (!this.next.isCharacter(terminator)) {\n        result.push(this.parsePipe());\n      } else {\n        break;\n      }\n    } while (this.consumeOptionalCharacter(chars.$COMMA));\n    return result;\n  }\n\n  parseLiteralMap(): LiteralMap {\n    const keys: LiteralMapKey[] = [];\n    const values: AST[] = [];\n    const start = this.inputIndex;\n    this.expectCharacter(chars.$LBRACE);\n    if (!this.consumeOptionalCharacter(chars.$RBRACE)) {\n      this.rbracesExpected++;\n      do {\n        const keyStart = this.inputIndex;\n        const quoted = this.next.isString();\n        const key = this.expectIdentifierOrKeywordOrString();\n        keys.push({key, quoted});\n\n        // Properties with quoted keys can't use the shorthand syntax.\n        if (quoted) {\n          this.expectCharacter(chars.$COLON);\n          values.push(this.parsePipe());\n        } else if (this.consumeOptionalCharacter(chars.$COLON)) {\n          values.push(this.parsePipe());\n        } else {\n          const span = this.span(keyStart);\n          const sourceSpan = this.sourceSpan(keyStart);\n          values.push(new PropertyRead(\n              span, sourceSpan, sourceSpan, new ImplicitReceiver(span, sourceSpan), key));\n        }\n      } while (this.consumeOptionalCharacter(chars.$COMMA));\n      this.rbracesExpected--;\n      this.expectCharacter(chars.$RBRACE);\n    }\n    return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);\n  }\n\n  parseAccessMember(readReceiver: AST, start: number, isSafe: boolean): AST {\n    const nameStart = this.inputIndex;\n    const id = this.withContext(ParseContextFlags.Writable, () => {\n      const id = this.expectIdentifierOrKeyword() ?? '';\n      if (id.length === 0) {\n        this.error(`Expected identifier for property access`, readReceiver.span.end);\n      }\n      return id;\n    });\n    const nameSpan = this.sourceSpan(nameStart);\n    let receiver: AST;\n\n    if (isSafe) {\n      if (this.consumeOptionalAssignment()) {\n        this.error('The \\'?.\\' operator cannot be used in the assignment');\n        receiver = new EmptyExpr(this.span(start), this.sourceSpan(start));\n      } else {\n        receiver = new SafePropertyRead(\n            this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n      }\n    } else {\n      if (this.consumeOptionalAssignment()) {\n        if (!(this.parseFlags & ParseFlags.Action)) {\n          this.error('Bindings cannot contain assignments');\n          return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        }\n\n        const value = this.parseConditional();\n        receiver = new PropertyWrite(\n            this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id, value);\n      } else {\n        receiver =\n            new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n      }\n    }\n\n    return receiver;\n  }\n\n  parseCall(receiver: AST, start: number, isSafe: boolean): AST {\n    const argumentStart = this.inputIndex;\n    this.rparensExpected++;\n    const args = this.parseCallArguments();\n    const argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);\n    this.expectCharacter(chars.$RPAREN);\n    this.rparensExpected--;\n    const span = this.span(start);\n    const sourceSpan = this.sourceSpan(start);\n    return isSafe ? new SafeCall(span, sourceSpan, receiver, args, argumentSpan) :\n                    new Call(span, sourceSpan, receiver, args, argumentSpan);\n  }\n\n  private consumeOptionalAssignment(): boolean {\n    // When parsing assignment events (originating from two-way-binding aka banana-in-a-box syntax),\n    // it is valid for the primary expression to be terminated by the non-null operator. This\n    // primary expression is substituted as LHS of the assignment operator to achieve\n    // two-way-binding, such that the LHS could be the non-null operator. The grammar doesn't\n    // naturally allow for this syntax, so assignment events are parsed specially.\n    if ((this.parseFlags & ParseFlags.AssignmentEvent) && this.next.isOperator('!') &&\n        this.peek(1).isOperator('=')) {\n      // First skip over the ! operator.\n      this.advance();\n      // Then skip over the = operator, to fully consume the optional assignment operator.\n      this.advance();\n      return true;\n    }\n\n    return this.consumeOptionalOperator('=');\n  }\n\n  parseCallArguments(): BindingPipe[] {\n    if (this.next.isCharacter(chars.$RPAREN)) return [];\n    const positionals: AST[] = [];\n    do {\n      positionals.push(this.parsePipe());\n    } while (this.consumeOptionalCharacter(chars.$COMMA));\n    return positionals as BindingPipe[];\n  }\n\n  /**\n   * Parses an identifier, a keyword, a string with an optional `-` in between,\n   * and returns the string along with its absolute source span.\n   */\n  expectTemplateBindingKey(): TemplateBindingIdentifier {\n    let result = '';\n    let operatorFound = false;\n    const start = this.currentAbsoluteOffset;\n    do {\n      result += this.expectIdentifierOrKeywordOrString();\n      operatorFound = this.consumeOptionalOperator('-');\n      if (operatorFound) {\n        result += '-';\n      }\n    } while (operatorFound);\n    return {\n      source: result,\n      span: new AbsoluteSourceSpan(start, start + result.length),\n    };\n  }\n\n  /**\n   * Parse microsyntax template expression and return a list of bindings or\n   * parsing errors in case the given expression is invalid.\n   *\n   * For example,\n   * ```\n   *   <div *ngFor=\"let item of items; index as i; trackBy: func\">\n   * ```\n   * contains five bindings:\n   * 1. ngFor -> null\n   * 2. item -> NgForOfContext.$implicit\n   * 3. ngForOf -> items\n   * 4. i -> NgForOfContext.index\n   * 5. ngForTrackBy -> func\n   *\n   * For a full description of the microsyntax grammar, see\n   * https://gist.github.com/mhevery/d3530294cff2e4a1b3fe15ff75d08855\n   *\n   * @param templateKey name of the microsyntax directive, like ngIf, ngFor,\n   * without the *, along with its absolute span.\n   */\n  parseTemplateBindings(templateKey: TemplateBindingIdentifier): TemplateBindingParseResult {\n    const bindings: TemplateBinding[] = [];\n\n    // The first binding is for the template key itself\n    // In *ngFor=\"let item of items\", key = \"ngFor\", value = null\n    // In *ngIf=\"cond | pipe\", key = \"ngIf\", value = \"cond | pipe\"\n    bindings.push(...this.parseDirectiveKeywordBindings(templateKey));\n\n    while (this.index < this.tokens.length) {\n      // If it starts with 'let', then this must be variable declaration\n      const letBinding = this.parseLetBinding();\n      if (letBinding) {\n        bindings.push(letBinding);\n      } else {\n        // Two possible cases here, either `value \"as\" key` or\n        // \"directive-keyword expression\". We don't know which case, but both\n        // \"value\" and \"directive-keyword\" are template binding key, so consume\n        // the key first.\n        const key = this.expectTemplateBindingKey();\n        // Peek at the next token, if it is \"as\" then this must be variable\n        // declaration.\n        const binding = this.parseAsBinding(key);\n        if (binding) {\n          bindings.push(binding);\n        } else {\n          // Otherwise the key must be a directive keyword, like \"of\". Transform\n          // the key to actual key. Eg. of -> ngForOf, trackBy -> ngForTrackBy\n          key.source =\n              templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);\n          bindings.push(...this.parseDirectiveKeywordBindings(key));\n        }\n      }\n      this.consumeStatementTerminator();\n    }\n\n    return new TemplateBindingParseResult(bindings, [] /* warnings */, this.errors);\n  }\n\n  parseKeyedReadOrWrite(receiver: AST, start: number, isSafe: boolean): AST {\n    return this.withContext(ParseContextFlags.Writable, () => {\n      this.rbracketsExpected++;\n      const key = this.parsePipe();\n      if (key instanceof EmptyExpr) {\n        this.error(`Key access cannot be empty`);\n      }\n      this.rbracketsExpected--;\n      this.expectCharacter(chars.$RBRACKET);\n      if (this.consumeOptionalOperator('=')) {\n        if (isSafe) {\n          this.error('The \\'?.\\' operator cannot be used in the assignment');\n        } else {\n          const value = this.parseConditional();\n          return new KeyedWrite(this.span(start), this.sourceSpan(start), receiver, key, value);\n        }\n      } else {\n        return isSafe ? new SafeKeyedRead(this.span(start), this.sourceSpan(start), receiver, key) :\n                        new KeyedRead(this.span(start), this.sourceSpan(start), receiver, key);\n      }\n\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n    });\n  }\n\n  /**\n   * Parse a directive keyword, followed by a mandatory expression.\n   * For example, \"of items\", \"trackBy: func\".\n   * The bindings are: ngForOf -> items, ngForTrackBy -> func\n   * There could be an optional \"as\" binding that follows the expression.\n   * For example,\n   * ```\n   *   *ngFor=\"let item of items | slice:0:1 as collection\".\n   *                    ^^ ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^\n   *               keyword    bound target   optional 'as' binding\n   * ```\n   *\n   * @param key binding key, for example, ngFor, ngIf, ngForOf, along with its\n   * absolute span.\n   */\n  private parseDirectiveKeywordBindings(key: TemplateBindingIdentifier): TemplateBinding[] {\n    const bindings: TemplateBinding[] = [];\n    this.consumeOptionalCharacter(chars.$COLON);  // trackBy: trackByFunction\n    const value = this.getDirectiveBoundTarget();\n    let spanEnd = this.currentAbsoluteOffset;\n    // The binding could optionally be followed by \"as\". For example,\n    // *ngIf=\"cond | pipe as x\". In this case, the key in the \"as\" binding\n    // is \"x\" and the value is the template key itself (\"ngIf\"). Note that the\n    // 'key' in the current context now becomes the \"value\" in the next binding.\n    const asBinding = this.parseAsBinding(key);\n    if (!asBinding) {\n      this.consumeStatementTerminator();\n      spanEnd = this.currentAbsoluteOffset;\n    }\n    const sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);\n    bindings.push(new ExpressionBinding(sourceSpan, key, value));\n    if (asBinding) {\n      bindings.push(asBinding);\n    }\n    return bindings;\n  }\n\n  /**\n   * Return the expression AST for the bound target of a directive keyword\n   * binding. For example,\n   * ```\n   *   *ngIf=\"condition | pipe\"\n   *          ^^^^^^^^^^^^^^^^ bound target for \"ngIf\"\n   *   *ngFor=\"let item of items\"\n   *                       ^^^^^ bound target for \"ngForOf\"\n   * ```\n   */\n  private getDirectiveBoundTarget(): ASTWithSource|null {\n    if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {\n      return null;\n    }\n    const ast = this.parsePipe();  // example: \"condition | async\"\n    const {start, end} = ast.span;\n    const value = this.input.substring(start, end);\n    return new ASTWithSource(ast, value, this.location, this.absoluteOffset + start, this.errors);\n  }\n\n  /**\n   * Return the binding for a variable declared using `as`. Note that the order\n   * of the key-value pair in this declaration is reversed. For example,\n   * ```\n   *   *ngFor=\"let item of items; index as i\"\n   *                              ^^^^^    ^\n   *                              value    key\n   * ```\n   *\n   * @param value name of the value in the declaration, \"ngIf\" in the example\n   * above, along with its absolute span.\n   */\n  private parseAsBinding(value: TemplateBindingIdentifier): TemplateBinding|null {\n    if (!this.peekKeywordAs()) {\n      return null;\n    }\n    this.advance();  // consume the 'as' keyword\n    const key = this.expectTemplateBindingKey();\n    this.consumeStatementTerminator();\n    const sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);\n    return new VariableBinding(sourceSpan, key, value);\n  }\n\n  /**\n   * Return the binding for a variable declared using `let`. For example,\n   * ```\n   *   *ngFor=\"let item of items; let i=index;\"\n   *           ^^^^^^^^           ^^^^^^^^^^^\n   * ```\n   * In the first binding, `item` is bound to `NgForOfContext.$implicit`.\n   * In the second binding, `i` is bound to `NgForOfContext.index`.\n   */\n  private parseLetBinding(): TemplateBinding|null {\n    if (!this.peekKeywordLet()) {\n      return null;\n    }\n    const spanStart = this.currentAbsoluteOffset;\n    this.advance();  // consume the 'let' keyword\n    const key = this.expectTemplateBindingKey();\n    let value: TemplateBindingIdentifier|null = null;\n    if (this.consumeOptionalOperator('=')) {\n      value = this.expectTemplateBindingKey();\n    }\n    this.consumeStatementTerminator();\n    const sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);\n    return new VariableBinding(sourceSpan, key, value);\n  }\n\n  /**\n   * Consume the optional statement terminator: semicolon or comma.\n   */\n  private consumeStatementTerminator() {\n    this.consumeOptionalCharacter(chars.$SEMICOLON) || this.consumeOptionalCharacter(chars.$COMMA);\n  }\n\n  /**\n   * Records an error and skips over the token stream until reaching a recoverable point. See\n   * `this.skip` for more details on token skipping.\n   */\n  error(message: string, index: number|null = null) {\n    this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n    this.skip();\n  }\n\n  private locationText(index: number|null = null) {\n    if (index == null) index = this.index;\n    return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :\n                                          `at the end of the expression`;\n  }\n\n  /**\n   * Records an error for an unexpected private identifier being discovered.\n   * @param token Token representing a private identifier.\n   * @param extraMessage Optional additional message being appended to the error.\n   */\n  private _reportErrorForPrivateIdentifier(token: Token, extraMessage: string|null) {\n    let errorMessage =\n        `Private identifiers are not supported. Unexpected private identifier: ${token}`;\n    if (extraMessage !== null) {\n      errorMessage += `, ${extraMessage}`;\n    }\n    this.error(errorMessage);\n  }\n\n  /**\n   * Error recovery should skip tokens until it encounters a recovery point.\n   *\n   * The following are treated as unconditional recovery points:\n   *   - end of input\n   *   - ';' (parseChain() is always the root production, and it expects a ';')\n   *   - '|' (since pipes may be chained and each pipe expression may be treated independently)\n   *\n   * The following are conditional recovery points:\n   *   - ')', '}', ']' if one of calling productions is expecting one of these symbols\n   *     - This allows skip() to recover from errors such as '(a.) + 1' allowing more of the AST to\n   *       be retained (it doesn't skip any tokens as the ')' is retained because of the '(' begins\n   *       an '(' <expr> ')' production).\n   *       The recovery points of grouping symbols must be conditional as they must be skipped if\n   *       none of the calling productions are not expecting the closing token else we will never\n   *       make progress in the case of an extraneous group closing symbol (such as a stray ')').\n   *       That is, we skip a closing symbol if we are not in a grouping production.\n   *   - '=' in a `Writable` context\n   *     - In this context, we are able to recover after seeing the `=` operator, which\n   *       signals the presence of an independent rvalue expression following the `=` operator.\n   *\n   * If a production expects one of these token it increments the corresponding nesting count,\n   * and then decrements it just prior to checking if the token is in the input.\n   */\n  private skip() {\n    let n = this.next;\n    while (this.index < this.tokens.length && !n.isCharacter(chars.$SEMICOLON) &&\n           !n.isOperator('|') && (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n           (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n           (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET)) &&\n           (!(this.context & ParseContextFlags.Writable) || !n.isOperator('='))) {\n      if (this.next.isError()) {\n        this.errors.push(\n            new ParserError(this.next.toString()!, this.input, this.locationText(), this.location));\n      }\n      this.advance();\n      n = this.next;\n    }\n  }\n}\n\nclass SimpleExpressionChecker extends RecursiveAstVisitor {\n  errors: string[] = [];\n\n  override visitPipe() {\n    this.errors.push('pipes');\n  }\n}\n/**\n * Computes the real offset in the original template for indexes in an interpolation.\n *\n * Because templates can have encoded HTML entities and the input passed to the parser at this stage\n * of the compiler is the _decoded_ value, we need to compute the real offset using the original\n * encoded values in the interpolated tokens. Note that this is only a special case handling for\n * `MlParserTokenType.ENCODED_ENTITY` token types. All other interpolated tokens are expected to\n * have parts which exactly match the input string for parsing the interpolation.\n *\n * @param interpolatedTokens The tokens for the interpolated value.\n *\n * @returns A map of index locations in the decoded template to indexes in the original template\n */\nfunction getIndexMapForOriginalTemplate(interpolatedTokens: InterpolatedAttributeToken[]|\n                                        InterpolatedTextToken[]): Map<number, number> {\n  let offsetMap = new Map<number, number>();\n  let consumedInOriginalTemplate = 0;\n  let consumedInInput = 0;\n  let tokenIndex = 0;\n  while (tokenIndex < interpolatedTokens.length) {\n    const currentToken = interpolatedTokens[tokenIndex];\n    if (currentToken.type === MlParserTokenType.ENCODED_ENTITY) {\n      const [decoded, encoded] = currentToken.parts;\n      consumedInOriginalTemplate += encoded.length;\n      consumedInInput += decoded.length;\n    } else {\n      const lengthOfParts = currentToken.parts.reduce((sum, current) => sum + current.length, 0);\n      consumedInInput += lengthOfParts;\n      consumedInOriginalTemplate += lengthOfParts;\n    }\n    offsetMap.set(consumedInInput, consumedInOriginalTemplate);\n    tokenIndex++;\n  }\n  return offsetMap;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {I18nMeta} from '../i18n/i18n_ast';\nimport {ParseSourceSpan} from '../parse_util';\n\nimport {InterpolatedAttributeToken, InterpolatedTextToken} from './tokens';\n\ninterface BaseNode {\n  sourceSpan: ParseSourceSpan;\n  visit(visitor: Visitor, context: any): any;\n}\n\nexport type Node = Attribute|Comment|Element|Expansion|ExpansionCase|Text;\n\nexport abstract class NodeWithI18n implements BaseNode {\n  constructor(public sourceSpan: ParseSourceSpan, public i18n?: I18nMeta) {}\n  abstract visit(visitor: Visitor, context: any): any;\n}\n\nexport class Text extends NodeWithI18n {\n  constructor(\n      public value: string, sourceSpan: ParseSourceSpan, public tokens: InterpolatedTextToken[],\n      i18n?: I18nMeta) {\n    super(sourceSpan, i18n);\n  }\n  override visit(visitor: Visitor, context: any): any {\n    return visitor.visitText(this, context);\n  }\n}\n\nexport class Expansion extends NodeWithI18n {\n  constructor(\n      public switchValue: string, public type: string, public cases: ExpansionCase[],\n      sourceSpan: ParseSourceSpan, public switchValueSourceSpan: ParseSourceSpan, i18n?: I18nMeta) {\n    super(sourceSpan, i18n);\n  }\n  override visit(visitor: Visitor, context: any): any {\n    return visitor.visitExpansion(this, context);\n  }\n}\n\nexport class ExpansionCase implements BaseNode {\n  constructor(\n      public value: string, public expression: Node[], public sourceSpan: ParseSourceSpan,\n      public valueSourceSpan: ParseSourceSpan, public expSourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitExpansionCase(this, context);\n  }\n}\n\nexport class Attribute extends NodeWithI18n {\n  constructor(\n      public name: string, public value: string, sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan|undefined, public valueSpan: ParseSourceSpan|undefined,\n      public valueTokens: InterpolatedAttributeToken[]|undefined, i18n: I18nMeta|undefined) {\n    super(sourceSpan, i18n);\n  }\n  override visit(visitor: Visitor, context: any): any {\n    return visitor.visitAttribute(this, context);\n  }\n}\n\nexport class Element extends NodeWithI18n {\n  constructor(\n      public name: string, public attrs: Attribute[], public children: Node[],\n      sourceSpan: ParseSourceSpan, public startSourceSpan: ParseSourceSpan,\n      public endSourceSpan: ParseSourceSpan|null = null, i18n?: I18nMeta) {\n    super(sourceSpan, i18n);\n  }\n  override visit(visitor: Visitor, context: any): any {\n    return visitor.visitElement(this, context);\n  }\n}\n\nexport class Comment implements BaseNode {\n  constructor(public value: string|null, public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitComment(this, context);\n  }\n}\n\nexport interface Visitor {\n  // Returning a truthy value from `visit()` will prevent `visitAll()` from the call to the typed\n  // method and result returned will become the result included in `visitAll()`s result array.\n  visit?(node: Node, context: any): any;\n\n  visitElement(element: Element, context: any): any;\n  visitAttribute(attribute: Attribute, context: any): any;\n  visitText(text: Text, context: any): any;\n  visitComment(comment: Comment, context: any): any;\n  visitExpansion(expansion: Expansion, context: any): any;\n  visitExpansionCase(expansionCase: ExpansionCase, context: any): any;\n}\n\nexport function visitAll(visitor: Visitor, nodes: Node[], context: any = null): any[] {\n  const result: any[] = [];\n\n  const visit = visitor.visit ?\n      (ast: Node) => visitor.visit!(ast, context) || ast.visit(visitor, context) :\n      (ast: Node) => ast.visit(visitor, context);\n  nodes.forEach(ast => {\n    const astResult = visit(ast);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n\nexport class RecursiveVisitor implements Visitor {\n  constructor() {}\n\n  visitElement(ast: Element, context: any): any {\n    this.visitChildren(context, visit => {\n      visit(ast.attrs);\n      visit(ast.children);\n    });\n  }\n\n  visitAttribute(ast: Attribute, context: any): any {}\n  visitText(ast: Text, context: any): any {}\n  visitComment(ast: Comment, context: any): any {}\n\n  visitExpansion(ast: Expansion, context: any): any {\n    return this.visitChildren(context, visit => {\n      visit(ast.cases);\n    });\n  }\n\n  visitExpansionCase(ast: ExpansionCase, context: any): any {}\n\n  private visitChildren<T extends Node>(\n      context: any, cb: (visit: (<V extends Node>(children: V[]|undefined) => void)) => void) {\n    let results: any[][] = [];\n    let t = this;\n    function visit<T extends Node>(children: T[]|undefined) {\n      if (children) results.push(visitAll(t, children, context));\n    }\n    cb(visit);\n    return Array.prototype.concat.apply([], results);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Mapping between all HTML entity names and their unicode representation.\n// Generated from https://html.spec.whatwg.org/multipage/entities.json by stripping\n// the `&` and `;` from the keys and removing the duplicates.\n// see https://www.w3.org/TR/html51/syntax.html#named-character-references\nexport const NAMED_ENTITIES: Record<string, string> = {\n  'AElig': '\\u00C6',\n  'AMP': '\\u0026',\n  'amp': '\\u0026',\n  'Aacute': '\\u00C1',\n  'Abreve': '\\u0102',\n  'Acirc': '\\u00C2',\n  'Acy': '\\u0410',\n  'Afr': '\\uD835\\uDD04',\n  'Agrave': '\\u00C0',\n  'Alpha': '\\u0391',\n  'Amacr': '\\u0100',\n  'And': '\\u2A53',\n  'Aogon': '\\u0104',\n  'Aopf': '\\uD835\\uDD38',\n  'ApplyFunction': '\\u2061',\n  'af': '\\u2061',\n  'Aring': '\\u00C5',\n  'angst': '\\u00C5',\n  'Ascr': '\\uD835\\uDC9C',\n  'Assign': '\\u2254',\n  'colone': '\\u2254',\n  'coloneq': '\\u2254',\n  'Atilde': '\\u00C3',\n  'Auml': '\\u00C4',\n  'Backslash': '\\u2216',\n  'setminus': '\\u2216',\n  'setmn': '\\u2216',\n  'smallsetminus': '\\u2216',\n  'ssetmn': '\\u2216',\n  'Barv': '\\u2AE7',\n  'Barwed': '\\u2306',\n  'doublebarwedge': '\\u2306',\n  'Bcy': '\\u0411',\n  'Because': '\\u2235',\n  'becaus': '\\u2235',\n  'because': '\\u2235',\n  'Bernoullis': '\\u212C',\n  'Bscr': '\\u212C',\n  'bernou': '\\u212C',\n  'Beta': '\\u0392',\n  'Bfr': '\\uD835\\uDD05',\n  'Bopf': '\\uD835\\uDD39',\n  'Breve': '\\u02D8',\n  'breve': '\\u02D8',\n  'Bumpeq': '\\u224E',\n  'HumpDownHump': '\\u224E',\n  'bump': '\\u224E',\n  'CHcy': '\\u0427',\n  'COPY': '\\u00A9',\n  'copy': '\\u00A9',\n  'Cacute': '\\u0106',\n  'Cap': '\\u22D2',\n  'CapitalDifferentialD': '\\u2145',\n  'DD': '\\u2145',\n  'Cayleys': '\\u212D',\n  'Cfr': '\\u212D',\n  'Ccaron': '\\u010C',\n  'Ccedil': '\\u00C7',\n  'Ccirc': '\\u0108',\n  'Cconint': '\\u2230',\n  'Cdot': '\\u010A',\n  'Cedilla': '\\u00B8',\n  'cedil': '\\u00B8',\n  'CenterDot': '\\u00B7',\n  'centerdot': '\\u00B7',\n  'middot': '\\u00B7',\n  'Chi': '\\u03A7',\n  'CircleDot': '\\u2299',\n  'odot': '\\u2299',\n  'CircleMinus': '\\u2296',\n  'ominus': '\\u2296',\n  'CirclePlus': '\\u2295',\n  'oplus': '\\u2295',\n  'CircleTimes': '\\u2297',\n  'otimes': '\\u2297',\n  'ClockwiseContourIntegral': '\\u2232',\n  'cwconint': '\\u2232',\n  'CloseCurlyDoubleQuote': '\\u201D',\n  'rdquo': '\\u201D',\n  'rdquor': '\\u201D',\n  'CloseCurlyQuote': '\\u2019',\n  'rsquo': '\\u2019',\n  'rsquor': '\\u2019',\n  'Colon': '\\u2237',\n  'Proportion': '\\u2237',\n  'Colone': '\\u2A74',\n  'Congruent': '\\u2261',\n  'equiv': '\\u2261',\n  'Conint': '\\u222F',\n  'DoubleContourIntegral': '\\u222F',\n  'ContourIntegral': '\\u222E',\n  'conint': '\\u222E',\n  'oint': '\\u222E',\n  'Copf': '\\u2102',\n  'complexes': '\\u2102',\n  'Coproduct': '\\u2210',\n  'coprod': '\\u2210',\n  'CounterClockwiseContourIntegral': '\\u2233',\n  'awconint': '\\u2233',\n  'Cross': '\\u2A2F',\n  'Cscr': '\\uD835\\uDC9E',\n  'Cup': '\\u22D3',\n  'CupCap': '\\u224D',\n  'asympeq': '\\u224D',\n  'DDotrahd': '\\u2911',\n  'DJcy': '\\u0402',\n  'DScy': '\\u0405',\n  'DZcy': '\\u040F',\n  'Dagger': '\\u2021',\n  'ddagger': '\\u2021',\n  'Darr': '\\u21A1',\n  'Dashv': '\\u2AE4',\n  'DoubleLeftTee': '\\u2AE4',\n  'Dcaron': '\\u010E',\n  'Dcy': '\\u0414',\n  'Del': '\\u2207',\n  'nabla': '\\u2207',\n  'Delta': '\\u0394',\n  'Dfr': '\\uD835\\uDD07',\n  'DiacriticalAcute': '\\u00B4',\n  'acute': '\\u00B4',\n  'DiacriticalDot': '\\u02D9',\n  'dot': '\\u02D9',\n  'DiacriticalDoubleAcute': '\\u02DD',\n  'dblac': '\\u02DD',\n  'DiacriticalGrave': '\\u0060',\n  'grave': '\\u0060',\n  'DiacriticalTilde': '\\u02DC',\n  'tilde': '\\u02DC',\n  'Diamond': '\\u22C4',\n  'diam': '\\u22C4',\n  'diamond': '\\u22C4',\n  'DifferentialD': '\\u2146',\n  'dd': '\\u2146',\n  'Dopf': '\\uD835\\uDD3B',\n  'Dot': '\\u00A8',\n  'DoubleDot': '\\u00A8',\n  'die': '\\u00A8',\n  'uml': '\\u00A8',\n  'DotDot': '\\u20DC',\n  'DotEqual': '\\u2250',\n  'doteq': '\\u2250',\n  'esdot': '\\u2250',\n  'DoubleDownArrow': '\\u21D3',\n  'Downarrow': '\\u21D3',\n  'dArr': '\\u21D3',\n  'DoubleLeftArrow': '\\u21D0',\n  'Leftarrow': '\\u21D0',\n  'lArr': '\\u21D0',\n  'DoubleLeftRightArrow': '\\u21D4',\n  'Leftrightarrow': '\\u21D4',\n  'hArr': '\\u21D4',\n  'iff': '\\u21D4',\n  'DoubleLongLeftArrow': '\\u27F8',\n  'Longleftarrow': '\\u27F8',\n  'xlArr': '\\u27F8',\n  'DoubleLongLeftRightArrow': '\\u27FA',\n  'Longleftrightarrow': '\\u27FA',\n  'xhArr': '\\u27FA',\n  'DoubleLongRightArrow': '\\u27F9',\n  'Longrightarrow': '\\u27F9',\n  'xrArr': '\\u27F9',\n  'DoubleRightArrow': '\\u21D2',\n  'Implies': '\\u21D2',\n  'Rightarrow': '\\u21D2',\n  'rArr': '\\u21D2',\n  'DoubleRightTee': '\\u22A8',\n  'vDash': '\\u22A8',\n  'DoubleUpArrow': '\\u21D1',\n  'Uparrow': '\\u21D1',\n  'uArr': '\\u21D1',\n  'DoubleUpDownArrow': '\\u21D5',\n  'Updownarrow': '\\u21D5',\n  'vArr': '\\u21D5',\n  'DoubleVerticalBar': '\\u2225',\n  'par': '\\u2225',\n  'parallel': '\\u2225',\n  'shortparallel': '\\u2225',\n  'spar': '\\u2225',\n  'DownArrow': '\\u2193',\n  'ShortDownArrow': '\\u2193',\n  'darr': '\\u2193',\n  'downarrow': '\\u2193',\n  'DownArrowBar': '\\u2913',\n  'DownArrowUpArrow': '\\u21F5',\n  'duarr': '\\u21F5',\n  'DownBreve': '\\u0311',\n  'DownLeftRightVector': '\\u2950',\n  'DownLeftTeeVector': '\\u295E',\n  'DownLeftVector': '\\u21BD',\n  'leftharpoondown': '\\u21BD',\n  'lhard': '\\u21BD',\n  'DownLeftVectorBar': '\\u2956',\n  'DownRightTeeVector': '\\u295F',\n  'DownRightVector': '\\u21C1',\n  'rhard': '\\u21C1',\n  'rightharpoondown': '\\u21C1',\n  'DownRightVectorBar': '\\u2957',\n  'DownTee': '\\u22A4',\n  'top': '\\u22A4',\n  'DownTeeArrow': '\\u21A7',\n  'mapstodown': '\\u21A7',\n  'Dscr': '\\uD835\\uDC9F',\n  'Dstrok': '\\u0110',\n  'ENG': '\\u014A',\n  'ETH': '\\u00D0',\n  'Eacute': '\\u00C9',\n  'Ecaron': '\\u011A',\n  'Ecirc': '\\u00CA',\n  'Ecy': '\\u042D',\n  'Edot': '\\u0116',\n  'Efr': '\\uD835\\uDD08',\n  'Egrave': '\\u00C8',\n  'Element': '\\u2208',\n  'in': '\\u2208',\n  'isin': '\\u2208',\n  'isinv': '\\u2208',\n  'Emacr': '\\u0112',\n  'EmptySmallSquare': '\\u25FB',\n  'EmptyVerySmallSquare': '\\u25AB',\n  'Eogon': '\\u0118',\n  'Eopf': '\\uD835\\uDD3C',\n  'Epsilon': '\\u0395',\n  'Equal': '\\u2A75',\n  'EqualTilde': '\\u2242',\n  'eqsim': '\\u2242',\n  'esim': '\\u2242',\n  'Equilibrium': '\\u21CC',\n  'rightleftharpoons': '\\u21CC',\n  'rlhar': '\\u21CC',\n  'Escr': '\\u2130',\n  'expectation': '\\u2130',\n  'Esim': '\\u2A73',\n  'Eta': '\\u0397',\n  'Euml': '\\u00CB',\n  'Exists': '\\u2203',\n  'exist': '\\u2203',\n  'ExponentialE': '\\u2147',\n  'ee': '\\u2147',\n  'exponentiale': '\\u2147',\n  'Fcy': '\\u0424',\n  'Ffr': '\\uD835\\uDD09',\n  'FilledSmallSquare': '\\u25FC',\n  'FilledVerySmallSquare': '\\u25AA',\n  'blacksquare': '\\u25AA',\n  'squarf': '\\u25AA',\n  'squf': '\\u25AA',\n  'Fopf': '\\uD835\\uDD3D',\n  'ForAll': '\\u2200',\n  'forall': '\\u2200',\n  'Fouriertrf': '\\u2131',\n  'Fscr': '\\u2131',\n  'GJcy': '\\u0403',\n  'GT': '\\u003E',\n  'gt': '\\u003E',\n  'Gamma': '\\u0393',\n  'Gammad': '\\u03DC',\n  'Gbreve': '\\u011E',\n  'Gcedil': '\\u0122',\n  'Gcirc': '\\u011C',\n  'Gcy': '\\u0413',\n  'Gdot': '\\u0120',\n  'Gfr': '\\uD835\\uDD0A',\n  'Gg': '\\u22D9',\n  'ggg': '\\u22D9',\n  'Gopf': '\\uD835\\uDD3E',\n  'GreaterEqual': '\\u2265',\n  'ge': '\\u2265',\n  'geq': '\\u2265',\n  'GreaterEqualLess': '\\u22DB',\n  'gel': '\\u22DB',\n  'gtreqless': '\\u22DB',\n  'GreaterFullEqual': '\\u2267',\n  'gE': '\\u2267',\n  'geqq': '\\u2267',\n  'GreaterGreater': '\\u2AA2',\n  'GreaterLess': '\\u2277',\n  'gl': '\\u2277',\n  'gtrless': '\\u2277',\n  'GreaterSlantEqual': '\\u2A7E',\n  'geqslant': '\\u2A7E',\n  'ges': '\\u2A7E',\n  'GreaterTilde': '\\u2273',\n  'gsim': '\\u2273',\n  'gtrsim': '\\u2273',\n  'Gscr': '\\uD835\\uDCA2',\n  'Gt': '\\u226B',\n  'NestedGreaterGreater': '\\u226B',\n  'gg': '\\u226B',\n  'HARDcy': '\\u042A',\n  'Hacek': '\\u02C7',\n  'caron': '\\u02C7',\n  'Hat': '\\u005E',\n  'Hcirc': '\\u0124',\n  'Hfr': '\\u210C',\n  'Poincareplane': '\\u210C',\n  'HilbertSpace': '\\u210B',\n  'Hscr': '\\u210B',\n  'hamilt': '\\u210B',\n  'Hopf': '\\u210D',\n  'quaternions': '\\u210D',\n  'HorizontalLine': '\\u2500',\n  'boxh': '\\u2500',\n  'Hstrok': '\\u0126',\n  'HumpEqual': '\\u224F',\n  'bumpe': '\\u224F',\n  'bumpeq': '\\u224F',\n  'IEcy': '\\u0415',\n  'IJlig': '\\u0132',\n  'IOcy': '\\u0401',\n  'Iacute': '\\u00CD',\n  'Icirc': '\\u00CE',\n  'Icy': '\\u0418',\n  'Idot': '\\u0130',\n  'Ifr': '\\u2111',\n  'Im': '\\u2111',\n  'image': '\\u2111',\n  'imagpart': '\\u2111',\n  'Igrave': '\\u00CC',\n  'Imacr': '\\u012A',\n  'ImaginaryI': '\\u2148',\n  'ii': '\\u2148',\n  'Int': '\\u222C',\n  'Integral': '\\u222B',\n  'int': '\\u222B',\n  'Intersection': '\\u22C2',\n  'bigcap': '\\u22C2',\n  'xcap': '\\u22C2',\n  'InvisibleComma': '\\u2063',\n  'ic': '\\u2063',\n  'InvisibleTimes': '\\u2062',\n  'it': '\\u2062',\n  'Iogon': '\\u012E',\n  'Iopf': '\\uD835\\uDD40',\n  'Iota': '\\u0399',\n  'Iscr': '\\u2110',\n  'imagline': '\\u2110',\n  'Itilde': '\\u0128',\n  'Iukcy': '\\u0406',\n  'Iuml': '\\u00CF',\n  'Jcirc': '\\u0134',\n  'Jcy': '\\u0419',\n  'Jfr': '\\uD835\\uDD0D',\n  'Jopf': '\\uD835\\uDD41',\n  'Jscr': '\\uD835\\uDCA5',\n  'Jsercy': '\\u0408',\n  'Jukcy': '\\u0404',\n  'KHcy': '\\u0425',\n  'KJcy': '\\u040C',\n  'Kappa': '\\u039A',\n  'Kcedil': '\\u0136',\n  'Kcy': '\\u041A',\n  'Kfr': '\\uD835\\uDD0E',\n  'Kopf': '\\uD835\\uDD42',\n  'Kscr': '\\uD835\\uDCA6',\n  'LJcy': '\\u0409',\n  'LT': '\\u003C',\n  'lt': '\\u003C',\n  'Lacute': '\\u0139',\n  'Lambda': '\\u039B',\n  'Lang': '\\u27EA',\n  'Laplacetrf': '\\u2112',\n  'Lscr': '\\u2112',\n  'lagran': '\\u2112',\n  'Larr': '\\u219E',\n  'twoheadleftarrow': '\\u219E',\n  'Lcaron': '\\u013D',\n  'Lcedil': '\\u013B',\n  'Lcy': '\\u041B',\n  'LeftAngleBracket': '\\u27E8',\n  'lang': '\\u27E8',\n  'langle': '\\u27E8',\n  'LeftArrow': '\\u2190',\n  'ShortLeftArrow': '\\u2190',\n  'larr': '\\u2190',\n  'leftarrow': '\\u2190',\n  'slarr': '\\u2190',\n  'LeftArrowBar': '\\u21E4',\n  'larrb': '\\u21E4',\n  'LeftArrowRightArrow': '\\u21C6',\n  'leftrightarrows': '\\u21C6',\n  'lrarr': '\\u21C6',\n  'LeftCeiling': '\\u2308',\n  'lceil': '\\u2308',\n  'LeftDoubleBracket': '\\u27E6',\n  'lobrk': '\\u27E6',\n  'LeftDownTeeVector': '\\u2961',\n  'LeftDownVector': '\\u21C3',\n  'dharl': '\\u21C3',\n  'downharpoonleft': '\\u21C3',\n  'LeftDownVectorBar': '\\u2959',\n  'LeftFloor': '\\u230A',\n  'lfloor': '\\u230A',\n  'LeftRightArrow': '\\u2194',\n  'harr': '\\u2194',\n  'leftrightarrow': '\\u2194',\n  'LeftRightVector': '\\u294E',\n  'LeftTee': '\\u22A3',\n  'dashv': '\\u22A3',\n  'LeftTeeArrow': '\\u21A4',\n  'mapstoleft': '\\u21A4',\n  'LeftTeeVector': '\\u295A',\n  'LeftTriangle': '\\u22B2',\n  'vartriangleleft': '\\u22B2',\n  'vltri': '\\u22B2',\n  'LeftTriangleBar': '\\u29CF',\n  'LeftTriangleEqual': '\\u22B4',\n  'ltrie': '\\u22B4',\n  'trianglelefteq': '\\u22B4',\n  'LeftUpDownVector': '\\u2951',\n  'LeftUpTeeVector': '\\u2960',\n  'LeftUpVector': '\\u21BF',\n  'uharl': '\\u21BF',\n  'upharpoonleft': '\\u21BF',\n  'LeftUpVectorBar': '\\u2958',\n  'LeftVector': '\\u21BC',\n  'leftharpoonup': '\\u21BC',\n  'lharu': '\\u21BC',\n  'LeftVectorBar': '\\u2952',\n  'LessEqualGreater': '\\u22DA',\n  'leg': '\\u22DA',\n  'lesseqgtr': '\\u22DA',\n  'LessFullEqual': '\\u2266',\n  'lE': '\\u2266',\n  'leqq': '\\u2266',\n  'LessGreater': '\\u2276',\n  'lessgtr': '\\u2276',\n  'lg': '\\u2276',\n  'LessLess': '\\u2AA1',\n  'LessSlantEqual': '\\u2A7D',\n  'leqslant': '\\u2A7D',\n  'les': '\\u2A7D',\n  'LessTilde': '\\u2272',\n  'lesssim': '\\u2272',\n  'lsim': '\\u2272',\n  'Lfr': '\\uD835\\uDD0F',\n  'Ll': '\\u22D8',\n  'Lleftarrow': '\\u21DA',\n  'lAarr': '\\u21DA',\n  'Lmidot': '\\u013F',\n  'LongLeftArrow': '\\u27F5',\n  'longleftarrow': '\\u27F5',\n  'xlarr': '\\u27F5',\n  'LongLeftRightArrow': '\\u27F7',\n  'longleftrightarrow': '\\u27F7',\n  'xharr': '\\u27F7',\n  'LongRightArrow': '\\u27F6',\n  'longrightarrow': '\\u27F6',\n  'xrarr': '\\u27F6',\n  'Lopf': '\\uD835\\uDD43',\n  'LowerLeftArrow': '\\u2199',\n  'swarr': '\\u2199',\n  'swarrow': '\\u2199',\n  'LowerRightArrow': '\\u2198',\n  'searr': '\\u2198',\n  'searrow': '\\u2198',\n  'Lsh': '\\u21B0',\n  'lsh': '\\u21B0',\n  'Lstrok': '\\u0141',\n  'Lt': '\\u226A',\n  'NestedLessLess': '\\u226A',\n  'll': '\\u226A',\n  'Map': '\\u2905',\n  'Mcy': '\\u041C',\n  'MediumSpace': '\\u205F',\n  'Mellintrf': '\\u2133',\n  'Mscr': '\\u2133',\n  'phmmat': '\\u2133',\n  'Mfr': '\\uD835\\uDD10',\n  'MinusPlus': '\\u2213',\n  'mnplus': '\\u2213',\n  'mp': '\\u2213',\n  'Mopf': '\\uD835\\uDD44',\n  'Mu': '\\u039C',\n  'NJcy': '\\u040A',\n  'Nacute': '\\u0143',\n  'Ncaron': '\\u0147',\n  'Ncedil': '\\u0145',\n  'Ncy': '\\u041D',\n  'NegativeMediumSpace': '\\u200B',\n  'NegativeThickSpace': '\\u200B',\n  'NegativeThinSpace': '\\u200B',\n  'NegativeVeryThinSpace': '\\u200B',\n  'ZeroWidthSpace': '\\u200B',\n  'NewLine': '\\u000A',\n  'Nfr': '\\uD835\\uDD11',\n  'NoBreak': '\\u2060',\n  'NonBreakingSpace': '\\u00A0',\n  'nbsp': '\\u00A0',\n  'Nopf': '\\u2115',\n  'naturals': '\\u2115',\n  'Not': '\\u2AEC',\n  'NotCongruent': '\\u2262',\n  'nequiv': '\\u2262',\n  'NotCupCap': '\\u226D',\n  'NotDoubleVerticalBar': '\\u2226',\n  'npar': '\\u2226',\n  'nparallel': '\\u2226',\n  'nshortparallel': '\\u2226',\n  'nspar': '\\u2226',\n  'NotElement': '\\u2209',\n  'notin': '\\u2209',\n  'notinva': '\\u2209',\n  'NotEqual': '\\u2260',\n  'ne': '\\u2260',\n  'NotEqualTilde': '\\u2242\\u0338',\n  'nesim': '\\u2242\\u0338',\n  'NotExists': '\\u2204',\n  'nexist': '\\u2204',\n  'nexists': '\\u2204',\n  'NotGreater': '\\u226F',\n  'ngt': '\\u226F',\n  'ngtr': '\\u226F',\n  'NotGreaterEqual': '\\u2271',\n  'nge': '\\u2271',\n  'ngeq': '\\u2271',\n  'NotGreaterFullEqual': '\\u2267\\u0338',\n  'ngE': '\\u2267\\u0338',\n  'ngeqq': '\\u2267\\u0338',\n  'NotGreaterGreater': '\\u226B\\u0338',\n  'nGtv': '\\u226B\\u0338',\n  'NotGreaterLess': '\\u2279',\n  'ntgl': '\\u2279',\n  'NotGreaterSlantEqual': '\\u2A7E\\u0338',\n  'ngeqslant': '\\u2A7E\\u0338',\n  'nges': '\\u2A7E\\u0338',\n  'NotGreaterTilde': '\\u2275',\n  'ngsim': '\\u2275',\n  'NotHumpDownHump': '\\u224E\\u0338',\n  'nbump': '\\u224E\\u0338',\n  'NotHumpEqual': '\\u224F\\u0338',\n  'nbumpe': '\\u224F\\u0338',\n  'NotLeftTriangle': '\\u22EA',\n  'nltri': '\\u22EA',\n  'ntriangleleft': '\\u22EA',\n  'NotLeftTriangleBar': '\\u29CF\\u0338',\n  'NotLeftTriangleEqual': '\\u22EC',\n  'nltrie': '\\u22EC',\n  'ntrianglelefteq': '\\u22EC',\n  'NotLess': '\\u226E',\n  'nless': '\\u226E',\n  'nlt': '\\u226E',\n  'NotLessEqual': '\\u2270',\n  'nle': '\\u2270',\n  'nleq': '\\u2270',\n  'NotLessGreater': '\\u2278',\n  'ntlg': '\\u2278',\n  'NotLessLess': '\\u226A\\u0338',\n  'nLtv': '\\u226A\\u0338',\n  'NotLessSlantEqual': '\\u2A7D\\u0338',\n  'nleqslant': '\\u2A7D\\u0338',\n  'nles': '\\u2A7D\\u0338',\n  'NotLessTilde': '\\u2274',\n  'nlsim': '\\u2274',\n  'NotNestedGreaterGreater': '\\u2AA2\\u0338',\n  'NotNestedLessLess': '\\u2AA1\\u0338',\n  'NotPrecedes': '\\u2280',\n  'npr': '\\u2280',\n  'nprec': '\\u2280',\n  'NotPrecedesEqual': '\\u2AAF\\u0338',\n  'npre': '\\u2AAF\\u0338',\n  'npreceq': '\\u2AAF\\u0338',\n  'NotPrecedesSlantEqual': '\\u22E0',\n  'nprcue': '\\u22E0',\n  'NotReverseElement': '\\u220C',\n  'notni': '\\u220C',\n  'notniva': '\\u220C',\n  'NotRightTriangle': '\\u22EB',\n  'nrtri': '\\u22EB',\n  'ntriangleright': '\\u22EB',\n  'NotRightTriangleBar': '\\u29D0\\u0338',\n  'NotRightTriangleEqual': '\\u22ED',\n  'nrtrie': '\\u22ED',\n  'ntrianglerighteq': '\\u22ED',\n  'NotSquareSubset': '\\u228F\\u0338',\n  'NotSquareSubsetEqual': '\\u22E2',\n  'nsqsube': '\\u22E2',\n  'NotSquareSuperset': '\\u2290\\u0338',\n  'NotSquareSupersetEqual': '\\u22E3',\n  'nsqsupe': '\\u22E3',\n  'NotSubset': '\\u2282\\u20D2',\n  'nsubset': '\\u2282\\u20D2',\n  'vnsub': '\\u2282\\u20D2',\n  'NotSubsetEqual': '\\u2288',\n  'nsube': '\\u2288',\n  'nsubseteq': '\\u2288',\n  'NotSucceeds': '\\u2281',\n  'nsc': '\\u2281',\n  'nsucc': '\\u2281',\n  'NotSucceedsEqual': '\\u2AB0\\u0338',\n  'nsce': '\\u2AB0\\u0338',\n  'nsucceq': '\\u2AB0\\u0338',\n  'NotSucceedsSlantEqual': '\\u22E1',\n  'nsccue': '\\u22E1',\n  'NotSucceedsTilde': '\\u227F\\u0338',\n  'NotSuperset': '\\u2283\\u20D2',\n  'nsupset': '\\u2283\\u20D2',\n  'vnsup': '\\u2283\\u20D2',\n  'NotSupersetEqual': '\\u2289',\n  'nsupe': '\\u2289',\n  'nsupseteq': '\\u2289',\n  'NotTilde': '\\u2241',\n  'nsim': '\\u2241',\n  'NotTildeEqual': '\\u2244',\n  'nsime': '\\u2244',\n  'nsimeq': '\\u2244',\n  'NotTildeFullEqual': '\\u2247',\n  'ncong': '\\u2247',\n  'NotTildeTilde': '\\u2249',\n  'nap': '\\u2249',\n  'napprox': '\\u2249',\n  'NotVerticalBar': '\\u2224',\n  'nmid': '\\u2224',\n  'nshortmid': '\\u2224',\n  'nsmid': '\\u2224',\n  'Nscr': '\\uD835\\uDCA9',\n  'Ntilde': '\\u00D1',\n  'Nu': '\\u039D',\n  'OElig': '\\u0152',\n  'Oacute': '\\u00D3',\n  'Ocirc': '\\u00D4',\n  'Ocy': '\\u041E',\n  'Odblac': '\\u0150',\n  'Ofr': '\\uD835\\uDD12',\n  'Ograve': '\\u00D2',\n  'Omacr': '\\u014C',\n  'Omega': '\\u03A9',\n  'ohm': '\\u03A9',\n  'Omicron': '\\u039F',\n  'Oopf': '\\uD835\\uDD46',\n  'OpenCurlyDoubleQuote': '\\u201C',\n  'ldquo': '\\u201C',\n  'OpenCurlyQuote': '\\u2018',\n  'lsquo': '\\u2018',\n  'Or': '\\u2A54',\n  'Oscr': '\\uD835\\uDCAA',\n  'Oslash': '\\u00D8',\n  'Otilde': '\\u00D5',\n  'Otimes': '\\u2A37',\n  'Ouml': '\\u00D6',\n  'OverBar': '\\u203E',\n  'oline': '\\u203E',\n  'OverBrace': '\\u23DE',\n  'OverBracket': '\\u23B4',\n  'tbrk': '\\u23B4',\n  'OverParenthesis': '\\u23DC',\n  'PartialD': '\\u2202',\n  'part': '\\u2202',\n  'Pcy': '\\u041F',\n  'Pfr': '\\uD835\\uDD13',\n  'Phi': '\\u03A6',\n  'Pi': '\\u03A0',\n  'PlusMinus': '\\u00B1',\n  'plusmn': '\\u00B1',\n  'pm': '\\u00B1',\n  'Popf': '\\u2119',\n  'primes': '\\u2119',\n  'Pr': '\\u2ABB',\n  'Precedes': '\\u227A',\n  'pr': '\\u227A',\n  'prec': '\\u227A',\n  'PrecedesEqual': '\\u2AAF',\n  'pre': '\\u2AAF',\n  'preceq': '\\u2AAF',\n  'PrecedesSlantEqual': '\\u227C',\n  'prcue': '\\u227C',\n  'preccurlyeq': '\\u227C',\n  'PrecedesTilde': '\\u227E',\n  'precsim': '\\u227E',\n  'prsim': '\\u227E',\n  'Prime': '\\u2033',\n  'Product': '\\u220F',\n  'prod': '\\u220F',\n  'Proportional': '\\u221D',\n  'prop': '\\u221D',\n  'propto': '\\u221D',\n  'varpropto': '\\u221D',\n  'vprop': '\\u221D',\n  'Pscr': '\\uD835\\uDCAB',\n  'Psi': '\\u03A8',\n  'QUOT': '\\u0022',\n  'quot': '\\u0022',\n  'Qfr': '\\uD835\\uDD14',\n  'Qopf': '\\u211A',\n  'rationals': '\\u211A',\n  'Qscr': '\\uD835\\uDCAC',\n  'RBarr': '\\u2910',\n  'drbkarow': '\\u2910',\n  'REG': '\\u00AE',\n  'circledR': '\\u00AE',\n  'reg': '\\u00AE',\n  'Racute': '\\u0154',\n  'Rang': '\\u27EB',\n  'Rarr': '\\u21A0',\n  'twoheadrightarrow': '\\u21A0',\n  'Rarrtl': '\\u2916',\n  'Rcaron': '\\u0158',\n  'Rcedil': '\\u0156',\n  'Rcy': '\\u0420',\n  'Re': '\\u211C',\n  'Rfr': '\\u211C',\n  'real': '\\u211C',\n  'realpart': '\\u211C',\n  'ReverseElement': '\\u220B',\n  'SuchThat': '\\u220B',\n  'ni': '\\u220B',\n  'niv': '\\u220B',\n  'ReverseEquilibrium': '\\u21CB',\n  'leftrightharpoons': '\\u21CB',\n  'lrhar': '\\u21CB',\n  'ReverseUpEquilibrium': '\\u296F',\n  'duhar': '\\u296F',\n  'Rho': '\\u03A1',\n  'RightAngleBracket': '\\u27E9',\n  'rang': '\\u27E9',\n  'rangle': '\\u27E9',\n  'RightArrow': '\\u2192',\n  'ShortRightArrow': '\\u2192',\n  'rarr': '\\u2192',\n  'rightarrow': '\\u2192',\n  'srarr': '\\u2192',\n  'RightArrowBar': '\\u21E5',\n  'rarrb': '\\u21E5',\n  'RightArrowLeftArrow': '\\u21C4',\n  'rightleftarrows': '\\u21C4',\n  'rlarr': '\\u21C4',\n  'RightCeiling': '\\u2309',\n  'rceil': '\\u2309',\n  'RightDoubleBracket': '\\u27E7',\n  'robrk': '\\u27E7',\n  'RightDownTeeVector': '\\u295D',\n  'RightDownVector': '\\u21C2',\n  'dharr': '\\u21C2',\n  'downharpoonright': '\\u21C2',\n  'RightDownVectorBar': '\\u2955',\n  'RightFloor': '\\u230B',\n  'rfloor': '\\u230B',\n  'RightTee': '\\u22A2',\n  'vdash': '\\u22A2',\n  'RightTeeArrow': '\\u21A6',\n  'map': '\\u21A6',\n  'mapsto': '\\u21A6',\n  'RightTeeVector': '\\u295B',\n  'RightTriangle': '\\u22B3',\n  'vartriangleright': '\\u22B3',\n  'vrtri': '\\u22B3',\n  'RightTriangleBar': '\\u29D0',\n  'RightTriangleEqual': '\\u22B5',\n  'rtrie': '\\u22B5',\n  'trianglerighteq': '\\u22B5',\n  'RightUpDownVector': '\\u294F',\n  'RightUpTeeVector': '\\u295C',\n  'RightUpVector': '\\u21BE',\n  'uharr': '\\u21BE',\n  'upharpoonright': '\\u21BE',\n  'RightUpVectorBar': '\\u2954',\n  'RightVector': '\\u21C0',\n  'rharu': '\\u21C0',\n  'rightharpoonup': '\\u21C0',\n  'RightVectorBar': '\\u2953',\n  'Ropf': '\\u211D',\n  'reals': '\\u211D',\n  'RoundImplies': '\\u2970',\n  'Rrightarrow': '\\u21DB',\n  'rAarr': '\\u21DB',\n  'Rscr': '\\u211B',\n  'realine': '\\u211B',\n  'Rsh': '\\u21B1',\n  'rsh': '\\u21B1',\n  'RuleDelayed': '\\u29F4',\n  'SHCHcy': '\\u0429',\n  'SHcy': '\\u0428',\n  'SOFTcy': '\\u042C',\n  'Sacute': '\\u015A',\n  'Sc': '\\u2ABC',\n  'Scaron': '\\u0160',\n  'Scedil': '\\u015E',\n  'Scirc': '\\u015C',\n  'Scy': '\\u0421',\n  'Sfr': '\\uD835\\uDD16',\n  'ShortUpArrow': '\\u2191',\n  'UpArrow': '\\u2191',\n  'uarr': '\\u2191',\n  'uparrow': '\\u2191',\n  'Sigma': '\\u03A3',\n  'SmallCircle': '\\u2218',\n  'compfn': '\\u2218',\n  'Sopf': '\\uD835\\uDD4A',\n  'Sqrt': '\\u221A',\n  'radic': '\\u221A',\n  'Square': '\\u25A1',\n  'squ': '\\u25A1',\n  'square': '\\u25A1',\n  'SquareIntersection': '\\u2293',\n  'sqcap': '\\u2293',\n  'SquareSubset': '\\u228F',\n  'sqsub': '\\u228F',\n  'sqsubset': '\\u228F',\n  'SquareSubsetEqual': '\\u2291',\n  'sqsube': '\\u2291',\n  'sqsubseteq': '\\u2291',\n  'SquareSuperset': '\\u2290',\n  'sqsup': '\\u2290',\n  'sqsupset': '\\u2290',\n  'SquareSupersetEqual': '\\u2292',\n  'sqsupe': '\\u2292',\n  'sqsupseteq': '\\u2292',\n  'SquareUnion': '\\u2294',\n  'sqcup': '\\u2294',\n  'Sscr': '\\uD835\\uDCAE',\n  'Star': '\\u22C6',\n  'sstarf': '\\u22C6',\n  'Sub': '\\u22D0',\n  'Subset': '\\u22D0',\n  'SubsetEqual': '\\u2286',\n  'sube': '\\u2286',\n  'subseteq': '\\u2286',\n  'Succeeds': '\\u227B',\n  'sc': '\\u227B',\n  'succ': '\\u227B',\n  'SucceedsEqual': '\\u2AB0',\n  'sce': '\\u2AB0',\n  'succeq': '\\u2AB0',\n  'SucceedsSlantEqual': '\\u227D',\n  'sccue': '\\u227D',\n  'succcurlyeq': '\\u227D',\n  'SucceedsTilde': '\\u227F',\n  'scsim': '\\u227F',\n  'succsim': '\\u227F',\n  'Sum': '\\u2211',\n  'sum': '\\u2211',\n  'Sup': '\\u22D1',\n  'Supset': '\\u22D1',\n  'Superset': '\\u2283',\n  'sup': '\\u2283',\n  'supset': '\\u2283',\n  'SupersetEqual': '\\u2287',\n  'supe': '\\u2287',\n  'supseteq': '\\u2287',\n  'THORN': '\\u00DE',\n  'TRADE': '\\u2122',\n  'trade': '\\u2122',\n  'TSHcy': '\\u040B',\n  'TScy': '\\u0426',\n  'Tab': '\\u0009',\n  'Tau': '\\u03A4',\n  'Tcaron': '\\u0164',\n  'Tcedil': '\\u0162',\n  'Tcy': '\\u0422',\n  'Tfr': '\\uD835\\uDD17',\n  'Therefore': '\\u2234',\n  'there4': '\\u2234',\n  'therefore': '\\u2234',\n  'Theta': '\\u0398',\n  'ThickSpace': '\\u205F\\u200A',\n  'ThinSpace': '\\u2009',\n  'thinsp': '\\u2009',\n  'Tilde': '\\u223C',\n  'sim': '\\u223C',\n  'thicksim': '\\u223C',\n  'thksim': '\\u223C',\n  'TildeEqual': '\\u2243',\n  'sime': '\\u2243',\n  'simeq': '\\u2243',\n  'TildeFullEqual': '\\u2245',\n  'cong': '\\u2245',\n  'TildeTilde': '\\u2248',\n  'ap': '\\u2248',\n  'approx': '\\u2248',\n  'asymp': '\\u2248',\n  'thickapprox': '\\u2248',\n  'thkap': '\\u2248',\n  'Topf': '\\uD835\\uDD4B',\n  'TripleDot': '\\u20DB',\n  'tdot': '\\u20DB',\n  'Tscr': '\\uD835\\uDCAF',\n  'Tstrok': '\\u0166',\n  'Uacute': '\\u00DA',\n  'Uarr': '\\u219F',\n  'Uarrocir': '\\u2949',\n  'Ubrcy': '\\u040E',\n  'Ubreve': '\\u016C',\n  'Ucirc': '\\u00DB',\n  'Ucy': '\\u0423',\n  'Udblac': '\\u0170',\n  'Ufr': '\\uD835\\uDD18',\n  'Ugrave': '\\u00D9',\n  'Umacr': '\\u016A',\n  'UnderBar': '\\u005F',\n  'lowbar': '\\u005F',\n  'UnderBrace': '\\u23DF',\n  'UnderBracket': '\\u23B5',\n  'bbrk': '\\u23B5',\n  'UnderParenthesis': '\\u23DD',\n  'Union': '\\u22C3',\n  'bigcup': '\\u22C3',\n  'xcup': '\\u22C3',\n  'UnionPlus': '\\u228E',\n  'uplus': '\\u228E',\n  'Uogon': '\\u0172',\n  'Uopf': '\\uD835\\uDD4C',\n  'UpArrowBar': '\\u2912',\n  'UpArrowDownArrow': '\\u21C5',\n  'udarr': '\\u21C5',\n  'UpDownArrow': '\\u2195',\n  'updownarrow': '\\u2195',\n  'varr': '\\u2195',\n  'UpEquilibrium': '\\u296E',\n  'udhar': '\\u296E',\n  'UpTee': '\\u22A5',\n  'bot': '\\u22A5',\n  'bottom': '\\u22A5',\n  'perp': '\\u22A5',\n  'UpTeeArrow': '\\u21A5',\n  'mapstoup': '\\u21A5',\n  'UpperLeftArrow': '\\u2196',\n  'nwarr': '\\u2196',\n  'nwarrow': '\\u2196',\n  'UpperRightArrow': '\\u2197',\n  'nearr': '\\u2197',\n  'nearrow': '\\u2197',\n  'Upsi': '\\u03D2',\n  'upsih': '\\u03D2',\n  'Upsilon': '\\u03A5',\n  'Uring': '\\u016E',\n  'Uscr': '\\uD835\\uDCB0',\n  'Utilde': '\\u0168',\n  'Uuml': '\\u00DC',\n  'VDash': '\\u22AB',\n  'Vbar': '\\u2AEB',\n  'Vcy': '\\u0412',\n  'Vdash': '\\u22A9',\n  'Vdashl': '\\u2AE6',\n  'Vee': '\\u22C1',\n  'bigvee': '\\u22C1',\n  'xvee': '\\u22C1',\n  'Verbar': '\\u2016',\n  'Vert': '\\u2016',\n  'VerticalBar': '\\u2223',\n  'mid': '\\u2223',\n  'shortmid': '\\u2223',\n  'smid': '\\u2223',\n  'VerticalLine': '\\u007C',\n  'verbar': '\\u007C',\n  'vert': '\\u007C',\n  'VerticalSeparator': '\\u2758',\n  'VerticalTilde': '\\u2240',\n  'wr': '\\u2240',\n  'wreath': '\\u2240',\n  'VeryThinSpace': '\\u200A',\n  'hairsp': '\\u200A',\n  'Vfr': '\\uD835\\uDD19',\n  'Vopf': '\\uD835\\uDD4D',\n  'Vscr': '\\uD835\\uDCB1',\n  'Vvdash': '\\u22AA',\n  'Wcirc': '\\u0174',\n  'Wedge': '\\u22C0',\n  'bigwedge': '\\u22C0',\n  'xwedge': '\\u22C0',\n  'Wfr': '\\uD835\\uDD1A',\n  'Wopf': '\\uD835\\uDD4E',\n  'Wscr': '\\uD835\\uDCB2',\n  'Xfr': '\\uD835\\uDD1B',\n  'Xi': '\\u039E',\n  'Xopf': '\\uD835\\uDD4F',\n  'Xscr': '\\uD835\\uDCB3',\n  'YAcy': '\\u042F',\n  'YIcy': '\\u0407',\n  'YUcy': '\\u042E',\n  'Yacute': '\\u00DD',\n  'Ycirc': '\\u0176',\n  'Ycy': '\\u042B',\n  'Yfr': '\\uD835\\uDD1C',\n  'Yopf': '\\uD835\\uDD50',\n  'Yscr': '\\uD835\\uDCB4',\n  'Yuml': '\\u0178',\n  'ZHcy': '\\u0416',\n  'Zacute': '\\u0179',\n  'Zcaron': '\\u017D',\n  'Zcy': '\\u0417',\n  'Zdot': '\\u017B',\n  'Zeta': '\\u0396',\n  'Zfr': '\\u2128',\n  'zeetrf': '\\u2128',\n  'Zopf': '\\u2124',\n  'integers': '\\u2124',\n  'Zscr': '\\uD835\\uDCB5',\n  'aacute': '\\u00E1',\n  'abreve': '\\u0103',\n  'ac': '\\u223E',\n  'mstpos': '\\u223E',\n  'acE': '\\u223E\\u0333',\n  'acd': '\\u223F',\n  'acirc': '\\u00E2',\n  'acy': '\\u0430',\n  'aelig': '\\u00E6',\n  'afr': '\\uD835\\uDD1E',\n  'agrave': '\\u00E0',\n  'alefsym': '\\u2135',\n  'aleph': '\\u2135',\n  'alpha': '\\u03B1',\n  'amacr': '\\u0101',\n  'amalg': '\\u2A3F',\n  'and': '\\u2227',\n  'wedge': '\\u2227',\n  'andand': '\\u2A55',\n  'andd': '\\u2A5C',\n  'andslope': '\\u2A58',\n  'andv': '\\u2A5A',\n  'ang': '\\u2220',\n  'angle': '\\u2220',\n  'ange': '\\u29A4',\n  'angmsd': '\\u2221',\n  'measuredangle': '\\u2221',\n  'angmsdaa': '\\u29A8',\n  'angmsdab': '\\u29A9',\n  'angmsdac': '\\u29AA',\n  'angmsdad': '\\u29AB',\n  'angmsdae': '\\u29AC',\n  'angmsdaf': '\\u29AD',\n  'angmsdag': '\\u29AE',\n  'angmsdah': '\\u29AF',\n  'angrt': '\\u221F',\n  'angrtvb': '\\u22BE',\n  'angrtvbd': '\\u299D',\n  'angsph': '\\u2222',\n  'angzarr': '\\u237C',\n  'aogon': '\\u0105',\n  'aopf': '\\uD835\\uDD52',\n  'apE': '\\u2A70',\n  'apacir': '\\u2A6F',\n  'ape': '\\u224A',\n  'approxeq': '\\u224A',\n  'apid': '\\u224B',\n  'apos': '\\u0027',\n  'aring': '\\u00E5',\n  'ascr': '\\uD835\\uDCB6',\n  'ast': '\\u002A',\n  'midast': '\\u002A',\n  'atilde': '\\u00E3',\n  'auml': '\\u00E4',\n  'awint': '\\u2A11',\n  'bNot': '\\u2AED',\n  'backcong': '\\u224C',\n  'bcong': '\\u224C',\n  'backepsilon': '\\u03F6',\n  'bepsi': '\\u03F6',\n  'backprime': '\\u2035',\n  'bprime': '\\u2035',\n  'backsim': '\\u223D',\n  'bsim': '\\u223D',\n  'backsimeq': '\\u22CD',\n  'bsime': '\\u22CD',\n  'barvee': '\\u22BD',\n  'barwed': '\\u2305',\n  'barwedge': '\\u2305',\n  'bbrktbrk': '\\u23B6',\n  'bcy': '\\u0431',\n  'bdquo': '\\u201E',\n  'ldquor': '\\u201E',\n  'bemptyv': '\\u29B0',\n  'beta': '\\u03B2',\n  'beth': '\\u2136',\n  'between': '\\u226C',\n  'twixt': '\\u226C',\n  'bfr': '\\uD835\\uDD1F',\n  'bigcirc': '\\u25EF',\n  'xcirc': '\\u25EF',\n  'bigodot': '\\u2A00',\n  'xodot': '\\u2A00',\n  'bigoplus': '\\u2A01',\n  'xoplus': '\\u2A01',\n  'bigotimes': '\\u2A02',\n  'xotime': '\\u2A02',\n  'bigsqcup': '\\u2A06',\n  'xsqcup': '\\u2A06',\n  'bigstar': '\\u2605',\n  'starf': '\\u2605',\n  'bigtriangledown': '\\u25BD',\n  'xdtri': '\\u25BD',\n  'bigtriangleup': '\\u25B3',\n  'xutri': '\\u25B3',\n  'biguplus': '\\u2A04',\n  'xuplus': '\\u2A04',\n  'bkarow': '\\u290D',\n  'rbarr': '\\u290D',\n  'blacklozenge': '\\u29EB',\n  'lozf': '\\u29EB',\n  'blacktriangle': '\\u25B4',\n  'utrif': '\\u25B4',\n  'blacktriangledown': '\\u25BE',\n  'dtrif': '\\u25BE',\n  'blacktriangleleft': '\\u25C2',\n  'ltrif': '\\u25C2',\n  'blacktriangleright': '\\u25B8',\n  'rtrif': '\\u25B8',\n  'blank': '\\u2423',\n  'blk12': '\\u2592',\n  'blk14': '\\u2591',\n  'blk34': '\\u2593',\n  'block': '\\u2588',\n  'bne': '\\u003D\\u20E5',\n  'bnequiv': '\\u2261\\u20E5',\n  'bnot': '\\u2310',\n  'bopf': '\\uD835\\uDD53',\n  'bowtie': '\\u22C8',\n  'boxDL': '\\u2557',\n  'boxDR': '\\u2554',\n  'boxDl': '\\u2556',\n  'boxDr': '\\u2553',\n  'boxH': '\\u2550',\n  'boxHD': '\\u2566',\n  'boxHU': '\\u2569',\n  'boxHd': '\\u2564',\n  'boxHu': '\\u2567',\n  'boxUL': '\\u255D',\n  'boxUR': '\\u255A',\n  'boxUl': '\\u255C',\n  'boxUr': '\\u2559',\n  'boxV': '\\u2551',\n  'boxVH': '\\u256C',\n  'boxVL': '\\u2563',\n  'boxVR': '\\u2560',\n  'boxVh': '\\u256B',\n  'boxVl': '\\u2562',\n  'boxVr': '\\u255F',\n  'boxbox': '\\u29C9',\n  'boxdL': '\\u2555',\n  'boxdR': '\\u2552',\n  'boxdl': '\\u2510',\n  'boxdr': '\\u250C',\n  'boxhD': '\\u2565',\n  'boxhU': '\\u2568',\n  'boxhd': '\\u252C',\n  'boxhu': '\\u2534',\n  'boxminus': '\\u229F',\n  'minusb': '\\u229F',\n  'boxplus': '\\u229E',\n  'plusb': '\\u229E',\n  'boxtimes': '\\u22A0',\n  'timesb': '\\u22A0',\n  'boxuL': '\\u255B',\n  'boxuR': '\\u2558',\n  'boxul': '\\u2518',\n  'boxur': '\\u2514',\n  'boxv': '\\u2502',\n  'boxvH': '\\u256A',\n  'boxvL': '\\u2561',\n  'boxvR': '\\u255E',\n  'boxvh': '\\u253C',\n  'boxvl': '\\u2524',\n  'boxvr': '\\u251C',\n  'brvbar': '\\u00A6',\n  'bscr': '\\uD835\\uDCB7',\n  'bsemi': '\\u204F',\n  'bsol': '\\u005C',\n  'bsolb': '\\u29C5',\n  'bsolhsub': '\\u27C8',\n  'bull': '\\u2022',\n  'bullet': '\\u2022',\n  'bumpE': '\\u2AAE',\n  'cacute': '\\u0107',\n  'cap': '\\u2229',\n  'capand': '\\u2A44',\n  'capbrcup': '\\u2A49',\n  'capcap': '\\u2A4B',\n  'capcup': '\\u2A47',\n  'capdot': '\\u2A40',\n  'caps': '\\u2229\\uFE00',\n  'caret': '\\u2041',\n  'ccaps': '\\u2A4D',\n  'ccaron': '\\u010D',\n  'ccedil': '\\u00E7',\n  'ccirc': '\\u0109',\n  'ccups': '\\u2A4C',\n  'ccupssm': '\\u2A50',\n  'cdot': '\\u010B',\n  'cemptyv': '\\u29B2',\n  'cent': '\\u00A2',\n  'cfr': '\\uD835\\uDD20',\n  'chcy': '\\u0447',\n  'check': '\\u2713',\n  'checkmark': '\\u2713',\n  'chi': '\\u03C7',\n  'cir': '\\u25CB',\n  'cirE': '\\u29C3',\n  'circ': '\\u02C6',\n  'circeq': '\\u2257',\n  'cire': '\\u2257',\n  'circlearrowleft': '\\u21BA',\n  'olarr': '\\u21BA',\n  'circlearrowright': '\\u21BB',\n  'orarr': '\\u21BB',\n  'circledS': '\\u24C8',\n  'oS': '\\u24C8',\n  'circledast': '\\u229B',\n  'oast': '\\u229B',\n  'circledcirc': '\\u229A',\n  'ocir': '\\u229A',\n  'circleddash': '\\u229D',\n  'odash': '\\u229D',\n  'cirfnint': '\\u2A10',\n  'cirmid': '\\u2AEF',\n  'cirscir': '\\u29C2',\n  'clubs': '\\u2663',\n  'clubsuit': '\\u2663',\n  'colon': '\\u003A',\n  'comma': '\\u002C',\n  'commat': '\\u0040',\n  'comp': '\\u2201',\n  'complement': '\\u2201',\n  'congdot': '\\u2A6D',\n  'copf': '\\uD835\\uDD54',\n  'copysr': '\\u2117',\n  'crarr': '\\u21B5',\n  'cross': '\\u2717',\n  'cscr': '\\uD835\\uDCB8',\n  'csub': '\\u2ACF',\n  'csube': '\\u2AD1',\n  'csup': '\\u2AD0',\n  'csupe': '\\u2AD2',\n  'ctdot': '\\u22EF',\n  'cudarrl': '\\u2938',\n  'cudarrr': '\\u2935',\n  'cuepr': '\\u22DE',\n  'curlyeqprec': '\\u22DE',\n  'cuesc': '\\u22DF',\n  'curlyeqsucc': '\\u22DF',\n  'cularr': '\\u21B6',\n  'curvearrowleft': '\\u21B6',\n  'cularrp': '\\u293D',\n  'cup': '\\u222A',\n  'cupbrcap': '\\u2A48',\n  'cupcap': '\\u2A46',\n  'cupcup': '\\u2A4A',\n  'cupdot': '\\u228D',\n  'cupor': '\\u2A45',\n  'cups': '\\u222A\\uFE00',\n  'curarr': '\\u21B7',\n  'curvearrowright': '\\u21B7',\n  'curarrm': '\\u293C',\n  'curlyvee': '\\u22CE',\n  'cuvee': '\\u22CE',\n  'curlywedge': '\\u22CF',\n  'cuwed': '\\u22CF',\n  'curren': '\\u00A4',\n  'cwint': '\\u2231',\n  'cylcty': '\\u232D',\n  'dHar': '\\u2965',\n  'dagger': '\\u2020',\n  'daleth': '\\u2138',\n  'dash': '\\u2010',\n  'hyphen': '\\u2010',\n  'dbkarow': '\\u290F',\n  'rBarr': '\\u290F',\n  'dcaron': '\\u010F',\n  'dcy': '\\u0434',\n  'ddarr': '\\u21CA',\n  'downdownarrows': '\\u21CA',\n  'ddotseq': '\\u2A77',\n  'eDDot': '\\u2A77',\n  'deg': '\\u00B0',\n  'delta': '\\u03B4',\n  'demptyv': '\\u29B1',\n  'dfisht': '\\u297F',\n  'dfr': '\\uD835\\uDD21',\n  'diamondsuit': '\\u2666',\n  'diams': '\\u2666',\n  'digamma': '\\u03DD',\n  'gammad': '\\u03DD',\n  'disin': '\\u22F2',\n  'div': '\\u00F7',\n  'divide': '\\u00F7',\n  'divideontimes': '\\u22C7',\n  'divonx': '\\u22C7',\n  'djcy': '\\u0452',\n  'dlcorn': '\\u231E',\n  'llcorner': '\\u231E',\n  'dlcrop': '\\u230D',\n  'dollar': '\\u0024',\n  'dopf': '\\uD835\\uDD55',\n  'doteqdot': '\\u2251',\n  'eDot': '\\u2251',\n  'dotminus': '\\u2238',\n  'minusd': '\\u2238',\n  'dotplus': '\\u2214',\n  'plusdo': '\\u2214',\n  'dotsquare': '\\u22A1',\n  'sdotb': '\\u22A1',\n  'drcorn': '\\u231F',\n  'lrcorner': '\\u231F',\n  'drcrop': '\\u230C',\n  'dscr': '\\uD835\\uDCB9',\n  'dscy': '\\u0455',\n  'dsol': '\\u29F6',\n  'dstrok': '\\u0111',\n  'dtdot': '\\u22F1',\n  'dtri': '\\u25BF',\n  'triangledown': '\\u25BF',\n  'dwangle': '\\u29A6',\n  'dzcy': '\\u045F',\n  'dzigrarr': '\\u27FF',\n  'eacute': '\\u00E9',\n  'easter': '\\u2A6E',\n  'ecaron': '\\u011B',\n  'ecir': '\\u2256',\n  'eqcirc': '\\u2256',\n  'ecirc': '\\u00EA',\n  'ecolon': '\\u2255',\n  'eqcolon': '\\u2255',\n  'ecy': '\\u044D',\n  'edot': '\\u0117',\n  'efDot': '\\u2252',\n  'fallingdotseq': '\\u2252',\n  'efr': '\\uD835\\uDD22',\n  'eg': '\\u2A9A',\n  'egrave': '\\u00E8',\n  'egs': '\\u2A96',\n  'eqslantgtr': '\\u2A96',\n  'egsdot': '\\u2A98',\n  'el': '\\u2A99',\n  'elinters': '\\u23E7',\n  'ell': '\\u2113',\n  'els': '\\u2A95',\n  'eqslantless': '\\u2A95',\n  'elsdot': '\\u2A97',\n  'emacr': '\\u0113',\n  'empty': '\\u2205',\n  'emptyset': '\\u2205',\n  'emptyv': '\\u2205',\n  'varnothing': '\\u2205',\n  'emsp13': '\\u2004',\n  'emsp14': '\\u2005',\n  'emsp': '\\u2003',\n  'eng': '\\u014B',\n  'ensp': '\\u2002',\n  'eogon': '\\u0119',\n  'eopf': '\\uD835\\uDD56',\n  'epar': '\\u22D5',\n  'eparsl': '\\u29E3',\n  'eplus': '\\u2A71',\n  'epsi': '\\u03B5',\n  'epsilon': '\\u03B5',\n  'epsiv': '\\u03F5',\n  'straightepsilon': '\\u03F5',\n  'varepsilon': '\\u03F5',\n  'equals': '\\u003D',\n  'equest': '\\u225F',\n  'questeq': '\\u225F',\n  'equivDD': '\\u2A78',\n  'eqvparsl': '\\u29E5',\n  'erDot': '\\u2253',\n  'risingdotseq': '\\u2253',\n  'erarr': '\\u2971',\n  'escr': '\\u212F',\n  'eta': '\\u03B7',\n  'eth': '\\u00F0',\n  'euml': '\\u00EB',\n  'euro': '\\u20AC',\n  'excl': '\\u0021',\n  'fcy': '\\u0444',\n  'female': '\\u2640',\n  'ffilig': '\\uFB03',\n  'fflig': '\\uFB00',\n  'ffllig': '\\uFB04',\n  'ffr': '\\uD835\\uDD23',\n  'filig': '\\uFB01',\n  'fjlig': '\\u0066\\u006A',\n  'flat': '\\u266D',\n  'fllig': '\\uFB02',\n  'fltns': '\\u25B1',\n  'fnof': '\\u0192',\n  'fopf': '\\uD835\\uDD57',\n  'fork': '\\u22D4',\n  'pitchfork': '\\u22D4',\n  'forkv': '\\u2AD9',\n  'fpartint': '\\u2A0D',\n  'frac12': '\\u00BD',\n  'half': '\\u00BD',\n  'frac13': '\\u2153',\n  'frac14': '\\u00BC',\n  'frac15': '\\u2155',\n  'frac16': '\\u2159',\n  'frac18': '\\u215B',\n  'frac23': '\\u2154',\n  'frac25': '\\u2156',\n  'frac34': '\\u00BE',\n  'frac35': '\\u2157',\n  'frac38': '\\u215C',\n  'frac45': '\\u2158',\n  'frac56': '\\u215A',\n  'frac58': '\\u215D',\n  'frac78': '\\u215E',\n  'frasl': '\\u2044',\n  'frown': '\\u2322',\n  'sfrown': '\\u2322',\n  'fscr': '\\uD835\\uDCBB',\n  'gEl': '\\u2A8C',\n  'gtreqqless': '\\u2A8C',\n  'gacute': '\\u01F5',\n  'gamma': '\\u03B3',\n  'gap': '\\u2A86',\n  'gtrapprox': '\\u2A86',\n  'gbreve': '\\u011F',\n  'gcirc': '\\u011D',\n  'gcy': '\\u0433',\n  'gdot': '\\u0121',\n  'gescc': '\\u2AA9',\n  'gesdot': '\\u2A80',\n  'gesdoto': '\\u2A82',\n  'gesdotol': '\\u2A84',\n  'gesl': '\\u22DB\\uFE00',\n  'gesles': '\\u2A94',\n  'gfr': '\\uD835\\uDD24',\n  'gimel': '\\u2137',\n  'gjcy': '\\u0453',\n  'glE': '\\u2A92',\n  'gla': '\\u2AA5',\n  'glj': '\\u2AA4',\n  'gnE': '\\u2269',\n  'gneqq': '\\u2269',\n  'gnap': '\\u2A8A',\n  'gnapprox': '\\u2A8A',\n  'gne': '\\u2A88',\n  'gneq': '\\u2A88',\n  'gnsim': '\\u22E7',\n  'gopf': '\\uD835\\uDD58',\n  'gscr': '\\u210A',\n  'gsime': '\\u2A8E',\n  'gsiml': '\\u2A90',\n  'gtcc': '\\u2AA7',\n  'gtcir': '\\u2A7A',\n  'gtdot': '\\u22D7',\n  'gtrdot': '\\u22D7',\n  'gtlPar': '\\u2995',\n  'gtquest': '\\u2A7C',\n  'gtrarr': '\\u2978',\n  'gvertneqq': '\\u2269\\uFE00',\n  'gvnE': '\\u2269\\uFE00',\n  'hardcy': '\\u044A',\n  'harrcir': '\\u2948',\n  'harrw': '\\u21AD',\n  'leftrightsquigarrow': '\\u21AD',\n  'hbar': '\\u210F',\n  'hslash': '\\u210F',\n  'planck': '\\u210F',\n  'plankv': '\\u210F',\n  'hcirc': '\\u0125',\n  'hearts': '\\u2665',\n  'heartsuit': '\\u2665',\n  'hellip': '\\u2026',\n  'mldr': '\\u2026',\n  'hercon': '\\u22B9',\n  'hfr': '\\uD835\\uDD25',\n  'hksearow': '\\u2925',\n  'searhk': '\\u2925',\n  'hkswarow': '\\u2926',\n  'swarhk': '\\u2926',\n  'hoarr': '\\u21FF',\n  'homtht': '\\u223B',\n  'hookleftarrow': '\\u21A9',\n  'larrhk': '\\u21A9',\n  'hookrightarrow': '\\u21AA',\n  'rarrhk': '\\u21AA',\n  'hopf': '\\uD835\\uDD59',\n  'horbar': '\\u2015',\n  'hscr': '\\uD835\\uDCBD',\n  'hstrok': '\\u0127',\n  'hybull': '\\u2043',\n  'iacute': '\\u00ED',\n  'icirc': '\\u00EE',\n  'icy': '\\u0438',\n  'iecy': '\\u0435',\n  'iexcl': '\\u00A1',\n  'ifr': '\\uD835\\uDD26',\n  'igrave': '\\u00EC',\n  'iiiint': '\\u2A0C',\n  'qint': '\\u2A0C',\n  'iiint': '\\u222D',\n  'tint': '\\u222D',\n  'iinfin': '\\u29DC',\n  'iiota': '\\u2129',\n  'ijlig': '\\u0133',\n  'imacr': '\\u012B',\n  'imath': '\\u0131',\n  'inodot': '\\u0131',\n  'imof': '\\u22B7',\n  'imped': '\\u01B5',\n  'incare': '\\u2105',\n  'infin': '\\u221E',\n  'infintie': '\\u29DD',\n  'intcal': '\\u22BA',\n  'intercal': '\\u22BA',\n  'intlarhk': '\\u2A17',\n  'intprod': '\\u2A3C',\n  'iprod': '\\u2A3C',\n  'iocy': '\\u0451',\n  'iogon': '\\u012F',\n  'iopf': '\\uD835\\uDD5A',\n  'iota': '\\u03B9',\n  'iquest': '\\u00BF',\n  'iscr': '\\uD835\\uDCBE',\n  'isinE': '\\u22F9',\n  'isindot': '\\u22F5',\n  'isins': '\\u22F4',\n  'isinsv': '\\u22F3',\n  'itilde': '\\u0129',\n  'iukcy': '\\u0456',\n  'iuml': '\\u00EF',\n  'jcirc': '\\u0135',\n  'jcy': '\\u0439',\n  'jfr': '\\uD835\\uDD27',\n  'jmath': '\\u0237',\n  'jopf': '\\uD835\\uDD5B',\n  'jscr': '\\uD835\\uDCBF',\n  'jsercy': '\\u0458',\n  'jukcy': '\\u0454',\n  'kappa': '\\u03BA',\n  'kappav': '\\u03F0',\n  'varkappa': '\\u03F0',\n  'kcedil': '\\u0137',\n  'kcy': '\\u043A',\n  'kfr': '\\uD835\\uDD28',\n  'kgreen': '\\u0138',\n  'khcy': '\\u0445',\n  'kjcy': '\\u045C',\n  'kopf': '\\uD835\\uDD5C',\n  'kscr': '\\uD835\\uDCC0',\n  'lAtail': '\\u291B',\n  'lBarr': '\\u290E',\n  'lEg': '\\u2A8B',\n  'lesseqqgtr': '\\u2A8B',\n  'lHar': '\\u2962',\n  'lacute': '\\u013A',\n  'laemptyv': '\\u29B4',\n  'lambda': '\\u03BB',\n  'langd': '\\u2991',\n  'lap': '\\u2A85',\n  'lessapprox': '\\u2A85',\n  'laquo': '\\u00AB',\n  'larrbfs': '\\u291F',\n  'larrfs': '\\u291D',\n  'larrlp': '\\u21AB',\n  'looparrowleft': '\\u21AB',\n  'larrpl': '\\u2939',\n  'larrsim': '\\u2973',\n  'larrtl': '\\u21A2',\n  'leftarrowtail': '\\u21A2',\n  'lat': '\\u2AAB',\n  'latail': '\\u2919',\n  'late': '\\u2AAD',\n  'lates': '\\u2AAD\\uFE00',\n  'lbarr': '\\u290C',\n  'lbbrk': '\\u2772',\n  'lbrace': '\\u007B',\n  'lcub': '\\u007B',\n  'lbrack': '\\u005B',\n  'lsqb': '\\u005B',\n  'lbrke': '\\u298B',\n  'lbrksld': '\\u298F',\n  'lbrkslu': '\\u298D',\n  'lcaron': '\\u013E',\n  'lcedil': '\\u013C',\n  'lcy': '\\u043B',\n  'ldca': '\\u2936',\n  'ldrdhar': '\\u2967',\n  'ldrushar': '\\u294B',\n  'ldsh': '\\u21B2',\n  'le': '\\u2264',\n  'leq': '\\u2264',\n  'leftleftarrows': '\\u21C7',\n  'llarr': '\\u21C7',\n  'leftthreetimes': '\\u22CB',\n  'lthree': '\\u22CB',\n  'lescc': '\\u2AA8',\n  'lesdot': '\\u2A7F',\n  'lesdoto': '\\u2A81',\n  'lesdotor': '\\u2A83',\n  'lesg': '\\u22DA\\uFE00',\n  'lesges': '\\u2A93',\n  'lessdot': '\\u22D6',\n  'ltdot': '\\u22D6',\n  'lfisht': '\\u297C',\n  'lfr': '\\uD835\\uDD29',\n  'lgE': '\\u2A91',\n  'lharul': '\\u296A',\n  'lhblk': '\\u2584',\n  'ljcy': '\\u0459',\n  'llhard': '\\u296B',\n  'lltri': '\\u25FA',\n  'lmidot': '\\u0140',\n  'lmoust': '\\u23B0',\n  'lmoustache': '\\u23B0',\n  'lnE': '\\u2268',\n  'lneqq': '\\u2268',\n  'lnap': '\\u2A89',\n  'lnapprox': '\\u2A89',\n  'lne': '\\u2A87',\n  'lneq': '\\u2A87',\n  'lnsim': '\\u22E6',\n  'loang': '\\u27EC',\n  'loarr': '\\u21FD',\n  'longmapsto': '\\u27FC',\n  'xmap': '\\u27FC',\n  'looparrowright': '\\u21AC',\n  'rarrlp': '\\u21AC',\n  'lopar': '\\u2985',\n  'lopf': '\\uD835\\uDD5D',\n  'loplus': '\\u2A2D',\n  'lotimes': '\\u2A34',\n  'lowast': '\\u2217',\n  'loz': '\\u25CA',\n  'lozenge': '\\u25CA',\n  'lpar': '\\u0028',\n  'lparlt': '\\u2993',\n  'lrhard': '\\u296D',\n  'lrm': '\\u200E',\n  'lrtri': '\\u22BF',\n  'lsaquo': '\\u2039',\n  'lscr': '\\uD835\\uDCC1',\n  'lsime': '\\u2A8D',\n  'lsimg': '\\u2A8F',\n  'lsquor': '\\u201A',\n  'sbquo': '\\u201A',\n  'lstrok': '\\u0142',\n  'ltcc': '\\u2AA6',\n  'ltcir': '\\u2A79',\n  'ltimes': '\\u22C9',\n  'ltlarr': '\\u2976',\n  'ltquest': '\\u2A7B',\n  'ltrPar': '\\u2996',\n  'ltri': '\\u25C3',\n  'triangleleft': '\\u25C3',\n  'lurdshar': '\\u294A',\n  'luruhar': '\\u2966',\n  'lvertneqq': '\\u2268\\uFE00',\n  'lvnE': '\\u2268\\uFE00',\n  'mDDot': '\\u223A',\n  'macr': '\\u00AF',\n  'strns': '\\u00AF',\n  'male': '\\u2642',\n  'malt': '\\u2720',\n  'maltese': '\\u2720',\n  'marker': '\\u25AE',\n  'mcomma': '\\u2A29',\n  'mcy': '\\u043C',\n  'mdash': '\\u2014',\n  'mfr': '\\uD835\\uDD2A',\n  'mho': '\\u2127',\n  'micro': '\\u00B5',\n  'midcir': '\\u2AF0',\n  'minus': '\\u2212',\n  'minusdu': '\\u2A2A',\n  'mlcp': '\\u2ADB',\n  'models': '\\u22A7',\n  'mopf': '\\uD835\\uDD5E',\n  'mscr': '\\uD835\\uDCC2',\n  'mu': '\\u03BC',\n  'multimap': '\\u22B8',\n  'mumap': '\\u22B8',\n  'nGg': '\\u22D9\\u0338',\n  'nGt': '\\u226B\\u20D2',\n  'nLeftarrow': '\\u21CD',\n  'nlArr': '\\u21CD',\n  'nLeftrightarrow': '\\u21CE',\n  'nhArr': '\\u21CE',\n  'nLl': '\\u22D8\\u0338',\n  'nLt': '\\u226A\\u20D2',\n  'nRightarrow': '\\u21CF',\n  'nrArr': '\\u21CF',\n  'nVDash': '\\u22AF',\n  'nVdash': '\\u22AE',\n  'nacute': '\\u0144',\n  'nang': '\\u2220\\u20D2',\n  'napE': '\\u2A70\\u0338',\n  'napid': '\\u224B\\u0338',\n  'napos': '\\u0149',\n  'natur': '\\u266E',\n  'natural': '\\u266E',\n  'ncap': '\\u2A43',\n  'ncaron': '\\u0148',\n  'ncedil': '\\u0146',\n  'ncongdot': '\\u2A6D\\u0338',\n  'ncup': '\\u2A42',\n  'ncy': '\\u043D',\n  'ndash': '\\u2013',\n  'neArr': '\\u21D7',\n  'nearhk': '\\u2924',\n  'nedot': '\\u2250\\u0338',\n  'nesear': '\\u2928',\n  'toea': '\\u2928',\n  'nfr': '\\uD835\\uDD2B',\n  'nharr': '\\u21AE',\n  'nleftrightarrow': '\\u21AE',\n  'nhpar': '\\u2AF2',\n  'nis': '\\u22FC',\n  'nisd': '\\u22FA',\n  'njcy': '\\u045A',\n  'nlE': '\\u2266\\u0338',\n  'nleqq': '\\u2266\\u0338',\n  'nlarr': '\\u219A',\n  'nleftarrow': '\\u219A',\n  'nldr': '\\u2025',\n  'nopf': '\\uD835\\uDD5F',\n  'not': '\\u00AC',\n  'notinE': '\\u22F9\\u0338',\n  'notindot': '\\u22F5\\u0338',\n  'notinvb': '\\u22F7',\n  'notinvc': '\\u22F6',\n  'notnivb': '\\u22FE',\n  'notnivc': '\\u22FD',\n  'nparsl': '\\u2AFD\\u20E5',\n  'npart': '\\u2202\\u0338',\n  'npolint': '\\u2A14',\n  'nrarr': '\\u219B',\n  'nrightarrow': '\\u219B',\n  'nrarrc': '\\u2933\\u0338',\n  'nrarrw': '\\u219D\\u0338',\n  'nscr': '\\uD835\\uDCC3',\n  'nsub': '\\u2284',\n  'nsubE': '\\u2AC5\\u0338',\n  'nsubseteqq': '\\u2AC5\\u0338',\n  'nsup': '\\u2285',\n  'nsupE': '\\u2AC6\\u0338',\n  'nsupseteqq': '\\u2AC6\\u0338',\n  'ntilde': '\\u00F1',\n  'nu': '\\u03BD',\n  'num': '\\u0023',\n  'numero': '\\u2116',\n  'numsp': '\\u2007',\n  'nvDash': '\\u22AD',\n  'nvHarr': '\\u2904',\n  'nvap': '\\u224D\\u20D2',\n  'nvdash': '\\u22AC',\n  'nvge': '\\u2265\\u20D2',\n  'nvgt': '\\u003E\\u20D2',\n  'nvinfin': '\\u29DE',\n  'nvlArr': '\\u2902',\n  'nvle': '\\u2264\\u20D2',\n  'nvlt': '\\u003C\\u20D2',\n  'nvltrie': '\\u22B4\\u20D2',\n  'nvrArr': '\\u2903',\n  'nvrtrie': '\\u22B5\\u20D2',\n  'nvsim': '\\u223C\\u20D2',\n  'nwArr': '\\u21D6',\n  'nwarhk': '\\u2923',\n  'nwnear': '\\u2927',\n  'oacute': '\\u00F3',\n  'ocirc': '\\u00F4',\n  'ocy': '\\u043E',\n  'odblac': '\\u0151',\n  'odiv': '\\u2A38',\n  'odsold': '\\u29BC',\n  'oelig': '\\u0153',\n  'ofcir': '\\u29BF',\n  'ofr': '\\uD835\\uDD2C',\n  'ogon': '\\u02DB',\n  'ograve': '\\u00F2',\n  'ogt': '\\u29C1',\n  'ohbar': '\\u29B5',\n  'olcir': '\\u29BE',\n  'olcross': '\\u29BB',\n  'olt': '\\u29C0',\n  'omacr': '\\u014D',\n  'omega': '\\u03C9',\n  'omicron': '\\u03BF',\n  'omid': '\\u29B6',\n  'oopf': '\\uD835\\uDD60',\n  'opar': '\\u29B7',\n  'operp': '\\u29B9',\n  'or': '\\u2228',\n  'vee': '\\u2228',\n  'ord': '\\u2A5D',\n  'order': '\\u2134',\n  'orderof': '\\u2134',\n  'oscr': '\\u2134',\n  'ordf': '\\u00AA',\n  'ordm': '\\u00BA',\n  'origof': '\\u22B6',\n  'oror': '\\u2A56',\n  'orslope': '\\u2A57',\n  'orv': '\\u2A5B',\n  'oslash': '\\u00F8',\n  'osol': '\\u2298',\n  'otilde': '\\u00F5',\n  'otimesas': '\\u2A36',\n  'ouml': '\\u00F6',\n  'ovbar': '\\u233D',\n  'para': '\\u00B6',\n  'parsim': '\\u2AF3',\n  'parsl': '\\u2AFD',\n  'pcy': '\\u043F',\n  'percnt': '\\u0025',\n  'period': '\\u002E',\n  'permil': '\\u2030',\n  'pertenk': '\\u2031',\n  'pfr': '\\uD835\\uDD2D',\n  'phi': '\\u03C6',\n  'phiv': '\\u03D5',\n  'straightphi': '\\u03D5',\n  'varphi': '\\u03D5',\n  'phone': '\\u260E',\n  'pi': '\\u03C0',\n  'piv': '\\u03D6',\n  'varpi': '\\u03D6',\n  'planckh': '\\u210E',\n  'plus': '\\u002B',\n  'plusacir': '\\u2A23',\n  'pluscir': '\\u2A22',\n  'plusdu': '\\u2A25',\n  'pluse': '\\u2A72',\n  'plussim': '\\u2A26',\n  'plustwo': '\\u2A27',\n  'pointint': '\\u2A15',\n  'popf': '\\uD835\\uDD61',\n  'pound': '\\u00A3',\n  'prE': '\\u2AB3',\n  'prap': '\\u2AB7',\n  'precapprox': '\\u2AB7',\n  'precnapprox': '\\u2AB9',\n  'prnap': '\\u2AB9',\n  'precneqq': '\\u2AB5',\n  'prnE': '\\u2AB5',\n  'precnsim': '\\u22E8',\n  'prnsim': '\\u22E8',\n  'prime': '\\u2032',\n  'profalar': '\\u232E',\n  'profline': '\\u2312',\n  'profsurf': '\\u2313',\n  'prurel': '\\u22B0',\n  'pscr': '\\uD835\\uDCC5',\n  'psi': '\\u03C8',\n  'puncsp': '\\u2008',\n  'qfr': '\\uD835\\uDD2E',\n  'qopf': '\\uD835\\uDD62',\n  'qprime': '\\u2057',\n  'qscr': '\\uD835\\uDCC6',\n  'quatint': '\\u2A16',\n  'quest': '\\u003F',\n  'rAtail': '\\u291C',\n  'rHar': '\\u2964',\n  'race': '\\u223D\\u0331',\n  'racute': '\\u0155',\n  'raemptyv': '\\u29B3',\n  'rangd': '\\u2992',\n  'range': '\\u29A5',\n  'raquo': '\\u00BB',\n  'rarrap': '\\u2975',\n  'rarrbfs': '\\u2920',\n  'rarrc': '\\u2933',\n  'rarrfs': '\\u291E',\n  'rarrpl': '\\u2945',\n  'rarrsim': '\\u2974',\n  'rarrtl': '\\u21A3',\n  'rightarrowtail': '\\u21A3',\n  'rarrw': '\\u219D',\n  'rightsquigarrow': '\\u219D',\n  'ratail': '\\u291A',\n  'ratio': '\\u2236',\n  'rbbrk': '\\u2773',\n  'rbrace': '\\u007D',\n  'rcub': '\\u007D',\n  'rbrack': '\\u005D',\n  'rsqb': '\\u005D',\n  'rbrke': '\\u298C',\n  'rbrksld': '\\u298E',\n  'rbrkslu': '\\u2990',\n  'rcaron': '\\u0159',\n  'rcedil': '\\u0157',\n  'rcy': '\\u0440',\n  'rdca': '\\u2937',\n  'rdldhar': '\\u2969',\n  'rdsh': '\\u21B3',\n  'rect': '\\u25AD',\n  'rfisht': '\\u297D',\n  'rfr': '\\uD835\\uDD2F',\n  'rharul': '\\u296C',\n  'rho': '\\u03C1',\n  'rhov': '\\u03F1',\n  'varrho': '\\u03F1',\n  'rightrightarrows': '\\u21C9',\n  'rrarr': '\\u21C9',\n  'rightthreetimes': '\\u22CC',\n  'rthree': '\\u22CC',\n  'ring': '\\u02DA',\n  'rlm': '\\u200F',\n  'rmoust': '\\u23B1',\n  'rmoustache': '\\u23B1',\n  'rnmid': '\\u2AEE',\n  'roang': '\\u27ED',\n  'roarr': '\\u21FE',\n  'ropar': '\\u2986',\n  'ropf': '\\uD835\\uDD63',\n  'roplus': '\\u2A2E',\n  'rotimes': '\\u2A35',\n  'rpar': '\\u0029',\n  'rpargt': '\\u2994',\n  'rppolint': '\\u2A12',\n  'rsaquo': '\\u203A',\n  'rscr': '\\uD835\\uDCC7',\n  'rtimes': '\\u22CA',\n  'rtri': '\\u25B9',\n  'triangleright': '\\u25B9',\n  'rtriltri': '\\u29CE',\n  'ruluhar': '\\u2968',\n  'rx': '\\u211E',\n  'sacute': '\\u015B',\n  'scE': '\\u2AB4',\n  'scap': '\\u2AB8',\n  'succapprox': '\\u2AB8',\n  'scaron': '\\u0161',\n  'scedil': '\\u015F',\n  'scirc': '\\u015D',\n  'scnE': '\\u2AB6',\n  'succneqq': '\\u2AB6',\n  'scnap': '\\u2ABA',\n  'succnapprox': '\\u2ABA',\n  'scnsim': '\\u22E9',\n  'succnsim': '\\u22E9',\n  'scpolint': '\\u2A13',\n  'scy': '\\u0441',\n  'sdot': '\\u22C5',\n  'sdote': '\\u2A66',\n  'seArr': '\\u21D8',\n  'sect': '\\u00A7',\n  'semi': '\\u003B',\n  'seswar': '\\u2929',\n  'tosa': '\\u2929',\n  'sext': '\\u2736',\n  'sfr': '\\uD835\\uDD30',\n  'sharp': '\\u266F',\n  'shchcy': '\\u0449',\n  'shcy': '\\u0448',\n  'shy': '\\u00AD',\n  'sigma': '\\u03C3',\n  'sigmaf': '\\u03C2',\n  'sigmav': '\\u03C2',\n  'varsigma': '\\u03C2',\n  'simdot': '\\u2A6A',\n  'simg': '\\u2A9E',\n  'simgE': '\\u2AA0',\n  'siml': '\\u2A9D',\n  'simlE': '\\u2A9F',\n  'simne': '\\u2246',\n  'simplus': '\\u2A24',\n  'simrarr': '\\u2972',\n  'smashp': '\\u2A33',\n  'smeparsl': '\\u29E4',\n  'smile': '\\u2323',\n  'ssmile': '\\u2323',\n  'smt': '\\u2AAA',\n  'smte': '\\u2AAC',\n  'smtes': '\\u2AAC\\uFE00',\n  'softcy': '\\u044C',\n  'sol': '\\u002F',\n  'solb': '\\u29C4',\n  'solbar': '\\u233F',\n  'sopf': '\\uD835\\uDD64',\n  'spades': '\\u2660',\n  'spadesuit': '\\u2660',\n  'sqcaps': '\\u2293\\uFE00',\n  'sqcups': '\\u2294\\uFE00',\n  'sscr': '\\uD835\\uDCC8',\n  'star': '\\u2606',\n  'sub': '\\u2282',\n  'subset': '\\u2282',\n  'subE': '\\u2AC5',\n  'subseteqq': '\\u2AC5',\n  'subdot': '\\u2ABD',\n  'subedot': '\\u2AC3',\n  'submult': '\\u2AC1',\n  'subnE': '\\u2ACB',\n  'subsetneqq': '\\u2ACB',\n  'subne': '\\u228A',\n  'subsetneq': '\\u228A',\n  'subplus': '\\u2ABF',\n  'subrarr': '\\u2979',\n  'subsim': '\\u2AC7',\n  'subsub': '\\u2AD5',\n  'subsup': '\\u2AD3',\n  'sung': '\\u266A',\n  'sup1': '\\u00B9',\n  'sup2': '\\u00B2',\n  'sup3': '\\u00B3',\n  'supE': '\\u2AC6',\n  'supseteqq': '\\u2AC6',\n  'supdot': '\\u2ABE',\n  'supdsub': '\\u2AD8',\n  'supedot': '\\u2AC4',\n  'suphsol': '\\u27C9',\n  'suphsub': '\\u2AD7',\n  'suplarr': '\\u297B',\n  'supmult': '\\u2AC2',\n  'supnE': '\\u2ACC',\n  'supsetneqq': '\\u2ACC',\n  'supne': '\\u228B',\n  'supsetneq': '\\u228B',\n  'supplus': '\\u2AC0',\n  'supsim': '\\u2AC8',\n  'supsub': '\\u2AD4',\n  'supsup': '\\u2AD6',\n  'swArr': '\\u21D9',\n  'swnwar': '\\u292A',\n  'szlig': '\\u00DF',\n  'target': '\\u2316',\n  'tau': '\\u03C4',\n  'tcaron': '\\u0165',\n  'tcedil': '\\u0163',\n  'tcy': '\\u0442',\n  'telrec': '\\u2315',\n  'tfr': '\\uD835\\uDD31',\n  'theta': '\\u03B8',\n  'thetasym': '\\u03D1',\n  'thetav': '\\u03D1',\n  'vartheta': '\\u03D1',\n  'thorn': '\\u00FE',\n  'times': '\\u00D7',\n  'timesbar': '\\u2A31',\n  'timesd': '\\u2A30',\n  'topbot': '\\u2336',\n  'topcir': '\\u2AF1',\n  'topf': '\\uD835\\uDD65',\n  'topfork': '\\u2ADA',\n  'tprime': '\\u2034',\n  'triangle': '\\u25B5',\n  'utri': '\\u25B5',\n  'triangleq': '\\u225C',\n  'trie': '\\u225C',\n  'tridot': '\\u25EC',\n  'triminus': '\\u2A3A',\n  'triplus': '\\u2A39',\n  'trisb': '\\u29CD',\n  'tritime': '\\u2A3B',\n  'trpezium': '\\u23E2',\n  'tscr': '\\uD835\\uDCC9',\n  'tscy': '\\u0446',\n  'tshcy': '\\u045B',\n  'tstrok': '\\u0167',\n  'uHar': '\\u2963',\n  'uacute': '\\u00FA',\n  'ubrcy': '\\u045E',\n  'ubreve': '\\u016D',\n  'ucirc': '\\u00FB',\n  'ucy': '\\u0443',\n  'udblac': '\\u0171',\n  'ufisht': '\\u297E',\n  'ufr': '\\uD835\\uDD32',\n  'ugrave': '\\u00F9',\n  'uhblk': '\\u2580',\n  'ulcorn': '\\u231C',\n  'ulcorner': '\\u231C',\n  'ulcrop': '\\u230F',\n  'ultri': '\\u25F8',\n  'umacr': '\\u016B',\n  'uogon': '\\u0173',\n  'uopf': '\\uD835\\uDD66',\n  'upsi': '\\u03C5',\n  'upsilon': '\\u03C5',\n  'upuparrows': '\\u21C8',\n  'uuarr': '\\u21C8',\n  'urcorn': '\\u231D',\n  'urcorner': '\\u231D',\n  'urcrop': '\\u230E',\n  'uring': '\\u016F',\n  'urtri': '\\u25F9',\n  'uscr': '\\uD835\\uDCCA',\n  'utdot': '\\u22F0',\n  'utilde': '\\u0169',\n  'uuml': '\\u00FC',\n  'uwangle': '\\u29A7',\n  'vBar': '\\u2AE8',\n  'vBarv': '\\u2AE9',\n  'vangrt': '\\u299C',\n  'varsubsetneq': '\\u228A\\uFE00',\n  'vsubne': '\\u228A\\uFE00',\n  'varsubsetneqq': '\\u2ACB\\uFE00',\n  'vsubnE': '\\u2ACB\\uFE00',\n  'varsupsetneq': '\\u228B\\uFE00',\n  'vsupne': '\\u228B\\uFE00',\n  'varsupsetneqq': '\\u2ACC\\uFE00',\n  'vsupnE': '\\u2ACC\\uFE00',\n  'vcy': '\\u0432',\n  'veebar': '\\u22BB',\n  'veeeq': '\\u225A',\n  'vellip': '\\u22EE',\n  'vfr': '\\uD835\\uDD33',\n  'vopf': '\\uD835\\uDD67',\n  'vscr': '\\uD835\\uDCCB',\n  'vzigzag': '\\u299A',\n  'wcirc': '\\u0175',\n  'wedbar': '\\u2A5F',\n  'wedgeq': '\\u2259',\n  'weierp': '\\u2118',\n  'wp': '\\u2118',\n  'wfr': '\\uD835\\uDD34',\n  'wopf': '\\uD835\\uDD68',\n  'wscr': '\\uD835\\uDCCC',\n  'xfr': '\\uD835\\uDD35',\n  'xi': '\\u03BE',\n  'xnis': '\\u22FB',\n  'xopf': '\\uD835\\uDD69',\n  'xscr': '\\uD835\\uDCCD',\n  'yacute': '\\u00FD',\n  'yacy': '\\u044F',\n  'ycirc': '\\u0177',\n  'ycy': '\\u044B',\n  'yen': '\\u00A5',\n  'yfr': '\\uD835\\uDD36',\n  'yicy': '\\u0457',\n  'yopf': '\\uD835\\uDD6A',\n  'yscr': '\\uD835\\uDCCE',\n  'yucy': '\\u044E',\n  'yuml': '\\u00FF',\n  'zacute': '\\u017A',\n  'zcaron': '\\u017E',\n  'zcy': '\\u0437',\n  'zdot': '\\u017C',\n  'zeta': '\\u03B6',\n  'zfr': '\\uD835\\uDD37',\n  'zhcy': '\\u0436',\n  'zigrarr': '\\u21DD',\n  'zopf': '\\uD835\\uDD6B',\n  'zscr': '\\uD835\\uDCCF',\n  'zwj': '\\u200D',\n  'zwnj': '\\u200C'\n};\n\n\n// The &ngsp; pseudo-entity is denoting a space. see:\n// https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart\nexport const NGSP_UNICODE = '\\uE500';\n\nNAMED_ENTITIES['ngsp'] = NGSP_UNICODE;\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\nimport {ParseError, ParseLocation, ParseSourceFile, ParseSourceSpan} from '../parse_util';\n\nimport {NAMED_ENTITIES} from './entities';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './interpolation_config';\nimport {TagContentType, TagDefinition} from './tags';\nimport {IncompleteTagOpenToken, TagOpenStartToken, Token, TokenType} from './tokens';\n\nexport class TokenError extends ParseError {\n  constructor(errorMsg: string, public tokenType: TokenType|null, span: ParseSourceSpan) {\n    super(span, errorMsg);\n  }\n}\n\nexport class TokenizeResult {\n  constructor(\n      public tokens: Token[], public errors: TokenError[],\n      public nonNormalizedIcuExpressions: Token[]) {}\n}\n\nexport interface LexerRange {\n  startPos: number;\n  startLine: number;\n  startCol: number;\n  endPos: number;\n}\n\n/**\n * Options that modify how the text is tokenized.\n */\nexport interface TokenizeOptions {\n  /** Whether to tokenize ICU messages (considered as text nodes when false). */\n  tokenizeExpansionForms?: boolean;\n  /** How to tokenize interpolation markers. */\n  interpolationConfig?: InterpolationConfig;\n  /**\n   * The start and end point of the text to parse within the `source` string.\n   * The entire `source` string is parsed if this is not provided.\n   * */\n  range?: LexerRange;\n  /**\n   * If this text is stored in a JavaScript string, then we have to deal with escape sequences.\n   *\n   * **Example 1:**\n   *\n   * ```\n   * \"abc\\\"def\\nghi\"\n   * ```\n   *\n   * - The `\\\"` must be converted to `\"`.\n   * - The `\\n` must be converted to a new line character in a token,\n   *   but it should not increment the current line for source mapping.\n   *\n   * **Example 2:**\n   *\n   * ```\n   * \"abc\\\n   *  def\"\n   * ```\n   *\n   * The line continuation (`\\` followed by a newline) should be removed from a token\n   * but the new line should increment the current line for source mapping.\n   */\n  escapedString?: boolean;\n  /**\n   * If this text is stored in an external template (e.g. via `templateUrl`) then we need to decide\n   * whether or not to normalize the line-endings (from `\\r\\n` to `\\n`) when processing ICU\n   * expressions.\n   *\n   * If `true` then we will normalize ICU expression line endings.\n   * The default is `false`, but this will be switched in a future major release.\n   */\n  i18nNormalizeLineEndingsInICUs?: boolean;\n  /**\n   * An array of characters that should be considered as leading trivia.\n   * Leading trivia are characters that are not important to the developer, and so should not be\n   * included in source-map segments.  A common example is whitespace.\n   */\n  leadingTriviaChars?: string[];\n  /**\n   * If true, do not convert CRLF to LF.\n   */\n  preserveLineEndings?: boolean;\n}\n\nexport function tokenize(\n    source: string, url: string, getTagDefinition: (tagName: string) => TagDefinition,\n    options: TokenizeOptions = {}): TokenizeResult {\n  const tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);\n  tokenizer.tokenize();\n  return new TokenizeResult(\n      mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);\n}\n\nconst _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\n\nfunction _unexpectedCharacterErrorMsg(charCode: number): string {\n  const char = charCode === chars.$EOF ? 'EOF' : String.fromCharCode(charCode);\n  return `Unexpected character \"${char}\"`;\n}\n\nfunction _unknownEntityErrorMsg(entitySrc: string): string {\n  return `Unknown entity \"${entitySrc}\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax`;\n}\n\nfunction _unparsableEntityErrorMsg(type: CharacterReferenceType, entityStr: string): string {\n  return `Unable to parse entity \"${entityStr}\" - ${\n      type} character reference entities must end with \";\"`;\n}\n\nenum CharacterReferenceType {\n  HEX = 'hexadecimal',\n  DEC = 'decimal',\n}\n\nclass _ControlFlowError {\n  constructor(public error: TokenError) {}\n}\n\n// See https://www.w3.org/TR/html51/syntax.html#writing-html-documents\nclass _Tokenizer {\n  private _cursor: CharacterCursor;\n  private _tokenizeIcu: boolean;\n  private _interpolationConfig: InterpolationConfig;\n  private _leadingTriviaCodePoints: number[]|undefined;\n  private _currentTokenStart: CharacterCursor|null = null;\n  private _currentTokenType: TokenType|null = null;\n  private _expansionCaseStack: TokenType[] = [];\n  private _inInterpolation: boolean = false;\n  private readonly _preserveLineEndings: boolean;\n  private readonly _escapedString: boolean;\n  private readonly _i18nNormalizeLineEndingsInICUs: boolean;\n  tokens: Token[] = [];\n  errors: TokenError[] = [];\n  nonNormalizedIcuExpressions: Token[] = [];\n\n  /**\n   * @param _file The html source file being tokenized.\n   * @param _getTagDefinition A function that will retrieve a tag definition for a given tag name.\n   * @param options Configuration of the tokenization.\n   */\n  constructor(\n      _file: ParseSourceFile, private _getTagDefinition: (tagName: string) => TagDefinition,\n      options: TokenizeOptions) {\n    this._tokenizeIcu = options.tokenizeExpansionForms || false;\n    this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n    this._leadingTriviaCodePoints =\n        options.leadingTriviaChars && options.leadingTriviaChars.map(c => c.codePointAt(0) || 0);\n    const range =\n        options.range || {endPos: _file.content.length, startPos: 0, startLine: 0, startCol: 0};\n    this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) :\n                                           new PlainCharacterCursor(_file, range);\n    this._preserveLineEndings = options.preserveLineEndings || false;\n    this._escapedString = options.escapedString || false;\n    this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;\n    try {\n      this._cursor.init();\n    } catch (e) {\n      this.handleError(e);\n    }\n  }\n\n  private _processCarriageReturns(content: string): string {\n    if (this._preserveLineEndings) {\n      return content;\n    }\n    // https://www.w3.org/TR/html51/syntax.html#preprocessing-the-input-stream\n    // In order to keep the original position in the source, we can not\n    // pre-process it.\n    // Instead CRs are processed right before instantiating the tokens.\n    return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n  }\n\n  tokenize(): void {\n    while (this._cursor.peek() !== chars.$EOF) {\n      const start = this._cursor.clone();\n      try {\n        if (this._attemptCharCode(chars.$LT)) {\n          if (this._attemptCharCode(chars.$BANG)) {\n            if (this._attemptCharCode(chars.$LBRACKET)) {\n              this._consumeCdata(start);\n            } else if (this._attemptCharCode(chars.$MINUS)) {\n              this._consumeComment(start);\n            } else {\n              this._consumeDocType(start);\n            }\n          } else if (this._attemptCharCode(chars.$SLASH)) {\n            this._consumeTagClose(start);\n          } else {\n            this._consumeTagOpen(start);\n          }\n        } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n          // In (possibly interpolated) text the end of the text is given by `isTextEnd()`, while\n          // the premature end of an interpolation is given by the start of a new HTML element.\n          this._consumeWithInterpolation(\n              TokenType.TEXT, TokenType.INTERPOLATION, () => this._isTextEnd(),\n              () => this._isTagStart());\n        }\n      } catch (e) {\n        this.handleError(e);\n      }\n    }\n    this._beginToken(TokenType.EOF);\n    this._endToken([]);\n  }\n\n  /**\n   * @returns whether an ICU token has been created\n   * @internal\n   */\n  private _tokenizeExpansionForm(): boolean {\n    if (this.isExpansionFormStart()) {\n      this._consumeExpansionFormStart();\n      return true;\n    }\n\n    if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {\n      this._consumeExpansionCaseStart();\n      return true;\n    }\n\n    if (this._cursor.peek() === chars.$RBRACE) {\n      if (this._isInExpansionCase()) {\n        this._consumeExpansionCaseEnd();\n        return true;\n      }\n\n      if (this._isInExpansionForm()) {\n        this._consumeExpansionFormEnd();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _beginToken(type: TokenType, start = this._cursor.clone()) {\n    this._currentTokenStart = start;\n    this._currentTokenType = type;\n  }\n\n  private _endToken(parts: string[], end?: CharacterCursor): Token {\n    if (this._currentTokenStart === null) {\n      throw new TokenError(\n          'Programming error - attempted to end a token when there was no start to the token',\n          this._currentTokenType, this._cursor.getSpan(end));\n    }\n    if (this._currentTokenType === null) {\n      throw new TokenError(\n          'Programming error - attempted to end a token which has no token type', null,\n          this._cursor.getSpan(this._currentTokenStart));\n    }\n    const token = {\n      type: this._currentTokenType,\n      parts,\n      sourceSpan:\n          (end ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints),\n    } as Token;\n    this.tokens.push(token);\n    this._currentTokenStart = null;\n    this._currentTokenType = null;\n    return token;\n  }\n\n  private _createError(msg: string, span: ParseSourceSpan): _ControlFlowError {\n    if (this._isInExpansionForm()) {\n      msg += ` (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)`;\n    }\n    const error = new TokenError(msg, this._currentTokenType, span);\n    this._currentTokenStart = null;\n    this._currentTokenType = null;\n    return new _ControlFlowError(error);\n  }\n\n  private handleError(e: any) {\n    if (e instanceof CursorError) {\n      e = this._createError(e.msg, this._cursor.getSpan(e.cursor));\n    }\n    if (e instanceof _ControlFlowError) {\n      this.errors.push(e.error);\n    } else {\n      throw e;\n    }\n  }\n\n  private _attemptCharCode(charCode: number): boolean {\n    if (this._cursor.peek() === charCode) {\n      this._cursor.advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _attemptCharCodeCaseInsensitive(charCode: number): boolean {\n    if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {\n      this._cursor.advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _requireCharCode(charCode: number) {\n    const location = this._cursor.clone();\n    if (!this._attemptCharCode(charCode)) {\n      throw this._createError(\n          _unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n    }\n  }\n\n  private _attemptStr(chars: string): boolean {\n    const len = chars.length;\n    if (this._cursor.charsLeft() < len) {\n      return false;\n    }\n    const initialPosition = this._cursor.clone();\n    for (let i = 0; i < len; i++) {\n      if (!this._attemptCharCode(chars.charCodeAt(i))) {\n        // If attempting to parse the string fails, we want to reset the parser\n        // to where it was before the attempt\n        this._cursor = initialPosition;\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _attemptStrCaseInsensitive(chars: string): boolean {\n    for (let i = 0; i < chars.length; i++) {\n      if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _requireStr(chars: string) {\n    const location = this._cursor.clone();\n    if (!this._attemptStr(chars)) {\n      throw this._createError(\n          _unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n    }\n  }\n\n  private _attemptCharCodeUntilFn(predicate: (code: number) => boolean) {\n    while (!predicate(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n  }\n\n  private _requireCharCodeUntilFn(predicate: (code: number) => boolean, len: number) {\n    const start = this._cursor.clone();\n    this._attemptCharCodeUntilFn(predicate);\n    if (this._cursor.diff(start) < len) {\n      throw this._createError(\n          _unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n    }\n  }\n\n  private _attemptUntilChar(char: number) {\n    while (this._cursor.peek() !== char) {\n      this._cursor.advance();\n    }\n  }\n\n  private _readChar(): string {\n    // Don't rely upon reading directly from `_input` as the actual char value\n    // may have been generated from an escape sequence.\n    const char = String.fromCodePoint(this._cursor.peek());\n    this._cursor.advance();\n    return char;\n  }\n\n  private _consumeEntity(textTokenType: TokenType): void {\n    this._beginToken(TokenType.ENCODED_ENTITY);\n    const start = this._cursor.clone();\n    this._cursor.advance();\n    if (this._attemptCharCode(chars.$HASH)) {\n      const isHex = this._attemptCharCode(chars.$x) || this._attemptCharCode(chars.$X);\n      const codeStart = this._cursor.clone();\n      this._attemptCharCodeUntilFn(isDigitEntityEnd);\n      if (this._cursor.peek() != chars.$SEMICOLON) {\n        // Advance cursor to include the peeked character in the string provided to the error\n        // message.\n        this._cursor.advance();\n        const entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;\n        throw this._createError(\n            _unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)),\n            this._cursor.getSpan());\n      }\n      const strNum = this._cursor.getChars(codeStart);\n      this._cursor.advance();\n      try {\n        const charCode = parseInt(strNum, isHex ? 16 : 10);\n        this._endToken([String.fromCharCode(charCode), this._cursor.getChars(start)]);\n      } catch {\n        throw this._createError(\n            _unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());\n      }\n    } else {\n      const nameStart = this._cursor.clone();\n      this._attemptCharCodeUntilFn(isNamedEntityEnd);\n      if (this._cursor.peek() != chars.$SEMICOLON) {\n        // No semicolon was found so abort the encoded entity token that was in progress, and treat\n        // this as a text token\n        this._beginToken(textTokenType, start);\n        this._cursor = nameStart;\n        this._endToken(['&']);\n      } else {\n        const name = this._cursor.getChars(nameStart);\n        this._cursor.advance();\n        const char = NAMED_ENTITIES[name];\n        if (!char) {\n          throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));\n        }\n        this._endToken([char, `&${name};`]);\n      }\n    }\n  }\n\n  private _consumeRawText(consumeEntities: boolean, endMarkerPredicate: () => boolean): void {\n    this._beginToken(consumeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT);\n    const parts: string[] = [];\n    while (true) {\n      const tagCloseStart = this._cursor.clone();\n      const foundEndMarker = endMarkerPredicate();\n      this._cursor = tagCloseStart;\n      if (foundEndMarker) {\n        break;\n      }\n      if (consumeEntities && this._cursor.peek() === chars.$AMPERSAND) {\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n        parts.length = 0;\n        this._consumeEntity(TokenType.ESCAPABLE_RAW_TEXT);\n        this._beginToken(TokenType.ESCAPABLE_RAW_TEXT);\n      } else {\n        parts.push(this._readChar());\n      }\n    }\n    this._endToken([this._processCarriageReturns(parts.join(''))]);\n  }\n\n  private _consumeComment(start: CharacterCursor) {\n    this._beginToken(TokenType.COMMENT_START, start);\n    this._requireCharCode(chars.$MINUS);\n    this._endToken([]);\n    this._consumeRawText(false, () => this._attemptStr('-->'));\n    this._beginToken(TokenType.COMMENT_END);\n    this._requireStr('-->');\n    this._endToken([]);\n  }\n\n  private _consumeCdata(start: CharacterCursor) {\n    this._beginToken(TokenType.CDATA_START, start);\n    this._requireStr('CDATA[');\n    this._endToken([]);\n    this._consumeRawText(false, () => this._attemptStr(']]>'));\n    this._beginToken(TokenType.CDATA_END);\n    this._requireStr(']]>');\n    this._endToken([]);\n  }\n\n  private _consumeDocType(start: CharacterCursor) {\n    this._beginToken(TokenType.DOC_TYPE, start);\n    const contentStart = this._cursor.clone();\n    this._attemptUntilChar(chars.$GT);\n    const content = this._cursor.getChars(contentStart);\n    this._cursor.advance();\n    this._endToken([content]);\n  }\n\n  private _consumePrefixAndName(): string[] {\n    const nameOrPrefixStart = this._cursor.clone();\n    let prefix: string = '';\n    while (this._cursor.peek() !== chars.$COLON && !isPrefixEnd(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n    let nameStart: CharacterCursor;\n    if (this._cursor.peek() === chars.$COLON) {\n      prefix = this._cursor.getChars(nameOrPrefixStart);\n      this._cursor.advance();\n      nameStart = this._cursor.clone();\n    } else {\n      nameStart = nameOrPrefixStart;\n    }\n    this._requireCharCodeUntilFn(isNameEnd, prefix === '' ? 0 : 1);\n    const name = this._cursor.getChars(nameStart);\n    return [prefix, name];\n  }\n\n  private _consumeTagOpen(start: CharacterCursor) {\n    let tagName: string;\n    let prefix: string;\n    let openTagToken: TagOpenStartToken|IncompleteTagOpenToken|undefined;\n    try {\n      if (!chars.isAsciiLetter(this._cursor.peek())) {\n        throw this._createError(\n            _unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n      }\n\n      openTagToken = this._consumeTagOpenStart(start);\n      prefix = openTagToken.parts[0];\n      tagName = openTagToken.parts[1];\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      while (this._cursor.peek() !== chars.$SLASH && this._cursor.peek() !== chars.$GT &&\n             this._cursor.peek() !== chars.$LT && this._cursor.peek() !== chars.$EOF) {\n        this._consumeAttributeName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        if (this._attemptCharCode(chars.$EQ)) {\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n          this._consumeAttributeValue();\n        }\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      }\n      this._consumeTagOpenEnd();\n    } catch (e) {\n      if (e instanceof _ControlFlowError) {\n        if (openTagToken) {\n          // We errored before we could close the opening tag, so it is incomplete.\n          openTagToken.type = TokenType.INCOMPLETE_TAG_OPEN;\n        } else {\n          // When the start tag is invalid, assume we want a \"<\" as text.\n          // Back to back text tokens are merged at the end.\n          this._beginToken(TokenType.TEXT, start);\n          this._endToken(['<']);\n        }\n        return;\n      }\n\n      throw e;\n    }\n\n    const contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);\n\n    if (contentTokenType === TagContentType.RAW_TEXT) {\n      this._consumeRawTextWithTagClose(prefix, tagName, false);\n    } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n      this._consumeRawTextWithTagClose(prefix, tagName, true);\n    }\n  }\n\n  private _consumeRawTextWithTagClose(prefix: string, tagName: string, consumeEntities: boolean) {\n    this._consumeRawText(consumeEntities, () => {\n      if (!this._attemptCharCode(chars.$LT)) return false;\n      if (!this._attemptCharCode(chars.$SLASH)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      if (!this._attemptStrCaseInsensitive(tagName)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      return this._attemptCharCode(chars.$GT);\n    });\n    this._beginToken(TokenType.TAG_CLOSE);\n    this._requireCharCodeUntilFn(code => code === chars.$GT, 3);\n    this._cursor.advance();  // Consume the `>`\n    this._endToken([prefix, tagName]);\n  }\n\n  private _consumeTagOpenStart(start: CharacterCursor): TagOpenStartToken {\n    this._beginToken(TokenType.TAG_OPEN_START, start);\n    const parts = this._consumePrefixAndName();\n    return this._endToken(parts) as TagOpenStartToken;\n  }\n\n  private _consumeAttributeName() {\n    const attrNameStart = this._cursor.peek();\n    if (attrNameStart === chars.$SQ || attrNameStart === chars.$DQ) {\n      throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());\n    }\n    this._beginToken(TokenType.ATTR_NAME);\n    const prefixAndName = this._consumePrefixAndName();\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeAttributeValue() {\n    let value: string;\n    if (this._cursor.peek() === chars.$SQ || this._cursor.peek() === chars.$DQ) {\n      const quoteChar = this._cursor.peek();\n      this._consumeQuote(quoteChar);\n      // In an attribute then end of the attribute value and the premature end to an interpolation\n      // are both triggered by the `quoteChar`.\n      const endPredicate = () => this._cursor.peek() === quoteChar;\n      this._consumeWithInterpolation(\n          TokenType.ATTR_VALUE_TEXT, TokenType.ATTR_VALUE_INTERPOLATION, endPredicate,\n          endPredicate);\n      this._consumeQuote(quoteChar);\n    } else {\n      const endPredicate = () => isNameEnd(this._cursor.peek());\n      this._consumeWithInterpolation(\n          TokenType.ATTR_VALUE_TEXT, TokenType.ATTR_VALUE_INTERPOLATION, endPredicate,\n          endPredicate);\n    }\n  }\n\n  private _consumeQuote(quoteChar: number) {\n    this._beginToken(TokenType.ATTR_QUOTE);\n    this._requireCharCode(quoteChar);\n    this._endToken([String.fromCodePoint(quoteChar)]);\n  }\n\n  private _consumeTagOpenEnd() {\n    const tokenType =\n        this._attemptCharCode(chars.$SLASH) ? TokenType.TAG_OPEN_END_VOID : TokenType.TAG_OPEN_END;\n    this._beginToken(tokenType);\n    this._requireCharCode(chars.$GT);\n    this._endToken([]);\n  }\n\n  private _consumeTagClose(start: CharacterCursor) {\n    this._beginToken(TokenType.TAG_CLOSE, start);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    const prefixAndName = this._consumePrefixAndName();\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._requireCharCode(chars.$GT);\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeExpansionFormStart() {\n    this._beginToken(TokenType.EXPANSION_FORM_START);\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);\n\n    this._beginToken(TokenType.RAW_TEXT);\n    const condition = this._readUntil(chars.$COMMA);\n    const normalizedCondition = this._processCarriageReturns(condition);\n    if (this._i18nNormalizeLineEndingsInICUs) {\n      // We explicitly want to normalize line endings for this text.\n      this._endToken([normalizedCondition]);\n    } else {\n      // We are not normalizing line endings.\n      const conditionToken = this._endToken([condition]);\n      if (normalizedCondition !== condition) {\n        this.nonNormalizedIcuExpressions.push(conditionToken);\n      }\n    }\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.RAW_TEXT);\n    const type = this._readUntil(chars.$COMMA);\n    this._endToken([type]);\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n\n  private _consumeExpansionCaseStart() {\n    this._beginToken(TokenType.EXPANSION_CASE_VALUE);\n    const value = this._readUntil(chars.$LBRACE).trim();\n    this._endToken([value]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_START);\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);\n  }\n\n  private _consumeExpansionCaseEnd() {\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_END);\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.pop();\n  }\n\n  private _consumeExpansionFormEnd() {\n    this._beginToken(TokenType.EXPANSION_FORM_END);\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.pop();\n  }\n\n  /**\n   * Consume a string that may contain interpolation expressions.\n   *\n   * The first token consumed will be of `tokenType` and then there will be alternating\n   * `interpolationTokenType` and `tokenType` tokens until the `endPredicate()` returns true.\n   *\n   * If an interpolation token ends prematurely it will have no end marker in its `parts` array.\n   *\n   * @param textTokenType the kind of tokens to interleave around interpolation tokens.\n   * @param interpolationTokenType the kind of tokens that contain interpolation.\n   * @param endPredicate a function that should return true when we should stop consuming.\n   * @param endInterpolation a function that should return true if there is a premature end to an\n   *     interpolation expression - i.e. before we get to the normal interpolation closing marker.\n   */\n  private _consumeWithInterpolation(\n      textTokenType: TokenType, interpolationTokenType: TokenType, endPredicate: () => boolean,\n      endInterpolation: () => boolean) {\n    this._beginToken(textTokenType);\n    const parts: string[] = [];\n\n    while (!endPredicate()) {\n      const current = this._cursor.clone();\n      if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n        this._endToken([this._processCarriageReturns(parts.join(''))], current);\n        parts.length = 0;\n        this._consumeInterpolation(interpolationTokenType, current, endInterpolation);\n        this._beginToken(textTokenType);\n      } else if (this._cursor.peek() === chars.$AMPERSAND) {\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n        parts.length = 0;\n        this._consumeEntity(textTokenType);\n        this._beginToken(textTokenType);\n      } else {\n        parts.push(this._readChar());\n      }\n    }\n\n    // It is possible that an interpolation was started but not ended inside this text token.\n    // Make sure that we reset the state of the lexer correctly.\n    this._inInterpolation = false;\n\n    this._endToken([this._processCarriageReturns(parts.join(''))]);\n  }\n\n  /**\n   * Consume a block of text that has been interpreted as an Angular interpolation.\n   *\n   * @param interpolationTokenType the type of the interpolation token to generate.\n   * @param interpolationStart a cursor that points to the start of this interpolation.\n   * @param prematureEndPredicate a function that should return true if the next characters indicate\n   *     an end to the interpolation before its normal closing marker.\n   */\n  private _consumeInterpolation(\n      interpolationTokenType: TokenType, interpolationStart: CharacterCursor,\n      prematureEndPredicate: (() => boolean)|null): void {\n    const parts: string[] = [];\n    this._beginToken(interpolationTokenType, interpolationStart);\n    parts.push(this._interpolationConfig.start);\n\n    // Find the end of the interpolation, ignoring content inside quotes.\n    const expressionStart = this._cursor.clone();\n    let inQuote: number|null = null;\n    let inComment = false;\n    while (this._cursor.peek() !== chars.$EOF &&\n           (prematureEndPredicate === null || !prematureEndPredicate())) {\n      const current = this._cursor.clone();\n\n      if (this._isTagStart()) {\n        // We are starting what looks like an HTML element in the middle of this interpolation.\n        // Reset the cursor to before the `<` character and end the interpolation token.\n        // (This is actually wrong but here for backward compatibility).\n        this._cursor = current;\n        parts.push(this._getProcessedChars(expressionStart, current));\n        this._endToken(parts);\n        return;\n      }\n\n      if (inQuote === null) {\n        if (this._attemptStr(this._interpolationConfig.end)) {\n          // We are not in a string, and we hit the end interpolation marker\n          parts.push(this._getProcessedChars(expressionStart, current));\n          parts.push(this._interpolationConfig.end);\n          this._endToken(parts);\n          return;\n        } else if (this._attemptStr('//')) {\n          // Once we are in a comment we ignore any quotes\n          inComment = true;\n        }\n      }\n\n      const char = this._cursor.peek();\n      this._cursor.advance();\n      if (char === chars.$BACKSLASH) {\n        // Skip the next character because it was escaped.\n        this._cursor.advance();\n      } else if (char === inQuote) {\n        // Exiting the current quoted string\n        inQuote = null;\n      } else if (!inComment && inQuote === null && chars.isQuote(char)) {\n        // Entering a new quoted string\n        inQuote = char;\n      }\n    }\n\n    // We hit EOF without finding a closing interpolation marker\n    parts.push(this._getProcessedChars(expressionStart, this._cursor));\n    this._endToken(parts);\n  }\n\n  private _getProcessedChars(start: CharacterCursor, end: CharacterCursor): string {\n    return this._processCarriageReturns(end.getChars(start));\n  }\n\n  private _isTextEnd(): boolean {\n    if (this._isTagStart() || this._cursor.peek() === chars.$EOF) {\n      return true;\n    }\n\n    if (this._tokenizeIcu && !this._inInterpolation) {\n      if (this.isExpansionFormStart()) {\n        // start of an expansion form\n        return true;\n      }\n\n      if (this._cursor.peek() === chars.$RBRACE && this._isInExpansionCase()) {\n        // end of and expansion case\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns true if the current cursor is pointing to the start of a tag\n   * (opening/closing/comments/cdata/etc).\n   */\n  private _isTagStart(): boolean {\n    if (this._cursor.peek() === chars.$LT) {\n      // We assume that `<` followed by whitespace is not the start of an HTML element.\n      const tmp = this._cursor.clone();\n      tmp.advance();\n      // If the next character is alphabetic, ! nor / then it is a tag start\n      const code = tmp.peek();\n      if ((chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) ||\n          code === chars.$SLASH || code === chars.$BANG) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private _readUntil(char: number): string {\n    const start = this._cursor.clone();\n    this._attemptUntilChar(char);\n    return this._cursor.getChars(start);\n  }\n\n  private _isInExpansionCase(): boolean {\n    return this._expansionCaseStack.length > 0 &&\n        this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n        TokenType.EXPANSION_CASE_EXP_START;\n  }\n\n  private _isInExpansionForm(): boolean {\n    return this._expansionCaseStack.length > 0 &&\n        this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n        TokenType.EXPANSION_FORM_START;\n  }\n\n  private isExpansionFormStart(): boolean {\n    if (this._cursor.peek() !== chars.$LBRACE) {\n      return false;\n    }\n    if (this._interpolationConfig) {\n      const start = this._cursor.clone();\n      const isInterpolation = this._attemptStr(this._interpolationConfig.start);\n      this._cursor = start;\n      return !isInterpolation;\n    }\n    return true;\n  }\n}\n\nfunction isNotWhitespace(code: number): boolean {\n  return !chars.isWhitespace(code) || code === chars.$EOF;\n}\n\nfunction isNameEnd(code: number): boolean {\n  return chars.isWhitespace(code) || code === chars.$GT || code === chars.$LT ||\n      code === chars.$SLASH || code === chars.$SQ || code === chars.$DQ || code === chars.$EQ ||\n      code === chars.$EOF;\n}\n\nfunction isPrefixEnd(code: number): boolean {\n  return (code < chars.$a || chars.$z < code) && (code < chars.$A || chars.$Z < code) &&\n      (code < chars.$0 || code > chars.$9);\n}\n\nfunction isDigitEntityEnd(code: number): boolean {\n  return code === chars.$SEMICOLON || code === chars.$EOF || !chars.isAsciiHexDigit(code);\n}\n\nfunction isNamedEntityEnd(code: number): boolean {\n  return code === chars.$SEMICOLON || code === chars.$EOF || !chars.isAsciiLetter(code);\n}\n\nfunction isExpansionCaseStart(peek: number): boolean {\n  return peek !== chars.$RBRACE;\n}\n\nfunction compareCharCodeCaseInsensitive(code1: number, code2: number): boolean {\n  return toUpperCaseCharCode(code1) === toUpperCaseCharCode(code2);\n}\n\nfunction toUpperCaseCharCode(code: number): number {\n  return code >= chars.$a && code <= chars.$z ? code - chars.$a + chars.$A : code;\n}\n\nfunction mergeTextTokens(srcTokens: Token[]): Token[] {\n  const dstTokens: Token[] = [];\n  let lastDstToken: Token|undefined = undefined;\n  for (let i = 0; i < srcTokens.length; i++) {\n    const token = srcTokens[i];\n    if ((lastDstToken && lastDstToken.type === TokenType.TEXT && token.type === TokenType.TEXT) ||\n        (lastDstToken && lastDstToken.type === TokenType.ATTR_VALUE_TEXT &&\n         token.type === TokenType.ATTR_VALUE_TEXT)) {\n      lastDstToken.parts[0]! += token.parts[0];\n      lastDstToken.sourceSpan.end = token.sourceSpan.end;\n    } else {\n      lastDstToken = token;\n      dstTokens.push(lastDstToken);\n    }\n  }\n\n  return dstTokens;\n}\n\n\n/**\n * The _Tokenizer uses objects of this type to move through the input text,\n * extracting \"parsed characters\". These could be more than one actual character\n * if the text contains escape sequences.\n */\ninterface CharacterCursor {\n  /** Initialize the cursor. */\n  init(): void;\n  /** The parsed character at the current cursor position. */\n  peek(): number;\n  /** Advance the cursor by one parsed character. */\n  advance(): void;\n  /** Get a span from the marked start point to the current point. */\n  getSpan(start?: this, leadingTriviaCodePoints?: number[]): ParseSourceSpan;\n  /** Get the parsed characters from the marked start point to the current point. */\n  getChars(start: this): string;\n  /** The number of characters left before the end of the cursor. */\n  charsLeft(): number;\n  /** The number of characters between `this` cursor and `other` cursor. */\n  diff(other: this): number;\n  /** Make a copy of this cursor */\n  clone(): CharacterCursor;\n}\n\ninterface CursorState {\n  peek: number;\n  offset: number;\n  line: number;\n  column: number;\n}\n\nclass PlainCharacterCursor implements CharacterCursor {\n  protected state: CursorState;\n  protected file: ParseSourceFile;\n  protected input: string;\n  protected end: number;\n\n  constructor(fileOrCursor: PlainCharacterCursor);\n  constructor(fileOrCursor: ParseSourceFile, range: LexerRange);\n  constructor(fileOrCursor: ParseSourceFile|PlainCharacterCursor, range?: LexerRange) {\n    if (fileOrCursor instanceof PlainCharacterCursor) {\n      this.file = fileOrCursor.file;\n      this.input = fileOrCursor.input;\n      this.end = fileOrCursor.end;\n\n      const state = fileOrCursor.state;\n      // Note: avoid using `{...fileOrCursor.state}` here as that has a severe performance penalty.\n      // In ES5 bundles the object spread operator is translated into the `__assign` helper, which\n      // is not optimized by VMs as efficiently as a raw object literal. Since this constructor is\n      // called in tight loops, this difference matters.\n      this.state = {\n        peek: state.peek,\n        offset: state.offset,\n        line: state.line,\n        column: state.column,\n      };\n    } else {\n      if (!range) {\n        throw new Error(\n            'Programming error: the range argument must be provided with a file argument.');\n      }\n      this.file = fileOrCursor;\n      this.input = fileOrCursor.content;\n      this.end = range.endPos;\n      this.state = {\n        peek: -1,\n        offset: range.startPos,\n        line: range.startLine,\n        column: range.startCol,\n      };\n    }\n  }\n\n  clone(): PlainCharacterCursor {\n    return new PlainCharacterCursor(this);\n  }\n\n  peek() {\n    return this.state.peek;\n  }\n  charsLeft() {\n    return this.end - this.state.offset;\n  }\n  diff(other: this) {\n    return this.state.offset - other.state.offset;\n  }\n\n  advance(): void {\n    this.advanceState(this.state);\n  }\n\n  init(): void {\n    this.updatePeek(this.state);\n  }\n\n  getSpan(start?: this, leadingTriviaCodePoints?: number[]): ParseSourceSpan {\n    start = start || this;\n    let fullStart = start;\n    if (leadingTriviaCodePoints) {\n      while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {\n        if (fullStart === start) {\n          start = start.clone() as this;\n        }\n        start.advance();\n      }\n    }\n    const startLocation = this.locationFromCursor(start);\n    const endLocation = this.locationFromCursor(this);\n    const fullStartLocation =\n        fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;\n    return new ParseSourceSpan(startLocation, endLocation, fullStartLocation);\n  }\n\n  getChars(start: this): string {\n    return this.input.substring(start.state.offset, this.state.offset);\n  }\n\n  charAt(pos: number): number {\n    return this.input.charCodeAt(pos);\n  }\n\n  protected advanceState(state: CursorState) {\n    if (state.offset >= this.end) {\n      this.state = state;\n      throw new CursorError('Unexpected character \"EOF\"', this);\n    }\n    const currentChar = this.charAt(state.offset);\n    if (currentChar === chars.$LF) {\n      state.line++;\n      state.column = 0;\n    } else if (!chars.isNewLine(currentChar)) {\n      state.column++;\n    }\n    state.offset++;\n    this.updatePeek(state);\n  }\n\n  protected updatePeek(state: CursorState): void {\n    state.peek = state.offset >= this.end ? chars.$EOF : this.charAt(state.offset);\n  }\n\n  private locationFromCursor(cursor: this): ParseLocation {\n    return new ParseLocation(\n        cursor.file, cursor.state.offset, cursor.state.line, cursor.state.column);\n  }\n}\n\nclass EscapedCharacterCursor extends PlainCharacterCursor {\n  protected internalState: CursorState;\n\n  constructor(fileOrCursor: EscapedCharacterCursor);\n  constructor(fileOrCursor: ParseSourceFile, range: LexerRange);\n  constructor(fileOrCursor: ParseSourceFile|EscapedCharacterCursor, range?: LexerRange) {\n    if (fileOrCursor instanceof EscapedCharacterCursor) {\n      super(fileOrCursor);\n      this.internalState = {...fileOrCursor.internalState};\n    } else {\n      super(fileOrCursor, range!);\n      this.internalState = this.state;\n    }\n  }\n\n  override advance(): void {\n    this.state = this.internalState;\n    super.advance();\n    this.processEscapeSequence();\n  }\n\n  override init(): void {\n    super.init();\n    this.processEscapeSequence();\n  }\n\n  override clone(): EscapedCharacterCursor {\n    return new EscapedCharacterCursor(this);\n  }\n\n  override getChars(start: this): string {\n    const cursor = start.clone();\n    let chars = '';\n    while (cursor.internalState.offset < this.internalState.offset) {\n      chars += String.fromCodePoint(cursor.peek());\n      cursor.advance();\n    }\n    return chars;\n  }\n\n  /**\n   * Process the escape sequence that starts at the current position in the text.\n   *\n   * This method is called to ensure that `peek` has the unescaped value of escape sequences.\n   */\n  protected processEscapeSequence(): void {\n    const peek = () => this.internalState.peek;\n\n    if (peek() === chars.$BACKSLASH) {\n      // We have hit an escape sequence so we need the internal state to become independent\n      // of the external state.\n      this.internalState = {...this.state};\n\n      // Move past the backslash\n      this.advanceState(this.internalState);\n\n      // First check for standard control char sequences\n      if (peek() === chars.$n) {\n        this.state.peek = chars.$LF;\n      } else if (peek() === chars.$r) {\n        this.state.peek = chars.$CR;\n      } else if (peek() === chars.$v) {\n        this.state.peek = chars.$VTAB;\n      } else if (peek() === chars.$t) {\n        this.state.peek = chars.$TAB;\n      } else if (peek() === chars.$b) {\n        this.state.peek = chars.$BSPACE;\n      } else if (peek() === chars.$f) {\n        this.state.peek = chars.$FF;\n      }\n\n      // Now consider more complex sequences\n      else if (peek() === chars.$u) {\n        // Unicode code-point sequence\n        this.advanceState(this.internalState);  // advance past the `u` char\n        if (peek() === chars.$LBRACE) {\n          // Variable length Unicode, e.g. `\\x{123}`\n          this.advanceState(this.internalState);  // advance past the `{` char\n          // Advance past the variable number of hex digits until we hit a `}` char\n          const digitStart = this.clone();\n          let length = 0;\n          while (peek() !== chars.$RBRACE) {\n            this.advanceState(this.internalState);\n            length++;\n          }\n          this.state.peek = this.decodeHexDigits(digitStart, length);\n        } else {\n          // Fixed length Unicode, e.g. `\\u1234`\n          const digitStart = this.clone();\n          this.advanceState(this.internalState);\n          this.advanceState(this.internalState);\n          this.advanceState(this.internalState);\n          this.state.peek = this.decodeHexDigits(digitStart, 4);\n        }\n      }\n\n      else if (peek() === chars.$x) {\n        // Hex char code, e.g. `\\x2F`\n        this.advanceState(this.internalState);  // advance past the `x` char\n        const digitStart = this.clone();\n        this.advanceState(this.internalState);\n        this.state.peek = this.decodeHexDigits(digitStart, 2);\n      }\n\n      else if (chars.isOctalDigit(peek())) {\n        // Octal char code, e.g. `\\012`,\n        let octal = '';\n        let length = 0;\n        let previous = this.clone();\n        while (chars.isOctalDigit(peek()) && length < 3) {\n          previous = this.clone();\n          octal += String.fromCodePoint(peek());\n          this.advanceState(this.internalState);\n          length++;\n        }\n        this.state.peek = parseInt(octal, 8);\n        // Backup one char\n        this.internalState = previous.internalState;\n      }\n\n      else if (chars.isNewLine(this.internalState.peek)) {\n        // Line continuation `\\` followed by a new line\n        this.advanceState(this.internalState);  // advance over the newline\n        this.state = this.internalState;\n      }\n\n      else {\n        // If none of the `if` blocks were executed then we just have an escaped normal character.\n        // In that case we just, effectively, skip the backslash from the character.\n        this.state.peek = this.internalState.peek;\n      }\n    }\n  }\n\n  protected decodeHexDigits(start: EscapedCharacterCursor, length: number): number {\n    const hex = this.input.slice(start.internalState.offset, start.internalState.offset + length);\n    const charCode = parseInt(hex, 16);\n    if (!isNaN(charCode)) {\n      return charCode;\n    } else {\n      start.state = start.internalState;\n      throw new CursorError('Invalid hexadecimal escape sequence', start);\n    }\n  }\n}\n\nexport class CursorError {\n  constructor(public msg: string, public cursor: CharacterCursor) {}\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseError, ParseLocation, ParseSourceSpan} from '../parse_util';\n\nimport * as html from './ast';\nimport {NAMED_ENTITIES} from './entities';\nimport {tokenize, TokenizeOptions} from './lexer';\nimport {getNsPrefix, mergeNsAndName, splitNsName, TagDefinition} from './tags';\nimport {AttributeNameToken, AttributeQuoteToken, CdataStartToken, CommentStartToken, ExpansionCaseExpressionEndToken, ExpansionCaseExpressionStartToken, ExpansionCaseValueToken, ExpansionFormStartToken, IncompleteTagOpenToken, InterpolatedAttributeToken, InterpolatedTextToken, TagCloseToken, TagOpenStartToken, TextToken, Token, TokenType} from './tokens';\n\nexport class TreeError extends ParseError {\n  static create(elementName: string|null, span: ParseSourceSpan, msg: string): TreeError {\n    return new TreeError(elementName, span, msg);\n  }\n\n  constructor(public elementName: string|null, span: ParseSourceSpan, msg: string) {\n    super(span, msg);\n  }\n}\n\nexport class ParseTreeResult {\n  constructor(public rootNodes: html.Node[], public errors: ParseError[]) {}\n}\n\nexport class Parser {\n  constructor(public getTagDefinition: (tagName: string) => TagDefinition) {}\n\n  parse(source: string, url: string, options?: TokenizeOptions): ParseTreeResult {\n    const tokenizeResult = tokenize(source, url, this.getTagDefinition, options);\n    const parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);\n    parser.build();\n    return new ParseTreeResult(\n        parser.rootNodes,\n        (tokenizeResult.errors as ParseError[]).concat(parser.errors),\n    );\n  }\n}\n\nclass _TreeBuilder {\n  private _index: number = -1;\n  // `_peek` will be initialized by the call to `_advance()` in the constructor.\n  private _peek!: Token;\n  private _elementStack: html.Element[] = [];\n\n  rootNodes: html.Node[] = [];\n  errors: TreeError[] = [];\n\n  constructor(\n      private tokens: Token[], private getTagDefinition: (tagName: string) => TagDefinition) {\n    this._advance();\n  }\n\n  build(): void {\n    while (this._peek.type !== TokenType.EOF) {\n      if (this._peek.type === TokenType.TAG_OPEN_START ||\n          this._peek.type === TokenType.INCOMPLETE_TAG_OPEN) {\n        this._consumeStartTag(this._advance<TagOpenStartToken|IncompleteTagOpenToken>());\n      } else if (this._peek.type === TokenType.TAG_CLOSE) {\n        this._consumeEndTag(this._advance<TagCloseToken>());\n      } else if (this._peek.type === TokenType.CDATA_START) {\n        this._closeVoidElement();\n        this._consumeCdata(this._advance<CdataStartToken>());\n      } else if (this._peek.type === TokenType.COMMENT_START) {\n        this._closeVoidElement();\n        this._consumeComment(this._advance<CommentStartToken>());\n      } else if (\n          this._peek.type === TokenType.TEXT || this._peek.type === TokenType.RAW_TEXT ||\n          this._peek.type === TokenType.ESCAPABLE_RAW_TEXT) {\n        this._closeVoidElement();\n        this._consumeText(this._advance<TextToken>());\n      } else if (this._peek.type === TokenType.EXPANSION_FORM_START) {\n        this._consumeExpansion(this._advance<ExpansionFormStartToken>());\n      } else {\n        // Skip all other tokens...\n        this._advance();\n      }\n    }\n  }\n\n  private _advance<T extends Token>(): T {\n    const prev = this._peek;\n    if (this._index < this.tokens.length - 1) {\n      // Note: there is always an EOF token at the end\n      this._index++;\n    }\n    this._peek = this.tokens[this._index];\n    return prev as T;\n  }\n\n  private _advanceIf<T extends TokenType>(type: T): (Token&{type: T})|null {\n    if (this._peek.type === type) {\n      return this._advance<Token&{type: T}>();\n    }\n    return null;\n  }\n\n  private _consumeCdata(_startToken: CdataStartToken) {\n    this._consumeText(this._advance<TextToken>());\n    this._advanceIf(TokenType.CDATA_END);\n  }\n\n  private _consumeComment(token: CommentStartToken) {\n    const text = this._advanceIf(TokenType.RAW_TEXT);\n    this._advanceIf(TokenType.COMMENT_END);\n    const value = text != null ? text.parts[0].trim() : null;\n    this._addToParent(new html.Comment(value, token.sourceSpan));\n  }\n\n  private _consumeExpansion(token: ExpansionFormStartToken) {\n    const switchValue = this._advance<TextToken>();\n\n    const type = this._advance<TextToken>();\n    const cases: html.ExpansionCase[] = [];\n\n    // read =\n    while (this._peek.type === TokenType.EXPANSION_CASE_VALUE) {\n      const expCase = this._parseExpansionCase();\n      if (!expCase) return;  // error\n      cases.push(expCase);\n    }\n\n    // read the final }\n    if (this._peek.type !== TokenType.EXPANSION_FORM_END) {\n      this.errors.push(\n          TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));\n      return;\n    }\n    const sourceSpan = new ParseSourceSpan(\n        token.sourceSpan.start, this._peek.sourceSpan.end, token.sourceSpan.fullStart);\n    this._addToParent(new html.Expansion(\n        switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));\n\n    this._advance();\n  }\n\n  private _parseExpansionCase(): html.ExpansionCase|null {\n    const value = this._advance<ExpansionCaseValueToken>();\n\n    // read {\n    if (this._peek.type !== TokenType.EXPANSION_CASE_EXP_START) {\n      this.errors.push(\n          TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));\n      return null;\n    }\n\n    // read until }\n    const start = this._advance<ExpansionCaseExpressionStartToken>();\n\n    const exp = this._collectExpansionExpTokens(start);\n    if (!exp) return null;\n\n    const end = this._advance<ExpansionCaseExpressionEndToken>();\n    exp.push({type: TokenType.EOF, parts: [], sourceSpan: end.sourceSpan});\n\n    // parse everything in between { and }\n    const expansionCaseParser = new _TreeBuilder(exp, this.getTagDefinition);\n    expansionCaseParser.build();\n    if (expansionCaseParser.errors.length > 0) {\n      this.errors = this.errors.concat(expansionCaseParser.errors);\n      return null;\n    }\n\n    const sourceSpan =\n        new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end, value.sourceSpan.fullStart);\n    const expSourceSpan =\n        new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end, start.sourceSpan.fullStart);\n    return new html.ExpansionCase(\n        value.parts[0], expansionCaseParser.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n  }\n\n  private _collectExpansionExpTokens(start: Token): Token[]|null {\n    const exp: Token[] = [];\n    const expansionFormStack = [TokenType.EXPANSION_CASE_EXP_START];\n\n    while (true) {\n      if (this._peek.type === TokenType.EXPANSION_FORM_START ||\n          this._peek.type === TokenType.EXPANSION_CASE_EXP_START) {\n        expansionFormStack.push(this._peek.type);\n      }\n\n      if (this._peek.type === TokenType.EXPANSION_CASE_EXP_END) {\n        if (lastOnStack(expansionFormStack, TokenType.EXPANSION_CASE_EXP_START)) {\n          expansionFormStack.pop();\n          if (expansionFormStack.length === 0) return exp;\n\n        } else {\n          this.errors.push(\n              TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n          return null;\n        }\n      }\n\n      if (this._peek.type === TokenType.EXPANSION_FORM_END) {\n        if (lastOnStack(expansionFormStack, TokenType.EXPANSION_FORM_START)) {\n          expansionFormStack.pop();\n        } else {\n          this.errors.push(\n              TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n          return null;\n        }\n      }\n\n      if (this._peek.type === TokenType.EOF) {\n        this.errors.push(\n            TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n        return null;\n      }\n\n      exp.push(this._advance());\n    }\n  }\n\n  private _consumeText(token: InterpolatedTextToken) {\n    const tokens = [token];\n    const startSpan = token.sourceSpan;\n    let text = token.parts[0];\n    if (text.length > 0 && text[0] === '\\n') {\n      const parent = this._getParentElement();\n      if (parent != null && parent.children.length === 0 &&\n          this.getTagDefinition(parent.name).ignoreFirstLf) {\n        text = text.substring(1);\n        tokens[0] = {type: token.type, sourceSpan: token.sourceSpan, parts: [text]} as typeof token;\n      }\n    }\n\n    while (this._peek.type === TokenType.INTERPOLATION || this._peek.type === TokenType.TEXT ||\n           this._peek.type === TokenType.ENCODED_ENTITY) {\n      token = this._advance();\n      tokens.push(token);\n      if (token.type === TokenType.INTERPOLATION) {\n        // For backward compatibility we decode HTML entities that appear in interpolation\n        // expressions. This is arguably a bug, but it could be a considerable breaking change to\n        // fix it. It should be addressed in a larger project to refactor the entire parser/lexer\n        // chain after View Engine has been removed.\n        text += token.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n      } else if (token.type === TokenType.ENCODED_ENTITY) {\n        text += token.parts[0];\n      } else {\n        text += token.parts.join('');\n      }\n    }\n\n    if (text.length > 0) {\n      const endSpan = token.sourceSpan;\n      this._addToParent(new html.Text(\n          text,\n          new ParseSourceSpan(startSpan.start, endSpan.end, startSpan.fullStart, startSpan.details),\n          tokens));\n    }\n  }\n\n  private _closeVoidElement(): void {\n    const el = this._getParentElement();\n    if (el && this.getTagDefinition(el.name).isVoid) {\n      this._elementStack.pop();\n    }\n  }\n\n  private _consumeStartTag(startTagToken: TagOpenStartToken|IncompleteTagOpenToken) {\n    const [prefix, name] = startTagToken.parts;\n    const attrs: html.Attribute[] = [];\n    while (this._peek.type === TokenType.ATTR_NAME) {\n      attrs.push(this._consumeAttr(this._advance<AttributeNameToken>()));\n    }\n    const fullName = this._getElementFullName(prefix, name, this._getParentElement());\n    let selfClosing = false;\n    // Note: There could have been a tokenizer error\n    // so that we don't get a token for the end tag...\n    if (this._peek.type === TokenType.TAG_OPEN_END_VOID) {\n      this._advance();\n      selfClosing = true;\n      const tagDef = this.getTagDefinition(fullName);\n      if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {\n        this.errors.push(TreeError.create(\n            fullName, startTagToken.sourceSpan,\n            `Only void and foreign elements can be self closed \"${startTagToken.parts[1]}\"`));\n      }\n    } else if (this._peek.type === TokenType.TAG_OPEN_END) {\n      this._advance();\n      selfClosing = false;\n    }\n    const end = this._peek.sourceSpan.fullStart;\n    const span = new ParseSourceSpan(\n        startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);\n    // Create a separate `startSpan` because `span` will be modified when there is an `end` span.\n    const startSpan = new ParseSourceSpan(\n        startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);\n    const el = new html.Element(fullName, attrs, [], span, startSpan, undefined);\n    this._pushElement(el);\n    if (selfClosing) {\n      // Elements that are self-closed have their `endSourceSpan` set to the full span, as the\n      // element start tag also represents the end tag.\n      this._popElement(fullName, span);\n    } else if (startTagToken.type === TokenType.INCOMPLETE_TAG_OPEN) {\n      // We already know the opening tag is not complete, so it is unlikely it has a corresponding\n      // close tag. Let's optimistically parse it as a full element and emit an error.\n      this._popElement(fullName, null);\n      this.errors.push(\n          TreeError.create(fullName, span, `Opening tag \"${fullName}\" not terminated.`));\n    }\n  }\n\n  private _pushElement(el: html.Element) {\n    const parentEl = this._getParentElement();\n\n    if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {\n      this._elementStack.pop();\n    }\n\n    this._addToParent(el);\n    this._elementStack.push(el);\n  }\n\n  private _consumeEndTag(endTagToken: TagCloseToken) {\n    const fullName = this._getElementFullName(\n        endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\n\n    if (this.getTagDefinition(fullName).isVoid) {\n      this.errors.push(TreeError.create(\n          fullName, endTagToken.sourceSpan,\n          `Void elements do not have end tags \"${endTagToken.parts[1]}\"`));\n    } else if (!this._popElement(fullName, endTagToken.sourceSpan)) {\n      const errMsg = `Unexpected closing tag \"${\n          fullName}\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;\n      this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n    }\n  }\n\n  /**\n   * Closes the nearest element with the tag name `fullName` in the parse tree.\n   * `endSourceSpan` is the span of the closing tag, or null if the element does\n   * not have a closing tag (for example, this happens when an incomplete\n   * opening tag is recovered).\n   */\n  private _popElement(fullName: string, endSourceSpan: ParseSourceSpan|null): boolean {\n    let unexpectedCloseTagDetected = false;\n    for (let stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n      const el = this._elementStack[stackIndex];\n      if (el.name === fullName) {\n        // Record the parse span with the element that is being closed. Any elements that are\n        // removed from the element stack at this point are closed implicitly, so they won't get\n        // an end source span (as there is no explicit closing element).\n        el.endSourceSpan = endSourceSpan;\n        el.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : el.sourceSpan.end;\n\n        this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n        return !unexpectedCloseTagDetected;\n      }\n\n      if (!this.getTagDefinition(el.name).closedByParent) {\n        // Note that we encountered an unexpected close tag but continue processing the element\n        // stack so we can assign an `endSourceSpan` if there is a corresponding start tag for this\n        // end tag in the stack.\n        unexpectedCloseTagDetected = true;\n      }\n    }\n    return false;\n  }\n\n  private _consumeAttr(attrName: AttributeNameToken): html.Attribute {\n    const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n    let attrEnd = attrName.sourceSpan.end;\n\n    // Consume any quote\n    if (this._peek.type === TokenType.ATTR_QUOTE) {\n      this._advance();\n    }\n\n    // Consume the attribute value\n    let value = '';\n    const valueTokens: InterpolatedAttributeToken[] = [];\n    let valueStartSpan: ParseSourceSpan|undefined = undefined;\n    let valueEnd: ParseLocation|undefined = undefined;\n    // NOTE: We need to use a new variable `nextTokenType` here to hide the actual type of\n    // `_peek.type` from TS. Otherwise TS will narrow the type of `_peek.type` preventing it from\n    // being able to consider `ATTR_VALUE_INTERPOLATION` as an option. This is because TS is not\n    // able to see that `_advance()` will actually mutate `_peek`.\n    const nextTokenType = this._peek.type as TokenType;\n    if (nextTokenType === TokenType.ATTR_VALUE_TEXT) {\n      valueStartSpan = this._peek.sourceSpan;\n      valueEnd = this._peek.sourceSpan.end;\n      while (this._peek.type === TokenType.ATTR_VALUE_TEXT ||\n             this._peek.type === TokenType.ATTR_VALUE_INTERPOLATION ||\n             this._peek.type === TokenType.ENCODED_ENTITY) {\n        const valueToken = this._advance<InterpolatedAttributeToken>();\n        valueTokens.push(valueToken);\n        if (valueToken.type === TokenType.ATTR_VALUE_INTERPOLATION) {\n          // For backward compatibility we decode HTML entities that appear in interpolation\n          // expressions. This is arguably a bug, but it could be a considerable breaking change to\n          // fix it. It should be addressed in a larger project to refactor the entire parser/lexer\n          // chain after View Engine has been removed.\n          value += valueToken.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n        } else if (valueToken.type === TokenType.ENCODED_ENTITY) {\n          value += valueToken.parts[0];\n        } else {\n          value += valueToken.parts.join('');\n        }\n        valueEnd = attrEnd = valueToken.sourceSpan.end;\n      }\n    }\n\n    // Consume any quote\n    if (this._peek.type === TokenType.ATTR_QUOTE) {\n      const quoteToken = this._advance<AttributeQuoteToken>();\n      attrEnd = quoteToken.sourceSpan.end;\n    }\n\n    const valueSpan = valueStartSpan && valueEnd &&\n        new ParseSourceSpan(valueStartSpan.start, valueEnd, valueStartSpan.fullStart);\n    return new html.Attribute(\n        fullName, value,\n        new ParseSourceSpan(attrName.sourceSpan.start, attrEnd, attrName.sourceSpan.fullStart),\n        attrName.sourceSpan, valueSpan, valueTokens.length > 0 ? valueTokens : undefined,\n        undefined);\n  }\n\n  private _getParentElement(): html.Element|null {\n    return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\n  }\n\n  private _addToParent(node: html.Node) {\n    const parent = this._getParentElement();\n    if (parent != null) {\n      parent.children.push(node);\n    } else {\n      this.rootNodes.push(node);\n    }\n  }\n\n  private _getElementFullName(prefix: string, localName: string, parentElement: html.Element|null):\n      string {\n    if (prefix === '') {\n      prefix = this.getTagDefinition(localName).implicitNamespacePrefix || '';\n      if (prefix === '' && parentElement != null) {\n        const parentTagName = splitNsName(parentElement.name)[1];\n        const parentTagDefinition = this.getTagDefinition(parentTagName);\n        if (!parentTagDefinition.preventNamespaceInheritance) {\n          prefix = getNsPrefix(parentElement.name);\n        }\n      }\n    }\n\n    return mergeNsAndName(prefix, localName);\n  }\n}\n\nfunction lastOnStack(stack: any[], element: any): boolean {\n  return stack.length > 0 && stack[stack.length - 1] === element;\n}\n\n/**\n * Decode the `entity` string, which we believe is the contents of an HTML entity.\n *\n * If the string is not actually a valid/known entity then just return the original `match` string.\n */\nfunction decodeEntity(match: string, entity: string): string {\n  if (NAMED_ENTITIES[entity] !== undefined) {\n    return NAMED_ENTITIES[entity] || match;\n  }\n  if (/^#x[a-f0-9]+$/i.test(entity)) {\n    return String.fromCodePoint(parseInt(entity.slice(2), 16));\n  }\n  if (/^#\\d+$/.test(entity)) {\n    return String.fromCodePoint(parseInt(entity.slice(1), 10));\n  }\n  return match;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getHtmlTagDefinition} from './html_tags';\nimport {TokenizeOptions} from './lexer';\nimport {Parser, ParseTreeResult} from './parser';\n\nexport class HtmlParser extends Parser {\n  constructor() {\n    super(getHtmlTagDefinition);\n  }\n\n  override parse(source: string, url: string, options?: TokenizeOptions): ParseTreeResult {\n    return super.parse(source, url, options);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as html from './ast';\nimport {NGSP_UNICODE} from './entities';\nimport {ParseTreeResult} from './parser';\nimport {TextToken, TokenType} from './tokens';\n\nexport const PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';\n\nconst SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']);\n\n// Equivalent to \\s with \\u00a0 (non-breaking space) excluded.\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\nconst WS_CHARS = ' \\f\\n\\r\\t\\v\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff';\nconst NO_WS_REGEXP = new RegExp(`[^${WS_CHARS}]`);\nconst WS_REPLACE_REGEXP = new RegExp(`[${WS_CHARS}]{2,}`, 'g');\n\nfunction hasPreserveWhitespacesAttr(attrs: html.Attribute[]): boolean {\n  return attrs.some((attr: html.Attribute) => attr.name === PRESERVE_WS_ATTR_NAME);\n}\n\n/**\n * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\n * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\n * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\n * and later on replaced by a space. We are re-implementing the same idea here.\n */\nexport function replaceNgsp(value: string): string {\n  // lexer is replacing the &ngsp; pseudo-entity with NGSP_UNICODE\n  return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');\n}\n\n/**\n * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:\n * - consider spaces, tabs and new lines as whitespace characters;\n * - drop text nodes consisting of whitespace characters only;\n * - for all other text nodes replace consecutive whitespace characters with one space;\n * - convert &ngsp; pseudo-entity to a single space;\n *\n * Removal and trimming of whitespaces have positive performance impact (less code to generate\n * while compiling templates, faster view creation). At the same time it can be \"destructive\"\n * in some cases (whitespaces can influence layout). Because of the potential of breaking layout\n * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for\n * whitespace removal. The default option for whitespace removal will be revisited in Angular 6\n * and might be changed to \"on\" by default.\n */\nexport class WhitespaceVisitor implements html.Visitor {\n  visitElement(element: html.Element, context: any): any {\n    if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {\n      // don't descent into elements where we need to preserve whitespaces\n      // but still visit all attributes to eliminate one used as a market to preserve WS\n      return new html.Element(\n          element.name, html.visitAll(this, element.attrs), element.children, element.sourceSpan,\n          element.startSourceSpan, element.endSourceSpan, element.i18n);\n    }\n\n    return new html.Element(\n        element.name, element.attrs, visitAllWithSiblings(this, element.children),\n        element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): any {\n    return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;\n  }\n\n  visitText(text: html.Text, context: SiblingVisitorContext|null): any {\n    const isNotBlank = text.value.match(NO_WS_REGEXP);\n    const hasExpansionSibling = context &&\n        (context.prev instanceof html.Expansion || context.next instanceof html.Expansion);\n\n    if (isNotBlank || hasExpansionSibling) {\n      // Process the whitespace in the tokens of this Text node\n      const tokens = text.tokens.map(\n          token =>\n              token.type === TokenType.TEXT ? createWhitespaceProcessedTextToken(token) : token);\n      // Process the whitespace of the value of this Text node\n      const value = processWhitespace(text.value);\n      return new html.Text(value, text.sourceSpan, tokens, text.i18n);\n    }\n\n    return null;\n  }\n\n  visitComment(comment: html.Comment, context: any): any {\n    return comment;\n  }\n\n  visitExpansion(expansion: html.Expansion, context: any): any {\n    return expansion;\n  }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase, context: any): any {\n    return expansionCase;\n  }\n}\n\nfunction createWhitespaceProcessedTextToken({type, parts, sourceSpan}: TextToken): TextToken {\n  return {type, parts: [processWhitespace(parts[0])], sourceSpan};\n}\n\nfunction processWhitespace(text: string): string {\n  return replaceNgsp(text).replace(WS_REPLACE_REGEXP, ' ');\n}\n\nexport function removeWhitespaces(htmlAstWithErrors: ParseTreeResult): ParseTreeResult {\n  return new ParseTreeResult(\n      html.visitAll(new WhitespaceVisitor(), htmlAstWithErrors.rootNodes),\n      htmlAstWithErrors.errors);\n}\n\ninterface SiblingVisitorContext {\n  prev: html.Node|undefined;\n  next: html.Node|undefined;\n}\n\nfunction visitAllWithSiblings(visitor: WhitespaceVisitor, nodes: html.Node[]): any[] {\n  const result: any[] = [];\n\n  nodes.forEach((ast, i) => {\n    const context: SiblingVisitorContext = {prev: nodes[i - 1], next: nodes[i + 1]};\n    const astResult = ast.visit(visitor, context);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from './output_ast';\n\nexport type MapEntry = {\n  key: string,\n  quoted: boolean,\n  value: o.Expression\n};\n\nexport type MapLiteral = MapEntry[];\n\nexport function mapEntry(key: string, value: o.Expression): MapEntry {\n  return {key, value, quoted: false};\n}\n\nexport function mapLiteral(\n    obj: {[key: string]: o.Expression}, quoted: boolean = false): o.Expression {\n  return o.literalMap(Object.keys(obj).map(key => ({\n                                             key,\n                                             quoted,\n                                             value: obj[key],\n                                           })));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SchemaMetadata, SecurityContext} from '../core';\n\nexport abstract class ElementSchemaRegistry {\n  abstract hasProperty(tagName: string, propName: string, schemaMetas: SchemaMetadata[]): boolean;\n  abstract hasElement(tagName: string, schemaMetas: SchemaMetadata[]): boolean;\n  abstract securityContext(elementName: string, propName: string, isAttribute: boolean):\n      SecurityContext;\n  abstract allKnownElementNames(): string[];\n  abstract getMappedPropName(propName: string): string;\n  abstract getDefaultComponentElementName(): string;\n  abstract validateProperty(name: string): {error: boolean, msg?: string};\n  abstract validateAttribute(name: string): {error: boolean, msg?: string};\n  abstract normalizeAnimationStyleProperty(propName: string): string;\n  abstract normalizeAnimationStyleValue(\n      camelCaseProp: string, userProvidedProp: string,\n      val: string|number): {error: string, value: string};\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, SchemaMetadata, SecurityContext} from '../core';\nimport {isNgContainer, isNgContent} from '../ml_parser/tags';\nimport {dashCaseToCamelCase} from '../util';\n\nimport {SECURITY_SCHEMA} from './dom_security_schema';\nimport {ElementSchemaRegistry} from './element_schema_registry';\n\nconst BOOLEAN = 'boolean';\nconst NUMBER = 'number';\nconst STRING = 'string';\nconst OBJECT = 'object';\n\n/**\n * This array represents the DOM schema. It encodes inheritance, properties, and events.\n *\n * ## Overview\n *\n * Each line represents one kind of element. The `element_inheritance` and properties are joined\n * using `element_inheritance|properties` syntax.\n *\n * ## Element Inheritance\n *\n * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.\n * Here the individual elements are separated by `,` (commas). Every element in the list\n * has identical properties.\n *\n * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is\n * specified then `\"\"` (blank) element is assumed.\n *\n * NOTE: The blank element inherits from root `[Element]` element, the super element of all\n * elements.\n *\n * NOTE an element prefix such as `:svg:` has no special meaning to the schema.\n *\n * ## Properties\n *\n * Each element has a set of properties separated by `,` (commas). Each property can be prefixed\n * by a special character designating its type:\n *\n * - (no prefix): property is a string.\n * - `*`: property represents an event.\n * - `!`: property is a boolean.\n * - `#`: property is a number.\n * - `%`: property is an object.\n *\n * ## Query\n *\n * The class creates an internal squas representation which allows to easily answer the query of\n * if a given property exist on a given element.\n *\n * NOTE: We don't yet support querying for types or events.\n * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,\n *       see dom_element_schema_registry_spec.ts\n */\n\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!\n//\n// Newly added properties must be security reviewed and assigned an appropriate SecurityContext in\n// dom_security_schema.ts. Reach out to mprobst & rjamet for details.\n//\n// =================================================================================================\n\nconst SCHEMA: string[] = [\n  '[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot' +\n      /* added manually to avoid breaking changes */\n      ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored',\n  '[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy',\n  'abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy',\n  'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume',\n  ':svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex',\n  ':svg:graphics^:svg:|',\n  ':svg:animation^:svg:|*begin,*end,*repeat',\n  ':svg:geometry^:svg:|',\n  ':svg:componentTransferFunction^:svg:|',\n  ':svg:gradient^:svg:|',\n  ':svg:textContent^:svg:graphics|',\n  ':svg:textPositioning^:svg:textContent|',\n  'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username',\n  'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username',\n  'audio^media|',\n  'br^[HTMLElement]|clear',\n  'base^[HTMLElement]|href,target',\n  'body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',\n  'button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',\n  'canvas^[HTMLElement]|#height,#width',\n  'content^[HTMLElement]|select',\n  'dl^[HTMLElement]|!compact',\n  'data^[HTMLElement]|value',\n  'datalist^[HTMLElement]|',\n  'details^[HTMLElement]|!open',\n  'dialog^[HTMLElement]|!open,returnValue',\n  'dir^[HTMLElement]|!compact',\n  'div^[HTMLElement]|align',\n  'embed^[HTMLElement]|align,height,name,src,type,width',\n  'fieldset^[HTMLElement]|!disabled,name',\n  'font^[HTMLElement]|color,face,size',\n  'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',\n  'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',\n  'frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',\n  'hr^[HTMLElement]|align,color,!noShade,size,width',\n  'head^[HTMLElement]|',\n  'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',\n  'html^[HTMLElement]|version',\n  'iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',\n  'img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',\n  'input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',\n  'li^[HTMLElement]|type,#value',\n  'label^[HTMLElement]|htmlFor',\n  'legend^[HTMLElement]|align',\n  'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type',\n  'map^[HTMLElement]|name',\n  'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',\n  'menu^[HTMLElement]|!compact',\n  'meta^[HTMLElement]|content,httpEquiv,media,name,scheme',\n  'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',\n  'ins,del^[HTMLElement]|cite,dateTime',\n  'ol^[HTMLElement]|!compact,!reversed,#start,type',\n  'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',\n  'optgroup^[HTMLElement]|!disabled,label',\n  'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',\n  'output^[HTMLElement]|defaultValue,%htmlFor,name,value',\n  'p^[HTMLElement]|align',\n  'param^[HTMLElement]|name,type,value,valueType',\n  'picture^[HTMLElement]|',\n  'pre^[HTMLElement]|#width',\n  'progress^[HTMLElement]|#max,#value',\n  'q,blockquote,cite^[HTMLElement]|',\n  'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type',\n  'select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',\n  'slot^[HTMLElement]|name',\n  'source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width',\n  'span^[HTMLElement]|',\n  'style^[HTMLElement]|!disabled,media,type',\n  'caption^[HTMLElement]|align',\n  'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',\n  'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',\n  'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',\n  'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',\n  'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',\n  'template^[HTMLElement]|',\n  'textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',\n  'time^[HTMLElement]|dateTime',\n  'title^[HTMLElement]|text',\n  'track^[HTMLElement]|!default,kind,label,src,srclang',\n  'ul^[HTMLElement]|!compact,type',\n  'unknown^[HTMLElement]|',\n  'video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width',\n  ':svg:a^:svg:graphics|',\n  ':svg:animate^:svg:animation|',\n  ':svg:animateMotion^:svg:animation|',\n  ':svg:animateTransform^:svg:animation|',\n  ':svg:circle^:svg:geometry|',\n  ':svg:clipPath^:svg:graphics|',\n  ':svg:defs^:svg:graphics|',\n  ':svg:desc^:svg:|',\n  ':svg:discard^:svg:|',\n  ':svg:ellipse^:svg:geometry|',\n  ':svg:feBlend^:svg:|',\n  ':svg:feColorMatrix^:svg:|',\n  ':svg:feComponentTransfer^:svg:|',\n  ':svg:feComposite^:svg:|',\n  ':svg:feConvolveMatrix^:svg:|',\n  ':svg:feDiffuseLighting^:svg:|',\n  ':svg:feDisplacementMap^:svg:|',\n  ':svg:feDistantLight^:svg:|',\n  ':svg:feDropShadow^:svg:|',\n  ':svg:feFlood^:svg:|',\n  ':svg:feFuncA^:svg:componentTransferFunction|',\n  ':svg:feFuncB^:svg:componentTransferFunction|',\n  ':svg:feFuncG^:svg:componentTransferFunction|',\n  ':svg:feFuncR^:svg:componentTransferFunction|',\n  ':svg:feGaussianBlur^:svg:|',\n  ':svg:feImage^:svg:|',\n  ':svg:feMerge^:svg:|',\n  ':svg:feMergeNode^:svg:|',\n  ':svg:feMorphology^:svg:|',\n  ':svg:feOffset^:svg:|',\n  ':svg:fePointLight^:svg:|',\n  ':svg:feSpecularLighting^:svg:|',\n  ':svg:feSpotLight^:svg:|',\n  ':svg:feTile^:svg:|',\n  ':svg:feTurbulence^:svg:|',\n  ':svg:filter^:svg:|',\n  ':svg:foreignObject^:svg:graphics|',\n  ':svg:g^:svg:graphics|',\n  ':svg:image^:svg:graphics|decoding',\n  ':svg:line^:svg:geometry|',\n  ':svg:linearGradient^:svg:gradient|',\n  ':svg:mpath^:svg:|',\n  ':svg:marker^:svg:|',\n  ':svg:mask^:svg:|',\n  ':svg:metadata^:svg:|',\n  ':svg:path^:svg:geometry|',\n  ':svg:pattern^:svg:|',\n  ':svg:polygon^:svg:geometry|',\n  ':svg:polyline^:svg:geometry|',\n  ':svg:radialGradient^:svg:gradient|',\n  ':svg:rect^:svg:geometry|',\n  ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',\n  ':svg:script^:svg:|type',\n  ':svg:set^:svg:animation|',\n  ':svg:stop^:svg:|',\n  ':svg:style^:svg:|!disabled,media,title,type',\n  ':svg:switch^:svg:graphics|',\n  ':svg:symbol^:svg:|',\n  ':svg:tspan^:svg:textPositioning|',\n  ':svg:text^:svg:textPositioning|',\n  ':svg:textPath^:svg:textContent|',\n  ':svg:title^:svg:|',\n  ':svg:use^:svg:graphics|',\n  ':svg:view^:svg:|#zoomAndPan',\n  'data^[HTMLElement]|value',\n  'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name',\n  'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',\n  'summary^[HTMLElement]|',\n  'time^[HTMLElement]|dateTime',\n  ':svg:cursor^:svg:|',\n];\n\nconst _ATTR_TO_PROP = new Map(Object.entries({\n  'class': 'className',\n  'for': 'htmlFor',\n  'formaction': 'formAction',\n  'innerHtml': 'innerHTML',\n  'readonly': 'readOnly',\n  'tabindex': 'tabIndex',\n}));\n\n// Invert _ATTR_TO_PROP.\nconst _PROP_TO_ATTR =\n    Array.from(_ATTR_TO_PROP).reduce((inverted, [propertyName, attributeName]) => {\n      inverted.set(propertyName, attributeName);\n      return inverted;\n    }, new Map<string, string>());\n\nexport class DomElementSchemaRegistry extends ElementSchemaRegistry {\n  private _schema = new Map<string, Map<string, string>>();\n  // We don't allow binding to events for security reasons. Allowing event bindings would almost\n  // certainly introduce bad XSS vulnerabilities. Instead, we store events in a separate schema.\n  private _eventSchema = new Map<string, Set<string>>;\n\n  constructor() {\n    super();\n    SCHEMA.forEach(encodedType => {\n      const type = new Map<string, string>();\n      const events: Set<string> = new Set();\n      const [strType, strProperties] = encodedType.split('|');\n      const properties = strProperties.split(',');\n      const [typeNames, superName] = strType.split('^');\n      typeNames.split(',').forEach(tag => {\n        this._schema.set(tag.toLowerCase(), type);\n        this._eventSchema.set(tag.toLowerCase(), events);\n      });\n      const superType = superName && this._schema.get(superName.toLowerCase());\n      if (superType) {\n        for (const [prop, value] of superType) {\n          type.set(prop, value);\n        }\n        for (const superEvent of this._eventSchema.get(superName.toLowerCase())!) {\n          events.add(superEvent);\n        }\n      }\n      properties.forEach((property: string) => {\n        if (property.length > 0) {\n          switch (property[0]) {\n            case '*':\n              events.add(property.substring(1));\n              break;\n            case '!':\n              type.set(property.substring(1), BOOLEAN);\n              break;\n            case '#':\n              type.set(property.substring(1), NUMBER);\n              break;\n            case '%':\n              type.set(property.substring(1), OBJECT);\n              break;\n            default:\n              type.set(property, STRING);\n          }\n        }\n      });\n    });\n  }\n\n  override hasProperty(tagName: string, propName: string, schemaMetas: SchemaMetadata[]): boolean {\n    if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {\n      return true;\n    }\n\n    if (tagName.indexOf('-') > -1) {\n      if (isNgContainer(tagName) || isNgContent(tagName)) {\n        return false;\n      }\n\n      if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\n        // Can't tell now as we don't know which properties a custom element will get\n        // once it is instantiated\n        return true;\n      }\n    }\n\n    const elementProperties =\n        this._schema.get(tagName.toLowerCase()) || this._schema.get('unknown')!;\n    return elementProperties.has(propName);\n  }\n\n  override hasElement(tagName: string, schemaMetas: SchemaMetadata[]): boolean {\n    if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {\n      return true;\n    }\n\n    if (tagName.indexOf('-') > -1) {\n      if (isNgContainer(tagName) || isNgContent(tagName)) {\n        return true;\n      }\n\n      if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\n        // Allow any custom elements\n        return true;\n      }\n    }\n\n    return this._schema.has(tagName.toLowerCase());\n  }\n\n  /**\n   * securityContext returns the security context for the given property on the given DOM tag.\n   *\n   * Tag and property name are statically known and cannot change at runtime, i.e. it is not\n   * possible to bind a value into a changing attribute or tag name.\n   *\n   * The filtering is based on a list of allowed tags|attributes. All attributes in the schema\n   * above are assumed to have the 'NONE' security context, i.e. that they are safe inert\n   * string values. Only specific well known attack vectors are assigned their appropriate context.\n   */\n  override securityContext(tagName: string, propName: string, isAttribute: boolean):\n      SecurityContext {\n    if (isAttribute) {\n      // NB: For security purposes, use the mapped property name, not the attribute name.\n      propName = this.getMappedPropName(propName);\n    }\n\n    // Make sure comparisons are case insensitive, so that case differences between attribute and\n    // property names do not have a security impact.\n    tagName = tagName.toLowerCase();\n    propName = propName.toLowerCase();\n    let ctx = SECURITY_SCHEMA()[tagName + '|' + propName];\n    if (ctx) {\n      return ctx;\n    }\n    ctx = SECURITY_SCHEMA()['*|' + propName];\n    return ctx ? ctx : SecurityContext.NONE;\n  }\n\n  override getMappedPropName(propName: string): string {\n    return _ATTR_TO_PROP.get(propName) ?? propName;\n  }\n\n  override getDefaultComponentElementName(): string {\n    return 'ng-component';\n  }\n\n  override validateProperty(name: string): {error: boolean, msg?: string} {\n    if (name.toLowerCase().startsWith('on')) {\n      const msg = `Binding to event property '${name}' is disallowed for security reasons, ` +\n          `please use (${name.slice(2)})=...` +\n          `\\nIf '${name}' is a directive input, make sure the directive is imported by the` +\n          ` current module.`;\n      return {error: true, msg: msg};\n    } else {\n      return {error: false};\n    }\n  }\n\n  override validateAttribute(name: string): {error: boolean, msg?: string} {\n    if (name.toLowerCase().startsWith('on')) {\n      const msg = `Binding to event attribute '${name}' is disallowed for security reasons, ` +\n          `please use (${name.slice(2)})=...`;\n      return {error: true, msg: msg};\n    } else {\n      return {error: false};\n    }\n  }\n\n  override allKnownElementNames(): string[] {\n    return Array.from(this._schema.keys());\n  }\n\n  allKnownAttributesOfElement(tagName: string): string[] {\n    const elementProperties =\n        this._schema.get(tagName.toLowerCase()) || this._schema.get('unknown')!;\n    // Convert properties to attributes.\n    return Array.from(elementProperties.keys()).map(prop => _PROP_TO_ATTR.get(prop) ?? prop);\n  }\n\n  allKnownEventsOfElement(tagName: string): string[] {\n    return Array.from(this._eventSchema.get(tagName.toLowerCase()) ?? []);\n  }\n\n  override normalizeAnimationStyleProperty(propName: string): string {\n    return dashCaseToCamelCase(propName);\n  }\n\n  override normalizeAnimationStyleValue(\n      camelCaseProp: string, userProvidedProp: string,\n      val: string|number): {error: string, value: string} {\n    let unit: string = '';\n    const strVal = val.toString().trim();\n    let errorMsg: string = null!;\n\n    if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {\n      if (typeof val === 'number') {\n        unit = 'px';\n      } else {\n        const valAndSuffixMatch = val.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n        if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n          errorMsg = `Please provide a CSS unit value for ${userProvidedProp}:${val}`;\n        }\n      }\n    }\n    return {error: errorMsg, value: strVal + unit};\n  }\n}\n\nfunction _isPixelDimensionStyle(prop: string): boolean {\n  switch (prop) {\n    case 'width':\n    case 'height':\n    case 'minWidth':\n    case 'minHeight':\n    case 'maxWidth':\n    case 'maxHeight':\n    case 'left':\n    case 'top':\n    case 'bottom':\n    case 'right':\n    case 'fontSize':\n    case 'outlineWidth':\n    case 'outlineOffset':\n    case 'paddingTop':\n    case 'paddingLeft':\n    case 'paddingBottom':\n    case 'paddingRight':\n    case 'marginTop':\n    case 'marginLeft':\n    case 'marginBottom':\n    case 'marginRight':\n    case 'borderRadius':\n    case 'borderWidth':\n    case 'borderTopWidth':\n    case 'borderLeftWidth':\n    case 'borderRightWidth':\n    case 'borderBottomWidth':\n    case 'textIndent':\n      return true;\n\n    default:\n      return false;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Set of tagName|propertyName corresponding to Trusted Types sinks. Properties applying to all\n * tags use '*'.\n *\n * Extracted from, and should be kept in sync with\n * https://w3c.github.io/webappsec-trusted-types/dist/spec/#integrations\n */\nconst TRUSTED_TYPES_SINKS = new Set<string>([\n  // NOTE: All strings in this set *must* be lowercase!\n\n  // TrustedHTML\n  'iframe|srcdoc',\n  '*|innerhtml',\n  '*|outerhtml',\n\n  // NB: no TrustedScript here, as the corresponding tags are stripped by the compiler.\n\n  // TrustedScriptURL\n  'embed|src',\n  'object|codebase',\n  'object|data',\n]);\n\n/**\n * isTrustedTypesSink returns true if the given property on the given DOM tag is a Trusted Types\n * sink. In that case, use `ElementSchemaRegistry.securityContext` to determine which particular\n * Trusted Type is required for values passed to the sink:\n * - SecurityContext.HTML corresponds to TrustedHTML\n * - SecurityContext.RESOURCE_URL corresponds to TrustedScriptURL\n */\nexport function isTrustedTypesSink(tagName: string, propName: string): boolean {\n  // Make sure comparisons are case insensitive, so that case differences between attribute and\n  // property names do not have a security impact.\n  tagName = tagName.toLowerCase();\n  propName = propName.toLowerCase();\n\n  return TRUSTED_TYPES_SINKS.has(tagName + '|' + propName) ||\n      TRUSTED_TYPES_SINKS.has('*|' + propName);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '../core';\nimport {AbsoluteSourceSpan, ASTWithSource, BindingPipe, BindingType, BoundElementProperty, EmptyExpr, ParsedEvent, ParsedEventType, ParsedProperty, ParsedPropertyType, ParsedVariable, ParserError, RecursiveAstVisitor, TemplateBinding, VariableBinding} from '../expression_parser/ast';\nimport {Parser} from '../expression_parser/parser';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {mergeNsAndName} from '../ml_parser/tags';\nimport {InterpolatedAttributeToken, InterpolatedTextToken} from '../ml_parser/tokens';\nimport {ParseError, ParseErrorLevel, ParseLocation, ParseSourceSpan} from '../parse_util';\nimport {ElementSchemaRegistry} from '../schema/element_schema_registry';\nimport {CssSelector} from '../selector';\nimport {splitAtColon, splitAtPeriod} from '../util';\n\nconst PROPERTY_PARTS_SEPARATOR = '.';\nconst ATTRIBUTE_PREFIX = 'attr';\nconst CLASS_PREFIX = 'class';\nconst STYLE_PREFIX = 'style';\nconst TEMPLATE_ATTR_PREFIX = '*';\nconst ANIMATE_PROP_PREFIX = 'animate-';\n\nexport interface HostProperties {\n  [key: string]: string;\n}\n\nexport interface HostListeners {\n  [key: string]: string;\n}\n\n/**\n * Parses bindings in templates and in the directive host area.\n */\nexport class BindingParser {\n  constructor(\n      private _exprParser: Parser, private _interpolationConfig: InterpolationConfig,\n      private _schemaRegistry: ElementSchemaRegistry, public errors: ParseError[]) {}\n\n  get interpolationConfig(): InterpolationConfig {\n    return this._interpolationConfig;\n  }\n\n  createBoundHostProperties(properties: HostProperties, sourceSpan: ParseSourceSpan):\n      ParsedProperty[]|null {\n    const boundProps: ParsedProperty[] = [];\n    for (const propName of Object.keys(properties)) {\n      const expression = properties[propName];\n      if (typeof expression === 'string') {\n        this.parsePropertyBinding(\n            propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [],\n            // Use the `sourceSpan` for  `keySpan`. This isn't really accurate, but neither is the\n            // sourceSpan, as it represents the sourceSpan of the host itself rather than the\n            // source of the host binding (which doesn't exist in the template). Regardless,\n            // neither of these values are used in Ivy but are only here to satisfy the function\n            // signature. This should likely be refactored in the future so that `sourceSpan`\n            // isn't being used inaccurately.\n            boundProps, sourceSpan);\n      } else {\n        this._reportError(\n            `Value of the host property binding \"${\n                propName}\" needs to be a string representing an expression but got \"${\n                expression}\" (${typeof expression})`,\n            sourceSpan);\n      }\n    }\n    return boundProps;\n  }\n\n  createDirectiveHostEventAsts(hostListeners: HostListeners, sourceSpan: ParseSourceSpan):\n      ParsedEvent[]|null {\n    const targetEvents: ParsedEvent[] = [];\n    for (const propName of Object.keys(hostListeners)) {\n      const expression = hostListeners[propName];\n      if (typeof expression === 'string') {\n        // Use the `sourceSpan` for  `keySpan` and `handlerSpan`. This isn't really accurate, but\n        // neither is the `sourceSpan`, as it represents the `sourceSpan` of the host itself\n        // rather than the source of the host binding (which doesn't exist in the template).\n        // Regardless, neither of these values are used in Ivy but are only here to satisfy the\n        // function signature. This should likely be refactored in the future so that `sourceSpan`\n        // isn't being used inaccurately.\n        this.parseEvent(\n            propName, expression, /* isAssignmentEvent */ false, sourceSpan, sourceSpan, [],\n            targetEvents, sourceSpan);\n      } else {\n        this._reportError(\n            `Value of the host listener \"${\n                propName}\" needs to be a string representing an expression but got \"${\n                expression}\" (${typeof expression})`,\n            sourceSpan);\n      }\n    }\n    return targetEvents;\n  }\n\n  parseInterpolation(\n      value: string, sourceSpan: ParseSourceSpan,\n      interpolatedTokens: InterpolatedAttributeToken[]|InterpolatedTextToken[]|\n      null): ASTWithSource {\n    const sourceInfo = sourceSpan.start.toString();\n    const absoluteOffset = sourceSpan.fullStart.offset;\n\n    try {\n      const ast = this._exprParser.parseInterpolation(\n          value, sourceInfo, absoluteOffset, interpolatedTokens, this._interpolationConfig)!;\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n    }\n  }\n\n  /**\n   * Similar to `parseInterpolation`, but treats the provided string as a single expression\n   * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\n   * This is used for parsing the switch expression in ICUs.\n   */\n  parseInterpolationExpression(expression: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const sourceInfo = sourceSpan.start.toString();\n    const absoluteOffset = sourceSpan.start.offset;\n\n    try {\n      const ast =\n          this._exprParser.parseInterpolationExpression(expression, sourceInfo, absoluteOffset);\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n    }\n  }\n\n  /**\n   * Parses the bindings in a microsyntax expression, and converts them to\n   * `ParsedProperty` or `ParsedVariable`.\n   *\n   * @param tplKey template binding name\n   * @param tplValue template binding value\n   * @param sourceSpan span of template binding relative to entire the template\n   * @param absoluteValueOffset start of the tplValue relative to the entire template\n   * @param targetMatchableAttrs potential attributes to match in the template\n   * @param targetProps target property bindings in the template\n   * @param targetVars target variables in the template\n   */\n  parseInlineTemplateBinding(\n      tplKey: string, tplValue: string, sourceSpan: ParseSourceSpan, absoluteValueOffset: number,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[], targetVars: ParsedVariable[],\n      isIvyAst: boolean) {\n    const absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX.length;\n    const bindings = this._parseTemplateBindings(\n        tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);\n\n    for (const binding of bindings) {\n      // sourceSpan is for the entire HTML attribute. bindingSpan is for a particular\n      // binding within the microsyntax expression so it's more narrow than sourceSpan.\n      const bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);\n      const key = binding.key.source;\n      const keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);\n      if (binding instanceof VariableBinding) {\n        const value = binding.value ? binding.value.source : '$implicit';\n        const valueSpan =\n            binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : undefined;\n        targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));\n      } else if (binding.value) {\n        const srcSpan = isIvyAst ? bindingSpan : sourceSpan;\n        const valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);\n        this._parsePropertyAst(\n            key, binding.value, srcSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n      } else {\n        targetMatchableAttrs.push([key, '' /* value */]);\n        // Since this is a literal attribute with no RHS, source span should be\n        // just the key span.\n        this.parseLiteralAttr(\n            key, null /* value */, keySpan, absoluteValueOffset, undefined /* valueSpan */,\n            targetMatchableAttrs, targetProps, keySpan);\n      }\n    }\n  }\n\n  /**\n   * Parses the bindings in a microsyntax expression, e.g.\n   * ```\n   *    <tag *tplKey=\"let value1 = prop; let value2 = localVar\">\n   * ```\n   *\n   * @param tplKey template binding name\n   * @param tplValue template binding value\n   * @param sourceSpan span of template binding relative to entire the template\n   * @param absoluteKeyOffset start of the `tplKey`\n   * @param absoluteValueOffset start of the `tplValue`\n   */\n  private _parseTemplateBindings(\n      tplKey: string, tplValue: string, sourceSpan: ParseSourceSpan, absoluteKeyOffset: number,\n      absoluteValueOffset: number): TemplateBinding[] {\n    const sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const bindingsResult = this._exprParser.parseTemplateBindings(\n          tplKey, tplValue, sourceInfo, absoluteKeyOffset, absoluteValueOffset);\n      this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n      bindingsResult.warnings.forEach((warning) => {\n        this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);\n      });\n      return bindingsResult.templateBindings;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return [];\n    }\n  }\n\n  parseLiteralAttr(\n      name: string, value: string|null, sourceSpan: ParseSourceSpan, absoluteOffset: number,\n      valueSpan: ParseSourceSpan|undefined, targetMatchableAttrs: string[][],\n      targetProps: ParsedProperty[], keySpan: ParseSourceSpan) {\n    if (isAnimationLabel(name)) {\n      name = name.substring(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(\n            keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n      }\n      if (value) {\n        this._reportError(\n            `Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid.` +\n                ` Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.`,\n            sourceSpan, ParseErrorLevel.ERROR);\n      }\n      this._parseAnimation(\n          name, value, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs,\n          targetProps);\n    } else {\n      targetProps.push(new ParsedProperty(\n          name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset),\n          ParsedPropertyType.LITERAL_ATTR, sourceSpan, keySpan, valueSpan));\n    }\n  }\n\n  parsePropertyBinding(\n      name: string, expression: string, isHost: boolean, sourceSpan: ParseSourceSpan,\n      absoluteOffset: number, valueSpan: ParseSourceSpan|undefined,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[], keySpan: ParseSourceSpan) {\n    if (name.length === 0) {\n      this._reportError(`Property name is missing in binding`, sourceSpan);\n    }\n\n    let isAnimationProp = false;\n    if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n      isAnimationProp = true;\n      name = name.substring(ANIMATE_PROP_PREFIX.length);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(\n            keySpan,\n            new AbsoluteSourceSpan(\n                keySpan.start.offset + ANIMATE_PROP_PREFIX.length, keySpan.end.offset));\n      }\n    } else if (isAnimationLabel(name)) {\n      isAnimationProp = true;\n      name = name.substring(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(\n            keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n      }\n    }\n\n    if (isAnimationProp) {\n      this._parseAnimation(\n          name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs,\n          targetProps);\n    } else {\n      this._parsePropertyAst(\n          name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset),\n          sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n    }\n  }\n\n  parsePropertyInterpolation(\n      name: string, value: string, sourceSpan: ParseSourceSpan,\n      valueSpan: ParseSourceSpan|undefined, targetMatchableAttrs: string[][],\n      targetProps: ParsedProperty[], keySpan: ParseSourceSpan,\n      interpolatedTokens: InterpolatedAttributeToken[]|InterpolatedTextToken[]|null): boolean {\n    const expr = this.parseInterpolation(value, valueSpan || sourceSpan, interpolatedTokens);\n    if (expr) {\n      this._parsePropertyAst(\n          name, expr, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n      return true;\n    }\n    return false;\n  }\n\n  private _parsePropertyAst(\n      name: string, ast: ASTWithSource, sourceSpan: ParseSourceSpan, keySpan: ParseSourceSpan,\n      valueSpan: ParseSourceSpan|undefined, targetMatchableAttrs: string[][],\n      targetProps: ParsedProperty[]) {\n    targetMatchableAttrs.push([name, ast.source!]);\n    targetProps.push(\n        new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, keySpan, valueSpan));\n  }\n\n  private _parseAnimation(\n      name: string, expression: string|null, sourceSpan: ParseSourceSpan, absoluteOffset: number,\n      keySpan: ParseSourceSpan, valueSpan: ParseSourceSpan|undefined,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    if (name.length === 0) {\n      this._reportError('Animation trigger is missing', sourceSpan);\n    }\n\n    // This will occur when a @trigger is not paired with an expression.\n    // For animations it is valid to not have an expression since */void\n    // states will be applied by angular when the element is attached/detached\n    const ast = this._parseBinding(\n        expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);\n    targetMatchableAttrs.push([name, ast.source!]);\n    targetProps.push(new ParsedProperty(\n        name, ast, ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan));\n  }\n\n  private _parseBinding(\n      value: string, isHostBinding: boolean, sourceSpan: ParseSourceSpan,\n      absoluteOffset: number): ASTWithSource {\n    const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();\n\n    try {\n      const ast = isHostBinding ?\n          this._exprParser.parseSimpleBinding(\n              value, sourceInfo, absoluteOffset, this._interpolationConfig) :\n          this._exprParser.parseBinding(\n              value, sourceInfo, absoluteOffset, this._interpolationConfig);\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n    }\n  }\n\n  createBoundElementProperty(\n      elementSelector: string, boundProp: ParsedProperty, skipValidation: boolean = false,\n      mapPropertyName: boolean = true): BoundElementProperty {\n    if (boundProp.isAnimation) {\n      return new BoundElementProperty(\n          boundProp.name, BindingType.Animation, SecurityContext.NONE, boundProp.expression, null,\n          boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n    }\n\n    let unit: string|null = null;\n    let bindingType: BindingType = undefined!;\n    let boundPropertyName: string|null = null;\n    const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n    let securityContexts: SecurityContext[] = undefined!;\n\n    // Check for special cases (prefix style, attr, class)\n    if (parts.length > 1) {\n      if (parts[0] == ATTRIBUTE_PREFIX) {\n        boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);\n        if (!skipValidation) {\n          this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n        }\n        securityContexts = calcPossibleSecurityContexts(\n            this._schemaRegistry, elementSelector, boundPropertyName, true);\n\n        const nsSeparatorIdx = boundPropertyName.indexOf(':');\n        if (nsSeparatorIdx > -1) {\n          const ns = boundPropertyName.substring(0, nsSeparatorIdx);\n          const name = boundPropertyName.substring(nsSeparatorIdx + 1);\n          boundPropertyName = mergeNsAndName(ns, name);\n        }\n\n        bindingType = BindingType.Attribute;\n      } else if (parts[0] == CLASS_PREFIX) {\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Class;\n        securityContexts = [SecurityContext.NONE];\n      } else if (parts[0] == STYLE_PREFIX) {\n        unit = parts.length > 2 ? parts[2] : null;\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Style;\n        securityContexts = [SecurityContext.STYLE];\n      }\n    }\n\n    // If not a special case, use the full property name\n    if (boundPropertyName === null) {\n      const mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);\n      boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;\n      securityContexts = calcPossibleSecurityContexts(\n          this._schemaRegistry, elementSelector, mappedPropName, false);\n      bindingType = BindingType.Property;\n      if (!skipValidation) {\n        this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);\n      }\n    }\n\n    return new BoundElementProperty(\n        boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit,\n        boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n  }\n\n  // TODO: keySpan should be required but was made optional to avoid changing VE parser.\n  parseEvent(\n      name: string, expression: string, isAssignmentEvent: boolean, sourceSpan: ParseSourceSpan,\n      handlerSpan: ParseSourceSpan, targetMatchableAttrs: string[][], targetEvents: ParsedEvent[],\n      keySpan: ParseSourceSpan) {\n    if (name.length === 0) {\n      this._reportError(`Event name is missing in binding`, sourceSpan);\n    }\n\n    if (isAnimationLabel(name)) {\n      name = name.slice(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(\n            keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n      }\n      this._parseAnimationEvent(\n          name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetEvents, keySpan);\n    } else {\n      this._parseRegularEvent(\n          name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs,\n          targetEvents, keySpan);\n    }\n  }\n\n  calcPossibleSecurityContexts(selector: string, propName: string, isAttribute: boolean):\n      SecurityContext[] {\n    const prop = this._schemaRegistry.getMappedPropName(propName);\n    return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);\n  }\n\n  private _parseAnimationEvent(\n      name: string, expression: string, isAssignmentEvent: boolean, sourceSpan: ParseSourceSpan,\n      handlerSpan: ParseSourceSpan, targetEvents: ParsedEvent[], keySpan: ParseSourceSpan) {\n    const matches = splitAtPeriod(name, [name, '']);\n    const eventName = matches[0];\n    const phase = matches[1].toLowerCase();\n    const ast = this._parseAction(expression, isAssignmentEvent, handlerSpan);\n    targetEvents.push(new ParsedEvent(\n        eventName, phase, ParsedEventType.Animation, ast, sourceSpan, handlerSpan, keySpan));\n\n    if (eventName.length === 0) {\n      this._reportError(`Animation event name is missing in binding`, sourceSpan);\n    }\n    if (phase) {\n      if (phase !== 'start' && phase !== 'done') {\n        this._reportError(\n            `The provided animation output phase value \"${phase}\" for \"@${\n                eventName}\" is not supported (use start or done)`,\n            sourceSpan);\n      }\n    } else {\n      this._reportError(\n          `The animation trigger output event (@${\n              eventName}) is missing its phase value name (start or done are currently supported)`,\n          sourceSpan);\n    }\n  }\n\n  private _parseRegularEvent(\n      name: string, expression: string, isAssignmentEvent: boolean, sourceSpan: ParseSourceSpan,\n      handlerSpan: ParseSourceSpan, targetMatchableAttrs: string[][], targetEvents: ParsedEvent[],\n      keySpan: ParseSourceSpan) {\n    // long format: 'target: eventName'\n    const [target, eventName] = splitAtColon(name, [null!, name]);\n    const ast = this._parseAction(expression, isAssignmentEvent, handlerSpan);\n    targetMatchableAttrs.push([name!, ast.source!]);\n    targetEvents.push(new ParsedEvent(\n        eventName, target, ParsedEventType.Regular, ast, sourceSpan, handlerSpan, keySpan));\n    // Don't detect directives for event names for now,\n    // so don't add the event name to the matchableAttrs\n  }\n\n  private _parseAction(value: string, isAssignmentEvent: boolean, sourceSpan: ParseSourceSpan):\n      ASTWithSource {\n    const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();\n    const absoluteOffset = (sourceSpan && sourceSpan.start) ? sourceSpan.start.offset : 0;\n\n    try {\n      const ast = this._exprParser.parseAction(\n          value, isAssignmentEvent, sourceInfo, absoluteOffset, this._interpolationConfig);\n      if (ast) {\n        this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      }\n      if (!ast || ast.ast instanceof EmptyExpr) {\n        this._reportError(`Empty expressions are not allowed`, sourceSpan);\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n      }\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n    }\n  }\n\n  private _reportError(\n      message: string, sourceSpan: ParseSourceSpan,\n      level: ParseErrorLevel = ParseErrorLevel.ERROR) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n\n  private _reportExpressionParserErrors(errors: ParserError[], sourceSpan: ParseSourceSpan) {\n    for (const error of errors) {\n      this._reportError(error.message, sourceSpan);\n    }\n  }\n\n  /**\n   * @param propName the name of the property / attribute\n   * @param sourceSpan\n   * @param isAttr true when binding to an attribute\n   */\n  private _validatePropertyOrAttributeName(\n      propName: string, sourceSpan: ParseSourceSpan, isAttr: boolean): void {\n    const report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n                            this._schemaRegistry.validateProperty(propName);\n    if (report.error) {\n      this._reportError(report.msg!, sourceSpan, ParseErrorLevel.ERROR);\n    }\n  }\n}\n\nexport class PipeCollector extends RecursiveAstVisitor {\n  pipes = new Map<string, BindingPipe>();\n  override visitPipe(ast: BindingPipe, context: any): any {\n    this.pipes.set(ast.name, ast);\n    ast.exp.visit(this);\n    this.visitAll(ast.args, context);\n    return null;\n  }\n}\n\nfunction isAnimationLabel(name: string): boolean {\n  return name[0] == '@';\n}\n\nexport function calcPossibleSecurityContexts(\n    registry: ElementSchemaRegistry, selector: string, propName: string,\n    isAttribute: boolean): SecurityContext[] {\n  const ctxs: SecurityContext[] = [];\n  CssSelector.parse(selector).forEach((selector) => {\n    const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n    const notElementNames =\n        new Set(selector.notSelectors.filter(selector => selector.isElementSelector())\n                    .map((selector) => selector.element));\n    const possibleElementNames =\n        elementNames.filter(elementName => !notElementNames.has(elementName));\n\n    ctxs.push(...possibleElementNames.map(\n        elementName => registry.securityContext(elementName, propName, isAttribute)));\n  });\n  return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\n\n/**\n * Compute a new ParseSourceSpan based off an original `sourceSpan` by using\n * absolute offsets from the specified `absoluteSpan`.\n *\n * @param sourceSpan original source span\n * @param absoluteSpan absolute source span to move to\n */\nfunction moveParseSourceSpan(\n    sourceSpan: ParseSourceSpan, absoluteSpan: AbsoluteSourceSpan): ParseSourceSpan {\n  // The difference of two absolute offsets provide the relative offset\n  const startDiff = absoluteSpan.start - sourceSpan.start.offset;\n  const endDiff = absoluteSpan.end - sourceSpan.end.offset;\n  return new ParseSourceSpan(\n      sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff),\n      sourceSpan.fullStart.moveBy(startDiff), sourceSpan.details);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Some of the code comes from WebComponents.JS\n// https://github.com/webcomponents/webcomponentsjs/blob/master/src/HTMLImports/path.js\n\nexport function isStyleUrlResolvable(url: string|null): url is string {\n  if (url == null || url.length === 0 || url[0] == '/') return false;\n  const schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\n  return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n}\n\nconst URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as html from '../ml_parser/ast';\nimport {isNgContent} from '../ml_parser/tags';\n\nconst NG_CONTENT_SELECT_ATTR = 'select';\nconst LINK_ELEMENT = 'link';\nconst LINK_STYLE_REL_ATTR = 'rel';\nconst LINK_STYLE_HREF_ATTR = 'href';\nconst LINK_STYLE_REL_VALUE = 'stylesheet';\nconst STYLE_ELEMENT = 'style';\nconst SCRIPT_ELEMENT = 'script';\nconst NG_NON_BINDABLE_ATTR = 'ngNonBindable';\nconst NG_PROJECT_AS = 'ngProjectAs';\n\nexport function preparseElement(ast: html.Element): PreparsedElement {\n  let selectAttr: string|null = null;\n  let hrefAttr: string|null = null;\n  let relAttr: string|null = null;\n  let nonBindable = false;\n  let projectAs = '';\n  ast.attrs.forEach(attr => {\n    const lcAttrName = attr.name.toLowerCase();\n    if (lcAttrName == NG_CONTENT_SELECT_ATTR) {\n      selectAttr = attr.value;\n    } else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\n      hrefAttr = attr.value;\n    } else if (lcAttrName == LINK_STYLE_REL_ATTR) {\n      relAttr = attr.value;\n    } else if (attr.name == NG_NON_BINDABLE_ATTR) {\n      nonBindable = true;\n    } else if (attr.name == NG_PROJECT_AS) {\n      if (attr.value.length > 0) {\n        projectAs = attr.value;\n      }\n    }\n  });\n  selectAttr = normalizeNgContentSelect(selectAttr);\n  const nodeName = ast.name.toLowerCase();\n  let type = PreparsedElementType.OTHER;\n  if (isNgContent(nodeName)) {\n    type = PreparsedElementType.NG_CONTENT;\n  } else if (nodeName == STYLE_ELEMENT) {\n    type = PreparsedElementType.STYLE;\n  } else if (nodeName == SCRIPT_ELEMENT) {\n    type = PreparsedElementType.SCRIPT;\n  } else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\n    type = PreparsedElementType.STYLESHEET;\n  }\n  return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);\n}\n\nexport enum PreparsedElementType {\n  NG_CONTENT,\n  STYLE,\n  STYLESHEET,\n  SCRIPT,\n  OTHER\n}\n\nexport class PreparsedElement {\n  constructor(\n      public type: PreparsedElementType, public selectAttr: string, public hrefAttr: string|null,\n      public nonBindable: boolean, public projectAs: string) {}\n}\n\n\nfunction normalizeNgContentSelect(selectAttr: string|null): string {\n  if (selectAttr === null || selectAttr.length === 0) {\n    return '*';\n  }\n  return selectAttr;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParsedEvent, ParsedProperty, ParsedVariable} from '../expression_parser/ast';\nimport * as i18n from '../i18n/i18n_ast';\nimport * as html from '../ml_parser/ast';\nimport {replaceNgsp} from '../ml_parser/html_whitespaces';\nimport {isNgTemplate} from '../ml_parser/tags';\nimport {InterpolatedAttributeToken, InterpolatedTextToken} from '../ml_parser/tokens';\nimport {ParseError, ParseErrorLevel, ParseSourceSpan} from '../parse_util';\nimport {isStyleUrlResolvable} from '../style_url_resolver';\nimport {BindingParser} from '../template_parser/binding_parser';\nimport {PreparsedElementType, preparseElement} from '../template_parser/template_preparser';\n\nimport * as t from './r3_ast';\nimport {I18N_ICU_VAR_PREFIX, isI18nRootNode} from './view/i18n/util';\n\nconst BIND_NAME_REGEXP = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/;\n\n// Group 1 = \"bind-\"\nconst KW_BIND_IDX = 1;\n// Group 2 = \"let-\"\nconst KW_LET_IDX = 2;\n// Group 3 = \"ref-/#\"\nconst KW_REF_IDX = 3;\n// Group 4 = \"on-\"\nconst KW_ON_IDX = 4;\n// Group 5 = \"bindon-\"\nconst KW_BINDON_IDX = 5;\n// Group 6 = \"@\"\nconst KW_AT_IDX = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nconst IDENT_KW_IDX = 7;\n\nconst BINDING_DELIMS = {\n  BANANA_BOX: {start: '[(', end: ')]'},\n  PROPERTY: {start: '[', end: ']'},\n  EVENT: {start: '(', end: ')'},\n};\n\nconst TEMPLATE_ATTR_PREFIX = '*';\n\n// Result of the html AST to Ivy AST transformation\nexport interface Render3ParseResult {\n  nodes: t.Node[];\n  errors: ParseError[];\n  styles: string[];\n  styleUrls: string[];\n  ngContentSelectors: string[];\n  // Will be defined if `Render3ParseOptions['collectCommentNodes']` is true\n  commentNodes?: t.Comment[];\n}\n\ninterface Render3ParseOptions {\n  collectCommentNodes: boolean;\n}\n\nexport function htmlAstToRender3Ast(\n    htmlNodes: html.Node[], bindingParser: BindingParser,\n    options: Render3ParseOptions): Render3ParseResult {\n  const transformer = new HtmlAstToIvyAst(bindingParser, options);\n  const ivyNodes = html.visitAll(transformer, htmlNodes);\n\n  // Errors might originate in either the binding parser or the html to ivy transformer\n  const allErrors = bindingParser.errors.concat(transformer.errors);\n\n  const result: Render3ParseResult = {\n    nodes: ivyNodes,\n    errors: allErrors,\n    styleUrls: transformer.styleUrls,\n    styles: transformer.styles,\n    ngContentSelectors: transformer.ngContentSelectors\n  };\n  if (options.collectCommentNodes) {\n    result.commentNodes = transformer.commentNodes;\n  }\n  return result;\n}\n\nclass HtmlAstToIvyAst implements html.Visitor {\n  errors: ParseError[] = [];\n  styles: string[] = [];\n  styleUrls: string[] = [];\n  ngContentSelectors: string[] = [];\n  // This array will be populated if `Render3ParseOptions['collectCommentNodes']` is true\n  commentNodes: t.Comment[] = [];\n  private inI18nBlock: boolean = false;\n\n  constructor(private bindingParser: BindingParser, private options: Render3ParseOptions) {}\n\n  // HTML visitor\n  visitElement(element: html.Element): t.Node|null {\n    const isI18nRootElement = isI18nRootNode(element.i18n);\n    if (isI18nRootElement) {\n      if (this.inI18nBlock) {\n        this.reportError(\n            'Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.',\n            element.sourceSpan);\n      }\n      this.inI18nBlock = true;\n    }\n    const preparsedElement = preparseElement(element);\n    if (preparsedElement.type === PreparsedElementType.SCRIPT) {\n      return null;\n    } else if (preparsedElement.type === PreparsedElementType.STYLE) {\n      const contents = textContents(element);\n      if (contents !== null) {\n        this.styles.push(contents);\n      }\n      return null;\n    } else if (\n        preparsedElement.type === PreparsedElementType.STYLESHEET &&\n        isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n      this.styleUrls.push(preparsedElement.hrefAttr);\n      return null;\n    }\n\n    // Whether the element is a `<ng-template>`\n    const isTemplateElement = isNgTemplate(element.name);\n\n    const parsedProperties: ParsedProperty[] = [];\n    const boundEvents: t.BoundEvent[] = [];\n    const variables: t.Variable[] = [];\n    const references: t.Reference[] = [];\n    const attributes: t.TextAttribute[] = [];\n    const i18nAttrsMeta: {[key: string]: i18n.I18nMeta} = {};\n\n    const templateParsedProperties: ParsedProperty[] = [];\n    const templateVariables: t.Variable[] = [];\n\n    // Whether the element has any *-attribute\n    let elementHasInlineTemplate = false;\n\n    for (const attribute of element.attrs) {\n      let hasBinding = false;\n      const normalizedName = normalizeAttributeName(attribute.name);\n\n      // `*attr` defines template bindings\n      let isTemplateBinding = false;\n\n      if (attribute.i18n) {\n        i18nAttrsMeta[attribute.name] = attribute.i18n;\n      }\n\n      if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n        // *-attributes\n        if (elementHasInlineTemplate) {\n          this.reportError(\n              `Can't have multiple template bindings on one element. Use only one attribute prefixed with *`,\n              attribute.sourceSpan);\n        }\n        isTemplateBinding = true;\n        elementHasInlineTemplate = true;\n        const templateValue = attribute.value;\n        const templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);\n\n        const parsedVariables: ParsedVariable[] = [];\n        const absoluteValueOffset = attribute.valueSpan ?\n            attribute.valueSpan.start.offset :\n            // If there is no value span the attribute does not have a value, like `attr` in\n            //`<div attr></div>`. In this case, point to one character beyond the last character of\n            // the attribute name.\n            attribute.sourceSpan.start.offset + attribute.name.length;\n\n        this.bindingParser.parseInlineTemplateBinding(\n            templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [],\n            templateParsedProperties, parsedVariables, true /* isIvyAst */);\n        templateVariables.push(...parsedVariables.map(\n            v => new t.Variable(v.name, v.value, v.sourceSpan, v.keySpan, v.valueSpan)));\n      } else {\n        // Check for variables, events, property bindings, interpolation\n        hasBinding = this.parseAttribute(\n            isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);\n      }\n\n      if (!hasBinding && !isTemplateBinding) {\n        // don't include the bindings as attributes as well in the AST\n        attributes.push(this.visitAttribute(attribute));\n      }\n    }\n\n    const children: t.Node[] =\n        html.visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children);\n\n    let parsedElement: t.Content|t.Template|t.Element|undefined;\n    if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n      // `<ng-content>`\n      if (element.children &&\n          !element.children.every(\n              (node: html.Node) => isEmptyTextNode(node) || isCommentNode(node))) {\n        this.reportError(`<ng-content> element cannot have content.`, element.sourceSpan);\n      }\n      const selector = preparsedElement.selectAttr;\n      const attrs: t.TextAttribute[] = element.attrs.map(attr => this.visitAttribute(attr));\n      parsedElement = new t.Content(selector, attrs, element.sourceSpan, element.i18n);\n\n      this.ngContentSelectors.push(selector);\n    } else if (isTemplateElement) {\n      // `<ng-template>`\n      const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n\n      parsedElement = new t.Template(\n          element.name, attributes, attrs.bound, boundEvents, [/* no template attributes */],\n          children, references, variables, element.sourceSpan, element.startSourceSpan,\n          element.endSourceSpan, element.i18n);\n    } else {\n      const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n      parsedElement = new t.Element(\n          element.name, attributes, attrs.bound, boundEvents, children, references,\n          element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n    }\n\n    if (elementHasInlineTemplate) {\n      // If this node is an inline-template (e.g. has *ngFor) then we need to create a template\n      // node that contains this node.\n      // Moreover, if the node is an element, then we need to hoist its attributes to the template\n      // node for matching against content projection selectors.\n      const attrs = this.extractAttributes('ng-template', templateParsedProperties, i18nAttrsMeta);\n      const templateAttrs: (t.TextAttribute|t.BoundAttribute)[] = [];\n      attrs.literal.forEach(attr => templateAttrs.push(attr));\n      attrs.bound.forEach(attr => templateAttrs.push(attr));\n      const hoistedAttrs = parsedElement instanceof t.Element ?\n          {\n            attributes: parsedElement.attributes,\n            inputs: parsedElement.inputs,\n            outputs: parsedElement.outputs,\n          } :\n          {attributes: [], inputs: [], outputs: []};\n\n      // For <ng-template>s with structural directives on them, avoid passing i18n information to\n      // the wrapping template to prevent unnecessary i18n instructions from being generated. The\n      // necessary i18n meta information will be extracted from child elements.\n      const i18n = isTemplateElement && isI18nRootElement ? undefined : element.i18n;\n      const name = parsedElement instanceof t.Template ? null : parsedElement.name;\n\n      parsedElement = new t.Template(\n          name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs,\n          [parsedElement], [/* no references */], templateVariables, element.sourceSpan,\n          element.startSourceSpan, element.endSourceSpan, i18n);\n    }\n    if (isI18nRootElement) {\n      this.inI18nBlock = false;\n    }\n    return parsedElement;\n  }\n\n  visitAttribute(attribute: html.Attribute): t.TextAttribute {\n    return new t.TextAttribute(\n        attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan,\n        attribute.valueSpan, attribute.i18n);\n  }\n\n  visitText(text: html.Text): t.Node {\n    return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.tokens, text.i18n);\n  }\n\n  visitExpansion(expansion: html.Expansion): t.Icu|null {\n    if (!expansion.i18n) {\n      // do not generate Icu in case it was created\n      // outside of i18n block in a template\n      return null;\n    }\n    if (!isI18nRootNode(expansion.i18n)) {\n      throw new Error(`Invalid type \"${expansion.i18n.constructor}\" for \"i18n\" property of ${\n          expansion.sourceSpan.toString()}. Expected a \"Message\"`);\n    }\n    const message = expansion.i18n;\n    const vars: {[name: string]: t.BoundText} = {};\n    const placeholders: {[name: string]: t.Text|t.BoundText} = {};\n    // extract VARs from ICUs - we process them separately while\n    // assembling resulting message via goog.getMsg function, since\n    // we need to pass them to top-level goog.getMsg call\n    Object.keys(message.placeholders).forEach(key => {\n      const value = message.placeholders[key];\n      if (key.startsWith(I18N_ICU_VAR_PREFIX)) {\n        // Currently when the `plural` or `select` keywords in an ICU contain trailing spaces (e.g.\n        // `{count, select , ...}`), these spaces are also included into the key names in ICU vars\n        // (e.g. \"VAR_SELECT \"). These trailing spaces are not desirable, since they will later be\n        // converted into `_` symbols while normalizing placeholder names, which might lead to\n        // mismatches at runtime (i.e. placeholder will not be replaced with the correct value).\n        const formattedKey = key.trim();\n\n        const ast = this.bindingParser.parseInterpolationExpression(value.text, value.sourceSpan);\n\n        vars[formattedKey] = new t.BoundText(ast, value.sourceSpan);\n      } else {\n        placeholders[key] = this._visitTextWithInterpolation(value.text, value.sourceSpan, null);\n      }\n    });\n    return new t.Icu(vars, placeholders, expansion.sourceSpan, message);\n  }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase): null {\n    return null;\n  }\n\n  visitComment(comment: html.Comment): null {\n    if (this.options.collectCommentNodes) {\n      this.commentNodes.push(new t.Comment(comment.value || '', comment.sourceSpan));\n    }\n    return null;\n  }\n\n  // convert view engine `ParsedProperty` to a format suitable for IVY\n  private extractAttributes(\n      elementName: string, properties: ParsedProperty[],\n      i18nPropsMeta: {[key: string]: i18n.I18nMeta}):\n      {bound: t.BoundAttribute[], literal: t.TextAttribute[]} {\n    const bound: t.BoundAttribute[] = [];\n    const literal: t.TextAttribute[] = [];\n\n    properties.forEach(prop => {\n      const i18n = i18nPropsMeta[prop.name];\n      if (prop.isLiteral) {\n        literal.push(new t.TextAttribute(\n            prop.name, prop.expression.source || '', prop.sourceSpan, prop.keySpan, prop.valueSpan,\n            i18n));\n      } else {\n        // Note that validation is skipped and property mapping is disabled\n        // due to the fact that we need to make sure a given prop is not an\n        // input of a directive and directive matching happens at runtime.\n        const bep = this.bindingParser.createBoundElementProperty(\n            elementName, prop, /* skipValidation */ true, /* mapPropertyName */ false);\n        bound.push(t.BoundAttribute.fromBoundElementProperty(bep, i18n));\n      }\n    });\n\n    return {bound, literal};\n  }\n\n  private parseAttribute(\n      isTemplateElement: boolean, attribute: html.Attribute, matchableAttributes: string[][],\n      parsedProperties: ParsedProperty[], boundEvents: t.BoundEvent[], variables: t.Variable[],\n      references: t.Reference[]) {\n    const name = normalizeAttributeName(attribute.name);\n    const value = attribute.value;\n    const srcSpan = attribute.sourceSpan;\n    const absoluteOffset =\n        attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;\n\n    function createKeySpan(srcSpan: ParseSourceSpan, prefix: string, identifier: string) {\n      // We need to adjust the start location for the keySpan to account for the removed 'data-'\n      // prefix from `normalizeAttributeName`.\n      const normalizationAdjustment = attribute.name.length - name.length;\n      const keySpanStart = srcSpan.start.moveBy(prefix.length + normalizationAdjustment);\n      const keySpanEnd = keySpanStart.moveBy(identifier.length);\n      return new ParseSourceSpan(keySpanStart, keySpanEnd, keySpanStart, identifier);\n    }\n\n    const bindParts = name.match(BIND_NAME_REGEXP);\n\n    if (bindParts) {\n      if (bindParts[KW_BIND_IDX] != null) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_BIND_IDX], identifier);\n        this.bindingParser.parsePropertyBinding(\n            identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan,\n            matchableAttributes, parsedProperties, keySpan);\n\n      } else if (bindParts[KW_LET_IDX]) {\n        if (isTemplateElement) {\n          const identifier = bindParts[IDENT_KW_IDX];\n          const keySpan = createKeySpan(srcSpan, bindParts[KW_LET_IDX], identifier);\n          this.parseVariable(identifier, value, srcSpan, keySpan, attribute.valueSpan, variables);\n        } else {\n          this.reportError(`\"let-\" is only supported on ng-template elements.`, srcSpan);\n        }\n\n      } else if (bindParts[KW_REF_IDX]) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_REF_IDX], identifier);\n        this.parseReference(identifier, value, srcSpan, keySpan, attribute.valueSpan, references);\n      } else if (bindParts[KW_ON_IDX]) {\n        const events: ParsedEvent[] = [];\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_ON_IDX], identifier);\n        this.bindingParser.parseEvent(\n            identifier, value, /* isAssignmentEvent */ false, srcSpan,\n            attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);\n        addEvents(events, boundEvents);\n      } else if (bindParts[KW_BINDON_IDX]) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        const keySpan = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX], identifier);\n        this.bindingParser.parsePropertyBinding(\n            identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan,\n            matchableAttributes, parsedProperties, keySpan);\n        this.parseAssignmentEvent(\n            identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents,\n            keySpan);\n      } else if (bindParts[KW_AT_IDX]) {\n        const keySpan = createKeySpan(srcSpan, '', name);\n        this.bindingParser.parseLiteralAttr(\n            name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes,\n            parsedProperties, keySpan);\n      }\n      return true;\n    }\n\n    // We didn't see a kw-prefixed property binding, but we have not yet checked\n    // for the []/()/[()] syntax.\n    let delims: {start: string, end: string}|null = null;\n    if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {\n      delims = BINDING_DELIMS.BANANA_BOX;\n    } else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {\n      delims = BINDING_DELIMS.PROPERTY;\n    } else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {\n      delims = BINDING_DELIMS.EVENT;\n    }\n    if (delims !== null &&\n        // NOTE: older versions of the parser would match a start/end delimited\n        // binding iff the property name was terminated by the ending delimiter\n        // and the identifier in the binding was non-empty.\n        // TODO(ayazhafiz): update this to handle malformed bindings.\n        name.endsWith(delims.end) && name.length > delims.start.length + delims.end.length) {\n      const identifier = name.substring(delims.start.length, name.length - delims.end.length);\n      const keySpan = createKeySpan(srcSpan, delims.start, identifier);\n      if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {\n        this.bindingParser.parsePropertyBinding(\n            identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan,\n            matchableAttributes, parsedProperties, keySpan);\n        this.parseAssignmentEvent(\n            identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents,\n            keySpan);\n      } else if (delims.start === BINDING_DELIMS.PROPERTY.start) {\n        this.bindingParser.parsePropertyBinding(\n            identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan,\n            matchableAttributes, parsedProperties, keySpan);\n      } else {\n        const events: ParsedEvent[] = [];\n        this.bindingParser.parseEvent(\n            identifier, value, /* isAssignmentEvent */ false, srcSpan,\n            attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);\n        addEvents(events, boundEvents);\n      }\n\n      return true;\n    }\n\n    // No explicit binding found.\n    const keySpan = createKeySpan(srcSpan, '' /* prefix */, name);\n    const hasBinding = this.bindingParser.parsePropertyInterpolation(\n        name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan,\n        attribute.valueTokens ?? null);\n    return hasBinding;\n  }\n\n  private _visitTextWithInterpolation(\n      value: string, sourceSpan: ParseSourceSpan,\n      interpolatedTokens: InterpolatedAttributeToken[]|InterpolatedTextToken[]|null,\n      i18n?: i18n.I18nMeta): t.Text|t.BoundText {\n    const valueNoNgsp = replaceNgsp(value);\n    const expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan, interpolatedTokens);\n    return expr ? new t.BoundText(expr, sourceSpan, i18n) : new t.Text(valueNoNgsp, sourceSpan);\n  }\n\n  private parseVariable(\n      identifier: string, value: string, sourceSpan: ParseSourceSpan, keySpan: ParseSourceSpan,\n      valueSpan: ParseSourceSpan|undefined, variables: t.Variable[]) {\n    if (identifier.indexOf('-') > -1) {\n      this.reportError(`\"-\" is not allowed in variable names`, sourceSpan);\n    } else if (identifier.length === 0) {\n      this.reportError(`Variable does not have a name`, sourceSpan);\n    }\n\n    variables.push(new t.Variable(identifier, value, sourceSpan, keySpan, valueSpan));\n  }\n\n  private parseReference(\n      identifier: string, value: string, sourceSpan: ParseSourceSpan, keySpan: ParseSourceSpan,\n      valueSpan: ParseSourceSpan|undefined, references: t.Reference[]) {\n    if (identifier.indexOf('-') > -1) {\n      this.reportError(`\"-\" is not allowed in reference names`, sourceSpan);\n    } else if (identifier.length === 0) {\n      this.reportError(`Reference does not have a name`, sourceSpan);\n    } else if (references.some(reference => reference.name === identifier)) {\n      this.reportError(`Reference \"#${identifier}\" is defined more than once`, sourceSpan);\n    }\n\n    references.push(new t.Reference(identifier, value, sourceSpan, keySpan, valueSpan));\n  }\n\n  private parseAssignmentEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan,\n      valueSpan: ParseSourceSpan|undefined, targetMatchableAttrs: string[][],\n      boundEvents: t.BoundEvent[], keySpan: ParseSourceSpan) {\n    const events: ParsedEvent[] = [];\n    this.bindingParser.parseEvent(\n        `${name}Change`, `${expression} =$event`, /* isAssignmentEvent */ true, sourceSpan,\n        valueSpan || sourceSpan, targetMatchableAttrs, events, keySpan);\n    addEvents(events, boundEvents);\n  }\n\n  private reportError(\n      message: string, sourceSpan: ParseSourceSpan,\n      level: ParseErrorLevel = ParseErrorLevel.ERROR) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n}\n\nclass NonBindableVisitor implements html.Visitor {\n  visitElement(ast: html.Element): t.Element|null {\n    const preparsedElement = preparseElement(ast);\n    if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n        preparsedElement.type === PreparsedElementType.STYLE ||\n        preparsedElement.type === PreparsedElementType.STYLESHEET) {\n      // Skipping <script> for security reasons\n      // Skipping <style> and stylesheets as we already processed them\n      // in the StyleCompiler\n      return null;\n    }\n\n    const children: t.Node[] = html.visitAll(this, ast.children, null);\n    return new t.Element(\n        ast.name, html.visitAll(this, ast.attrs) as t.TextAttribute[],\n        /* inputs */[], /* outputs */[], children,\u00A0 /* references */[], ast.sourceSpan,\n        ast.startSourceSpan, ast.endSourceSpan);\n  }\n\n  visitComment(comment: html.Comment): any {\n    return null;\n  }\n\n  visitAttribute(attribute: html.Attribute): t.TextAttribute {\n    return new t.TextAttribute(\n        attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan,\n        attribute.valueSpan, attribute.i18n);\n  }\n\n  visitText(text: html.Text): t.Text {\n    return new t.Text(text.value, text.sourceSpan);\n  }\n\n  visitExpansion(expansion: html.Expansion): any {\n    return null;\n  }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase): any {\n    return null;\n  }\n}\n\nconst NON_BINDABLE_VISITOR = new NonBindableVisitor();\n\nfunction normalizeAttributeName(attrName: string): string {\n  return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n}\n\nfunction addEvents(events: ParsedEvent[], boundEvents: t.BoundEvent[]) {\n  boundEvents.push(...events.map(e => t.BoundEvent.fromParsedEvent(e)));\n}\n\nfunction isEmptyTextNode(node: html.Node): boolean {\n  return node instanceof html.Text && node.value.trim().length == 0;\n}\n\nfunction isCommentNode(node: html.Node): boolean {\n  return node instanceof html.Comment;\n}\n\nfunction textContents(node: html.Element): string|null {\n  if (node.children.length !== 1 || !(node.children[0] instanceof html.Text)) {\n    return null;\n  } else {\n    return (node.children[0] as html.Text).value;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST} from '../../../expression_parser/ast';\nimport * as i18n from '../../../i18n/i18n_ast';\nimport * as o from '../../../output/output_ast';\n\nimport {assembleBoundTextPlaceholders, getSeqNumberGenerator, updatePlaceholderMap, wrapI18nPlaceholder} from './util';\n\nenum TagType {\n  ELEMENT,\n  TEMPLATE,\n}\n\n/**\n * Generates an object that is used as a shared state between parent and all child contexts.\n */\nfunction setupRegistry() {\n  return {getUniqueId: getSeqNumberGenerator(), icus: new Map<string, any[]>()};\n}\n\n/**\n * I18nContext is a helper class which keeps track of all i18n-related aspects\n * (accumulates placeholders, bindings, etc) between i18nStart and i18nEnd instructions.\n *\n * When we enter a nested template, the top-level context is being passed down\n * to the nested component, which uses this context to generate a child instance\n * of I18nContext class (to handle nested template) and at the end, reconciles it back\n * with the parent context.\n *\n * @param index Instruction index of i18nStart, which initiates this context\n * @param ref Reference to a translation const that represents the content if thus context\n * @param level Nesting level defined for child contexts\n * @param templateIndex Instruction index of a template which this context belongs to\n * @param meta Meta information (id, meaning, description, etc) associated with this context\n */\nexport class I18nContext {\n  public readonly id: number;\n  public bindings = new Set<AST>();\n  public placeholders = new Map<string, any[]>();\n  public isEmitted: boolean = false;\n\n  private _registry!: any;\n  private _unresolvedCtxCount: number = 0;\n\n  constructor(\n      readonly index: number, readonly ref: o.ReadVarExpr, readonly level: number = 0,\n      readonly templateIndex: number|null = null, readonly meta: i18n.I18nMeta,\n      private registry?: any) {\n    this._registry = registry || setupRegistry();\n    this.id = this._registry.getUniqueId();\n  }\n\n  private appendTag(type: TagType, node: i18n.TagPlaceholder, index: number, closed?: boolean) {\n    if (node.isVoid && closed) {\n      return;  // ignore \"close\" for void tags\n    }\n    const ph = node.isVoid || !closed ? node.startName : node.closeName;\n    const content = {type, index, ctx: this.id, isVoid: node.isVoid, closed};\n    updatePlaceholderMap(this.placeholders, ph, content);\n  }\n\n  get icus() {\n    return this._registry.icus;\n  }\n  get isRoot() {\n    return this.level === 0;\n  }\n  get isResolved() {\n    return this._unresolvedCtxCount === 0;\n  }\n\n  getSerializedPlaceholders() {\n    const result = new Map<string, any[]>();\n    this.placeholders.forEach(\n        (values, key) => result.set(key, values.map(serializePlaceholderValue)));\n    return result;\n  }\n\n  // public API to accumulate i18n-related content\n  appendBinding(binding: AST) {\n    this.bindings.add(binding);\n  }\n  appendIcu(name: string, ref: o.Expression) {\n    updatePlaceholderMap(this._registry.icus, name, ref);\n  }\n  appendBoundText(node: i18n.I18nMeta) {\n    const phs = assembleBoundTextPlaceholders(node, this.bindings.size, this.id);\n    phs.forEach((values, key) => updatePlaceholderMap(this.placeholders, key, ...values));\n  }\n  appendTemplate(node: i18n.I18nMeta, index: number) {\n    // add open and close tags at the same time,\n    // since we process nested templates separately\n    this.appendTag(TagType.TEMPLATE, node as i18n.TagPlaceholder, index, false);\n    this.appendTag(TagType.TEMPLATE, node as i18n.TagPlaceholder, index, true);\n    this._unresolvedCtxCount++;\n  }\n  appendElement(node: i18n.I18nMeta, index: number, closed?: boolean) {\n    this.appendTag(TagType.ELEMENT, node as i18n.TagPlaceholder, index, closed);\n  }\n  appendProjection(node: i18n.I18nMeta, index: number) {\n    // Add open and close tags at the same time, since `<ng-content>` has no content,\n    // so when we come across `<ng-content>` we can register both open and close tags.\n    // Note: runtime i18n logic doesn't distinguish `<ng-content>` tag placeholders and\n    // regular element tag placeholders, so we generate element placeholders for both types.\n    this.appendTag(TagType.ELEMENT, node as i18n.TagPlaceholder, index, false);\n    this.appendTag(TagType.ELEMENT, node as i18n.TagPlaceholder, index, true);\n  }\n\n  /**\n   * Generates an instance of a child context based on the root one,\n   * when we enter a nested template within I18n section.\n   *\n   * @param index Instruction index of corresponding i18nStart, which initiates this context\n   * @param templateIndex Instruction index of a template which this context belongs to\n   * @param meta Meta information (id, meaning, description, etc) associated with this context\n   *\n   * @returns I18nContext instance\n   */\n  forkChildContext(index: number, templateIndex: number, meta: i18n.I18nMeta) {\n    return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);\n  }\n\n  /**\n   * Reconciles child context into parent one once the end of the i18n block is reached (i18nEnd).\n   *\n   * @param context Child I18nContext instance to be reconciled with parent context.\n   */\n  reconcileChildContext(context: I18nContext) {\n    // set the right context id for open and close\n    // template tags, so we can use it as sub-block ids\n    ['start', 'close'].forEach((op: string) => {\n      const key = (context.meta as any)[`${op}Name`];\n      const phs = this.placeholders.get(key) || [];\n      const tag = phs.find(findTemplateFn(this.id, context.templateIndex));\n      if (tag) {\n        tag.ctx = context.id;\n      }\n    });\n\n    // reconcile placeholders\n    const childPhs = context.placeholders;\n    childPhs.forEach((values: any[], key: string) => {\n      const phs = this.placeholders.get(key);\n      if (!phs) {\n        this.placeholders.set(key, values);\n        return;\n      }\n      // try to find matching template...\n      const tmplIdx = phs.findIndex(findTemplateFn(context.id, context.templateIndex));\n      if (tmplIdx >= 0) {\n        // ... if found - replace it with nested template content\n        const isCloseTag = key.startsWith('CLOSE');\n        const isTemplateTag = key.endsWith('NG-TEMPLATE');\n        if (isTemplateTag) {\n          // current template's content is placed before or after\n          // parent template tag, depending on the open/close attribute\n          phs.splice(tmplIdx + (isCloseTag ? 0 : 1), 0, ...values);\n        } else {\n          const idx = isCloseTag ? values.length - 1 : 0;\n          values[idx].tmpl = phs[tmplIdx];\n          phs.splice(tmplIdx, 1, ...values);\n        }\n      } else {\n        // ... otherwise just append content to placeholder value\n        phs.push(...values);\n      }\n      this.placeholders.set(key, phs);\n    });\n    this._unresolvedCtxCount--;\n  }\n}\n\n//\n// Helper methods\n//\n\nfunction wrap(symbol: string, index: number, contextId: number, closed?: boolean): string {\n  const state = closed ? '/' : '';\n  return wrapI18nPlaceholder(`${state}${symbol}${index}`, contextId);\n}\n\nfunction wrapTag(symbol: string, {index, ctx, isVoid}: any, closed?: boolean): string {\n  return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) :\n                  wrap(symbol, index, ctx, closed);\n}\n\nfunction findTemplateFn(ctx: number, templateIndex: number|null) {\n  return (token: any) => typeof token === 'object' && token.type === TagType.TEMPLATE &&\n      token.index === templateIndex && token.ctx === ctx;\n}\n\nfunction serializePlaceholderValue(value: any): string {\n  const element = (data: any, closed?: boolean) => wrapTag('#', data, closed);\n  const template = (data: any, closed?: boolean) => wrapTag('*', data, closed);\n  const projection = (data: any, closed?: boolean) => wrapTag('!', data, closed);\n\n  switch (value.type) {\n    case TagType.ELEMENT:\n      // close element tag\n      if (value.closed) {\n        return element(value, true) + (value.tmpl ? template(value.tmpl, true) : '');\n      }\n      // open element tag that also initiates a template\n      if (value.tmpl) {\n        return template(value.tmpl) + element(value) +\n            (value.isVoid ? template(value.tmpl, true) : '');\n      }\n      return element(value);\n\n    case TagType.TEMPLATE:\n      return template(value, value.closed);\n\n    default:\n      return value;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as i18n from '../../../i18n/i18n_ast';\n\nimport {formatI18nPlaceholderName} from './util';\n\nclass IcuSerializerVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text): any {\n    return text.value;\n  }\n\n  visitContainer(container: i18n.Container): any {\n    return container.children.map(child => child.visit(this)).join('');\n  }\n\n  visitIcu(icu: i18n.Icu): any {\n    const strCases =\n        Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    const result = `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\n    return result;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder): any {\n    return ph.isVoid ?\n        this.formatPh(ph.startName) :\n        `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${\n            this.formatPh(ph.closeName)}`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder): any {\n    return this.formatPh(ph.name);\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    return this.formatPh(ph.name);\n  }\n\n  private formatPh(value: string): string {\n    return `{${formatI18nPlaceholderName(value, /* useCamelCase */ false)}}`;\n  }\n}\n\nconst serializer = new IcuSerializerVisitor();\nexport function serializeIcuNode(icu: i18n.Icu): string {\n  return icu.visit(serializer);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst TAG_TO_PLACEHOLDER_NAMES: {[k: string]: string} = {\n  'A': 'LINK',\n  'B': 'BOLD_TEXT',\n  'BR': 'LINE_BREAK',\n  'EM': 'EMPHASISED_TEXT',\n  'H1': 'HEADING_LEVEL1',\n  'H2': 'HEADING_LEVEL2',\n  'H3': 'HEADING_LEVEL3',\n  'H4': 'HEADING_LEVEL4',\n  'H5': 'HEADING_LEVEL5',\n  'H6': 'HEADING_LEVEL6',\n  'HR': 'HORIZONTAL_RULE',\n  'I': 'ITALIC_TEXT',\n  'LI': 'LIST_ITEM',\n  'LINK': 'MEDIA_LINK',\n  'OL': 'ORDERED_LIST',\n  'P': 'PARAGRAPH',\n  'Q': 'QUOTATION',\n  'S': 'STRIKETHROUGH_TEXT',\n  'SMALL': 'SMALL_TEXT',\n  'SUB': 'SUBSTRIPT',\n  'SUP': 'SUPERSCRIPT',\n  'TBODY': 'TABLE_BODY',\n  'TD': 'TABLE_CELL',\n  'TFOOT': 'TABLE_FOOTER',\n  'TH': 'TABLE_HEADER_CELL',\n  'THEAD': 'TABLE_HEADER',\n  'TR': 'TABLE_ROW',\n  'TT': 'MONOSPACED_TEXT',\n  'U': 'UNDERLINED_TEXT',\n  'UL': 'UNORDERED_LIST',\n};\n\n/**\n * Creates unique names for placeholder with different content.\n *\n * Returns the same placeholder name when the content is identical.\n */\nexport class PlaceholderRegistry {\n  // Count the occurrence of the base name top generate a unique name\n  private _placeHolderNameCounts: {[k: string]: number} = {};\n  // Maps signature to placeholder names\n  private _signatureToName: {[k: string]: string} = {};\n\n  getStartTagPlaceholderName(tag: string, attrs: {[k: string]: string}, isVoid: boolean): string {\n    const signature = this._hashTag(tag, attrs, isVoid);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n\n    const upperTag = tag.toUpperCase();\n    const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n    const name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);\n\n    this._signatureToName[signature] = name;\n\n    return name;\n  }\n\n  getCloseTagPlaceholderName(tag: string): string {\n    const signature = this._hashClosingTag(tag);\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n\n    const upperTag = tag.toUpperCase();\n    const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n    const name = this._generateUniqueName(`CLOSE_${baseName}`);\n\n    this._signatureToName[signature] = name;\n\n    return name;\n  }\n\n  getPlaceholderName(name: string, content: string): string {\n    const upperName = name.toUpperCase();\n    const signature = `PH: ${upperName}=${content}`;\n    if (this._signatureToName[signature]) {\n      return this._signatureToName[signature];\n    }\n\n    const uniqueName = this._generateUniqueName(upperName);\n    this._signatureToName[signature] = uniqueName;\n\n    return uniqueName;\n  }\n\n  getUniquePlaceholder(name: string): string {\n    return this._generateUniqueName(name.toUpperCase());\n  }\n\n  // Generate a hash for a tag - does not take attribute order into account\n  private _hashTag(tag: string, attrs: {[k: string]: string}, isVoid: boolean): string {\n    const start = `<${tag}`;\n    const strAttrs = Object.keys(attrs).sort().map((name) => ` ${name}=${attrs[name]}`).join('');\n    const end = isVoid ? '/>' : `></${tag}>`;\n\n    return start + strAttrs + end;\n  }\n\n  private _hashClosingTag(tag: string): string {\n    return this._hashTag(`/${tag}`, {}, false);\n  }\n\n  private _generateUniqueName(base: string): string {\n    const seen = this._placeHolderNameCounts.hasOwnProperty(base);\n    if (!seen) {\n      this._placeHolderNameCounts[base] = 1;\n      return base;\n    }\n\n    const id = this._placeHolderNameCounts[base];\n    this._placeHolderNameCounts[base] = id + 1;\n    return `${base}_${id}`;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Lexer as ExpressionLexer} from '../expression_parser/lexer';\nimport {Parser as ExpressionParser} from '../expression_parser/parser';\nimport * as html from '../ml_parser/ast';\nimport {getHtmlTagDefinition} from '../ml_parser/html_tags';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {InterpolatedAttributeToken, InterpolatedTextToken, TokenType} from '../ml_parser/tokens';\nimport {ParseSourceSpan} from '../parse_util';\n\nimport * as i18n from './i18n_ast';\nimport {PlaceholderRegistry} from './serializers/placeholder';\n\nconst _expParser = new ExpressionParser(new ExpressionLexer());\n\nexport type VisitNodeFn = (html: html.Node, i18n: i18n.Node) => i18n.Node;\n\nexport interface I18nMessageFactory {\n  (nodes: html.Node[], meaning: string|undefined, description: string|undefined,\n   customId: string|undefined, visitNodeFn?: VisitNodeFn): i18n.Message;\n}\n\n/**\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n */\nexport function createI18nMessageFactory(interpolationConfig: InterpolationConfig):\n    I18nMessageFactory {\n  const visitor = new _I18nVisitor(_expParser, interpolationConfig);\n  return (nodes, meaning, description, customId, visitNodeFn) =>\n             visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n}\n\ninterface I18nMessageVisitorContext {\n  isIcu: boolean;\n  icuDepth: number;\n  placeholderRegistry: PlaceholderRegistry;\n  placeholderToContent: {[phName: string]: i18n.MessagePlaceholder};\n  placeholderToMessage: {[phName: string]: i18n.Message};\n  visitNodeFn: VisitNodeFn;\n}\n\nfunction noopVisitNodeFn(_html: html.Node, i18n: i18n.Node): i18n.Node {\n  return i18n;\n}\n\nclass _I18nVisitor implements html.Visitor {\n  constructor(\n      private _expressionParser: ExpressionParser,\n      private _interpolationConfig: InterpolationConfig) {}\n\n  public toI18nMessage(\n      nodes: html.Node[], meaning = '', description = '', customId = '',\n      visitNodeFn: VisitNodeFn|undefined): i18n.Message {\n    const context: I18nMessageVisitorContext = {\n      isIcu: nodes.length == 1 && nodes[0] instanceof html.Expansion,\n      icuDepth: 0,\n      placeholderRegistry: new PlaceholderRegistry(),\n      placeholderToContent: {},\n      placeholderToMessage: {},\n      visitNodeFn: visitNodeFn || noopVisitNodeFn,\n    };\n\n    const i18nodes: i18n.Node[] = html.visitAll(this, nodes, context);\n\n    return new i18n.Message(\n        i18nodes, context.placeholderToContent, context.placeholderToMessage, meaning, description,\n        customId);\n  }\n\n  visitElement(el: html.Element, context: I18nMessageVisitorContext): i18n.Node {\n    const children = html.visitAll(this, el.children, context);\n    const attrs: {[k: string]: string} = {};\n    el.attrs.forEach(attr => {\n      // Do not visit the attributes, translatable ones are top-level ASTs\n      attrs[attr.name] = attr.value;\n    });\n\n    const isVoid: boolean = getHtmlTagDefinition(el.name).isVoid;\n    const startPhName =\n        context.placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n    context.placeholderToContent[startPhName] = {\n      text: el.startSourceSpan.toString(),\n      sourceSpan: el.startSourceSpan,\n    };\n\n    let closePhName = '';\n\n    if (!isVoid) {\n      closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(el.name);\n      context.placeholderToContent[closePhName] = {\n        text: `</${el.name}>`,\n        sourceSpan: el.endSourceSpan ?? el.sourceSpan,\n      };\n    }\n\n    const node = new i18n.TagPlaceholder(\n        el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan,\n        el.startSourceSpan, el.endSourceSpan);\n    return context.visitNodeFn(el, node);\n  }\n\n  visitAttribute(attribute: html.Attribute, context: I18nMessageVisitorContext): i18n.Node {\n    const node = attribute.valueTokens === undefined || attribute.valueTokens.length === 1 ?\n        new i18n.Text(attribute.value, attribute.valueSpan || attribute.sourceSpan) :\n        this._visitTextWithInterpolation(\n            attribute.valueTokens, attribute.valueSpan || attribute.sourceSpan, context,\n            attribute.i18n);\n    return context.visitNodeFn(attribute, node);\n  }\n\n  visitText(text: html.Text, context: I18nMessageVisitorContext): i18n.Node {\n    const node = text.tokens.length === 1 ?\n        new i18n.Text(text.value, text.sourceSpan) :\n        this._visitTextWithInterpolation(text.tokens, text.sourceSpan, context, text.i18n);\n    return context.visitNodeFn(text, node);\n  }\n\n  visitComment(comment: html.Comment, context: I18nMessageVisitorContext): i18n.Node|null {\n    return null;\n  }\n\n  visitExpansion(icu: html.Expansion, context: I18nMessageVisitorContext): i18n.Node {\n    context.icuDepth++;\n    const i18nIcuCases: {[k: string]: i18n.Node} = {};\n    const i18nIcu = new i18n.Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n    icu.cases.forEach((caze): void => {\n      i18nIcuCases[caze.value] = new i18n.Container(\n          caze.expression.map((node) => node.visit(this, context)), caze.expSourceSpan);\n    });\n    context.icuDepth--;\n\n    if (context.isIcu || context.icuDepth > 0) {\n      // Returns an ICU node when:\n      // - the message (vs a part of the message) is an ICU message, or\n      // - the ICU message is nested.\n      const expPh = context.placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);\n      i18nIcu.expressionPlaceholder = expPh;\n      context.placeholderToContent[expPh] = {\n        text: icu.switchValue,\n        sourceSpan: icu.switchValueSourceSpan,\n      };\n      return context.visitNodeFn(icu, i18nIcu);\n    }\n\n    // Else returns a placeholder\n    // ICU placeholders should not be replaced with their original content but with the their\n    // translations.\n    // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n    const phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n    context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);\n    const node = new i18n.IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n    return context.visitNodeFn(icu, node);\n  }\n\n  visitExpansionCase(_icuCase: html.ExpansionCase, _context: I18nMessageVisitorContext): i18n.Node {\n    throw new Error('Unreachable code');\n  }\n\n  /**\n   * Convert, text and interpolated tokens up into text and placeholder pieces.\n   *\n   * @param tokens The text and interpolated tokens.\n   * @param sourceSpan The span of the whole of the `text` string.\n   * @param context The current context of the visitor, used to compute and store placeholders.\n   * @param previousI18n Any i18n metadata associated with this `text` from a previous pass.\n   */\n  private _visitTextWithInterpolation(\n      tokens: (InterpolatedTextToken|InterpolatedAttributeToken)[], sourceSpan: ParseSourceSpan,\n      context: I18nMessageVisitorContext, previousI18n: i18n.I18nMeta|undefined): i18n.Node {\n    // Return a sequence of `Text` and `Placeholder` nodes grouped in a `Container`.\n    const nodes: i18n.Node[] = [];\n    // We will only create a container if there are actually interpolations,\n    // so this flag tracks that.\n    let hasInterpolation = false;\n    for (const token of tokens) {\n      switch (token.type) {\n        case TokenType.INTERPOLATION:\n        case TokenType.ATTR_VALUE_INTERPOLATION:\n          hasInterpolation = true;\n          const expression = token.parts[1];\n          const baseName = extractPlaceholderName(expression) || 'INTERPOLATION';\n          const phName = context.placeholderRegistry.getPlaceholderName(baseName, expression);\n          context.placeholderToContent[phName] = {\n            text: token.parts.join(''),\n            sourceSpan: token.sourceSpan\n          };\n          nodes.push(new i18n.Placeholder(expression, phName, token.sourceSpan));\n          break;\n        default:\n          if (token.parts[0].length > 0) {\n            // This token is text or an encoded entity.\n            // If it is following on from a previous text node then merge it into that node\n            // Otherwise, if it is following an interpolation, then add a new node.\n            const previous = nodes[nodes.length - 1];\n            if (previous instanceof i18n.Text) {\n              previous.value += token.parts[0];\n              previous.sourceSpan = new ParseSourceSpan(\n                  previous.sourceSpan.start, token.sourceSpan.end, previous.sourceSpan.fullStart,\n                  previous.sourceSpan.details);\n            } else {\n              nodes.push(new i18n.Text(token.parts[0], token.sourceSpan));\n            }\n          }\n          break;\n      }\n    }\n\n    if (hasInterpolation) {\n      // Whitespace removal may have invalidated the interpolation source-spans.\n      reusePreviousSourceSpans(nodes, previousI18n);\n      return new i18n.Container(nodes, sourceSpan);\n    } else {\n      return nodes[0];\n    }\n  }\n}\n\n/**\n * Re-use the source-spans from `previousI18n` metadata for the `nodes`.\n *\n * Whitespace removal can invalidate the source-spans of interpolation nodes, so we\n * reuse the source-span stored from a previous pass before the whitespace was removed.\n *\n * @param nodes The `Text` and `Placeholder` nodes to be processed.\n * @param previousI18n Any i18n metadata for these `nodes` stored from a previous pass.\n */\nfunction reusePreviousSourceSpans(nodes: i18n.Node[], previousI18n: i18n.I18nMeta|undefined): void {\n  if (previousI18n instanceof i18n.Message) {\n    // The `previousI18n` is an i18n `Message`, so we are processing an `Attribute` with i18n\n    // metadata. The `Message` should consist only of a single `Container` that contains the\n    // parts (`Text` and `Placeholder`) to process.\n    assertSingleContainerMessage(previousI18n);\n    previousI18n = previousI18n.nodes[0];\n  }\n\n  if (previousI18n instanceof i18n.Container) {\n    // The `previousI18n` is a `Container`, which means that this is a second i18n extraction pass\n    // after whitespace has been removed from the AST nodes.\n    assertEquivalentNodes(previousI18n.children, nodes);\n\n    // Reuse the source-spans from the first pass.\n    for (let i = 0; i < nodes.length; i++) {\n      nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;\n    }\n  }\n}\n\n/**\n * Asserts that the `message` contains exactly one `Container` node.\n */\nfunction assertSingleContainerMessage(message: i18n.Message): void {\n  const nodes = message.nodes;\n  if (nodes.length !== 1 || !(nodes[0] instanceof i18n.Container)) {\n    throw new Error(\n        'Unexpected previous i18n message - expected it to consist of only a single `Container` node.');\n  }\n}\n\n/**\n * Asserts that the `previousNodes` and `node` collections have the same number of elements and\n * corresponding elements have the same node type.\n */\nfunction assertEquivalentNodes(previousNodes: i18n.Node[], nodes: i18n.Node[]): void {\n  if (previousNodes.length !== nodes.length) {\n    throw new Error('The number of i18n message children changed between first and second pass.');\n  }\n  if (previousNodes.some((node, i) => nodes[i].constructor !== node.constructor)) {\n    throw new Error(\n        'The types of the i18n message children changed between first and second pass.');\n  }\n}\n\nconst _CUSTOM_PH_EXP =\n    /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\n\nfunction extractPlaceholderName(input: string): string {\n  return input.split(_CUSTOM_PH_EXP)[2];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseError, ParseSourceSpan} from '../parse_util';\n\n/**\n * An i18n error.\n */\nexport class I18nError extends ParseError {\n  constructor(span: ParseSourceSpan, msg: string) {\n    super(span, msg);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {computeDecimalDigest, computeDigest, decimalDigest} from '../../../i18n/digest';\nimport * as i18n from '../../../i18n/i18n_ast';\nimport {createI18nMessageFactory, VisitNodeFn} from '../../../i18n/i18n_parser';\nimport {I18nError} from '../../../i18n/parse_util';\nimport * as html from '../../../ml_parser/ast';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../../../ml_parser/interpolation_config';\nimport {ParseTreeResult} from '../../../ml_parser/parser';\nimport * as o from '../../../output/output_ast';\nimport {isTrustedTypesSink} from '../../../schema/trusted_types_sinks';\n\nimport {hasI18nAttrs, I18N_ATTR, I18N_ATTR_PREFIX, icuFromI18nMessage} from './util';\n\nexport type I18nMeta = {\n  id?: string,\n  customId?: string,\n  legacyIds?: string[],\n  description?: string,\n  meaning?: string\n};\n\n\nconst setI18nRefs: VisitNodeFn = (htmlNode, i18nNode) => {\n  if (htmlNode instanceof html.NodeWithI18n) {\n    if (i18nNode instanceof i18n.IcuPlaceholder && htmlNode.i18n instanceof i18n.Message) {\n      // This html node represents an ICU but this is a second processing pass, and the legacy id\n      // was computed in the previous pass and stored in the `i18n` property as a message.\n      // We are about to wipe out that property so capture the previous message to be reused when\n      // generating the message for this ICU later. See `_generateI18nMessage()`.\n      i18nNode.previousMessage = htmlNode.i18n;\n    }\n    htmlNode.i18n = i18nNode;\n  }\n  return i18nNode;\n};\n\n/**\n * This visitor walks over HTML parse tree and converts information stored in\n * i18n-related attributes (\"i18n\" and \"i18n-*\") into i18n meta object that is\n * stored with other element's and attribute's information.\n */\nexport class I18nMetaVisitor implements html.Visitor {\n  // whether visited nodes contain i18n information\n  public hasI18nMeta: boolean = false;\n  private _errors: I18nError[] = [];\n\n  // i18n message generation factory\n  private _createI18nMessage = createI18nMessageFactory(this.interpolationConfig);\n\n  constructor(\n      private interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG,\n      private keepI18nAttrs = false, private enableI18nLegacyMessageIdFormat = false) {}\n\n  private _generateI18nMessage(\n      nodes: html.Node[], meta: string|i18n.I18nMeta = '',\n      visitNodeFn?: VisitNodeFn): i18n.Message {\n    const {meaning, description, customId} = this._parseMetadata(meta);\n    const message = this._createI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n    this._setMessageId(message, meta);\n    this._setLegacyIds(message, meta);\n    return message;\n  }\n\n  visitAllWithErrors(nodes: html.Node[]): ParseTreeResult {\n    const result = nodes.map(node => node.visit(this, null));\n    return new ParseTreeResult(result, this._errors);\n  }\n\n  visitElement(element: html.Element): any {\n    let message: i18n.Message|undefined = undefined;\n\n    if (hasI18nAttrs(element)) {\n      this.hasI18nMeta = true;\n      const attrs: html.Attribute[] = [];\n      const attrsMeta: {[key: string]: string} = {};\n\n      for (const attr of element.attrs) {\n        if (attr.name === I18N_ATTR) {\n          // root 'i18n' node attribute\n          const i18n = element.i18n || attr.value;\n          message = this._generateI18nMessage(element.children, i18n, setI18nRefs);\n          if (message.nodes.length === 0) {\n            // Ignore the message if it is empty.\n            message = undefined;\n          }\n          // Store the message on the element\n          element.i18n = message;\n        } else if (attr.name.startsWith(I18N_ATTR_PREFIX)) {\n          // 'i18n-*' attributes\n          const name = attr.name.slice(I18N_ATTR_PREFIX.length);\n          if (isTrustedTypesSink(element.name, name)) {\n            this._reportError(\n                attr, `Translating attribute '${name}' is disallowed for security reasons.`);\n          } else {\n            attrsMeta[name] = attr.value;\n          }\n        } else {\n          // non-i18n attributes\n          attrs.push(attr);\n        }\n      }\n\n      // set i18n meta for attributes\n      if (Object.keys(attrsMeta).length) {\n        for (const attr of attrs) {\n          const meta = attrsMeta[attr.name];\n          // do not create translation for empty attributes\n          if (meta !== undefined && attr.value) {\n            attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);\n          }\n        }\n      }\n\n      if (!this.keepI18nAttrs) {\n        // update element's attributes,\n        // keeping only non-i18n related ones\n        element.attrs = attrs;\n      }\n    }\n    html.visitAll(this, element.children, message);\n    return element;\n  }\n\n  visitExpansion(expansion: html.Expansion, currentMessage: i18n.Message|null): any {\n    let message;\n    const meta = expansion.i18n;\n    this.hasI18nMeta = true;\n    if (meta instanceof i18n.IcuPlaceholder) {\n      // set ICU placeholder name (e.g. \"ICU_1\"),\n      // generated while processing root element contents,\n      // so we can reference it when we output translation\n      const name = meta.name;\n      message = this._generateI18nMessage([expansion], meta);\n      const icu = icuFromI18nMessage(message);\n      icu.name = name;\n      if (currentMessage !== null) {\n        // Also update the placeholderToMessage map with this new message\n        currentMessage.placeholderToMessage[name] = message;\n      }\n    } else {\n      // ICU is a top level message, try to use metadata from container element if provided via\n      // `context` argument. Note: context may not be available for standalone ICUs (without\n      // wrapping element), so fallback to ICU metadata in this case.\n      message = this._generateI18nMessage([expansion], currentMessage || meta);\n    }\n    expansion.i18n = message;\n    return expansion;\n  }\n\n  visitText(text: html.Text): any {\n    return text;\n  }\n  visitAttribute(attribute: html.Attribute): any {\n    return attribute;\n  }\n  visitComment(comment: html.Comment): any {\n    return comment;\n  }\n  visitExpansionCase(expansionCase: html.ExpansionCase): any {\n    return expansionCase;\n  }\n\n  /**\n   * Parse the general form `meta` passed into extract the explicit metadata needed to create a\n   * `Message`.\n   *\n   * There are three possibilities for the `meta` variable\n   * 1) a string from an `i18n` template attribute: parse it to extract the metadata values.\n   * 2) a `Message` from a previous processing pass: reuse the metadata values in the message.\n   * 4) other: ignore this and just process the message metadata as normal\n   *\n   * @param meta the bucket that holds information about the message\n   * @returns the parsed metadata.\n   */\n  private _parseMetadata(meta: string|i18n.I18nMeta): I18nMeta {\n    return typeof meta === 'string'  ? parseI18nMeta(meta) :\n        meta instanceof i18n.Message ? meta :\n                                       {};\n  }\n\n  /**\n   * Generate (or restore) message id if not specified already.\n   */\n  private _setMessageId(message: i18n.Message, meta: string|i18n.I18nMeta): void {\n    if (!message.id) {\n      message.id = meta instanceof i18n.Message && meta.id || decimalDigest(message);\n    }\n  }\n\n  /**\n   * Update the `message` with a `legacyId` if necessary.\n   *\n   * @param message the message whose legacy id should be set\n   * @param meta information about the message being processed\n   */\n  private _setLegacyIds(message: i18n.Message, meta: string|i18n.I18nMeta): void {\n    if (this.enableI18nLegacyMessageIdFormat) {\n      message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];\n    } else if (typeof meta !== 'string') {\n      // This occurs if we are doing the 2nd pass after whitespace removal (see `parseTemplate()` in\n      // `packages/compiler/src/render3/view/template.ts`).\n      // In that case we want to reuse the legacy message generated in the 1st pass (see\n      // `setI18nRefs()`).\n      const previousMessage = meta instanceof i18n.Message ? meta :\n          meta instanceof i18n.IcuPlaceholder              ? meta.previousMessage :\n                                                             undefined;\n      message.legacyIds = previousMessage ? previousMessage.legacyIds : [];\n    }\n  }\n\n  private _reportError(node: html.Node, msg: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, msg));\n  }\n}\n\n/** I18n separators for metadata **/\nconst I18N_MEANING_SEPARATOR = '|';\nconst I18N_ID_SEPARATOR = '@@';\n\n/**\n * Parses i18n metas like:\n *  - \"@@id\",\n *  - \"description[@@id]\",\n *  - \"meaning|description[@@id]\"\n * and returns an object with parsed output.\n *\n * @param meta String that represents i18n meta\n * @returns Object with id, meaning and description fields\n */\nexport function parseI18nMeta(meta: string = ''): I18nMeta {\n  let customId: string|undefined;\n  let meaning: string|undefined;\n  let description: string|undefined;\n\n  meta = meta.trim();\n  if (meta) {\n    const idIndex = meta.indexOf(I18N_ID_SEPARATOR);\n    const descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);\n    let meaningAndDesc: string;\n    [meaningAndDesc, customId] =\n        (idIndex > -1) ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''];\n    [meaning, description] = (descIndex > -1) ?\n        [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n        ['', meaningAndDesc];\n  }\n\n  return {customId, meaning, description};\n}\n\n// Converts i18n meta information for a message (id, description, meaning)\n// to a JsDoc statement formatted as expected by the Closure compiler.\nexport function i18nMetaToJSDoc(meta: I18nMeta): o.JSDocComment {\n  const tags: o.JSDocTag[] = [];\n  if (meta.description) {\n    tags.push({tagName: o.JSDocTagName.Desc, text: meta.description});\n  } else {\n    // Suppress the JSCompiler warning that a `@desc` was not given for this message.\n    tags.push({tagName: o.JSDocTagName.Suppress, text: '{msgDescriptions}'});\n  }\n  if (meta.meaning) {\n    tags.push({tagName: o.JSDocTagName.Meaning, text: meta.meaning});\n  }\n  return o.jsDocComment(tags);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as i18n from '../../../i18n/i18n_ast';\nimport {mapLiteral} from '../../../output/map_util';\nimport * as o from '../../../output/output_ast';\n\nimport {serializeIcuNode} from './icu_serializer';\nimport {i18nMetaToJSDoc} from './meta';\nimport {formatI18nPlaceholderName, formatI18nPlaceholderNamesInMap} from './util';\n\n/** Closure uses `goog.getMsg(message)` to lookup translations */\nconst GOOG_GET_MSG = 'goog.getMsg';\n\n/**\n * Generates a `goog.getMsg()` statement and reassignment. The template:\n *\n * ```html\n * <div i18n>Sent from {{ sender }} to <span class=\"receiver\">{{ receiver }}</span></div>\n * ```\n *\n * Generates:\n *\n * ```typescript\n * const MSG_FOO = goog.getMsg(\n *   // Message template.\n *   'Sent from {$interpolation} to {$startTagSpan}{$interpolation_1}{$closeTagSpan}.',\n *   // Placeholder values, set to magic strings which get replaced by the Angular runtime.\n *   {\n *     'interpolation': '\\uFFFD0\\uFFFD',\n *     'startTagSpan': '\\uFFFD1\\uFFFD',\n *     'interpolation_1': '\\uFFFD2\\uFFFD',\n *     'closeTagSpan': '\\uFFFD3\\uFFFD',\n *   },\n *   // Options bag.\n *   {\n *     // Maps each placeholder to the original Angular source code which generates it's value.\n *     original_code: {\n *       'interpolation': '{{ sender }}',\n *       'startTagSpan': '<span class=\"receiver\">',\n *       'interpolation_1': '{{ receiver }}',\n *       'closeTagSpan': '</span>',\n *     },\n *   },\n * );\n * const I18N_0 = MSG_FOO;\n * ```\n */\nexport function createGoogleGetMsgStatements(\n    variable: o.ReadVarExpr, message: i18n.Message, closureVar: o.ReadVarExpr,\n    placeholderValues: {[name: string]: o.Expression}): o.Statement[] {\n  const messageString = serializeI18nMessageForGetMsg(message);\n  const args = [o.literal(messageString) as o.Expression];\n  if (Object.keys(placeholderValues).length) {\n    // Message template parameters containing the magic strings replaced by the Angular runtime with\n    // real data, e.g. `{'interpolation': '\\uFFFD0\\uFFFD'}`.\n    args.push(mapLiteral(\n        formatI18nPlaceholderNamesInMap(placeholderValues, true /* useCamelCase */),\n        true /* quoted */));\n\n    // Message options object, which contains original source code for placeholders (as they are\n    // present in a template, e.g.\n    // `{original_code: {'interpolation': '{{ name }}', 'startTagSpan': '<span>'}}`.\n    args.push(mapLiteral({\n      original_code:\n          o.literalMap(Object.keys(placeholderValues)\n                           .map((param) => ({\n                                  key: formatI18nPlaceholderName(param),\n                                  quoted: true,\n                                  value: message.placeholders[param] ?\n                                      // Get source span for typical placeholder if it exists.\n                                      o.literal(message.placeholders[param].sourceSpan.toString()) :\n                                      // Otherwise must be an ICU expression, get it's source span.\n                                      o.literal(\n                                          message.placeholderToMessage[param]\n                                              .nodes.map((node) => node.sourceSpan.toString())\n                                              .join(''),\n                                          ),\n                                }))),\n    }));\n  }\n\n  // /**\n  //  * @desc description of message\n  //  * @meaning meaning of message\n  //  */\n  // const MSG_... = goog.getMsg(..);\n  // I18N_X = MSG_...;\n  const googGetMsgStmt = closureVar.set(o.variable(GOOG_GET_MSG).callFn(args)).toConstDecl();\n  googGetMsgStmt.addLeadingComment(i18nMetaToJSDoc(message));\n  const i18nAssignmentStmt = new o.ExpressionStatement(variable.set(closureVar));\n  return [googGetMsgStmt, i18nAssignmentStmt];\n}\n\n/**\n * This visitor walks over i18n tree and generates its string representation, including ICUs and\n * placeholders in `{$placeholder}` (for plain messages) or `{PLACEHOLDER}` (inside ICUs) format.\n */\nclass GetMsgSerializerVisitor implements i18n.Visitor {\n  private formatPh(value: string): string {\n    return `{$${formatI18nPlaceholderName(value)}}`;\n  }\n\n  visitText(text: i18n.Text): any {\n    return text.value;\n  }\n\n  visitContainer(container: i18n.Container): any {\n    return container.children.map(child => child.visit(this)).join('');\n  }\n\n  visitIcu(icu: i18n.Icu): any {\n    return serializeIcuNode(icu);\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder): any {\n    return ph.isVoid ?\n        this.formatPh(ph.startName) :\n        `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${\n            this.formatPh(ph.closeName)}`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder): any {\n    return this.formatPh(ph.name);\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    return this.formatPh(ph.name);\n  }\n}\n\nconst serializerVisitor = new GetMsgSerializerVisitor();\n\nexport function serializeI18nMessageForGetMsg(message: i18n.Message): string {\n  return message.nodes.map(node => node.visit(serializerVisitor, null)).join('');\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as i18n from '../../../i18n/i18n_ast';\nimport * as o from '../../../output/output_ast';\nimport {ParseLocation, ParseSourceSpan} from '../../../parse_util';\n\nimport {serializeIcuNode} from './icu_serializer';\nimport {formatI18nPlaceholderName} from './util';\n\nexport function createLocalizeStatements(\n    variable: o.ReadVarExpr, message: i18n.Message,\n    params: {[name: string]: o.Expression}): o.Statement[] {\n  const {messageParts, placeHolders} = serializeI18nMessageForLocalize(message);\n  const sourceSpan = getSourceSpan(message);\n  const expressions = placeHolders.map(ph => params[ph.text]);\n  const localizedString =\n      o.localizedString(message, messageParts, placeHolders, expressions, sourceSpan);\n  const variableInitialization = variable.set(localizedString);\n  return [new o.ExpressionStatement(variableInitialization)];\n}\n\n/**\n * This visitor walks over an i18n tree, capturing literal strings and placeholders.\n *\n * The result can be used for generating the `$localize` tagged template literals.\n */\nclass LocalizeSerializerVisitor implements i18n.Visitor {\n  constructor(\n      private placeholderToMessage: {[phName: string]: i18n.Message},\n      private pieces: o.MessagePiece[]) {}\n\n  visitText(text: i18n.Text): any {\n    if (this.pieces[this.pieces.length - 1] instanceof o.LiteralPiece) {\n      // Two literal pieces in a row means that there was some comment node in-between.\n      this.pieces[this.pieces.length - 1].text += text.value;\n    } else {\n      const sourceSpan = new ParseSourceSpan(\n          text.sourceSpan.fullStart, text.sourceSpan.end, text.sourceSpan.fullStart,\n          text.sourceSpan.details);\n      this.pieces.push(new o.LiteralPiece(text.value, sourceSpan));\n    }\n  }\n\n  visitContainer(container: i18n.Container): any {\n    container.children.forEach(child => child.visit(this));\n  }\n\n  visitIcu(icu: i18n.Icu): any {\n    this.pieces.push(new o.LiteralPiece(serializeIcuNode(icu), icu.sourceSpan));\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder): any {\n    this.pieces.push(\n        this.createPlaceholderPiece(ph.startName, ph.startSourceSpan ?? ph.sourceSpan));\n    if (!ph.isVoid) {\n      ph.children.forEach(child => child.visit(this));\n      this.pieces.push(\n          this.createPlaceholderPiece(ph.closeName, ph.endSourceSpan ?? ph.sourceSpan));\n    }\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder): any {\n    this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder): any {\n    this.pieces.push(\n        this.createPlaceholderPiece(ph.name, ph.sourceSpan, this.placeholderToMessage[ph.name]));\n  }\n\n  private createPlaceholderPiece(\n      name: string, sourceSpan: ParseSourceSpan,\n      associatedMessage?: i18n.Message): o.PlaceholderPiece {\n    return new o.PlaceholderPiece(\n        formatI18nPlaceholderName(name, /* useCamelCase */ false), sourceSpan, associatedMessage);\n  }\n}\n\n/**\n * Serialize an i18n message into two arrays: messageParts and placeholders.\n *\n * These arrays will be used to generate `$localize` tagged template literals.\n *\n * @param message The message to be serialized.\n * @returns an object containing the messageParts and placeholders.\n */\nexport function serializeI18nMessageForLocalize(message: i18n.Message):\n    {messageParts: o.LiteralPiece[], placeHolders: o.PlaceholderPiece[]} {\n  const pieces: o.MessagePiece[] = [];\n  const serializerVisitor = new LocalizeSerializerVisitor(message.placeholderToMessage, pieces);\n  message.nodes.forEach(node => node.visit(serializerVisitor));\n  return processMessagePieces(pieces);\n}\n\nfunction getSourceSpan(message: i18n.Message): ParseSourceSpan {\n  const startNode = message.nodes[0];\n  const endNode = message.nodes[message.nodes.length - 1];\n  return new ParseSourceSpan(\n      startNode.sourceSpan.fullStart, endNode.sourceSpan.end, startNode.sourceSpan.fullStart,\n      startNode.sourceSpan.details);\n}\n\n/**\n * Convert the list of serialized MessagePieces into two arrays.\n *\n * One contains the literal string pieces and the other the placeholders that will be replaced by\n * expressions when rendering `$localize` tagged template literals.\n *\n * @param pieces The pieces to process.\n * @returns an object containing the messageParts and placeholders.\n */\nfunction processMessagePieces(pieces: o.MessagePiece[]):\n    {messageParts: o.LiteralPiece[], placeHolders: o.PlaceholderPiece[]} {\n  const messageParts: o.LiteralPiece[] = [];\n  const placeHolders: o.PlaceholderPiece[] = [];\n\n  if (pieces[0] instanceof o.PlaceholderPiece) {\n    // The first piece was a placeholder so we need to add an initial empty message part.\n    messageParts.push(createEmptyMessagePart(pieces[0].sourceSpan.start));\n  }\n\n  for (let i = 0; i < pieces.length; i++) {\n    const part = pieces[i];\n    if (part instanceof o.LiteralPiece) {\n      messageParts.push(part);\n    } else {\n      placeHolders.push(part);\n      if (pieces[i - 1] instanceof o.PlaceholderPiece) {\n        // There were two placeholders in a row, so we need to add an empty message part.\n        messageParts.push(createEmptyMessagePart(pieces[i - 1].sourceSpan.end));\n      }\n    }\n  }\n  if (pieces[pieces.length - 1] instanceof o.PlaceholderPiece) {\n    // The last piece was a placeholder so we need to add a final empty message part.\n    messageParts.push(createEmptyMessagePart(pieces[pieces.length - 1].sourceSpan.end));\n  }\n  return {messageParts, placeHolders};\n}\n\nfunction createEmptyMessagePart(location: ParseLocation): o.LiteralPiece {\n  return new o.LiteralPiece('', new ParseSourceSpan(location, location));\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BuiltinFunctionCall, convertActionBinding, convertPropertyBinding, convertUpdateArguments, LocalResolver} from '../../compiler_util/expression_converter';\nimport {ConstantPool} from '../../constant_pool';\nimport * as core from '../../core';\nimport {AST, AstMemoryEfficientTransformer, BindingPipe, BindingType, Call, ImplicitReceiver, Interpolation, LiteralArray, LiteralMap, LiteralPrimitive, ParsedEventType, PropertyRead} from '../../expression_parser/ast';\nimport {Lexer} from '../../expression_parser/lexer';\nimport {Parser} from '../../expression_parser/parser';\nimport * as i18n from '../../i18n/i18n_ast';\nimport * as html from '../../ml_parser/ast';\nimport {HtmlParser} from '../../ml_parser/html_parser';\nimport {WhitespaceVisitor} from '../../ml_parser/html_whitespaces';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../../ml_parser/interpolation_config';\nimport {LexerRange} from '../../ml_parser/lexer';\nimport {isNgContainer as checkIsNgContainer, splitNsName} from '../../ml_parser/tags';\nimport {mapLiteral} from '../../output/map_util';\nimport * as o from '../../output/output_ast';\nimport {ParseError, ParseSourceSpan, sanitizeIdentifier} from '../../parse_util';\nimport {DomElementSchemaRegistry} from '../../schema/dom_element_schema_registry';\nimport {isIframeSecuritySensitiveAttr} from '../../schema/dom_security_schema';\nimport {isTrustedTypesSink} from '../../schema/trusted_types_sinks';\nimport {CssSelector} from '../../selector';\nimport {BindingParser} from '../../template_parser/binding_parser';\nimport {error, partitionArray} from '../../util';\nimport * as t from '../r3_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {htmlAstToRender3Ast} from '../r3_template_transform';\nimport {prepareSyntheticListenerFunctionName, prepareSyntheticListenerName, prepareSyntheticPropertyName} from '../util';\n\nimport {I18nContext} from './i18n/context';\nimport {createGoogleGetMsgStatements} from './i18n/get_msg_utils';\nimport {createLocalizeStatements} from './i18n/localize_utils';\nimport {I18nMetaVisitor} from './i18n/meta';\nimport {assembleBoundTextPlaceholders, assembleI18nBoundString, declareI18nVariable, formatI18nPlaceholderNamesInMap, getTranslationConstPrefix, hasI18nMeta, I18N_ICU_MAPPING_PREFIX, icuFromI18nMessage, isI18nRootNode, isSingleI18nIcu, placeholdersToParams, TRANSLATION_VAR_PREFIX, wrapI18nPlaceholder} from './i18n/util';\nimport {StylingBuilder, StylingInstruction} from './styling_builder';\nimport {asLiteral, CONTEXT_NAME, getInstructionStatements, getInterpolationArgsLength, IMPLICIT_REFERENCE, Instruction, InstructionParams, invalid, invokeInstruction, NON_BINDABLE_ATTR, REFERENCE_PREFIX, RENDER_FLAGS, RESTORED_VIEW_CONTEXT_NAME, trimTrailingNulls} from './util';\n\n\n\n// Selector attribute name of `<ng-content>`\nconst NG_CONTENT_SELECT_ATTR = 'select';\n\n// Attribute name of `ngProjectAs`.\nconst NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs';\n\n// Global symbols available only inside event bindings.\nconst EVENT_BINDING_SCOPE_GLOBALS = new Set<string>(['$event']);\n\n// List of supported global targets for event listeners\nconst GLOBAL_TARGET_RESOLVERS = new Map<string, o.ExternalReference>(\n    [['window', R3.resolveWindow], ['document', R3.resolveDocument], ['body', R3.resolveBody]]);\n\nexport const LEADING_TRIVIA_CHARS = [' ', '\\n', '\\r', '\\t'];\n\n//  if (rf & flags) { .. }\nexport function renderFlagCheckIfStmt(\n    flags: core.RenderFlags, statements: o.Statement[]): o.IfStmt {\n  return o.ifStmt(o.variable(RENDER_FLAGS).bitwiseAnd(o.literal(flags), null, false), statements);\n}\n\nexport function prepareEventListenerParameters(\n    eventAst: t.BoundEvent, handlerName: string|null = null,\n    scope: BindingScope|null = null): o.Expression[] {\n  const {type, name, target, phase, handler} = eventAst;\n  if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {\n    throw new Error(`Unexpected global target '${target}' defined for '${name}' event.\n        Supported list of global targets: ${Array.from(GLOBAL_TARGET_RESOLVERS.keys())}.`);\n  }\n\n  const eventArgumentName = '$event';\n  const implicitReceiverAccesses = new Set<string>();\n  const implicitReceiverExpr = (scope === null || scope.bindingLevel === 0) ?\n      o.variable(CONTEXT_NAME) :\n      scope.getOrCreateSharedContextVar(0);\n  const bindingStatements = convertActionBinding(\n      scope, implicitReceiverExpr, handler, 'b', eventAst.handlerSpan, implicitReceiverAccesses,\n      EVENT_BINDING_SCOPE_GLOBALS);\n  const statements = [];\n  const variableDeclarations = scope?.variableDeclarations();\n  const restoreViewStatement = scope?.restoreViewStatement();\n\n  if (variableDeclarations) {\n    // `variableDeclarations` needs to run first, because\n    // `restoreViewStatement` depends on the result.\n    statements.push(...variableDeclarations);\n  }\n\n  statements.push(...bindingStatements);\n\n  if (restoreViewStatement) {\n    statements.unshift(restoreViewStatement);\n\n    // If there's a `restoreView` call, we need to reset the view at the end of the listener\n    // in order to avoid a leak. If there's a `return` statement already, we wrap it in the\n    // call, e.g. `return resetView(ctx.foo())`. Otherwise we add the call as the last statement.\n    const lastStatement = statements[statements.length - 1];\n    if (lastStatement instanceof o.ReturnStatement) {\n      statements[statements.length - 1] = new o.ReturnStatement(\n          invokeInstruction(lastStatement.value.sourceSpan, R3.resetView, [lastStatement.value]));\n    } else {\n      statements.push(new o.ExpressionStatement(invokeInstruction(null, R3.resetView, [])));\n    }\n  }\n\n  const eventName: string =\n      type === ParsedEventType.Animation ? prepareSyntheticListenerName(name, phase!) : name;\n  const fnName = handlerName && sanitizeIdentifier(handlerName);\n  const fnArgs: o.FnParam[] = [];\n\n  if (implicitReceiverAccesses.has(eventArgumentName)) {\n    fnArgs.push(new o.FnParam(eventArgumentName, o.DYNAMIC_TYPE));\n  }\n\n  const handlerFn = o.fn(fnArgs, statements, o.INFERRED_TYPE, null, fnName);\n  const params: o.Expression[] = [o.literal(eventName), handlerFn];\n  if (target) {\n    params.push(\n        o.literal(false),  // `useCapture` flag, defaults to `false`\n        o.importExpr(GLOBAL_TARGET_RESOLVERS.get(target)!));\n  }\n  return params;\n}\n\n// Collects information needed to generate `consts` field of the ComponentDef.\nexport interface ComponentDefConsts {\n  /**\n   * When a constant requires some pre-processing (e.g. i18n translation block that includes\n   * goog.getMsg and $localize calls), the `prepareStatements` section contains corresponding\n   * statements.\n   */\n  prepareStatements: o.Statement[];\n\n  /**\n   * Actual expressions that represent constants.\n   */\n  constExpressions: o.Expression[];\n\n  /**\n   * Cache to avoid generating duplicated i18n translation blocks.\n   */\n  i18nVarRefsCache: Map<i18n.I18nMeta, o.ReadVarExpr>;\n}\n\nfunction createComponentDefConsts(): ComponentDefConsts {\n  return {\n    prepareStatements: [],\n    constExpressions: [],\n    i18nVarRefsCache: new Map(),\n  };\n}\n\nexport class TemplateDefinitionBuilder implements t.Visitor<void>, LocalResolver {\n  private _dataIndex = 0;\n  private _bindingContext = 0;\n  private _prefixCode: o.Statement[] = [];\n  /**\n   * List of callbacks to generate creation mode instructions. We store them here as we process\n   * the template so bindings in listeners are resolved only once all nodes have been visited.\n   * This ensures all local refs and context variables are available for matching.\n   */\n  private _creationCodeFns: Instruction[] = [];\n  /**\n   * List of callbacks to generate update mode instructions. We store them here as we process\n   * the template so bindings are resolved only once all nodes have been visited. This ensures\n   * all local refs and context variables are available for matching.\n   */\n  private _updateCodeFns: Instruction[] = [];\n\n  /** Index of the currently-selected node. */\n  private _currentIndex: number = 0;\n\n  /** Temporary variable declarations generated from visiting pipes, literals, etc. */\n  private _tempVariables: o.Statement[] = [];\n  /**\n   * List of callbacks to build nested templates. Nested templates must not be visited until\n   * after the parent template has finished visiting all of its nodes. This ensures that all\n   * local ref bindings in nested templates are able to find local ref values if the refs\n   * are defined after the template declaration.\n   */\n  private _nestedTemplateFns: (() => void)[] = [];\n  /**\n   * This scope contains local variables declared in the update mode block of the template.\n   * (e.g. refs and context vars in bindings)\n   */\n  private _bindingScope: BindingScope;\n  private _valueConverter: ValueConverter;\n\n  // i18n context local to this template\n  private i18n: I18nContext|null = null;\n\n  // Number of slots to reserve for pureFunctions\n  private _pureFunctionSlots = 0;\n\n  // Number of binding slots\n  private _bindingSlots = 0;\n\n  private fileBasedI18nSuffix: string;\n\n  // Projection slots found in the template. Projection slots can distribute projected\n  // nodes based on a selector, or can just use the wildcard selector to match\n  // all nodes which aren't matching any selector.\n  private _ngContentReservedSlots: (string|'*')[] = [];\n\n  // Number of non-default selectors found in all parent templates of this template. We need to\n  // track it to properly adjust projection slot index in the `projection` instruction.\n  private _ngContentSelectorsOffset = 0;\n\n  // Expression that should be used as implicit receiver when converting template\n  // expressions to output AST.\n  private _implicitReceiverExpr: o.ReadVarExpr|null = null;\n\n  constructor(\n      private constantPool: ConstantPool, parentBindingScope: BindingScope, private level = 0,\n      private contextName: string|null, private i18nContext: I18nContext|null,\n      private templateIndex: number|null, private templateName: string|null,\n      private _namespace: o.ExternalReference, relativeContextFilePath: string,\n      private i18nUseExternalIds: boolean,\n      private _constants: ComponentDefConsts = createComponentDefConsts()) {\n    this._bindingScope = parentBindingScope.nestedScope(level);\n\n    // Turn the relative context file path into an identifier by replacing non-alphanumeric\n    // characters with underscores.\n    this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_') + '_';\n\n    this._valueConverter = new ValueConverter(\n        constantPool, () => this.allocateDataSlot(),\n        (numSlots: number) => this.allocatePureFunctionSlots(numSlots),\n        (name, localName, slot, value: o.Expression) => {\n          this._bindingScope.set(this.level, localName, value);\n          this.creationInstruction(null, R3.pipe, [o.literal(slot), o.literal(name)]);\n        });\n  }\n\n  buildTemplateFunction(\n      nodes: t.Node[], variables: t.Variable[], ngContentSelectorsOffset: number = 0,\n      i18n?: i18n.I18nMeta): o.FunctionExpr {\n    this._ngContentSelectorsOffset = ngContentSelectorsOffset;\n\n    if (this._namespace !== R3.namespaceHTML) {\n      this.creationInstruction(null, this._namespace);\n    }\n\n    // Create variable bindings\n    variables.forEach(v => this.registerContextVariables(v));\n\n    // Initiate i18n context in case:\n    // - this template has parent i18n context\n    // - or the template has i18n meta associated with it,\n    //   but it's not initiated by the Element (e.g. <ng-template i18n>)\n    const initI18nContext = this.i18nContext ||\n        (isI18nRootNode(i18n) && !isSingleI18nIcu(i18n) &&\n         !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n));\n    const selfClosingI18nInstruction = hasTextChildrenOnly(nodes);\n    if (initI18nContext) {\n      this.i18nStart(null, i18n!, selfClosingI18nInstruction);\n    }\n\n    // This is the initial pass through the nodes of this template. In this pass, we\n    // queue all creation mode and update mode instructions for generation in the second\n    // pass. It's necessary to separate the passes to ensure local refs are defined before\n    // resolving bindings. We also count bindings in this pass as we walk bound expressions.\n    t.visitAll(this, nodes);\n\n    // Add total binding count to pure function count so pure function instructions are\n    // generated with the correct slot offset when update instructions are processed.\n    this._pureFunctionSlots += this._bindingSlots;\n\n    // Pipes are walked in the first pass (to enqueue `pipe()` creation instructions and\n    // `pipeBind` update instructions), so we have to update the slot offsets manually\n    // to account for bindings.\n    this._valueConverter.updatePipeSlotOffsets(this._bindingSlots);\n\n    // Nested templates must be processed before creation instructions so template()\n    // instructions can be generated with the correct internal const count.\n    this._nestedTemplateFns.forEach(buildTemplateFn => buildTemplateFn());\n\n    // Output the `projectionDef` instruction when some `<ng-content>` tags are present.\n    // The `projectionDef` instruction is only emitted for the component template and\n    // is skipped for nested templates (<ng-template> tags).\n    if (this.level === 0 && this._ngContentReservedSlots.length) {\n      const parameters: o.Expression[] = [];\n\n      // By default the `projectionDef` instructions creates one slot for the wildcard\n      // selector if no parameters are passed. Therefore we only want to allocate a new\n      // array for the projection slots if the default projection slot is not sufficient.\n      if (this._ngContentReservedSlots.length > 1 || this._ngContentReservedSlots[0] !== '*') {\n        const r3ReservedSlots = this._ngContentReservedSlots.map(\n            s => s !== '*' ? core.parseSelectorToR3Selector(s) : s);\n        parameters.push(this.constantPool.getConstLiteral(asLiteral(r3ReservedSlots), true));\n      }\n\n      // Since we accumulate ngContent selectors while processing template elements,\n      // we *prepend* `projectionDef` to creation instructions block, to put it before\n      // any `projection` instructions\n      this.creationInstruction(null, R3.projectionDef, parameters, /* prepend */ true);\n    }\n\n    if (initI18nContext) {\n      this.i18nEnd(null, selfClosingI18nInstruction);\n    }\n\n    // Generate all the creation mode instructions (e.g. resolve bindings in listeners)\n    const creationStatements = getInstructionStatements(this._creationCodeFns);\n\n    // Generate all the update mode instructions (e.g. resolve property or text bindings)\n    const updateStatements = getInstructionStatements(this._updateCodeFns);\n\n    //  Variable declaration must occur after binding resolution so we can generate context\n    //  instructions that build on each other.\n    // e.g. const b = nextContext().$implicit(); const b = nextContext();\n    const creationVariables = this._bindingScope.viewSnapshotStatements();\n    const updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);\n\n    const creationBlock = creationStatements.length > 0 ?\n        [renderFlagCheckIfStmt(\n            core.RenderFlags.Create, creationVariables.concat(creationStatements))] :\n        [];\n\n    const updateBlock = updateStatements.length > 0 ?\n        [renderFlagCheckIfStmt(core.RenderFlags.Update, updateVariables.concat(updateStatements))] :\n        [];\n\n    return o.fn(\n        // i.e. (rf: RenderFlags, ctx: any)\n        [new o.FnParam(RENDER_FLAGS, o.NUMBER_TYPE), new o.FnParam(CONTEXT_NAME, null)],\n        [\n          // Temporary variable declarations for query refresh (i.e. let _t: any;)\n          ...this._prefixCode,\n          // Creating mode (i.e. if (rf & RenderFlags.Create) { ... })\n          ...creationBlock,\n          // Binding and refresh mode (i.e. if (rf & RenderFlags.Update) {...})\n          ...updateBlock,\n        ],\n        o.INFERRED_TYPE, null, this.templateName);\n  }\n\n  // LocalResolver\n  getLocal(name: string): o.Expression|null {\n    return this._bindingScope.get(name);\n  }\n\n  // LocalResolver\n  notifyImplicitReceiverUse(): void {\n    this._bindingScope.notifyImplicitReceiverUse();\n  }\n\n  // LocalResolver\n  maybeRestoreView(): void {\n    this._bindingScope.maybeRestoreView();\n  }\n\n  private i18nTranslate(\n      message: i18n.Message, params: {[name: string]: o.Expression} = {}, ref?: o.ReadVarExpr,\n      transformFn?: (raw: o.ReadVarExpr) => o.Expression): o.ReadVarExpr {\n    const _ref = ref || this.i18nGenerateMainBlockVar();\n    // Closure Compiler requires const names to start with `MSG_` but disallows any other const to\n    // start with `MSG_`. We define a variable starting with `MSG_` just for the `goog.getMsg` call\n    const closureVar = this.i18nGenerateClosureVar(message.id);\n    const statements = getTranslationDeclStmts(message, _ref, closureVar, params, transformFn);\n    this._constants.prepareStatements.push(...statements);\n    return _ref;\n  }\n\n  private registerContextVariables(variable: t.Variable) {\n    const scopedName = this._bindingScope.freshReferenceName();\n    const retrievalLevel = this.level;\n    const lhs = o.variable(variable.name + scopedName);\n    this._bindingScope.set(\n        retrievalLevel, variable.name, lhs, DeclarationPriority.CONTEXT,\n        (scope: BindingScope, relativeLevel: number) => {\n          let rhs: o.Expression;\n          if (scope.bindingLevel === retrievalLevel) {\n            if (scope.isListenerScope() && scope.hasRestoreViewVariable()) {\n              // e.g. restoredCtx.\n              // We have to get the context from a view reference, if one is available, because\n              // the context that was passed in during creation may not be correct anymore.\n              // For more information see: https://github.com/angular/angular/pull/40360.\n              rhs = o.variable(RESTORED_VIEW_CONTEXT_NAME);\n              scope.notifyRestoredViewContextUse();\n            } else {\n              // e.g. ctx\n              rhs = o.variable(CONTEXT_NAME);\n            }\n          } else {\n            const sharedCtxVar = scope.getSharedContextName(retrievalLevel);\n            // e.g. ctx_r0   OR  x(2);\n            rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);\n          }\n          // e.g. const $item$ = x(2).$implicit;\n          return [lhs.set(rhs.prop(variable.value || IMPLICIT_REFERENCE)).toConstDecl()];\n        });\n  }\n\n  private i18nAppendBindings(expressions: AST[]) {\n    if (expressions.length > 0) {\n      expressions.forEach(expression => this.i18n!.appendBinding(expression));\n    }\n  }\n\n  private i18nBindProps(props: {[key: string]: t.Text|t.BoundText}): {[key: string]: o.Expression} {\n    const bound: {[key: string]: o.Expression} = {};\n    Object.keys(props).forEach(key => {\n      const prop = props[key];\n      if (prop instanceof t.Text) {\n        bound[key] = o.literal(prop.value);\n      } else {\n        const value = prop.value.visit(this._valueConverter);\n        this.allocateBindingSlots(value);\n        if (value instanceof Interpolation) {\n          const {strings, expressions} = value;\n          const {id, bindings} = this.i18n!;\n          const label = assembleI18nBoundString(strings, bindings.size, id);\n          this.i18nAppendBindings(expressions);\n          bound[key] = o.literal(label);\n        }\n      }\n    });\n    return bound;\n  }\n\n  // Generates top level vars for i18n blocks (i.e. `i18n_N`).\n  private i18nGenerateMainBlockVar(): o.ReadVarExpr {\n    return o.variable(this.constantPool.uniqueName(TRANSLATION_VAR_PREFIX));\n  }\n\n  // Generates vars with Closure-specific names for i18n blocks (i.e. `MSG_XXX`).\n  private i18nGenerateClosureVar(messageId: string): o.ReadVarExpr {\n    let name: string;\n    const suffix = this.fileBasedI18nSuffix.toUpperCase();\n    if (this.i18nUseExternalIds) {\n      const prefix = getTranslationConstPrefix(`EXTERNAL_`);\n      const uniqueSuffix = this.constantPool.uniqueName(suffix);\n      name = `${prefix}${sanitizeIdentifier(messageId)}$$${uniqueSuffix}`;\n    } else {\n      const prefix = getTranslationConstPrefix(suffix);\n      name = this.constantPool.uniqueName(prefix);\n    }\n    return o.variable(name);\n  }\n\n  private i18nUpdateRef(context: I18nContext): void {\n    const {icus, meta, isRoot, isResolved, isEmitted} = context;\n    if (isRoot && isResolved && !isEmitted && !isSingleI18nIcu(meta)) {\n      context.isEmitted = true;\n      const placeholders = context.getSerializedPlaceholders();\n      let icuMapping: {[name: string]: o.Expression} = {};\n      let params: {[name: string]: o.Expression} =\n          placeholders.size ? placeholdersToParams(placeholders) : {};\n      if (icus.size) {\n        icus.forEach((refs: o.Expression[], key: string) => {\n          if (refs.length === 1) {\n            // if we have one ICU defined for a given\n            // placeholder - just output its reference\n            params[key] = refs[0];\n          } else {\n            // ... otherwise we need to activate post-processing\n            // to replace ICU placeholders with proper values\n            const placeholder: string = wrapI18nPlaceholder(`${I18N_ICU_MAPPING_PREFIX}${key}`);\n            params[key] = o.literal(placeholder);\n            icuMapping[key] = o.literalArr(refs);\n          }\n        });\n      }\n\n      // translation requires post processing in 2 cases:\n      // - if we have placeholders with multiple values (ex. `START_DIV`: [\uFFFD#1\uFFFD, \uFFFD#2\uFFFD, ...])\n      // - if we have multiple ICUs that refer to the same placeholder name\n      const needsPostprocessing =\n          Array.from(placeholders.values()).some((value: string[]) => value.length > 1) ||\n          Object.keys(icuMapping).length;\n\n      let transformFn;\n      if (needsPostprocessing) {\n        transformFn = (raw: o.ReadVarExpr) => {\n          const args: o.Expression[] = [raw];\n          if (Object.keys(icuMapping).length) {\n            args.push(mapLiteral(icuMapping, true));\n          }\n          return invokeInstruction(null, R3.i18nPostprocess, args);\n        };\n      }\n      this.i18nTranslate(meta as i18n.Message, params, context.ref, transformFn);\n    }\n  }\n\n  private i18nStart(span: ParseSourceSpan|null = null, meta: i18n.I18nMeta, selfClosing?: boolean):\n      void {\n    const index = this.allocateDataSlot();\n    this.i18n = this.i18nContext ?\n        this.i18nContext.forkChildContext(index, this.templateIndex!, meta) :\n        new I18nContext(index, this.i18nGenerateMainBlockVar(), 0, this.templateIndex, meta);\n\n    // generate i18nStart instruction\n    const {id, ref} = this.i18n;\n    const params: o.Expression[] = [o.literal(index), this.addToConsts(ref)];\n    if (id > 0) {\n      // do not push 3rd argument (sub-block id)\n      // into i18nStart call for top level i18n context\n      params.push(o.literal(id));\n    }\n    this.creationInstruction(span, selfClosing ? R3.i18n : R3.i18nStart, params);\n  }\n\n  private i18nEnd(span: ParseSourceSpan|null = null, selfClosing?: boolean): void {\n    if (!this.i18n) {\n      throw new Error('i18nEnd is executed with no i18n context present');\n    }\n\n    if (this.i18nContext) {\n      this.i18nContext.reconcileChildContext(this.i18n);\n      this.i18nUpdateRef(this.i18nContext);\n    } else {\n      this.i18nUpdateRef(this.i18n);\n    }\n\n    // setup accumulated bindings\n    const {index, bindings} = this.i18n;\n    if (bindings.size) {\n      for (const binding of bindings) {\n        // for i18n block, advance to the most recent element index (by taking the current number of\n        // elements and subtracting one) before invoking `i18nExp` instructions, to make sure the\n        // necessary lifecycle hooks of components/directives are properly flushed.\n        this.updateInstructionWithAdvance(\n            this.getConstCount() - 1, span, R3.i18nExp, () => this.convertPropertyBinding(binding));\n      }\n\n      this.updateInstruction(span, R3.i18nApply, [o.literal(index)]);\n    }\n    if (!selfClosing) {\n      this.creationInstruction(span, R3.i18nEnd);\n    }\n    this.i18n = null;  // reset local i18n context\n  }\n\n  private i18nAttributesInstruction(\n      nodeIndex: number, attrs: t.BoundAttribute[], sourceSpan: ParseSourceSpan): void {\n    let hasBindings = false;\n    const i18nAttrArgs: o.Expression[] = [];\n    attrs.forEach(attr => {\n      const message = attr.i18n! as i18n.Message;\n      const converted = attr.value.visit(this._valueConverter);\n      this.allocateBindingSlots(converted);\n      if (converted instanceof Interpolation) {\n        const placeholders = assembleBoundTextPlaceholders(message);\n        const params = placeholdersToParams(placeholders);\n        i18nAttrArgs.push(o.literal(attr.name), this.i18nTranslate(message, params));\n        converted.expressions.forEach(expression => {\n          hasBindings = true;\n          this.updateInstructionWithAdvance(\n              nodeIndex, sourceSpan, R3.i18nExp, () => this.convertPropertyBinding(expression));\n        });\n      }\n    });\n    if (i18nAttrArgs.length > 0) {\n      const index: o.Expression = o.literal(this.allocateDataSlot());\n      const constIndex = this.addToConsts(o.literalArr(i18nAttrArgs));\n      this.creationInstruction(sourceSpan, R3.i18nAttributes, [index, constIndex]);\n      if (hasBindings) {\n        this.updateInstruction(sourceSpan, R3.i18nApply, [index]);\n      }\n    }\n  }\n\n  private getNamespaceInstruction(namespaceKey: string|null) {\n    switch (namespaceKey) {\n      case 'math':\n        return R3.namespaceMathML;\n      case 'svg':\n        return R3.namespaceSVG;\n      default:\n        return R3.namespaceHTML;\n    }\n  }\n\n  private addNamespaceInstruction(nsInstruction: o.ExternalReference, element: t.Element) {\n    this._namespace = nsInstruction;\n    this.creationInstruction(element.startSourceSpan, nsInstruction);\n  }\n\n  /**\n   * Adds an update instruction for an interpolated property or attribute, such as\n   * `prop=\"{{value}}\"` or `attr.title=\"{{value}}\"`\n   */\n  private interpolatedUpdateInstruction(\n      instruction: o.ExternalReference, elementIndex: number, attrName: string,\n      input: t.BoundAttribute, value: Interpolation, params: any[]) {\n    this.updateInstructionWithAdvance(\n        elementIndex, input.sourceSpan, instruction,\n        () => [o.literal(attrName), ...this.getUpdateInstructionArguments(value), ...params]);\n  }\n\n  visitContent(ngContent: t.Content) {\n    const slot = this.allocateDataSlot();\n    const projectionSlotIdx = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length;\n    const parameters: o.Expression[] = [o.literal(slot)];\n\n    this._ngContentReservedSlots.push(ngContent.selector);\n\n    const nonContentSelectAttributes =\n        ngContent.attributes.filter(attr => attr.name.toLowerCase() !== NG_CONTENT_SELECT_ATTR);\n    const attributes =\n        this.getAttributeExpressions(ngContent.name, nonContentSelectAttributes, [], []);\n\n    if (attributes.length > 0) {\n      parameters.push(o.literal(projectionSlotIdx), o.literalArr(attributes));\n    } else if (projectionSlotIdx !== 0) {\n      parameters.push(o.literal(projectionSlotIdx));\n    }\n\n    this.creationInstruction(ngContent.sourceSpan, R3.projection, parameters);\n    if (this.i18n) {\n      this.i18n.appendProjection(ngContent.i18n!, slot);\n    }\n  }\n\n  visitElement(element: t.Element) {\n    const elementIndex = this.allocateDataSlot();\n    const stylingBuilder = new StylingBuilder(null);\n\n    let isNonBindableMode: boolean = false;\n    const isI18nRootElement: boolean =\n        isI18nRootNode(element.i18n) && !isSingleI18nIcu(element.i18n);\n\n    const outputAttrs: t.TextAttribute[] = [];\n    const [namespaceKey, elementName] = splitNsName(element.name);\n    const isNgContainer = checkIsNgContainer(element.name);\n\n    // Handle styling, i18n, ngNonBindable attributes\n    for (const attr of element.attributes) {\n      const {name, value} = attr;\n      if (name === NON_BINDABLE_ATTR) {\n        isNonBindableMode = true;\n      } else if (name === 'style') {\n        stylingBuilder.registerStyleAttr(value);\n      } else if (name === 'class') {\n        stylingBuilder.registerClassAttr(value);\n      } else {\n        outputAttrs.push(attr);\n      }\n    }\n\n    // Regular element or ng-container creation mode\n    const parameters: o.Expression[] = [o.literal(elementIndex)];\n    if (!isNgContainer) {\n      parameters.push(o.literal(elementName));\n    }\n\n    // Add the attributes\n    const allOtherInputs: t.BoundAttribute[] = [];\n    const boundI18nAttrs: t.BoundAttribute[] = [];\n\n    element.inputs.forEach(input => {\n      const stylingInputWasSet = stylingBuilder.registerBoundInput(input);\n      if (!stylingInputWasSet) {\n        if (input.type === BindingType.Property && input.i18n) {\n          boundI18nAttrs.push(input);\n        } else {\n          allOtherInputs.push(input);\n        }\n      }\n    });\n\n    // add attributes for directive and projection matching purposes\n    const attributes: o.Expression[] = this.getAttributeExpressions(\n        element.name, outputAttrs, allOtherInputs, element.outputs, stylingBuilder, [],\n        boundI18nAttrs);\n    parameters.push(this.addAttrsToConsts(attributes));\n\n    // local refs (ex.: <div #foo #bar=\"baz\">)\n    const refs = this.prepareRefsArray(element.references);\n    parameters.push(this.addToConsts(refs));\n\n    const wasInNamespace = this._namespace;\n    const currentNamespace = this.getNamespaceInstruction(namespaceKey);\n\n    // If the namespace is changing now, include an instruction to change it\n    // during element creation.\n    if (currentNamespace !== wasInNamespace) {\n      this.addNamespaceInstruction(currentNamespace, element);\n    }\n\n    if (this.i18n) {\n      this.i18n.appendElement(element.i18n!, elementIndex);\n    }\n\n    // Note that we do not append text node instructions and ICUs inside i18n section,\n    // so we exclude them while calculating whether current element has children\n    const hasChildren = (!isI18nRootElement && this.i18n) ? !hasTextChildrenOnly(element.children) :\n                                                            element.children.length > 0;\n\n    const createSelfClosingInstruction = !stylingBuilder.hasBindingsWithPipes &&\n        element.outputs.length === 0 && boundI18nAttrs.length === 0 && !hasChildren;\n    const createSelfClosingI18nInstruction =\n        !createSelfClosingInstruction && hasTextChildrenOnly(element.children);\n\n    if (createSelfClosingInstruction) {\n      this.creationInstruction(\n          element.sourceSpan, isNgContainer ? R3.elementContainer : R3.element,\n          trimTrailingNulls(parameters));\n    } else {\n      this.creationInstruction(\n          element.startSourceSpan, isNgContainer ? R3.elementContainerStart : R3.elementStart,\n          trimTrailingNulls(parameters));\n\n      if (isNonBindableMode) {\n        this.creationInstruction(element.startSourceSpan, R3.disableBindings);\n      }\n\n      if (boundI18nAttrs.length > 0) {\n        this.i18nAttributesInstruction(\n            elementIndex, boundI18nAttrs, element.startSourceSpan ?? element.sourceSpan);\n      }\n\n      // Generate Listeners (outputs)\n      if (element.outputs.length > 0) {\n        for (const outputAst of element.outputs) {\n          this.creationInstruction(\n              outputAst.sourceSpan, R3.listener,\n              this.prepareListenerParameter(element.name, outputAst, elementIndex));\n        }\n      }\n\n      // Note: it's important to keep i18n/i18nStart instructions after i18nAttributes and\n      // listeners, to make sure i18nAttributes instruction targets current element at runtime.\n      if (isI18nRootElement) {\n        this.i18nStart(element.startSourceSpan, element.i18n!, createSelfClosingI18nInstruction);\n      }\n    }\n\n    // the code here will collect all update-level styling instructions and add them to the\n    // update block of the template function AOT code. Instructions like `styleProp`,\n    // `styleMap`, `classMap`, `classProp`\n    // are all generated and assigned in the code below.\n    const stylingInstructions = stylingBuilder.buildUpdateLevelInstructions(this._valueConverter);\n    const limit = stylingInstructions.length - 1;\n    for (let i = 0; i <= limit; i++) {\n      const instruction = stylingInstructions[i];\n      this._bindingSlots += this.processStylingUpdateInstruction(elementIndex, instruction);\n    }\n\n    // the reason why `undefined` is used is because the renderer understands this as a\n    // special value to symbolize that there is no RHS to this binding\n    // TODO (matsko): revisit this once FW-959 is approached\n    const emptyValueBindInstruction = o.literal(undefined);\n    const propertyBindings: Omit<Instruction, 'reference'>[] = [];\n    const attributeBindings: Omit<Instruction, 'reference'>[] = [];\n\n    // Generate element input bindings\n    allOtherInputs.forEach(input => {\n      const inputType = input.type;\n      if (inputType === BindingType.Animation) {\n        const value = input.value.visit(this._valueConverter);\n        // animation bindings can be presented in the following formats:\n        // 1. [@binding]=\"fooExp\"\n        // 2. [@binding]=\"{value:fooExp, params:{...}}\"\n        // 3. [@binding]\n        // 4. @binding\n        // All formats will be valid for when a synthetic binding is created.\n        // The reasoning for this is because the renderer should get each\n        // synthetic binding value in the order of the array that they are\n        // defined in...\n        const hasValue = value instanceof LiteralPrimitive ? !!value.value : true;\n        this.allocateBindingSlots(value);\n\n        propertyBindings.push({\n          span: input.sourceSpan,\n          paramsOrFn: getBindingFunctionParams(\n              () => hasValue ? this.convertPropertyBinding(value) : emptyValueBindInstruction,\n              prepareSyntheticPropertyName(input.name))\n        });\n      } else {\n        // we must skip attributes with associated i18n context, since these attributes are handled\n        // separately and corresponding `i18nExp` and `i18nApply` instructions will be generated\n        if (input.i18n) return;\n\n        const value = input.value.visit(this._valueConverter);\n        if (value !== undefined) {\n          const params: any[] = [];\n          const [attrNamespace, attrName] = splitNsName(input.name);\n          const isAttributeBinding = inputType === BindingType.Attribute;\n          let sanitizationRef = resolveSanitizationFn(input.securityContext, isAttributeBinding);\n          if (!sanitizationRef) {\n            // If there was no sanitization function found based on the security context\n            // of an attribute/property - check whether this attribute/property is\n            // one of the security-sensitive <iframe> attributes (and that the current\n            // element is actually an <iframe>).\n            if (isIframeElement(element.name) && isIframeSecuritySensitiveAttr(input.name)) {\n              sanitizationRef = o.importExpr(R3.validateIframeAttribute);\n            }\n          }\n          if (sanitizationRef) {\n            params.push(sanitizationRef);\n          }\n          if (attrNamespace) {\n            const namespaceLiteral = o.literal(attrNamespace);\n\n            if (sanitizationRef) {\n              params.push(namespaceLiteral);\n            } else {\n              // If there wasn't a sanitization ref, we need to add\n              // an extra param so that we can pass in the namespace.\n              params.push(o.literal(null), namespaceLiteral);\n            }\n          }\n          this.allocateBindingSlots(value);\n\n          if (inputType === BindingType.Property) {\n            if (value instanceof Interpolation) {\n              // prop=\"{{value}}\" and friends\n              this.interpolatedUpdateInstruction(\n                  getPropertyInterpolationExpression(value), elementIndex, attrName, input, value,\n                  params);\n            } else {\n              // [prop]=\"value\"\n              // Collect all the properties so that we can chain into a single function at the end.\n              propertyBindings.push({\n                span: input.sourceSpan,\n                paramsOrFn: getBindingFunctionParams(\n                    () => this.convertPropertyBinding(value), attrName, params)\n              });\n            }\n          } else if (inputType === BindingType.Attribute) {\n            if (value instanceof Interpolation && getInterpolationArgsLength(value) > 1) {\n              // attr.name=\"text{{value}}\" and friends\n              this.interpolatedUpdateInstruction(\n                  getAttributeInterpolationExpression(value), elementIndex, attrName, input, value,\n                  params);\n            } else {\n              const boundValue = value instanceof Interpolation ? value.expressions[0] : value;\n              // [attr.name]=\"value\" or attr.name=\"{{value}}\"\n              // Collect the attribute bindings so that they can be chained at the end.\n              attributeBindings.push({\n                span: input.sourceSpan,\n                paramsOrFn: getBindingFunctionParams(\n                    () => this.convertPropertyBinding(boundValue), attrName, params)\n              });\n            }\n          } else {\n            // class prop\n            this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, R3.classProp, () => {\n              return [\n                o.literal(elementIndex), o.literal(attrName), this.convertPropertyBinding(value),\n                ...params\n              ];\n            });\n          }\n        }\n      }\n    });\n\n    for (const propertyBinding of propertyBindings) {\n      this.updateInstructionWithAdvance(\n          elementIndex, propertyBinding.span, R3.property, propertyBinding.paramsOrFn);\n    }\n\n    for (const attributeBinding of attributeBindings) {\n      this.updateInstructionWithAdvance(\n          elementIndex, attributeBinding.span, R3.attribute, attributeBinding.paramsOrFn);\n    }\n\n    // Traverse element child nodes\n    t.visitAll(this, element.children);\n\n    if (!isI18nRootElement && this.i18n) {\n      this.i18n.appendElement(element.i18n!, elementIndex, true);\n    }\n\n    if (!createSelfClosingInstruction) {\n      // Finish element construction mode.\n      const span = element.endSourceSpan ?? element.sourceSpan;\n      if (isI18nRootElement) {\n        this.i18nEnd(span, createSelfClosingI18nInstruction);\n      }\n      if (isNonBindableMode) {\n        this.creationInstruction(span, R3.enableBindings);\n      }\n      this.creationInstruction(span, isNgContainer ? R3.elementContainerEnd : R3.elementEnd);\n    }\n  }\n\n\n  visitTemplate(template: t.Template) {\n    const NG_TEMPLATE_TAG_NAME = 'ng-template';\n    const templateIndex = this.allocateDataSlot();\n\n    if (this.i18n) {\n      this.i18n.appendTemplate(template.i18n!, templateIndex);\n    }\n\n    const tagNameWithoutNamespace =\n        template.tagName ? splitNsName(template.tagName)[1] : template.tagName;\n    const contextName = `${this.contextName}${\n        template.tagName ? '_' + sanitizeIdentifier(template.tagName) : ''}_${templateIndex}`;\n    const templateName = `${contextName}_Template`;\n    const parameters: o.Expression[] = [\n      o.literal(templateIndex),\n      o.variable(templateName),\n      // We don't care about the tag's namespace here, because we infer\n      // it based on the parent nodes inside the template instruction.\n      o.literal(tagNameWithoutNamespace),\n    ];\n\n    // prepare attributes parameter (including attributes used for directive matching)\n    const attrsExprs: o.Expression[] = this.getAttributeExpressions(\n        NG_TEMPLATE_TAG_NAME, template.attributes, template.inputs, template.outputs,\n        undefined /* styles */, template.templateAttrs);\n    parameters.push(this.addAttrsToConsts(attrsExprs));\n\n    // local refs (ex.: <ng-template #foo>)\n    if (template.references && template.references.length) {\n      const refs = this.prepareRefsArray(template.references);\n      parameters.push(this.addToConsts(refs));\n      parameters.push(o.importExpr(R3.templateRefExtractor));\n    }\n\n    // Create the template function\n    const templateVisitor = new TemplateDefinitionBuilder(\n        this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n,\n        templateIndex, templateName, this._namespace, this.fileBasedI18nSuffix,\n        this.i18nUseExternalIds, this._constants);\n\n    // Nested templates must not be visited until after their parent templates have completed\n    // processing, so they are queued here until after the initial pass. Otherwise, we wouldn't\n    // be able to support bindings in nested templates to local refs that occur after the\n    // template definition. e.g. <div *ngIf=\"showing\">{{ foo }}</div>  <div #foo></div>\n    this._nestedTemplateFns.push(() => {\n      const templateFunctionExpr = templateVisitor.buildTemplateFunction(\n          template.children, template.variables,\n          this._ngContentReservedSlots.length + this._ngContentSelectorsOffset, template.i18n);\n      this.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName));\n      if (templateVisitor._ngContentReservedSlots.length) {\n        this._ngContentReservedSlots.push(...templateVisitor._ngContentReservedSlots);\n      }\n    });\n\n    // e.g. template(1, MyComp_Template_1)\n    this.creationInstruction(template.sourceSpan, R3.templateCreate, () => {\n      parameters.splice(\n          2, 0, o.literal(templateVisitor.getConstCount()),\n          o.literal(templateVisitor.getVarCount()));\n      return trimTrailingNulls(parameters);\n    });\n\n    // handle property bindings e.g. \u0275\u0275property('ngForOf', ctx.items), et al;\n    this.templatePropertyBindings(templateIndex, template.templateAttrs);\n\n    // Only add normal input/output binding instructions on explicit <ng-template> elements.\n    if (tagNameWithoutNamespace === NG_TEMPLATE_TAG_NAME) {\n      const [i18nInputs, inputs] =\n          partitionArray<t.BoundAttribute, t.BoundAttribute>(template.inputs, hasI18nMeta);\n\n      // Add i18n attributes that may act as inputs to directives. If such attributes are present,\n      // generate `i18nAttributes` instruction. Note: we generate it only for explicit <ng-template>\n      // elements, in case of inline templates, corresponding instructions will be generated in the\n      // nested template function.\n      if (i18nInputs.length > 0) {\n        this.i18nAttributesInstruction(\n            templateIndex, i18nInputs, template.startSourceSpan ?? template.sourceSpan);\n      }\n\n      // Add the input bindings\n      if (inputs.length > 0) {\n        this.templatePropertyBindings(templateIndex, inputs);\n      }\n\n      // Generate listeners for directive output\n      for (const outputAst of template.outputs) {\n        this.creationInstruction(\n            outputAst.sourceSpan, R3.listener,\n            this.prepareListenerParameter('ng_template', outputAst, templateIndex));\n      }\n    }\n  }\n\n  // These should be handled in the template or element directly.\n  readonly visitReference = invalid;\n  readonly visitVariable = invalid;\n  readonly visitTextAttribute = invalid;\n  readonly visitBoundAttribute = invalid;\n  readonly visitBoundEvent = invalid;\n\n  visitBoundText(text: t.BoundText) {\n    if (this.i18n) {\n      const value = text.value.visit(this._valueConverter);\n      this.allocateBindingSlots(value);\n      if (value instanceof Interpolation) {\n        this.i18n.appendBoundText(text.i18n!);\n        this.i18nAppendBindings(value.expressions);\n      }\n      return;\n    }\n\n    const nodeIndex = this.allocateDataSlot();\n\n    this.creationInstruction(text.sourceSpan, R3.text, [o.literal(nodeIndex)]);\n\n    const value = text.value.visit(this._valueConverter);\n    this.allocateBindingSlots(value);\n\n    if (value instanceof Interpolation) {\n      this.updateInstructionWithAdvance(\n          nodeIndex, text.sourceSpan, getTextInterpolationExpression(value),\n          () => this.getUpdateInstructionArguments(value));\n    } else {\n      error('Text nodes should be interpolated and never bound directly.');\n    }\n  }\n\n  visitText(text: t.Text) {\n    // when a text element is located within a translatable\n    // block, we exclude this text element from instructions set,\n    // since it will be captured in i18n content and processed at runtime\n    if (!this.i18n) {\n      this.creationInstruction(\n          text.sourceSpan, R3.text, [o.literal(this.allocateDataSlot()), o.literal(text.value)]);\n    }\n  }\n\n  visitIcu(icu: t.Icu) {\n    let initWasInvoked = false;\n\n    // if an ICU was created outside of i18n block, we still treat\n    // it as a translatable entity and invoke i18nStart and i18nEnd\n    // to generate i18n context and the necessary instructions\n    if (!this.i18n) {\n      initWasInvoked = true;\n      this.i18nStart(null, icu.i18n!, true);\n    }\n\n    const i18n = this.i18n!;\n    const vars = this.i18nBindProps(icu.vars);\n    const placeholders = this.i18nBindProps(icu.placeholders);\n\n    // output ICU directly and keep ICU reference in context\n    const message = icu.i18n! as i18n.Message;\n\n    // we always need post-processing function for ICUs, to make sure that:\n    // - all placeholders in a form of {PLACEHOLDER} are replaced with actual values (note:\n    // `goog.getMsg` does not process ICUs and uses the `{PLACEHOLDER}` format for placeholders\n    // inside ICUs)\n    // - all ICU vars (such as `VAR_SELECT` or `VAR_PLURAL`) are replaced with correct values\n    const transformFn = (raw: o.ReadVarExpr) => {\n      const params = {...vars, ...placeholders};\n      const formatted = formatI18nPlaceholderNamesInMap(params, /* useCamelCase */ false);\n      return invokeInstruction(null, R3.i18nPostprocess, [raw, mapLiteral(formatted, true)]);\n    };\n\n    // in case the whole i18n message is a single ICU - we do not need to\n    // create a separate top-level translation, we can use the root ref instead\n    // and make this ICU a top-level translation\n    // note: ICU placeholders are replaced with actual values in `i18nPostprocess` function\n    // separately, so we do not pass placeholders into `i18nTranslate` function.\n    if (isSingleI18nIcu(i18n.meta)) {\n      this.i18nTranslate(message, /* placeholders */ {}, i18n.ref, transformFn);\n    } else {\n      // output ICU directly and keep ICU reference in context\n      const ref =\n          this.i18nTranslate(message, /* placeholders */ {}, /* ref */ undefined, transformFn);\n      i18n.appendIcu(icuFromI18nMessage(message).name, ref);\n    }\n\n    if (initWasInvoked) {\n      this.i18nEnd(null, true);\n    }\n    return null;\n  }\n\n  private allocateDataSlot() {\n    return this._dataIndex++;\n  }\n\n  getConstCount() {\n    return this._dataIndex;\n  }\n\n  getVarCount() {\n    return this._pureFunctionSlots;\n  }\n\n  getConsts(): ComponentDefConsts {\n    return this._constants;\n  }\n\n  getNgContentSelectors(): o.Expression|null {\n    return this._ngContentReservedSlots.length ?\n        this.constantPool.getConstLiteral(asLiteral(this._ngContentReservedSlots), true) :\n        null;\n  }\n\n  private bindingContext() {\n    return `${this._bindingContext++}`;\n  }\n\n  private templatePropertyBindings(\n      templateIndex: number, attrs: (t.BoundAttribute|t.TextAttribute)[]) {\n    const propertyBindings: Omit<Instruction, 'reference'>[] = [];\n\n    for (const input of attrs) {\n      if (!(input instanceof t.BoundAttribute)) {\n        continue;\n      }\n\n      const value = input.value.visit(this._valueConverter);\n      if (value === undefined) {\n        continue;\n      }\n\n      this.allocateBindingSlots(value);\n      if (value instanceof Interpolation) {\n        // Params typically contain attribute namespace and value sanitizer, which is applicable\n        // for regular HTML elements, but not applicable for <ng-template> (since props act as\n        // inputs to directives), so keep params array empty.\n        const params: any[] = [];\n\n        // prop=\"{{value}}\" case\n        this.interpolatedUpdateInstruction(\n            getPropertyInterpolationExpression(value), templateIndex, input.name, input, value,\n            params);\n      } else {\n        // [prop]=\"value\" case\n        propertyBindings.push({\n          span: input.sourceSpan,\n          paramsOrFn: getBindingFunctionParams(() => this.convertPropertyBinding(value), input.name)\n        });\n      }\n    }\n\n    for (const propertyBinding of propertyBindings) {\n      this.updateInstructionWithAdvance(\n          templateIndex, propertyBinding.span, R3.property, propertyBinding.paramsOrFn);\n    }\n  }\n\n  // Bindings must only be resolved after all local refs have been visited, so all\n  // instructions are queued in callbacks that execute once the initial pass has completed.\n  // Otherwise, we wouldn't be able to support local refs that are defined after their\n  // bindings. e.g. {{ foo }} <div #foo></div>\n  private instructionFn(\n      fns: Instruction[], span: ParseSourceSpan|null, reference: o.ExternalReference,\n      paramsOrFn: InstructionParams, prepend: boolean = false): void {\n    fns[prepend ? 'unshift' : 'push']({span, reference, paramsOrFn});\n  }\n\n  private processStylingUpdateInstruction(\n      elementIndex: number, instruction: StylingInstruction|null) {\n    let allocateBindingSlots = 0;\n    if (instruction) {\n      for (const call of instruction.calls) {\n        allocateBindingSlots += call.allocateBindingSlots;\n        this.updateInstructionWithAdvance(\n            elementIndex, call.sourceSpan, instruction.reference,\n            () => call.params(\n                      value => (call.supportsInterpolation && value instanceof Interpolation) ?\n                          this.getUpdateInstructionArguments(value) :\n                          this.convertPropertyBinding(value)) as o.Expression[]);\n      }\n    }\n    return allocateBindingSlots;\n  }\n\n  private creationInstruction(\n      span: ParseSourceSpan|null, reference: o.ExternalReference, paramsOrFn?: InstructionParams,\n      prepend?: boolean) {\n    this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);\n  }\n\n  private updateInstructionWithAdvance(\n      nodeIndex: number, span: ParseSourceSpan|null, reference: o.ExternalReference,\n      paramsOrFn?: InstructionParams) {\n    this.addAdvanceInstructionIfNecessary(nodeIndex, span);\n    this.updateInstruction(span, reference, paramsOrFn);\n  }\n\n  private updateInstruction(\n      span: ParseSourceSpan|null, reference: o.ExternalReference, paramsOrFn?: InstructionParams) {\n    this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);\n  }\n\n  private addAdvanceInstructionIfNecessary(nodeIndex: number, span: ParseSourceSpan|null) {\n    if (nodeIndex !== this._currentIndex) {\n      const delta = nodeIndex - this._currentIndex;\n\n      if (delta < 1) {\n        throw new Error('advance instruction can only go forwards');\n      }\n\n      this.instructionFn(this._updateCodeFns, span, R3.advance, [o.literal(delta)]);\n      this._currentIndex = nodeIndex;\n    }\n  }\n\n  private allocatePureFunctionSlots(numSlots: number): number {\n    const originalSlots = this._pureFunctionSlots;\n    this._pureFunctionSlots += numSlots;\n    return originalSlots;\n  }\n\n  private allocateBindingSlots(value: AST|null) {\n    this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;\n  }\n\n  /**\n   * Gets an expression that refers to the implicit receiver. The implicit\n   * receiver is always the root level context.\n   */\n  private getImplicitReceiverExpr(): o.ReadVarExpr {\n    if (this._implicitReceiverExpr) {\n      return this._implicitReceiverExpr;\n    }\n\n    return this._implicitReceiverExpr = this.level === 0 ?\n        o.variable(CONTEXT_NAME) :\n        this._bindingScope.getOrCreateSharedContextVar(0);\n  }\n\n  private convertPropertyBinding(value: AST): o.Expression {\n    const convertedPropertyBinding =\n        convertPropertyBinding(this, this.getImplicitReceiverExpr(), value, this.bindingContext());\n    const valExpr = convertedPropertyBinding.currValExpr;\n    this._tempVariables.push(...convertedPropertyBinding.stmts);\n    return valExpr;\n  }\n\n  /**\n   * Gets a list of argument expressions to pass to an update instruction expression. Also updates\n   * the temp variables state with temp variables that were identified as needing to be created\n   * while visiting the arguments.\n   * @param value The original expression we will be resolving an arguments list from.\n   */\n  private getUpdateInstructionArguments(value: Interpolation): o.Expression[] {\n    const {args, stmts} =\n        convertUpdateArguments(this, this.getImplicitReceiverExpr(), value, this.bindingContext());\n\n    this._tempVariables.push(...stmts);\n    return args;\n  }\n\n  /**\n   * Prepares all attribute expression values for the `TAttributes` array.\n   *\n   * The purpose of this function is to properly construct an attributes array that\n   * is passed into the `elementStart` (or just `element`) functions. Because there\n   * are many different types of attributes, the array needs to be constructed in a\n   * special way so that `elementStart` can properly evaluate them.\n   *\n   * The format looks like this:\n   *\n   * ```\n   * attrs = [prop, value, prop2, value2,\n   *   PROJECT_AS, selector,\n   *   CLASSES, class1, class2,\n   *   STYLES, style1, value1, style2, value2,\n   *   BINDINGS, name1, name2, name3,\n   *   TEMPLATE, name4, name5, name6,\n   *   I18N, name7, name8, ...]\n   * ```\n   *\n   * Note that this function will fully ignore all synthetic (@foo) attribute values\n   * because those values are intended to always be generated as property instructions.\n   */\n  private getAttributeExpressions(\n      elementName: string, renderAttributes: t.TextAttribute[], inputs: t.BoundAttribute[],\n      outputs: t.BoundEvent[], styles?: StylingBuilder,\n      templateAttrs: (t.BoundAttribute|t.TextAttribute)[] = [],\n      boundI18nAttrs: t.BoundAttribute[] = []): o.Expression[] {\n    const alreadySeen = new Set<string>();\n    const attrExprs: o.Expression[] = [];\n    let ngProjectAsAttr: t.TextAttribute|undefined;\n\n    for (const attr of renderAttributes) {\n      if (attr.name === NG_PROJECT_AS_ATTR_NAME) {\n        ngProjectAsAttr = attr;\n      }\n\n      // Note that static i18n attributes aren't in the i18n array,\n      // because they're treated in the same way as regular attributes.\n      if (attr.i18n) {\n        // When i18n attributes are present on elements with structural directives\n        // (e.g. `<div *ngIf title=\"Hello\" i18n-title>`), we want to avoid generating\n        // duplicate i18n translation blocks for `\u0275\u0275template` and `\u0275\u0275element` instruction\n        // attributes. So we do a cache lookup to see if suitable i18n translation block\n        // already exists.\n        const {i18nVarRefsCache} = this._constants;\n        let i18nVarRef: o.ReadVarExpr;\n        if (i18nVarRefsCache.has(attr.i18n)) {\n          i18nVarRef = i18nVarRefsCache.get(attr.i18n)!;\n        } else {\n          i18nVarRef = this.i18nTranslate(attr.i18n as i18n.Message);\n          i18nVarRefsCache.set(attr.i18n, i18nVarRef);\n        }\n        attrExprs.push(o.literal(attr.name), i18nVarRef);\n      } else {\n        attrExprs.push(\n            ...getAttributeNameLiterals(attr.name), trustedConstAttribute(elementName, attr));\n      }\n    }\n\n    // Keep ngProjectAs next to the other name, value pairs so we can verify that we match\n    // ngProjectAs marker in the attribute name slot.\n    if (ngProjectAsAttr) {\n      attrExprs.push(...getNgProjectAsLiteral(ngProjectAsAttr));\n    }\n\n    function addAttrExpr(key: string|number, value?: o.Expression): void {\n      if (typeof key === 'string') {\n        if (!alreadySeen.has(key)) {\n          attrExprs.push(...getAttributeNameLiterals(key));\n          value !== undefined && attrExprs.push(value);\n          alreadySeen.add(key);\n        }\n      } else {\n        attrExprs.push(o.literal(key));\n      }\n    }\n\n    // it's important that this occurs before BINDINGS and TEMPLATE because once `elementStart`\n    // comes across the BINDINGS or TEMPLATE markers then it will continue reading each value as\n    // as single property value cell by cell.\n    if (styles) {\n      styles.populateInitialStylingAttrs(attrExprs);\n    }\n\n    if (inputs.length || outputs.length) {\n      const attrsLengthBeforeInputs = attrExprs.length;\n\n      for (let i = 0; i < inputs.length; i++) {\n        const input = inputs[i];\n        // We don't want the animation and attribute bindings in the\n        // attributes array since they aren't used for directive matching.\n        if (input.type !== BindingType.Animation && input.type !== BindingType.Attribute) {\n          addAttrExpr(input.name);\n        }\n      }\n\n      for (let i = 0; i < outputs.length; i++) {\n        const output = outputs[i];\n        if (output.type !== ParsedEventType.Animation) {\n          addAttrExpr(output.name);\n        }\n      }\n\n      // this is a cheap way of adding the marker only after all the input/output\n      // values have been filtered (by not including the animation ones) and added\n      // to the expressions. The marker is important because it tells the runtime\n      // code that this is where attributes without values start...\n      if (attrExprs.length !== attrsLengthBeforeInputs) {\n        attrExprs.splice(attrsLengthBeforeInputs, 0, o.literal(core.AttributeMarker.Bindings));\n      }\n    }\n\n    if (templateAttrs.length) {\n      attrExprs.push(o.literal(core.AttributeMarker.Template));\n      templateAttrs.forEach(attr => addAttrExpr(attr.name));\n    }\n\n    if (boundI18nAttrs.length) {\n      attrExprs.push(o.literal(core.AttributeMarker.I18n));\n      boundI18nAttrs.forEach(attr => addAttrExpr(attr.name));\n    }\n\n    return attrExprs;\n  }\n\n  private addToConsts(expression: o.Expression): o.LiteralExpr {\n    if (o.isNull(expression)) {\n      return o.TYPED_NULL_EXPR;\n    }\n\n    const consts = this._constants.constExpressions;\n\n    // Try to reuse a literal that's already in the array, if possible.\n    for (let i = 0; i < consts.length; i++) {\n      if (consts[i].isEquivalent(expression)) {\n        return o.literal(i);\n      }\n    }\n\n    return o.literal(consts.push(expression) - 1);\n  }\n\n  private addAttrsToConsts(attrs: o.Expression[]): o.LiteralExpr {\n    return attrs.length > 0 ? this.addToConsts(o.literalArr(attrs)) : o.TYPED_NULL_EXPR;\n  }\n\n  private prepareRefsArray(references: t.Reference[]): o.Expression {\n    if (!references || references.length === 0) {\n      return o.TYPED_NULL_EXPR;\n    }\n\n    const refsParam = flatten(references.map(reference => {\n      const slot = this.allocateDataSlot();\n      // Generate the update temporary.\n      const variableName = this._bindingScope.freshReferenceName();\n      const retrievalLevel = this.level;\n      const lhs = o.variable(variableName);\n      this._bindingScope.set(\n          retrievalLevel, reference.name, lhs,\n          DeclarationPriority.DEFAULT, (scope: BindingScope, relativeLevel: number) => {\n            // e.g. nextContext(2);\n            const nextContextStmt =\n                relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : [];\n\n            // e.g. const $foo$ = reference(1);\n            const refExpr = lhs.set(o.importExpr(R3.reference).callFn([o.literal(slot)]));\n            return nextContextStmt.concat(refExpr.toConstDecl());\n          }, true);\n      return [reference.name, reference.value];\n    }));\n\n    return asLiteral(refsParam);\n  }\n\n  private prepareListenerParameter(tagName: string, outputAst: t.BoundEvent, index: number):\n      () => o.Expression[] {\n    return () => {\n      const eventName: string = outputAst.name;\n      const bindingFnName = outputAst.type === ParsedEventType.Animation ?\n          // synthetic @listener.foo values are treated the exact same as are standard listeners\n          prepareSyntheticListenerFunctionName(eventName, outputAst.phase!) :\n          sanitizeIdentifier(eventName);\n      const handlerName = `${this.templateName}_${tagName}_${bindingFnName}_${index}_listener`;\n      const scope = this._bindingScope.nestedScope(\n          this._bindingScope.bindingLevel, EVENT_BINDING_SCOPE_GLOBALS);\n      return prepareEventListenerParameters(outputAst, handlerName, scope);\n    };\n  }\n}\n\nexport class ValueConverter extends AstMemoryEfficientTransformer {\n  private _pipeBindExprs: Call[] = [];\n\n  constructor(\n      private constantPool: ConstantPool, private allocateSlot: () => number,\n      private allocatePureFunctionSlots: (numSlots: number) => number,\n      private definePipe:\n          (name: string, localName: string, slot: number, value: o.Expression) => void) {\n    super();\n  }\n\n  // AstMemoryEfficientTransformer\n  override visitPipe(pipe: BindingPipe, context: any): AST {\n    // Allocate a slot to create the pipe\n    const slot = this.allocateSlot();\n    const slotPseudoLocal = `PIPE:${slot}`;\n    // Allocate one slot for the result plus one slot per pipe argument\n    const pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);\n    const target = new PropertyRead(\n        pipe.span, pipe.sourceSpan, pipe.nameSpan, new ImplicitReceiver(pipe.span, pipe.sourceSpan),\n        slotPseudoLocal);\n    const {identifier, isVarLength} = pipeBindingCallInfo(pipe.args);\n    this.definePipe(pipe.name, slotPseudoLocal, slot, o.importExpr(identifier));\n    const args: AST[] = [pipe.exp, ...pipe.args];\n    const convertedArgs: AST[] = isVarLength ?\n        this.visitAll([new LiteralArray(pipe.span, pipe.sourceSpan, args)]) :\n        this.visitAll(args);\n\n    const pipeBindExpr = new Call(\n        pipe.span, pipe.sourceSpan, target,\n        [\n          new LiteralPrimitive(pipe.span, pipe.sourceSpan, slot),\n          new LiteralPrimitive(pipe.span, pipe.sourceSpan, pureFunctionSlot),\n          ...convertedArgs,\n        ],\n        null!);\n    this._pipeBindExprs.push(pipeBindExpr);\n    return pipeBindExpr;\n  }\n\n  updatePipeSlotOffsets(bindingSlots: number) {\n    this._pipeBindExprs.forEach((pipe: Call) => {\n      // update the slot offset arg (index 1) to account for binding slots\n      const slotOffset = pipe.args[1] as LiteralPrimitive;\n      (slotOffset.value as number) += bindingSlots;\n    });\n  }\n\n  override visitLiteralArray(array: LiteralArray, context: any): AST {\n    return new BuiltinFunctionCall(\n        array.span, array.sourceSpan, this.visitAll(array.expressions), values => {\n          // If the literal has calculated (non-literal) elements transform it into\n          // calls to literal factories that compose the literal and will cache intermediate\n          // values.\n          const literal = o.literalArr(values);\n          return getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);\n        });\n  }\n\n  override visitLiteralMap(map: LiteralMap, context: any): AST {\n    return new BuiltinFunctionCall(map.span, map.sourceSpan, this.visitAll(map.values), values => {\n      // If the literal has calculated (non-literal) elements  transform it into\n      // calls to literal factories that compose the literal and will cache intermediate\n      // values.\n      const literal = o.literalMap(values.map(\n          (value, index) => ({key: map.keys[index].key, value, quoted: map.keys[index].quoted})));\n      return getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);\n    });\n  }\n}\n\n// Pipes always have at least one parameter, the value they operate on\nconst pipeBindingIdentifiers = [R3.pipeBind1, R3.pipeBind2, R3.pipeBind3, R3.pipeBind4];\n\nfunction pipeBindingCallInfo(args: o.Expression[]) {\n  const identifier = pipeBindingIdentifiers[args.length];\n  return {\n    identifier: identifier || R3.pipeBindV,\n    isVarLength: !identifier,\n  };\n}\n\nconst pureFunctionIdentifiers = [\n  R3.pureFunction0, R3.pureFunction1, R3.pureFunction2, R3.pureFunction3, R3.pureFunction4,\n  R3.pureFunction5, R3.pureFunction6, R3.pureFunction7, R3.pureFunction8\n];\n\nfunction pureFunctionCallInfo(args: o.Expression[]) {\n  const identifier = pureFunctionIdentifiers[args.length];\n  return {\n    identifier: identifier || R3.pureFunctionV,\n    isVarLength: !identifier,\n  };\n}\n\n// e.g. x(2);\nfunction generateNextContextExpr(relativeLevelDiff: number): o.Expression {\n  return o.importExpr(R3.nextContext)\n      .callFn(relativeLevelDiff > 1 ? [o.literal(relativeLevelDiff)] : []);\n}\n\nfunction getLiteralFactory(\n    constantPool: ConstantPool, literal: o.LiteralArrayExpr|o.LiteralMapExpr,\n    allocateSlots: (numSlots: number) => number): o.Expression {\n  const {literalFactory, literalFactoryArguments} = constantPool.getLiteralFactory(literal);\n  // Allocate 1 slot for the result plus 1 per argument\n  const startSlot = allocateSlots(1 + literalFactoryArguments.length);\n  const {identifier, isVarLength} = pureFunctionCallInfo(literalFactoryArguments);\n\n  // Literal factories are pure functions that only need to be re-invoked when the parameters\n  // change.\n  const args = [o.literal(startSlot), literalFactory];\n\n  if (isVarLength) {\n    args.push(o.literalArr(literalFactoryArguments));\n  } else {\n    args.push(...literalFactoryArguments);\n  }\n\n  return o.importExpr(identifier).callFn(args);\n}\n\n/**\n * Gets an array of literals that can be added to an expression\n * to represent the name and namespace of an attribute. E.g.\n * `:xlink:href` turns into `[AttributeMarker.NamespaceURI, 'xlink', 'href']`.\n *\n * @param name Name of the attribute, including the namespace.\n */\nfunction getAttributeNameLiterals(name: string): o.LiteralExpr[] {\n  const [attributeNamespace, attributeName] = splitNsName(name);\n  const nameLiteral = o.literal(attributeName);\n\n  if (attributeNamespace) {\n    return [\n      o.literal(core.AttributeMarker.NamespaceURI), o.literal(attributeNamespace), nameLiteral\n    ];\n  }\n\n  return [nameLiteral];\n}\n\n/**\n * Function which is executed whenever a variable is referenced for the first time in a given\n * scope.\n *\n * It is expected that the function creates the `const localName = expression`; statement.\n */\nexport type DeclareLocalVarCallback = (scope: BindingScope, relativeLevel: number) => o.Statement[];\n\n/** The prefix used to get a shared context in BindingScope's map. */\nconst SHARED_CONTEXT_KEY = '$$shared_ctx$$';\n\n/**\n * This is used when one refers to variable such as: 'let abc = nextContext(2).$implicit`.\n * - key to the map is the string literal `\"abc\"`.\n * - value `retrievalLevel` is the level from which this value can be retrieved, which is 2 levels\n * up in example.\n * - value `lhs` is the left hand side which is an AST representing `abc`.\n * - value `declareLocalCallback` is a callback that is invoked when declaring the local.\n * - value `declare` is true if this value needs to be declared.\n * - value `localRef` is true if we are storing a local reference\n * - value `priority` dictates the sorting priority of this var declaration compared\n * to other var declarations on the same retrieval level. For example, if there is a\n * context variable and a local ref accessing the same parent view, the context var\n * declaration should always come before the local ref declaration.\n */\ntype BindingData = {\n  retrievalLevel: number; lhs: o.Expression;\n  declareLocalCallback?: DeclareLocalVarCallback; declare: boolean; priority: number;\n};\n\n/**\n * The sorting priority of a local variable declaration. Higher numbers\n * mean the declaration will appear first in the generated code.\n */\nconst enum DeclarationPriority {\n  DEFAULT = 0,\n  CONTEXT = 1,\n  SHARED_CONTEXT = 2\n}\n\nexport class BindingScope implements LocalResolver {\n  /** Keeps a map from local variables to their BindingData. */\n  private map = new Map<string, BindingData>();\n  private referenceNameIndex = 0;\n  private restoreViewVariable: o.ReadVarExpr|null = null;\n  private usesRestoredViewContext = false;\n  static createRootScope(): BindingScope {\n    return new BindingScope();\n  }\n\n  private constructor(\n      public bindingLevel: number = 0, private parent: BindingScope|null = null,\n      public globals?: Set<string>) {\n    if (globals !== undefined) {\n      for (const name of globals) {\n        this.set(0, name, o.variable(name));\n      }\n    }\n  }\n\n  get(name: string): o.Expression|null {\n    let current: BindingScope|null = this;\n    while (current) {\n      let value = current.map.get(name);\n      if (value != null) {\n        if (current !== this) {\n          // make a local copy and reset the `declare` state\n          value = {\n            retrievalLevel: value.retrievalLevel,\n            lhs: value.lhs,\n            declareLocalCallback: value.declareLocalCallback,\n            declare: false,\n            priority: value.priority\n          };\n\n          // Cache the value locally.\n          this.map.set(name, value);\n          // Possibly generate a shared context var\n          this.maybeGenerateSharedContextVar(value);\n          this.maybeRestoreView();\n        }\n\n        if (value.declareLocalCallback && !value.declare) {\n          value.declare = true;\n        }\n        return value.lhs;\n      }\n      current = current.parent;\n    }\n\n    // If we get to this point, we are looking for a property on the top level component\n    // - If level === 0, we are on the top and don't need to re-declare `ctx`.\n    // - If level > 0, we are in an embedded view. We need to retrieve the name of the\n    // local var we used to store the component context, e.g. const $comp$ = x();\n    return this.bindingLevel === 0 ? null : this.getComponentProperty(name);\n  }\n\n  /**\n   * Create a local variable for later reference.\n   *\n   * @param retrievalLevel The level from which this value can be retrieved\n   * @param name Name of the variable.\n   * @param lhs AST representing the left hand side of the `let lhs = rhs;`.\n   * @param priority The sorting priority of this var\n   * @param declareLocalCallback The callback to invoke when declaring this local var\n   * @param localRef Whether or not this is a local ref\n   */\n  set(retrievalLevel: number, name: string, lhs: o.Expression,\n      priority: number = DeclarationPriority.DEFAULT,\n      declareLocalCallback?: DeclareLocalVarCallback, localRef?: true): BindingScope {\n    if (this.map.has(name)) {\n      if (localRef) {\n        // Do not throw an error if it's a local ref and do not update existing value,\n        // so the first defined ref is always returned.\n        return this;\n      }\n      error(`The name ${name} is already defined in scope to be ${this.map.get(name)}`);\n    }\n    this.map.set(name, {\n      retrievalLevel: retrievalLevel,\n      lhs: lhs,\n      declare: false,\n      declareLocalCallback: declareLocalCallback,\n      priority: priority,\n    });\n    return this;\n  }\n\n  // Implemented as part of LocalResolver.\n  getLocal(name: string): (o.Expression|null) {\n    return this.get(name);\n  }\n\n  // Implemented as part of LocalResolver.\n  notifyImplicitReceiverUse(): void {\n    if (this.bindingLevel !== 0) {\n      // Since the implicit receiver is accessed in an embedded view, we need to\n      // ensure that we declare a shared context variable for the current template\n      // in the update variables.\n      this.map.get(SHARED_CONTEXT_KEY + 0)!.declare = true;\n    }\n  }\n\n  nestedScope(level: number, globals?: Set<string>): BindingScope {\n    const newScope = new BindingScope(level, this, globals);\n    if (level > 0) newScope.generateSharedContextVar(0);\n    return newScope;\n  }\n\n  /**\n   * Gets or creates a shared context variable and returns its expression. Note that\n   * this does not mean that the shared variable will be declared. Variables in the\n   * binding scope will be only declared if they are used.\n   */\n  getOrCreateSharedContextVar(retrievalLevel: number): o.ReadVarExpr {\n    const bindingKey = SHARED_CONTEXT_KEY + retrievalLevel;\n    if (!this.map.has(bindingKey)) {\n      this.generateSharedContextVar(retrievalLevel);\n    }\n    // Shared context variables are always generated as \"ReadVarExpr\".\n    return this.map.get(bindingKey)!.lhs as o.ReadVarExpr;\n  }\n\n  getSharedContextName(retrievalLevel: number): o.ReadVarExpr|null {\n    const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel);\n    // Shared context variables are always generated as \"ReadVarExpr\".\n    return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs as o.ReadVarExpr : null;\n  }\n\n  maybeGenerateSharedContextVar(value: BindingData) {\n    if (value.priority === DeclarationPriority.CONTEXT &&\n        value.retrievalLevel < this.bindingLevel) {\n      const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);\n      if (sharedCtxObj) {\n        sharedCtxObj.declare = true;\n      } else {\n        this.generateSharedContextVar(value.retrievalLevel);\n      }\n    }\n  }\n\n  generateSharedContextVar(retrievalLevel: number) {\n    const lhs = o.variable(CONTEXT_NAME + this.freshReferenceName());\n    this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {\n      retrievalLevel: retrievalLevel,\n      lhs: lhs,\n      declareLocalCallback: (scope: BindingScope, relativeLevel: number) => {\n        // const ctx_r0 = nextContext(2);\n        return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];\n      },\n      declare: false,\n      priority: DeclarationPriority.SHARED_CONTEXT,\n    });\n  }\n\n  getComponentProperty(name: string): o.Expression {\n    const componentValue = this.map.get(SHARED_CONTEXT_KEY + 0)!;\n    componentValue.declare = true;\n    this.maybeRestoreView();\n    return componentValue.lhs.prop(name);\n  }\n\n  maybeRestoreView() {\n    // View restoration is required for listener instructions inside embedded views, because\n    // they only run in creation mode and they can have references to the context object.\n    // If the context object changes in update mode, the reference will be incorrect, because\n    // it was established during creation.\n    if (this.isListenerScope()) {\n      if (!this.parent!.restoreViewVariable) {\n        // parent saves variable to generate a shared `const $s$ = getCurrentView();` instruction\n        this.parent!.restoreViewVariable = o.variable(this.parent!.freshReferenceName());\n      }\n      this.restoreViewVariable = this.parent!.restoreViewVariable;\n    }\n  }\n\n  restoreViewStatement(): o.Statement|null {\n    if (this.restoreViewVariable) {\n      const restoreCall = invokeInstruction(null, R3.restoreView, [this.restoreViewVariable]);\n      // Either `const restoredCtx = restoreView($state$);` or `restoreView($state$);`\n      // depending on whether it is being used.\n      return this.usesRestoredViewContext ?\n          o.variable(RESTORED_VIEW_CONTEXT_NAME).set(restoreCall).toConstDecl() :\n          restoreCall.toStmt();\n    }\n    return null;\n  }\n\n  viewSnapshotStatements(): o.Statement[] {\n    // const $state$ = getCurrentView();\n    return this.restoreViewVariable ?\n        [\n          this.restoreViewVariable.set(invokeInstruction(null, R3.getCurrentView, [])).toConstDecl()\n        ] :\n        [];\n  }\n\n  isListenerScope() {\n    return this.parent && this.parent.bindingLevel === this.bindingLevel;\n  }\n\n  variableDeclarations(): o.Statement[] {\n    let currentContextLevel = 0;\n    return Array.from(this.map.values())\n               .filter(value => value.declare)\n               .sort((a, b) => b.retrievalLevel - a.retrievalLevel || b.priority - a.priority)\n               .reduce((stmts: o.Statement[], value: BindingData) => {\n                 const levelDiff = this.bindingLevel - value.retrievalLevel;\n                 const currStmts =\n                     value.declareLocalCallback!(this, levelDiff - currentContextLevel);\n                 currentContextLevel = levelDiff;\n                 return stmts.concat(currStmts);\n               }, []) as o.Statement[];\n  }\n\n\n  freshReferenceName(): string {\n    let current: BindingScope = this;\n    // Find the top scope as it maintains the global reference count\n    while (current.parent) current = current.parent;\n    const ref = `${REFERENCE_PREFIX}${current.referenceNameIndex++}`;\n    return ref;\n  }\n\n  hasRestoreViewVariable(): boolean {\n    return !!this.restoreViewVariable;\n  }\n\n  notifyRestoredViewContextUse(): void {\n    this.usesRestoredViewContext = true;\n  }\n}\n\n/**\n * Creates a `CssSelector` given a tag name and a map of attributes\n */\nexport function createCssSelector(\n    elementName: string, attributes: {[name: string]: string}): CssSelector {\n  const cssSelector = new CssSelector();\n  const elementNameNoNs = splitNsName(elementName)[1];\n\n  cssSelector.setElement(elementNameNoNs);\n\n  Object.getOwnPropertyNames(attributes).forEach((name) => {\n    const nameNoNs = splitNsName(name)[1];\n    const value = attributes[name];\n\n    cssSelector.addAttribute(nameNoNs, value);\n    if (name.toLowerCase() === 'class') {\n      const classes = value.trim().split(/\\s+/);\n      classes.forEach(className => cssSelector.addClassName(className));\n    }\n  });\n\n  return cssSelector;\n}\n\n/**\n * Creates an array of expressions out of an `ngProjectAs` attributes\n * which can be added to the instruction parameters.\n */\nfunction getNgProjectAsLiteral(attribute: t.TextAttribute): o.Expression[] {\n  // Parse the attribute value into a CssSelectorList. Note that we only take the\n  // first selector, because we don't support multiple selectors in ngProjectAs.\n  const parsedR3Selector = core.parseSelectorToR3Selector(attribute.value)[0];\n  return [o.literal(core.AttributeMarker.ProjectAs), asLiteral(parsedR3Selector)];\n}\n\n/**\n * Gets the instruction to generate for an interpolated property\n * @param interpolation An Interpolation AST\n */\nfunction getPropertyInterpolationExpression(interpolation: Interpolation) {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return R3.propertyInterpolate;\n    case 3:\n      return R3.propertyInterpolate1;\n    case 5:\n      return R3.propertyInterpolate2;\n    case 7:\n      return R3.propertyInterpolate3;\n    case 9:\n      return R3.propertyInterpolate4;\n    case 11:\n      return R3.propertyInterpolate5;\n    case 13:\n      return R3.propertyInterpolate6;\n    case 15:\n      return R3.propertyInterpolate7;\n    case 17:\n      return R3.propertyInterpolate8;\n    default:\n      return R3.propertyInterpolateV;\n  }\n}\n\n/**\n * Gets the instruction to generate for an interpolated attribute\n * @param interpolation An Interpolation AST\n */\nfunction getAttributeInterpolationExpression(interpolation: Interpolation) {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 3:\n      return R3.attributeInterpolate1;\n    case 5:\n      return R3.attributeInterpolate2;\n    case 7:\n      return R3.attributeInterpolate3;\n    case 9:\n      return R3.attributeInterpolate4;\n    case 11:\n      return R3.attributeInterpolate5;\n    case 13:\n      return R3.attributeInterpolate6;\n    case 15:\n      return R3.attributeInterpolate7;\n    case 17:\n      return R3.attributeInterpolate8;\n    default:\n      return R3.attributeInterpolateV;\n  }\n}\n\n/**\n * Gets the instruction to generate for interpolated text.\n * @param interpolation An Interpolation AST\n */\nfunction getTextInterpolationExpression(interpolation: Interpolation): o.ExternalReference {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return R3.textInterpolate;\n    case 3:\n      return R3.textInterpolate1;\n    case 5:\n      return R3.textInterpolate2;\n    case 7:\n      return R3.textInterpolate3;\n    case 9:\n      return R3.textInterpolate4;\n    case 11:\n      return R3.textInterpolate5;\n    case 13:\n      return R3.textInterpolate6;\n    case 15:\n      return R3.textInterpolate7;\n    case 17:\n      return R3.textInterpolate8;\n    default:\n      return R3.textInterpolateV;\n  }\n}\n\n/**\n * Options that can be used to modify how a template is parsed by `parseTemplate()`.\n */\nexport interface ParseTemplateOptions {\n  /**\n   * Include whitespace nodes in the parsed output.\n   */\n  preserveWhitespaces?: boolean;\n  /**\n   * Preserve original line endings instead of normalizing '\\r\\n' endings to '\\n'.\n   */\n  preserveLineEndings?: boolean;\n  /**\n   * How to parse interpolation markers.\n   */\n  interpolationConfig?: InterpolationConfig;\n  /**\n   * The start and end point of the text to parse within the `source` string.\n   * The entire `source` string is parsed if this is not provided.\n   * */\n  range?: LexerRange;\n  /**\n   * If this text is stored in a JavaScript string, then we have to deal with escape sequences.\n   *\n   * **Example 1:**\n   *\n   * ```\n   * \"abc\\\"def\\nghi\"\n   * ```\n   *\n   * - The `\\\"` must be converted to `\"`.\n   * - The `\\n` must be converted to a new line character in a token,\n   *   but it should not increment the current line for source mapping.\n   *\n   * **Example 2:**\n   *\n   * ```\n   * \"abc\\\n   *  def\"\n   * ```\n   *\n   * The line continuation (`\\` followed by a newline) should be removed from a token\n   * but the new line should increment the current line for source mapping.\n   */\n  escapedString?: boolean;\n  /**\n   * An array of characters that should be considered as leading trivia.\n   * Leading trivia are characters that are not important to the developer, and so should not be\n   * included in source-map segments.  A common example is whitespace.\n   */\n  leadingTriviaChars?: string[];\n\n  /**\n   * Render `$localize` message ids with additional legacy message ids.\n   *\n   * This option defaults to `true` but in the future the default will be flipped.\n   *\n   * For now set this option to false if you have migrated the translation files to use the new\n   * `$localize` message id format and you are not using compile time translation merging.\n   */\n  enableI18nLegacyMessageIdFormat?: boolean;\n\n  /**\n   * If this text is stored in an external template (e.g. via `templateUrl`) then we need to decide\n   * whether or not to normalize the line-endings (from `\\r\\n` to `\\n`) when processing ICU\n   * expressions.\n   *\n   * If `true` then we will normalize ICU expression line endings.\n   * The default is `false`, but this will be switched in a future major release.\n   */\n  i18nNormalizeLineEndingsInICUs?: boolean;\n\n  /**\n   * Whether to always attempt to convert the parsed HTML AST to an R3 AST, despite HTML or i18n\n   * Meta parse errors.\n   *\n   *\n   * This option is useful in the context of the language service, where we want to get as much\n   * information as possible, despite any errors in the HTML. As an example, a user may be adding\n   * a new tag and expecting autocomplete on that tag. In this scenario, the HTML is in an errored\n   * state, as there is an incomplete open tag. However, we're still able to convert the HTML AST\n   * nodes to R3 AST nodes in order to provide information for the language service.\n   *\n   * Note that even when `true` the HTML parse and i18n errors are still appended to the errors\n   * output, but this is done after converting the HTML AST to R3 AST.\n   */\n  alwaysAttemptHtmlToR3AstConversion?: boolean;\n\n  /**\n   * Include HTML Comment nodes in a top-level comments array on the returned R3 AST.\n   *\n   * This option is required by tooling that needs to know the location of comment nodes within the\n   * AST. A concrete example is @angular-eslint which requires this in order to enable\n   * \"eslint-disable\" comments within HTML templates, which then allows users to turn off specific\n   * rules on a case by case basis, instead of for their whole project within a configuration file.\n   */\n  collectCommentNodes?: boolean;\n}\n\n/**\n * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.\n *\n * @param template text of the template to parse\n * @param templateUrl URL to use for source mapping of the parsed template\n * @param options options to modify how the template is parsed\n */\nexport function parseTemplate(\n    template: string, templateUrl: string, options: ParseTemplateOptions = {}): ParsedTemplate {\n  const {interpolationConfig, preserveWhitespaces, enableI18nLegacyMessageIdFormat} = options;\n  const bindingParser = makeBindingParser(interpolationConfig);\n  const htmlParser = new HtmlParser();\n  const parseResult = htmlParser.parse(\n      template, templateUrl,\n      {leadingTriviaChars: LEADING_TRIVIA_CHARS, ...options, tokenizeExpansionForms: true});\n\n  if (!options.alwaysAttemptHtmlToR3AstConversion && parseResult.errors &&\n      parseResult.errors.length > 0) {\n    const parsedTemplate: ParsedTemplate = {\n      interpolationConfig,\n      preserveWhitespaces,\n      errors: parseResult.errors,\n      nodes: [],\n      styleUrls: [],\n      styles: [],\n      ngContentSelectors: []\n    };\n    if (options.collectCommentNodes) {\n      parsedTemplate.commentNodes = [];\n    }\n    return parsedTemplate;\n  }\n\n  let rootNodes: html.Node[] = parseResult.rootNodes;\n\n  // process i18n meta information (scan attributes, generate ids)\n  // before we run whitespace removal process, because existing i18n\n  // extraction process (ng extract-i18n) relies on a raw content to generate\n  // message ids\n  const i18nMetaVisitor = new I18nMetaVisitor(\n      interpolationConfig, /* keepI18nAttrs */ !preserveWhitespaces,\n      enableI18nLegacyMessageIdFormat);\n  const i18nMetaResult = i18nMetaVisitor.visitAllWithErrors(rootNodes);\n\n  if (!options.alwaysAttemptHtmlToR3AstConversion && i18nMetaResult.errors &&\n      i18nMetaResult.errors.length > 0) {\n    const parsedTemplate: ParsedTemplate = {\n      interpolationConfig,\n      preserveWhitespaces,\n      errors: i18nMetaResult.errors,\n      nodes: [],\n      styleUrls: [],\n      styles: [],\n      ngContentSelectors: []\n    };\n    if (options.collectCommentNodes) {\n      parsedTemplate.commentNodes = [];\n    }\n    return parsedTemplate;\n  }\n\n  rootNodes = i18nMetaResult.rootNodes;\n\n  if (!preserveWhitespaces) {\n    rootNodes = html.visitAll(new WhitespaceVisitor(), rootNodes);\n\n    // run i18n meta visitor again in case whitespaces are removed (because that might affect\n    // generated i18n message content) and first pass indicated that i18n content is present in a\n    // template. During this pass i18n IDs generated at the first pass will be preserved, so we can\n    // mimic existing extraction process (ng extract-i18n)\n    if (i18nMetaVisitor.hasI18nMeta) {\n      rootNodes = html.visitAll(\n          new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ false), rootNodes);\n    }\n  }\n\n  const {nodes, errors, styleUrls, styles, ngContentSelectors, commentNodes} = htmlAstToRender3Ast(\n      rootNodes, bindingParser, {collectCommentNodes: !!options.collectCommentNodes});\n  errors.push(...parseResult.errors, ...i18nMetaResult.errors);\n\n  const parsedTemplate: ParsedTemplate = {\n    interpolationConfig,\n    preserveWhitespaces,\n    errors: errors.length > 0 ? errors : null,\n    nodes,\n    styleUrls,\n    styles,\n    ngContentSelectors\n  };\n\n  if (options.collectCommentNodes) {\n    parsedTemplate.commentNodes = commentNodes;\n  }\n  return parsedTemplate;\n}\n\nconst elementRegistry = new DomElementSchemaRegistry();\n\n/**\n * Construct a `BindingParser` with a default configuration.\n */\nexport function makeBindingParser(\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): BindingParser {\n  return new BindingParser(new Parser(new Lexer()), interpolationConfig, elementRegistry, []);\n}\n\nexport function resolveSanitizationFn(context: core.SecurityContext, isAttribute?: boolean) {\n  switch (context) {\n    case core.SecurityContext.HTML:\n      return o.importExpr(R3.sanitizeHtml);\n    case core.SecurityContext.SCRIPT:\n      return o.importExpr(R3.sanitizeScript);\n    case core.SecurityContext.STYLE:\n      // the compiler does not fill in an instruction for [style.prop?] binding\n      // values because the style algorithm knows internally what props are subject\n      // to sanitization (only [attr.style] values are explicitly sanitized)\n      return isAttribute ? o.importExpr(R3.sanitizeStyle) : null;\n    case core.SecurityContext.URL:\n      return o.importExpr(R3.sanitizeUrl);\n    case core.SecurityContext.RESOURCE_URL:\n      return o.importExpr(R3.sanitizeResourceUrl);\n    default:\n      return null;\n  }\n}\n\nfunction trustedConstAttribute(tagName: string, attr: t.TextAttribute): o.Expression {\n  const value = asLiteral(attr.value);\n  if (isTrustedTypesSink(tagName, attr.name)) {\n    switch (elementRegistry.securityContext(tagName, attr.name, /* isAttribute */ true)) {\n      case core.SecurityContext.HTML:\n        return o.taggedTemplate(\n            o.importExpr(R3.trustConstantHtml),\n            new o.TemplateLiteral([new o.TemplateLiteralElement(attr.value)], []), undefined,\n            attr.valueSpan);\n      // NB: no SecurityContext.SCRIPT here, as the corresponding tags are stripped by the compiler.\n      case core.SecurityContext.RESOURCE_URL:\n        return o.taggedTemplate(\n            o.importExpr(R3.trustConstantResourceUrl),\n            new o.TemplateLiteral([new o.TemplateLiteralElement(attr.value)], []), undefined,\n            attr.valueSpan);\n      default:\n        return value;\n    }\n  } else {\n    return value;\n  }\n}\n\nfunction isSingleElementTemplate(children: t.Node[]): children is[t.Element] {\n  return children.length === 1 && children[0] instanceof t.Element;\n}\n\nfunction isTextNode(node: t.Node): boolean {\n  return node instanceof t.Text || node instanceof t.BoundText || node instanceof t.Icu;\n}\n\nfunction isIframeElement(tagName: string): boolean {\n  return tagName.toLowerCase() === 'iframe';\n}\n\nfunction hasTextChildrenOnly(children: t.Node[]): boolean {\n  return children.every(isTextNode);\n}\n\nfunction getBindingFunctionParams(\n    deferredParams: () => (o.Expression | o.Expression[]), name?: string,\n    eagerParams?: o.Expression[]) {\n  return () => {\n    const value = deferredParams();\n    const fnParams = Array.isArray(value) ? value : [value];\n    if (eagerParams) {\n      fnParams.push(...eagerParams);\n    }\n    if (name) {\n      // We want the property name to always be the first function parameter.\n      fnParams.unshift(o.literal(name));\n    }\n    return fnParams;\n  };\n}\n\n/** Name of the global variable that is used to determine if we use Closure translations or not */\nconst NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';\n\n/**\n * Generate statements that define a given translation message.\n *\n * ```\n * var I18N_1;\n * if (typeof ngI18nClosureMode !== undefined && ngI18nClosureMode) {\n *     var MSG_EXTERNAL_XXX = goog.getMsg(\n *          \"Some message with {$interpolation}!\",\n *          { \"interpolation\": \"\\uFFFD0\\uFFFD\" }\n *     );\n *     I18N_1 = MSG_EXTERNAL_XXX;\n * }\n * else {\n *     I18N_1 = $localize`Some message with ${'\\uFFFD0\\uFFFD'}!`;\n * }\n * ```\n *\n * @param message The original i18n AST message node\n * @param variable The variable that will be assigned the translation, e.g. `I18N_1`.\n * @param closureVar The variable for Closure `goog.getMsg` calls, e.g. `MSG_EXTERNAL_XXX`.\n * @param params Object mapping placeholder names to their values (e.g.\n * `{ \"interpolation\": \"\\uFFFD0\\uFFFD\" }`).\n * @param transformFn Optional transformation function that will be applied to the translation (e.g.\n * post-processing).\n * @returns An array of statements that defined a given translation.\n */\nexport function getTranslationDeclStmts(\n    message: i18n.Message, variable: o.ReadVarExpr, closureVar: o.ReadVarExpr,\n    params: {[name: string]: o.Expression} = {},\n    transformFn?: (raw: o.ReadVarExpr) => o.Expression): o.Statement[] {\n  const statements: o.Statement[] = [\n    declareI18nVariable(variable),\n    o.ifStmt(\n        createClosureModeGuard(),\n        createGoogleGetMsgStatements(variable, message, closureVar, params),\n        createLocalizeStatements(\n            variable, message, formatI18nPlaceholderNamesInMap(params, /* useCamelCase */ false))),\n  ];\n\n  if (transformFn) {\n    statements.push(new o.ExpressionStatement(variable.set(transformFn(variable))));\n  }\n\n  return statements;\n}\n\n/**\n * Create the expression that will be used to guard the closure mode block\n * It is equivalent to:\n *\n * ```\n * typeof ngI18nClosureMode !== undefined && ngI18nClosureMode\n * ```\n */\nfunction createClosureModeGuard(): o.BinaryOperatorExpr {\n  return o.typeofExpr(o.variable(NG_I18N_CLOSURE_MODE))\n      .notIdentical(o.literal('undefined', o.STRING_TYPE))\n      .and(o.variable(NG_I18N_CLOSURE_MODE));\n}\n\n/**\n * Information about the template which was extracted during parsing.\n *\n * This contains the actual parsed template as well as any metadata collected during its parsing,\n * some of which might be useful for re-parsing the template with different options.\n */\nexport interface ParsedTemplate {\n  /**\n   * Include whitespace nodes in the parsed output.\n   */\n  preserveWhitespaces?: boolean;\n\n  /**\n   * How to parse interpolation markers.\n   */\n  interpolationConfig?: InterpolationConfig;\n  /**\n   * Any errors from parsing the template the first time.\n   *\n   * `null` if there are no errors. Otherwise, the array of errors is guaranteed to be non-empty.\n   */\n  errors: ParseError[]|null;\n\n  /**\n   * The template AST, parsed from the template.\n   */\n  nodes: t.Node[];\n\n  /**\n   * Any styleUrls extracted from the metadata.\n   */\n  styleUrls: string[];\n\n  /**\n   * Any inline styles extracted from the metadata.\n   */\n  styles: string[];\n\n  /**\n   * Any ng-content selectors extracted from the template.\n   */\n  ngContentSelectors: string[];\n\n  /**\n   * Any R3 Comment Nodes extracted from the template when the `collectCommentNodes` parse template\n   * option is enabled.\n   */\n  commentNodes?: t.Comment[];\n}\n\nfunction flatten<T>(list: Array<T|T[]>): T[] {\n  return list.reduce((flat: any[], item: T|T[]): T[] => {\n    const flatItem = Array.isArray(item) ? flatten(item) : item;\n    return (<T[]>flat).concat(flatItem);\n  }, []);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {convertPropertyBinding} from '../../compiler_util/expression_converter';\nimport {ConstantPool} from '../../constant_pool';\nimport * as core from '../../core';\nimport {AST, ParsedEvent, ParsedEventType, ParsedProperty} from '../../expression_parser/ast';\nimport * as o from '../../output/output_ast';\nimport {ParseError, ParseSourceSpan, sanitizeIdentifier} from '../../parse_util';\nimport {isIframeSecuritySensitiveAttr} from '../../schema/dom_security_schema';\nimport {CssSelector} from '../../selector';\nimport {ShadowCss} from '../../shadow_css';\nimport {BindingParser} from '../../template_parser/binding_parser';\nimport {error} from '../../util';\nimport {BoundEvent} from '../r3_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {prepareSyntheticListenerFunctionName, prepareSyntheticPropertyName, R3CompiledExpression, typeWithParameters} from '../util';\n\nimport {DeclarationListEmitMode, R3ComponentMetadata, R3DirectiveMetadata, R3HostMetadata, R3QueryMetadata, R3TemplateDependency} from './api';\nimport {MIN_STYLING_BINDING_SLOTS_REQUIRED, StylingBuilder, StylingInstructionCall} from './styling_builder';\nimport {BindingScope, makeBindingParser, prepareEventListenerParameters, renderFlagCheckIfStmt, resolveSanitizationFn, TemplateDefinitionBuilder, ValueConverter} from './template';\nimport {asLiteral, conditionallyCreateMapObjectLiteral, CONTEXT_NAME, DefinitionMap, getInstructionStatements, getQueryPredicate, Instruction, RENDER_FLAGS, TEMPORARY_NAME, temporaryAllocator} from './util';\n\n\n// This regex matches any binding names that contain the \"attr.\" prefix, e.g. \"attr.required\"\n// If there is a match, the first matching group will contain the attribute name to bind.\nconst ATTR_REGEX = /attr\\.([^\\]]+)/;\n\n\nconst COMPONENT_VARIABLE = '%COMP%';\nconst HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\nconst CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\n\nfunction baseDirectiveFields(\n    meta: R3DirectiveMetadata, constantPool: ConstantPool,\n    bindingParser: BindingParser): DefinitionMap {\n  const definitionMap = new DefinitionMap();\n  const selectors = core.parseSelectorToR3Selector(meta.selector);\n\n  // e.g. `type: MyDirective`\n  definitionMap.set('type', meta.internalType);\n\n  // e.g. `selectors: [['', 'someDir', '']]`\n  if (selectors.length > 0) {\n    definitionMap.set('selectors', asLiteral(selectors));\n  }\n\n  if (meta.queries.length > 0) {\n    // e.g. `contentQueries: (rf, ctx, dirIndex) => { ... }\n    definitionMap.set(\n        'contentQueries', createContentQueriesFunction(meta.queries, constantPool, meta.name));\n  }\n\n  if (meta.viewQueries.length) {\n    definitionMap.set(\n        'viewQuery', createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));\n  }\n\n  // e.g. `hostBindings: (rf, ctx) => { ... }\n  definitionMap.set(\n      'hostBindings',\n      createHostBindingsFunction(\n          meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || '',\n          meta.name, definitionMap));\n\n  // e.g 'inputs: {a: 'a'}`\n  definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));\n\n  // e.g 'outputs: {a: 'a'}`\n  definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));\n\n  if (meta.exportAs !== null) {\n    definitionMap.set('exportAs', o.literalArr(meta.exportAs.map(e => o.literal(e))));\n  }\n\n  if (meta.isStandalone) {\n    definitionMap.set('standalone', o.literal(true));\n  }\n\n  return definitionMap;\n}\n\n/**\n * Add features to the definition map.\n */\nfunction addFeatures(\n    definitionMap: DefinitionMap,\n    meta: R3DirectiveMetadata|R3ComponentMetadata<R3TemplateDependency>) {\n  // e.g. `features: [NgOnChangesFeature]`\n  const features: o.Expression[] = [];\n\n  const providers = meta.providers;\n  const viewProviders = (meta as R3ComponentMetadata<R3TemplateDependency>).viewProviders;\n  if (providers || viewProviders) {\n    const args = [providers || new o.LiteralArrayExpr([])];\n    if (viewProviders) {\n      args.push(viewProviders);\n    }\n    features.push(o.importExpr(R3.ProvidersFeature).callFn(args));\n  }\n\n  if (meta.usesInheritance) {\n    features.push(o.importExpr(R3.InheritDefinitionFeature));\n  }\n  if (meta.fullInheritance) {\n    features.push(o.importExpr(R3.CopyDefinitionFeature));\n  }\n  if (meta.lifecycle.usesOnChanges) {\n    features.push(o.importExpr(R3.NgOnChangesFeature));\n  }\n  // TODO: better way of differentiating component vs directive metadata.\n  if (meta.hasOwnProperty('template') && meta.isStandalone) {\n    features.push(o.importExpr(R3.StandaloneFeature));\n  }\n  if (meta.hostDirectives?.length) {\n    features.push(o.importExpr(R3.HostDirectivesFeature).callFn([createHostDirectivesFeatureArg(\n        meta.hostDirectives)]));\n  }\n  if (features.length) {\n    definitionMap.set('features', o.literalArr(features));\n  }\n}\n\n/**\n * Compile a directive for the render3 runtime as defined by the `R3DirectiveMetadata`.\n */\nexport function compileDirectiveFromMetadata(\n    meta: R3DirectiveMetadata, constantPool: ConstantPool,\n    bindingParser: BindingParser): R3CompiledExpression {\n  const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n  addFeatures(definitionMap, meta);\n  const expression =\n      o.importExpr(R3.defineDirective).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createDirectiveType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Compile a component for the render3 runtime as defined by the `R3ComponentMetadata`.\n */\nexport function compileComponentFromMetadata(\n    meta: R3ComponentMetadata<R3TemplateDependency>, constantPool: ConstantPool,\n    bindingParser: BindingParser): R3CompiledExpression {\n  const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n  addFeatures(definitionMap, meta);\n\n  const selector = meta.selector && CssSelector.parse(meta.selector);\n  const firstSelector = selector && selector[0];\n\n  // e.g. `attr: [\"class\", \".my.app\"]`\n  // This is optional an only included if the first selector of a component specifies attributes.\n  if (firstSelector) {\n    const selectorAttributes = firstSelector.getAttrs();\n    if (selectorAttributes.length) {\n      definitionMap.set(\n          'attrs',\n          constantPool.getConstLiteral(\n              o.literalArr(selectorAttributes.map(\n                  value => value != null ? o.literal(value) : o.literal(undefined))),\n              /* forceShared */ true));\n    }\n  }\n\n  // e.g. `template: function MyComponent_Template(_ctx, _cm) {...}`\n  const templateTypeName = meta.name;\n  const templateName = templateTypeName ? `${templateTypeName}_Template` : null;\n\n  const changeDetection = meta.changeDetection;\n\n  const template = meta.template;\n  const templateBuilder = new TemplateDefinitionBuilder(\n      constantPool, BindingScope.createRootScope(), 0, templateTypeName, null, null, templateName,\n      R3.namespaceHTML, meta.relativeContextFilePath, meta.i18nUseExternalIds);\n\n  const templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []);\n\n  // We need to provide this so that dynamically generated components know what\n  // projected content blocks to pass through to the component when it is instantiated.\n  const ngContentSelectors = templateBuilder.getNgContentSelectors();\n  if (ngContentSelectors) {\n    definitionMap.set('ngContentSelectors', ngContentSelectors);\n  }\n\n  // e.g. `decls: 2`\n  definitionMap.set('decls', o.literal(templateBuilder.getConstCount()));\n\n  // e.g. `vars: 2`\n  definitionMap.set('vars', o.literal(templateBuilder.getVarCount()));\n\n  // Generate `consts` section of ComponentDef:\n  // - either as an array:\n  //   `consts: [['one', 'two'], ['three', 'four']]`\n  // - or as a factory function in case additional statements are present (to support i18n):\n  //   `consts: function() { var i18n_0; if (ngI18nClosureMode) {...} else {...} return [i18n_0]; }`\n  const {constExpressions, prepareStatements} = templateBuilder.getConsts();\n  if (constExpressions.length > 0) {\n    let constsExpr: o.LiteralArrayExpr|o.FunctionExpr = o.literalArr(constExpressions);\n    // Prepare statements are present - turn `consts` into a function.\n    if (prepareStatements.length > 0) {\n      constsExpr = o.fn([], [...prepareStatements, new o.ReturnStatement(constsExpr)]);\n    }\n    definitionMap.set('consts', constsExpr);\n  }\n\n  definitionMap.set('template', templateFunctionExpression);\n\n  if (meta.declarations.length > 0) {\n    definitionMap.set(\n        'dependencies',\n        compileDeclarationList(\n            o.literalArr(meta.declarations.map(decl => decl.type)), meta.declarationListEmitMode));\n  }\n\n  if (meta.encapsulation === null) {\n    meta.encapsulation = core.ViewEncapsulation.Emulated;\n  }\n\n  // e.g. `styles: [str1, str2]`\n  if (meta.styles && meta.styles.length) {\n    const styleValues = meta.encapsulation == core.ViewEncapsulation.Emulated ?\n        compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) :\n        meta.styles;\n    const styleNodes = styleValues.reduce((result, style) => {\n      if (style.trim().length > 0) {\n        result.push(constantPool.getConstLiteral(o.literal(style)));\n      }\n      return result;\n    }, [] as o.Expression[]);\n\n    if (styleNodes.length > 0) {\n      definitionMap.set('styles', o.literalArr(styleNodes));\n    }\n  } else if (meta.encapsulation === core.ViewEncapsulation.Emulated) {\n    // If there is no style, don't generate css selectors on elements\n    meta.encapsulation = core.ViewEncapsulation.None;\n  }\n\n  // Only set view encapsulation if it's not the default value\n  if (meta.encapsulation !== core.ViewEncapsulation.Emulated) {\n    definitionMap.set('encapsulation', o.literal(meta.encapsulation));\n  }\n\n  // e.g. `animation: [trigger('123', [])]`\n  if (meta.animations !== null) {\n    definitionMap.set(\n        'data', o.literalMap([{key: 'animation', value: meta.animations, quoted: false}]));\n  }\n\n  // Only set the change detection flag if it's defined and it's not the default.\n  if (changeDetection != null && changeDetection !== core.ChangeDetectionStrategy.Default) {\n    definitionMap.set('changeDetection', o.literal(changeDetection));\n  }\n\n  const expression =\n      o.importExpr(R3.defineComponent).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createComponentType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Creates the type specification from the component meta. This type is inserted into .d.ts files\n * to be consumed by upstream compilations.\n */\nexport function createComponentType(meta: R3ComponentMetadata<R3TemplateDependency>): o.Type {\n  const typeParams = createBaseDirectiveTypeParams(meta);\n  typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));\n  typeParams.push(o.expressionType(o.literal(meta.isStandalone)));\n  typeParams.push(createHostDirectivesType(meta));\n  return o.expressionType(o.importExpr(R3.ComponentDeclaration, typeParams));\n}\n\n/**\n * Compiles the array literal of declarations into an expression according to the provided emit\n * mode.\n */\nfunction compileDeclarationList(\n    list: o.LiteralArrayExpr, mode: DeclarationListEmitMode): o.Expression {\n  switch (mode) {\n    case DeclarationListEmitMode.Direct:\n      // directives: [MyDir],\n      return list;\n    case DeclarationListEmitMode.Closure:\n      // directives: function () { return [MyDir]; }\n      return o.fn([], [new o.ReturnStatement(list)]);\n    case DeclarationListEmitMode.ClosureResolved:\n      // directives: function () { return [MyDir].map(ng.resolveForwardRef); }\n      const resolvedList = list.prop('map').callFn([o.importExpr(R3.resolveForwardRef)]);\n      return o.fn([], [new o.ReturnStatement(resolvedList)]);\n  }\n}\n\nfunction prepareQueryParams(query: R3QueryMetadata, constantPool: ConstantPool): o.Expression[] {\n  const parameters = [getQueryPredicate(query, constantPool), o.literal(toQueryFlags(query))];\n  if (query.read) {\n    parameters.push(query.read);\n  }\n  return parameters;\n}\n\n/**\n * A set of flags to be used with Queries.\n *\n * NOTE: Ensure changes here are in sync with `packages/core/src/render3/interfaces/query.ts`\n */\nexport const enum QueryFlags {\n  /**\n   * No flags\n   */\n  none = 0b0000,\n\n  /**\n   * Whether or not the query should descend into children.\n   */\n  descendants = 0b0001,\n\n  /**\n   * The query can be computed statically and hence can be assigned eagerly.\n   *\n   * NOTE: Backwards compatibility with ViewEngine.\n   */\n  isStatic = 0b0010,\n\n  /**\n   * If the `QueryList` should fire change event only if actual change to query was computed (vs old\n   * behavior where the change was fired whenever the query was recomputed, even if the recomputed\n   * query resulted in the same list.)\n   */\n  emitDistinctChangesOnly = 0b0100,\n}\n\n/**\n * Translates query flags into `TQueryFlags` type in packages/core/src/render3/interfaces/query.ts\n * @param query\n */\nfunction toQueryFlags(query: R3QueryMetadata): number {\n  return (query.descendants ? QueryFlags.descendants : QueryFlags.none) |\n      (query.static ? QueryFlags.isStatic : QueryFlags.none) |\n      (query.emitDistinctChangesOnly ? QueryFlags.emitDistinctChangesOnly : QueryFlags.none);\n}\n\nfunction convertAttributesToExpressions(attributes: {[name: string]: o.Expression}):\n    o.Expression[] {\n  const values: o.Expression[] = [];\n  for (let key of Object.getOwnPropertyNames(attributes)) {\n    const value = attributes[key];\n    values.push(o.literal(key), value);\n  }\n  return values;\n}\n\n// Define and update any content queries\nfunction createContentQueriesFunction(\n    queries: R3QueryMetadata[], constantPool: ConstantPool, name?: string): o.Expression {\n  const createStatements: o.Statement[] = [];\n  const updateStatements: o.Statement[] = [];\n  const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);\n\n  for (const query of queries) {\n    // creation, e.g. r3.contentQuery(dirIndex, somePredicate, true, null);\n    createStatements.push(\n        o.importExpr(R3.contentQuery)\n            .callFn([o.variable('dirIndex'), ...prepareQueryParams(query, constantPool) as any])\n            .toStmt());\n\n    // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\n    const temporary = tempAllocator();\n    const getQueryList = o.importExpr(R3.loadQuery).callFn([]);\n    const refresh = o.importExpr(R3.queryRefresh).callFn([temporary.set(getQueryList)]);\n    const updateDirective = o.variable(CONTEXT_NAME)\n                                .prop(query.propertyName)\n                                .set(query.first ? temporary.prop('first') : temporary);\n    updateStatements.push(refresh.and(updateDirective).toStmt());\n  }\n\n  const contentQueriesFnName = name ? `${name}_ContentQueries` : null;\n  return o.fn(\n      [\n        new o.FnParam(RENDER_FLAGS, o.NUMBER_TYPE), new o.FnParam(CONTEXT_NAME, null),\n        new o.FnParam('dirIndex', null)\n      ],\n      [\n        renderFlagCheckIfStmt(core.RenderFlags.Create, createStatements),\n        renderFlagCheckIfStmt(core.RenderFlags.Update, updateStatements)\n      ],\n      o.INFERRED_TYPE, null, contentQueriesFnName);\n}\n\nfunction stringAsType(str: string): o.Type {\n  return o.expressionType(o.literal(str));\n}\n\nfunction stringMapAsLiteralExpression(map: {[key: string]: string|string[]}): o.LiteralMapExpr {\n  const mapValues = Object.keys(map).map(key => {\n    const value = Array.isArray(map[key]) ? map[key][0] : map[key];\n    return {\n      key,\n      value: o.literal(value),\n      quoted: true,\n    };\n  });\n\n  return o.literalMap(mapValues);\n}\n\nfunction stringArrayAsType(arr: ReadonlyArray<string|null>): o.Type {\n  return arr.length > 0 ? o.expressionType(o.literalArr(arr.map(value => o.literal(value)))) :\n                          o.NONE_TYPE;\n}\n\nexport function createBaseDirectiveTypeParams(meta: R3DirectiveMetadata): o.Type[] {\n  // On the type side, remove newlines from the selector as it will need to fit into a TypeScript\n  // string literal, which must be on one line.\n  const selectorForType = meta.selector !== null ? meta.selector.replace(/\\n/g, '') : null;\n\n  return [\n    typeWithParameters(meta.type.type, meta.typeArgumentCount),\n    selectorForType !== null ? stringAsType(selectorForType) : o.NONE_TYPE,\n    meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : o.NONE_TYPE,\n    o.expressionType(stringMapAsLiteralExpression(meta.inputs)),\n    o.expressionType(stringMapAsLiteralExpression(meta.outputs)),\n    stringArrayAsType(meta.queries.map(q => q.propertyName)),\n  ];\n}\n\n/**\n * Creates the type specification from the directive meta. This type is inserted into .d.ts files\n * to be consumed by upstream compilations.\n */\nexport function createDirectiveType(meta: R3DirectiveMetadata): o.Type {\n  const typeParams = createBaseDirectiveTypeParams(meta);\n  // Directives have no NgContentSelectors slot, but instead express a `never` type\n  // so that future fields align.\n  typeParams.push(o.NONE_TYPE);\n  typeParams.push(o.expressionType(o.literal(meta.isStandalone)));\n  typeParams.push(createHostDirectivesType(meta));\n  return o.expressionType(o.importExpr(R3.DirectiveDeclaration, typeParams));\n}\n\n// Define and update any view queries\nfunction createViewQueriesFunction(\n    viewQueries: R3QueryMetadata[], constantPool: ConstantPool, name?: string): o.Expression {\n  const createStatements: o.Statement[] = [];\n  const updateStatements: o.Statement[] = [];\n  const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);\n\n  viewQueries.forEach((query: R3QueryMetadata) => {\n    // creation, e.g. r3.viewQuery(somePredicate, true);\n    const queryDefinition =\n        o.importExpr(R3.viewQuery).callFn(prepareQueryParams(query, constantPool));\n    createStatements.push(queryDefinition.toStmt());\n\n    // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\n    const temporary = tempAllocator();\n    const getQueryList = o.importExpr(R3.loadQuery).callFn([]);\n    const refresh = o.importExpr(R3.queryRefresh).callFn([temporary.set(getQueryList)]);\n    const updateDirective = o.variable(CONTEXT_NAME)\n                                .prop(query.propertyName)\n                                .set(query.first ? temporary.prop('first') : temporary);\n    updateStatements.push(refresh.and(updateDirective).toStmt());\n  });\n\n  const viewQueryFnName = name ? `${name}_Query` : null;\n  return o.fn(\n      [new o.FnParam(RENDER_FLAGS, o.NUMBER_TYPE), new o.FnParam(CONTEXT_NAME, null)],\n      [\n        renderFlagCheckIfStmt(core.RenderFlags.Create, createStatements),\n        renderFlagCheckIfStmt(core.RenderFlags.Update, updateStatements)\n      ],\n      o.INFERRED_TYPE, null, viewQueryFnName);\n}\n\n// Return a host binding function or null if one is not necessary.\nfunction createHostBindingsFunction(\n    hostBindingsMetadata: R3HostMetadata, typeSourceSpan: ParseSourceSpan,\n    bindingParser: BindingParser, constantPool: ConstantPool, selector: string, name: string,\n    definitionMap: DefinitionMap): o.Expression|null {\n  const bindingContext = o.variable(CONTEXT_NAME);\n  const styleBuilder = new StylingBuilder(bindingContext);\n\n  const {styleAttr, classAttr} = hostBindingsMetadata.specialAttributes;\n  if (styleAttr !== undefined) {\n    styleBuilder.registerStyleAttr(styleAttr);\n  }\n  if (classAttr !== undefined) {\n    styleBuilder.registerClassAttr(classAttr);\n  }\n\n  const createInstructions: Instruction[] = [];\n  const updateInstructions: Instruction[] = [];\n  const updateVariables: o.Statement[] = [];\n\n  const hostBindingSourceSpan = typeSourceSpan;\n\n  // Calculate host event bindings\n  const eventBindings = bindingParser.createDirectiveHostEventAsts(\n      hostBindingsMetadata.listeners, hostBindingSourceSpan);\n  if (eventBindings && eventBindings.length) {\n    createInstructions.push(...createHostListeners(eventBindings, name));\n  }\n\n  // Calculate the host property bindings\n  const bindings = bindingParser.createBoundHostProperties(\n      hostBindingsMetadata.properties, hostBindingSourceSpan);\n  const allOtherBindings: ParsedProperty[] = [];\n\n  // We need to calculate the total amount of binding slots required by\n  // all the instructions together before any value conversions happen.\n  // Value conversions may require additional slots for interpolation and\n  // bindings with pipes. These calculates happen after this block.\n  let totalHostVarsCount = 0;\n  bindings && bindings.forEach((binding: ParsedProperty) => {\n    const stylingInputWasSet = styleBuilder.registerInputBasedOnName(\n        binding.name, binding.expression, hostBindingSourceSpan);\n    if (stylingInputWasSet) {\n      totalHostVarsCount += MIN_STYLING_BINDING_SLOTS_REQUIRED;\n    } else {\n      allOtherBindings.push(binding);\n      totalHostVarsCount++;\n    }\n  });\n\n  let valueConverter: ValueConverter;\n  const getValueConverter = () => {\n    if (!valueConverter) {\n      const hostVarsCountFn = (numSlots: number): number => {\n        const originalVarsCount = totalHostVarsCount;\n        totalHostVarsCount += numSlots;\n        return originalVarsCount;\n      };\n      valueConverter = new ValueConverter(\n          constantPool,\n          () => error('Unexpected node'),  // new nodes are illegal here\n          hostVarsCountFn,\n          () => error('Unexpected pipe'));  // pipes are illegal here\n    }\n    return valueConverter;\n  };\n\n  const propertyBindings: o.Expression[][] = [];\n  const attributeBindings: o.Expression[][] = [];\n  const syntheticHostBindings: o.Expression[][] = [];\n\n  for (const binding of allOtherBindings) {\n    // resolve literal arrays and literal objects\n    const value = binding.expression.visit(getValueConverter());\n    const bindingExpr = bindingFn(bindingContext, value);\n\n    const {bindingName, instruction, isAttribute} = getBindingNameAndInstruction(binding);\n\n    const securityContexts =\n        bindingParser.calcPossibleSecurityContexts(selector, bindingName, isAttribute)\n            .filter(context => context !== core.SecurityContext.NONE);\n\n    let sanitizerFn: o.ExternalExpr|null = null;\n    if (securityContexts.length) {\n      if (securityContexts.length === 2 &&\n          securityContexts.indexOf(core.SecurityContext.URL) > -1 &&\n          securityContexts.indexOf(core.SecurityContext.RESOURCE_URL) > -1) {\n        // Special case for some URL attributes (such as \"src\" and \"href\") that may be a part\n        // of different security contexts. In this case we use special sanitization function and\n        // select the actual sanitizer at runtime based on a tag name that is provided while\n        // invoking sanitization function.\n        sanitizerFn = o.importExpr(R3.sanitizeUrlOrResourceUrl);\n      } else {\n        sanitizerFn = resolveSanitizationFn(securityContexts[0], isAttribute);\n      }\n    }\n    const instructionParams = [o.literal(bindingName), bindingExpr.currValExpr];\n    if (sanitizerFn) {\n      instructionParams.push(sanitizerFn);\n    } else {\n      // If there was no sanitization function found based on the security context\n      // of an attribute/property binding - check whether this attribute/property is\n      // one of the security-sensitive <iframe> attributes.\n      // Note: for host bindings defined on a directive, we do not try to find all\n      // possible places where it can be matched, so we can not determine whether\n      // the host element is an <iframe>. In this case, if an attribute/binding\n      // name is in the `IFRAME_SECURITY_SENSITIVE_ATTRS` set - append a validation\n      // function, which would be invoked at runtime and would have access to the\n      // underlying DOM element, check if it's an <iframe> and if so - runs extra checks.\n      if (isIframeSecuritySensitiveAttr(bindingName)) {\n        instructionParams.push(o.importExpr(R3.validateIframeAttribute));\n      }\n    }\n\n    updateVariables.push(...bindingExpr.stmts);\n\n    if (instruction === R3.hostProperty) {\n      propertyBindings.push(instructionParams);\n    } else if (instruction === R3.attribute) {\n      attributeBindings.push(instructionParams);\n    } else if (instruction === R3.syntheticHostProperty) {\n      syntheticHostBindings.push(instructionParams);\n    } else {\n      updateInstructions.push({reference: instruction, paramsOrFn: instructionParams, span: null});\n    }\n  }\n\n  for (const bindingParams of propertyBindings) {\n    updateInstructions.push({reference: R3.hostProperty, paramsOrFn: bindingParams, span: null});\n  }\n\n  for (const bindingParams of attributeBindings) {\n    updateInstructions.push({reference: R3.attribute, paramsOrFn: bindingParams, span: null});\n  }\n\n  for (const bindingParams of syntheticHostBindings) {\n    updateInstructions.push(\n        {reference: R3.syntheticHostProperty, paramsOrFn: bindingParams, span: null});\n  }\n\n  // since we're dealing with directives/components and both have hostBinding\n  // functions, we need to generate a special hostAttrs instruction that deals\n  // with both the assignment of styling as well as static attributes to the host\n  // element. The instruction below will instruct all initial styling (styling\n  // that is inside of a host binding within a directive/component) to be attached\n  // to the host element alongside any of the provided host attributes that were\n  // collected earlier.\n  const hostAttrs = convertAttributesToExpressions(hostBindingsMetadata.attributes);\n  styleBuilder.assignHostAttrs(hostAttrs, definitionMap);\n\n  if (styleBuilder.hasBindings) {\n    // finally each binding that was registered in the statement above will need to be added to\n    // the update block of a component/directive templateFn/hostBindingsFn so that the bindings\n    // are evaluated and updated for the element.\n    styleBuilder.buildUpdateLevelInstructions(getValueConverter()).forEach(instruction => {\n      for (const call of instruction.calls) {\n        // we subtract a value of `1` here because the binding slot was already allocated\n        // at the top of this method when all the input bindings were counted.\n        totalHostVarsCount +=\n            Math.max(call.allocateBindingSlots - MIN_STYLING_BINDING_SLOTS_REQUIRED, 0);\n\n        updateInstructions.push({\n          reference: instruction.reference,\n          paramsOrFn: convertStylingCall(call, bindingContext, bindingFn),\n          span: null\n        });\n      }\n    });\n  }\n\n  if (totalHostVarsCount) {\n    definitionMap.set('hostVars', o.literal(totalHostVarsCount));\n  }\n\n  if (createInstructions.length > 0 || updateInstructions.length > 0) {\n    const hostBindingsFnName = name ? `${name}_HostBindings` : null;\n    const statements: o.Statement[] = [];\n    if (createInstructions.length > 0) {\n      statements.push(renderFlagCheckIfStmt(\n          core.RenderFlags.Create, getInstructionStatements(createInstructions)));\n    }\n    if (updateInstructions.length > 0) {\n      statements.push(renderFlagCheckIfStmt(\n          core.RenderFlags.Update,\n          updateVariables.concat(getInstructionStatements(updateInstructions))));\n    }\n    return o.fn(\n        [new o.FnParam(RENDER_FLAGS, o.NUMBER_TYPE), new o.FnParam(CONTEXT_NAME, null)], statements,\n        o.INFERRED_TYPE, null, hostBindingsFnName);\n  }\n\n  return null;\n}\n\nfunction bindingFn(implicit: any, value: AST) {\n  return convertPropertyBinding(null, implicit, value, 'b');\n}\n\nfunction convertStylingCall(\n    call: StylingInstructionCall, bindingContext: any, bindingFn: Function) {\n  return call.params(value => bindingFn(bindingContext, value).currValExpr);\n}\n\nfunction getBindingNameAndInstruction(binding: ParsedProperty):\n    {bindingName: string, instruction: o.ExternalReference, isAttribute: boolean} {\n  let bindingName = binding.name;\n  let instruction!: o.ExternalReference;\n\n  // Check to see if this is an attr binding or a property binding\n  const attrMatches = bindingName.match(ATTR_REGEX);\n  if (attrMatches) {\n    bindingName = attrMatches[1];\n    instruction = R3.attribute;\n  } else {\n    if (binding.isAnimation) {\n      bindingName = prepareSyntheticPropertyName(bindingName);\n      // host bindings that have a synthetic property (e.g. @foo) should always be rendered\n      // in the context of the component and not the parent. Therefore there is a special\n      // compatibility instruction available for this purpose.\n      instruction = R3.syntheticHostProperty;\n    } else {\n      instruction = R3.hostProperty;\n    }\n  }\n\n  return {bindingName, instruction, isAttribute: !!attrMatches};\n}\n\nfunction createHostListeners(eventBindings: ParsedEvent[], name?: string): Instruction[] {\n  const listenerParams: o.Expression[][] = [];\n  const syntheticListenerParams: o.Expression[][] = [];\n  const instructions: Instruction[] = [];\n\n  for (const binding of eventBindings) {\n    let bindingName = binding.name && sanitizeIdentifier(binding.name);\n    const bindingFnName = binding.type === ParsedEventType.Animation ?\n        prepareSyntheticListenerFunctionName(bindingName, binding.targetOrPhase) :\n        bindingName;\n    const handlerName = name && bindingName ? `${name}_${bindingFnName}_HostBindingHandler` : null;\n    const params = prepareEventListenerParameters(BoundEvent.fromParsedEvent(binding), handlerName);\n\n    if (binding.type == ParsedEventType.Animation) {\n      syntheticListenerParams.push(params);\n    } else {\n      listenerParams.push(params);\n    }\n  }\n\n  for (const params of syntheticListenerParams) {\n    instructions.push({reference: R3.syntheticHostListener, paramsOrFn: params, span: null});\n  }\n\n  for (const params of listenerParams) {\n    instructions.push({reference: R3.listener, paramsOrFn: params, span: null});\n  }\n\n  return instructions;\n}\n\n\nconst HOST_REG_EXP = /^(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\))$/;\n// Represents the groups in the above regex.\nconst enum HostBindingGroup {\n  // group 1: \"prop\" from \"[prop]\", or \"attr.role\" from \"[attr.role]\", or @anim from [@anim]\n  Binding = 1,\n\n  // group 2: \"event\" from \"(event)\"\n  Event = 2,\n}\n\n// Defines Host Bindings structure that contains attributes, listeners, and properties,\n// parsed from the `host` object defined for a Type.\nexport interface ParsedHostBindings {\n  attributes: {[key: string]: o.Expression};\n  listeners: {[key: string]: string};\n  properties: {[key: string]: string};\n  specialAttributes: {styleAttr?: string; classAttr?: string;};\n}\n\nexport function parseHostBindings(host: {[key: string]: string|o.Expression}): ParsedHostBindings {\n  const attributes: {[key: string]: o.Expression} = {};\n  const listeners: {[key: string]: string} = {};\n  const properties: {[key: string]: string} = {};\n  const specialAttributes: {styleAttr?: string; classAttr?: string;} = {};\n\n  for (const key of Object.keys(host)) {\n    const value = host[key];\n    const matches = key.match(HOST_REG_EXP);\n\n    if (matches === null) {\n      switch (key) {\n        case 'class':\n          if (typeof value !== 'string') {\n            // TODO(alxhub): make this a diagnostic.\n            throw new Error(`Class binding must be string`);\n          }\n          specialAttributes.classAttr = value;\n          break;\n        case 'style':\n          if (typeof value !== 'string') {\n            // TODO(alxhub): make this a diagnostic.\n            throw new Error(`Style binding must be string`);\n          }\n          specialAttributes.styleAttr = value;\n          break;\n        default:\n          if (typeof value === 'string') {\n            attributes[key] = o.literal(value);\n          } else {\n            attributes[key] = value;\n          }\n      }\n    } else if (matches[HostBindingGroup.Binding] != null) {\n      if (typeof value !== 'string') {\n        // TODO(alxhub): make this a diagnostic.\n        throw new Error(`Property binding must be string`);\n      }\n      // synthetic properties (the ones that have a `@` as a prefix)\n      // are still treated the same as regular properties. Therefore\n      // there is no point in storing them in a separate map.\n      properties[matches[HostBindingGroup.Binding]] = value;\n    } else if (matches[HostBindingGroup.Event] != null) {\n      if (typeof value !== 'string') {\n        // TODO(alxhub): make this a diagnostic.\n        throw new Error(`Event binding must be string`);\n      }\n      listeners[matches[HostBindingGroup.Event]] = value;\n    }\n  }\n\n  return {attributes, listeners, properties, specialAttributes};\n}\n\n/**\n * Verifies host bindings and returns the list of errors (if any). Empty array indicates that a\n * given set of host bindings has no errors.\n *\n * @param bindings set of host bindings to verify.\n * @param sourceSpan source span where host bindings were defined.\n * @returns array of errors associated with a given set of host bindings.\n */\nexport function verifyHostBindings(\n    bindings: ParsedHostBindings, sourceSpan: ParseSourceSpan): ParseError[] {\n  // TODO: abstract out host bindings verification logic and use it instead of\n  // creating events and properties ASTs to detect errors (FW-996)\n  const bindingParser = makeBindingParser();\n  bindingParser.createDirectiveHostEventAsts(bindings.listeners, sourceSpan);\n  bindingParser.createBoundHostProperties(bindings.properties, sourceSpan);\n  return bindingParser.errors;\n}\n\nfunction compileStyles(styles: string[], selector: string, hostSelector: string): string[] {\n  const shadowCss = new ShadowCss();\n  return styles.map(style => {\n    return shadowCss!.shimCssText(style, selector, hostSelector);\n  });\n}\n\nfunction createHostDirectivesType(meta: R3DirectiveMetadata): o.Type {\n  if (!meta.hostDirectives?.length) {\n    return o.NONE_TYPE;\n  }\n\n  return o.expressionType(o.literalArr(meta.hostDirectives.map(hostMeta => o.literalMap([\n    {key: 'directive', value: o.typeofExpr(hostMeta.directive.type), quoted: false},\n    {key: 'inputs', value: stringMapAsLiteralExpression(hostMeta.inputs || {}), quoted: false},\n    {key: 'outputs', value: stringMapAsLiteralExpression(hostMeta.outputs || {}), quoted: false},\n  ]))));\n}\n\nfunction createHostDirectivesFeatureArg(\n    hostDirectives: NonNullable<R3DirectiveMetadata['hostDirectives']>): o.Expression {\n  const expressions: o.Expression[] = [];\n  let hasForwardRef = false;\n\n  for (const current of hostDirectives) {\n    // Use a shorthand if there are no inputs or outputs.\n    if (!current.inputs && !current.outputs) {\n      expressions.push(current.directive.type);\n    } else {\n      const keys = [{key: 'directive', value: current.directive.type, quoted: false}];\n\n      if (current.inputs) {\n        const inputsLiteral = createHostDirectivesMappingArray(current.inputs);\n        if (inputsLiteral) {\n          keys.push({key: 'inputs', value: inputsLiteral, quoted: false});\n        }\n      }\n\n      if (current.outputs) {\n        const outputsLiteral = createHostDirectivesMappingArray(current.outputs);\n        if (outputsLiteral) {\n          keys.push({key: 'outputs', value: outputsLiteral, quoted: false});\n        }\n      }\n\n      expressions.push(o.literalMap(keys));\n    }\n\n    if (current.isForwardReference) {\n      hasForwardRef = true;\n    }\n  }\n\n  // If there's a forward reference, we generate a `function() { return [HostDir] }`,\n  // otherwise we can save some bytes by using a plain array, e.g. `[HostDir]`.\n  return hasForwardRef ?\n      new o.FunctionExpr([], [new o.ReturnStatement(o.literalArr(expressions))]) :\n      o.literalArr(expressions);\n}\n\n/**\n * Converts an input/output mapping object literal into an array where the even keys are the\n * public name of the binding and the odd ones are the name it was aliased to. E.g.\n * `{inputOne: 'aliasOne', inputTwo: 'aliasTwo'}` will become\n * `['inputOne', 'aliasOne', 'inputTwo', 'aliasTwo']`.\n *\n * This conversion is necessary, because hosts bind to the public name of the host directive and\n * keeping the mapping in an object literal will break for apps using property renaming.\n */\nexport function createHostDirectivesMappingArray(mapping: Record<string, string>):\n    o.LiteralArrayExpr|null {\n  const elements: o.LiteralExpr[] = [];\n\n  for (const publicName in mapping) {\n    if (mapping.hasOwnProperty(publicName)) {\n      elements.push(o.literal(publicName), o.literal(mapping[publicName]));\n    }\n  }\n\n  return elements.length > 0 ? o.literalArr(elements) : null;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * An interface for retrieving documents by URL that the compiler uses to\n * load templates.\n *\n * This is an abstract class, rather than an interface, so that it can be used\n * as injection token.\n */\nexport abstract class ResourceLoader {\n  abstract get(url: string): Promise<string>|string;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {CompilerFacade, CoreEnvironment, ExportedCompilerFacade, OpaqueValue, R3ComponentMetadataFacade, R3DeclareComponentFacade, R3DeclareDependencyMetadataFacade, R3DeclareDirectiveDependencyFacade, R3DeclareDirectiveFacade, R3DeclareFactoryFacade, R3DeclareInjectableFacade, R3DeclareInjectorFacade, R3DeclareNgModuleFacade, R3DeclarePipeDependencyFacade, R3DeclarePipeFacade, R3DeclareQueryMetadataFacade, R3DependencyMetadataFacade, R3DirectiveMetadataFacade, R3FactoryDefMetadataFacade, R3InjectableMetadataFacade, R3InjectorMetadataFacade, R3NgModuleMetadataFacade, R3PipeMetadataFacade, R3QueryMetadataFacade, R3TemplateDependencyFacade, StringMap, StringMapWithRename} from './compiler_facade_interface';\nimport {ConstantPool} from './constant_pool';\nimport {ChangeDetectionStrategy, HostBinding, HostListener, Input, Output, ViewEncapsulation} from './core';\nimport {compileInjectable} from './injectable_compiler_2';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './ml_parser/interpolation_config';\nimport {DeclareVarStmt, Expression, literal, LiteralExpr, Statement, StmtModifier, WrappedNodeExpr} from './output/output_ast';\nimport {JitEvaluator} from './output/output_jit';\nimport {ParseError, ParseSourceSpan, r3JitTypeSourceSpan} from './parse_util';\nimport {compileFactoryFunction, FactoryTarget, R3DependencyMetadata} from './render3/r3_factory';\nimport {compileInjector, R3InjectorMetadata} from './render3/r3_injector_compiler';\nimport {R3JitReflector} from './render3/r3_jit';\nimport {compileNgModule, compileNgModuleDeclarationExpression, R3NgModuleMetadata, R3SelectorScopeMode} from './render3/r3_module_compiler';\nimport {compilePipeFromMetadata, R3PipeMetadata} from './render3/r3_pipe_compiler';\nimport {createMayBeForwardRefExpression, ForwardRefHandling, getSafePropertyAccessString, MaybeForwardRefExpression, wrapReference} from './render3/util';\nimport {DeclarationListEmitMode, R3ComponentMetadata, R3DirectiveDependencyMetadata, R3DirectiveMetadata, R3HostDirectiveMetadata, R3HostMetadata, R3PipeDependencyMetadata, R3QueryMetadata, R3TemplateDependency, R3TemplateDependencyKind, R3TemplateDependencyMetadata} from './render3/view/api';\nimport {compileComponentFromMetadata, compileDirectiveFromMetadata, ParsedHostBindings, parseHostBindings, verifyHostBindings} from './render3/view/compiler';\nimport {makeBindingParser, parseTemplate} from './render3/view/template';\nimport {ResourceLoader} from './resource_loader';\nimport {DomElementSchemaRegistry} from './schema/dom_element_schema_registry';\n\nexport class CompilerFacadeImpl implements CompilerFacade {\n  FactoryTarget = FactoryTarget as any;\n  ResourceLoader = ResourceLoader;\n  private elementSchemaRegistry = new DomElementSchemaRegistry();\n\n  constructor(private jitEvaluator = new JitEvaluator()) {}\n\n  compilePipe(angularCoreEnv: CoreEnvironment, sourceMapUrl: string, facade: R3PipeMetadataFacade):\n      any {\n    const metadata: R3PipeMetadata = {\n      name: facade.name,\n      type: wrapReference(facade.type),\n      internalType: new WrappedNodeExpr(facade.type),\n      typeArgumentCount: 0,\n      deps: null,\n      pipeName: facade.pipeName,\n      pure: facade.pure,\n      isStandalone: facade.isStandalone,\n    };\n    const res = compilePipeFromMetadata(metadata);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compilePipeDeclaration(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      declaration: R3DeclarePipeFacade): any {\n    const meta = convertDeclarePipeFacadeToMetadata(declaration);\n    const res = compilePipeFromMetadata(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compileInjectable(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      facade: R3InjectableMetadataFacade): any {\n    const {expression, statements} = compileInjectable(\n        {\n          name: facade.name,\n          type: wrapReference(facade.type),\n          internalType: new WrappedNodeExpr(facade.type),\n          typeArgumentCount: facade.typeArgumentCount,\n          providedIn: computeProvidedIn(facade.providedIn),\n          useClass: convertToProviderExpression(facade, 'useClass'),\n          useFactory: wrapExpression(facade, 'useFactory'),\n          useValue: convertToProviderExpression(facade, 'useValue'),\n          useExisting: convertToProviderExpression(facade, 'useExisting'),\n          deps: facade.deps?.map(convertR3DependencyMetadata),\n        },\n        /* resolveForwardRefs */ true);\n\n    return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n  }\n\n  compileInjectableDeclaration(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      facade: R3DeclareInjectableFacade): any {\n    const {expression, statements} = compileInjectable(\n        {\n          name: facade.type.name,\n          type: wrapReference(facade.type),\n          internalType: new WrappedNodeExpr(facade.type),\n          typeArgumentCount: 0,\n          providedIn: computeProvidedIn(facade.providedIn),\n          useClass: convertToProviderExpression(facade, 'useClass'),\n          useFactory: wrapExpression(facade, 'useFactory'),\n          useValue: convertToProviderExpression(facade, 'useValue'),\n          useExisting: convertToProviderExpression(facade, 'useExisting'),\n          deps: facade.deps?.map(convertR3DeclareDependencyMetadata),\n        },\n        /* resolveForwardRefs */ true);\n\n    return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n  }\n\n  compileInjector(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      facade: R3InjectorMetadataFacade): any {\n    const meta: R3InjectorMetadata = {\n      name: facade.name,\n      type: wrapReference(facade.type),\n      internalType: new WrappedNodeExpr(facade.type),\n      providers: facade.providers && facade.providers.length > 0 ?\n          new WrappedNodeExpr(facade.providers) :\n          null,\n      imports: facade.imports.map(i => new WrappedNodeExpr(i)),\n    };\n    const res = compileInjector(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compileInjectorDeclaration(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      declaration: R3DeclareInjectorFacade): any {\n    const meta = convertDeclareInjectorFacadeToMetadata(declaration);\n    const res = compileInjector(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compileNgModule(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      facade: R3NgModuleMetadataFacade): any {\n    const meta: R3NgModuleMetadata = {\n      type: wrapReference(facade.type),\n      internalType: new WrappedNodeExpr(facade.type),\n      adjacentType: new WrappedNodeExpr(facade.type),\n      bootstrap: facade.bootstrap.map(wrapReference),\n      declarations: facade.declarations.map(wrapReference),\n      publicDeclarationTypes: null,  // only needed for types in AOT\n      imports: facade.imports.map(wrapReference),\n      includeImportTypes: true,\n      exports: facade.exports.map(wrapReference),\n      selectorScopeMode: R3SelectorScopeMode.Inline,\n      containsForwardDecls: false,\n      schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,\n      id: facade.id ? new WrappedNodeExpr(facade.id) : null,\n    };\n    const res = compileNgModule(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compileNgModuleDeclaration(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      declaration: R3DeclareNgModuleFacade): any {\n    const expression = compileNgModuleDeclarationExpression(declaration);\n    return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compileDirective(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      facade: R3DirectiveMetadataFacade): any {\n    const meta: R3DirectiveMetadata = convertDirectiveFacadeToMetadata(facade);\n    return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n\n  compileDirectiveDeclaration(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      declaration: R3DeclareDirectiveFacade): any {\n    const typeSourceSpan =\n        this.createParseSourceSpan('Directive', declaration.type.name, sourceMapUrl);\n    const meta = convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan);\n    return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n\n  private compileDirectiveFromMeta(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3DirectiveMetadata): any {\n    const constantPool = new ConstantPool();\n    const bindingParser = makeBindingParser();\n    const res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);\n    return this.jitExpression(\n        res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n  }\n\n  compileComponent(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      facade: R3ComponentMetadataFacade): any {\n    // Parse the template and check for errors.\n    const {template, interpolation} = parseJitTemplate(\n        facade.template, facade.name, sourceMapUrl, facade.preserveWhitespaces,\n        facade.interpolation);\n\n    // Compile the component metadata, including template, into an expression.\n    const meta: R3ComponentMetadata<R3TemplateDependency> = {\n      ...facade as R3ComponentMetadataFacadeNoPropAndWhitespace,\n      ...convertDirectiveFacadeToMetadata(facade),\n      selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(),\n      template,\n      declarations: facade.declarations.map(convertDeclarationFacadeToMetadata),\n      declarationListEmitMode: DeclarationListEmitMode.Direct,\n      styles: [...facade.styles, ...template.styles],\n      encapsulation: facade.encapsulation as any,\n      interpolation,\n      changeDetection: facade.changeDetection,\n      animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null,\n      viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) :\n                                                    null,\n      relativeContextFilePath: '',\n      i18nUseExternalIds: true,\n    };\n    const jitExpressionSourceMap = `ng:///${facade.name}.js`;\n    return this.compileComponentFromMeta(angularCoreEnv, jitExpressionSourceMap, meta);\n  }\n\n  compileComponentDeclaration(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      declaration: R3DeclareComponentFacade): any {\n    const typeSourceSpan =\n        this.createParseSourceSpan('Component', declaration.type.name, sourceMapUrl);\n    const meta = convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl);\n    return this.compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n\n  private compileComponentFromMeta(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      meta: R3ComponentMetadata<R3TemplateDependency>): any {\n    const constantPool = new ConstantPool();\n    const bindingParser = makeBindingParser(meta.interpolation);\n    const res = compileComponentFromMetadata(meta, constantPool, bindingParser);\n    return this.jitExpression(\n        res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n  }\n\n  compileFactory(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3FactoryDefMetadataFacade) {\n    const factoryRes = compileFactoryFunction({\n      name: meta.name,\n      type: wrapReference(meta.type),\n      internalType: new WrappedNodeExpr(meta.type),\n      typeArgumentCount: meta.typeArgumentCount,\n      deps: convertR3DependencyMetadataArray(meta.deps),\n      target: meta.target,\n    });\n    return this.jitExpression(\n        factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n  }\n\n  compileFactoryDeclaration(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3DeclareFactoryFacade) {\n    const factoryRes = compileFactoryFunction({\n      name: meta.type.name,\n      type: wrapReference(meta.type),\n      internalType: new WrappedNodeExpr(meta.type),\n      typeArgumentCount: 0,\n      deps: Array.isArray(meta.deps) ? meta.deps.map(convertR3DeclareDependencyMetadata) :\n                                       meta.deps,\n      target: meta.target,\n    });\n    return this.jitExpression(\n        factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n  }\n\n\n  createParseSourceSpan(kind: string, typeName: string, sourceUrl: string): ParseSourceSpan {\n    return r3JitTypeSourceSpan(kind, typeName, sourceUrl);\n  }\n\n  /**\n   * JIT compiles an expression and returns the result of executing that expression.\n   *\n   * @param def the definition which will be compiled and executed to get the value to patch\n   * @param context an object map of @angular/core symbol names to symbols which will be available\n   * in the context of the compiled expression\n   * @param sourceUrl a URL to use for the source map of the compiled expression\n   * @param preStatements a collection of statements that should be evaluated before the expression.\n   */\n  private jitExpression(\n      def: Expression, context: {[key: string]: any}, sourceUrl: string,\n      preStatements: Statement[]): any {\n    // The ConstantPool may contain Statements which declare variables used in the final expression.\n    // Therefore, its statements need to precede the actual JIT operation. The final statement is a\n    // declaration of $def which is set to the expression being compiled.\n    const statements: Statement[] = [\n      ...preStatements,\n      new DeclareVarStmt('$def', def, undefined, StmtModifier.Exported),\n    ];\n\n    const res = this.jitEvaluator.evaluateStatements(\n        sourceUrl, statements, new R3JitReflector(context), /* enableSourceMaps */ true);\n    return res['$def'];\n  }\n}\n\n// This seems to be needed to placate TS v3.0 only\ntype R3ComponentMetadataFacadeNoPropAndWhitespace = Pick<\n    R3ComponentMetadataFacade,\n    Exclude<Exclude<keyof R3ComponentMetadataFacade, 'preserveWhitespaces'>, 'propMetadata'>>;\n\nfunction convertToR3QueryMetadata(facade: R3QueryMetadataFacade): R3QueryMetadata {\n  return {\n    ...facade,\n    predicate: convertQueryPredicate(facade.predicate),\n    read: facade.read ? new WrappedNodeExpr(facade.read) : null,\n    static: facade.static,\n    emitDistinctChangesOnly: facade.emitDistinctChangesOnly,\n  };\n}\n\nfunction convertQueryDeclarationToMetadata(declaration: R3DeclareQueryMetadataFacade):\n    R3QueryMetadata {\n  return {\n    propertyName: declaration.propertyName,\n    first: declaration.first ?? false,\n    predicate: convertQueryPredicate(declaration.predicate),\n    descendants: declaration.descendants ?? false,\n    read: declaration.read ? new WrappedNodeExpr(declaration.read) : null,\n    static: declaration.static ?? false,\n    emitDistinctChangesOnly: declaration.emitDistinctChangesOnly ?? true,\n  };\n}\n\nfunction convertQueryPredicate(predicate: OpaqueValue|string[]): MaybeForwardRefExpression|\n    string[] {\n  return Array.isArray(predicate) ?\n      // The predicate is an array of strings so pass it through.\n      predicate :\n      // The predicate is a type - assume that we will need to unwrap any `forwardRef()` calls.\n      createMayBeForwardRefExpression(new WrappedNodeExpr(predicate), ForwardRefHandling.Wrapped);\n}\n\nfunction convertDirectiveFacadeToMetadata(facade: R3DirectiveMetadataFacade): R3DirectiveMetadata {\n  const inputsFromMetadata = parseInputOutputs(facade.inputs || []);\n  const outputsFromMetadata = parseInputOutputs(facade.outputs || []);\n  const propMetadata = facade.propMetadata;\n  const inputsFromType: StringMapWithRename = {};\n  const outputsFromType: StringMap = {};\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      propMetadata[field].forEach(ann => {\n        if (isInput(ann)) {\n          inputsFromType[field] =\n              ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;\n        } else if (isOutput(ann)) {\n          outputsFromType[field] = ann.bindingPropertyName || field;\n        }\n      });\n    }\n  }\n\n  return {\n    ...facade as R3DirectiveMetadataFacadeNoPropAndWhitespace,\n    typeArgumentCount: 0,\n    typeSourceSpan: facade.typeSourceSpan,\n    type: wrapReference(facade.type),\n    internalType: new WrappedNodeExpr(facade.type),\n    deps: null,\n    host: extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host),\n    inputs: {...inputsFromMetadata, ...inputsFromType},\n    outputs: {...outputsFromMetadata, ...outputsFromType},\n    queries: facade.queries.map(convertToR3QueryMetadata),\n    providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null,\n    viewQueries: facade.viewQueries.map(convertToR3QueryMetadata),\n    fullInheritance: false,\n    hostDirectives: convertHostDirectivesToMetadata(facade),\n  };\n}\n\nfunction convertDeclareDirectiveFacadeToMetadata(\n    declaration: R3DeclareDirectiveFacade, typeSourceSpan: ParseSourceSpan): R3DirectiveMetadata {\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    typeSourceSpan,\n    internalType: new WrappedNodeExpr(declaration.type),\n    selector: declaration.selector ?? null,\n    inputs: declaration.inputs ?? {},\n    outputs: declaration.outputs ?? {},\n    host: convertHostDeclarationToMetadata(declaration.host),\n    queries: (declaration.queries ?? []).map(convertQueryDeclarationToMetadata),\n    viewQueries: (declaration.viewQueries ?? []).map(convertQueryDeclarationToMetadata),\n    providers: declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) :\n                                                     null,\n    exportAs: declaration.exportAs ?? null,\n    usesInheritance: declaration.usesInheritance ?? false,\n    lifecycle: {usesOnChanges: declaration.usesOnChanges ?? false},\n    deps: null,\n    typeArgumentCount: 0,\n    fullInheritance: false,\n    isStandalone: declaration.isStandalone ?? false,\n    hostDirectives: convertHostDirectivesToMetadata(declaration),\n  };\n}\n\nfunction convertHostDeclarationToMetadata(host: R3DeclareDirectiveFacade['host'] = {}):\n    R3HostMetadata {\n  return {\n    attributes: convertOpaqueValuesToExpressions(host.attributes ?? {}),\n    listeners: host.listeners ?? {},\n    properties: host.properties ?? {},\n    specialAttributes: {\n      classAttr: host.classAttribute,\n      styleAttr: host.styleAttribute,\n    },\n  };\n}\n\nfunction convertHostDirectivesToMetadata(\n    metadata: R3DeclareDirectiveFacade|R3DirectiveMetadataFacade): R3HostDirectiveMetadata[]|null {\n  if (metadata.hostDirectives?.length) {\n    return metadata.hostDirectives.map(hostDirective => {\n      return typeof hostDirective === 'function' ?\n          {\n            directive: wrapReference(hostDirective),\n            inputs: null,\n            outputs: null,\n            isForwardReference: false\n          } :\n          {\n            directive: wrapReference(hostDirective.directive),\n            isForwardReference: false,\n            inputs: hostDirective.inputs ? parseInputOutputs(hostDirective.inputs) : null,\n            outputs: hostDirective.outputs ? parseInputOutputs(hostDirective.outputs) : null,\n          };\n    });\n  }\n\n  return null;\n}\n\nfunction convertOpaqueValuesToExpressions(obj: {[key: string]: OpaqueValue}):\n    {[key: string]: WrappedNodeExpr<unknown>} {\n  const result: {[key: string]: WrappedNodeExpr<unknown>} = {};\n  for (const key of Object.keys(obj)) {\n    result[key] = new WrappedNodeExpr(obj[key]);\n  }\n  return result;\n}\n\nfunction convertDeclareComponentFacadeToMetadata(\n    decl: R3DeclareComponentFacade, typeSourceSpan: ParseSourceSpan,\n    sourceMapUrl: string): R3ComponentMetadata<R3TemplateDependencyMetadata> {\n  const {template, interpolation} = parseJitTemplate(\n      decl.template, decl.type.name, sourceMapUrl, decl.preserveWhitespaces ?? false,\n      decl.interpolation);\n\n  const declarations: R3TemplateDependencyMetadata[] = [];\n  if (decl.dependencies) {\n    for (const innerDep of decl.dependencies) {\n      switch (innerDep.kind) {\n        case 'directive':\n        case 'component':\n          declarations.push(convertDirectiveDeclarationToMetadata(innerDep));\n          break;\n        case 'pipe':\n          declarations.push(convertPipeDeclarationToMetadata(innerDep));\n          break;\n      }\n    }\n  } else if (decl.components || decl.directives || decl.pipes) {\n    // Existing declarations on NPM may not be using the new `dependencies` merged field, and may\n    // have separate fields for dependencies instead. Unify them for JIT compilation.\n    decl.components &&\n        declarations.push(...decl.components.map(\n            dir => convertDirectiveDeclarationToMetadata(dir, /* isComponent */ true)));\n    decl.directives &&\n        declarations.push(\n            ...decl.directives.map(dir => convertDirectiveDeclarationToMetadata(dir)));\n    decl.pipes && declarations.push(...convertPipeMapToMetadata(decl.pipes));\n  }\n\n  return {\n    ...convertDeclareDirectiveFacadeToMetadata(decl, typeSourceSpan),\n    template,\n    styles: decl.styles ?? [],\n    declarations,\n    viewProviders: decl.viewProviders !== undefined ? new WrappedNodeExpr(decl.viewProviders) :\n                                                      null,\n    animations: decl.animations !== undefined ? new WrappedNodeExpr(decl.animations) : null,\n    changeDetection: decl.changeDetection ?? ChangeDetectionStrategy.Default,\n    encapsulation: decl.encapsulation ?? ViewEncapsulation.Emulated,\n    interpolation,\n    declarationListEmitMode: DeclarationListEmitMode.ClosureResolved,\n    relativeContextFilePath: '',\n    i18nUseExternalIds: true,\n  };\n}\n\nfunction convertDeclarationFacadeToMetadata(declaration: R3TemplateDependencyFacade):\n    R3TemplateDependency {\n  return {\n    ...declaration,\n    type: new WrappedNodeExpr(declaration.type),\n  };\n}\n\nfunction convertDirectiveDeclarationToMetadata(\n    declaration: R3DeclareDirectiveDependencyFacade,\n    isComponent: true|null = null): R3DirectiveDependencyMetadata {\n  return {\n    kind: R3TemplateDependencyKind.Directive,\n    isComponent: isComponent || declaration.kind === 'component',\n    selector: declaration.selector,\n    type: new WrappedNodeExpr(declaration.type),\n    inputs: declaration.inputs ?? [],\n    outputs: declaration.outputs ?? [],\n    exportAs: declaration.exportAs ?? null,\n  };\n}\n\nfunction convertPipeMapToMetadata(pipes: R3DeclareComponentFacade['pipes']):\n    R3PipeDependencyMetadata[] {\n  if (!pipes) {\n    return [];\n  }\n\n  return Object.keys(pipes).map(name => {\n    return {\n      kind: R3TemplateDependencyKind.Pipe,\n      name,\n      type: new WrappedNodeExpr(pipes[name]),\n    };\n  });\n}\n\nfunction convertPipeDeclarationToMetadata(pipe: R3DeclarePipeDependencyFacade):\n    R3PipeDependencyMetadata {\n  return {\n    kind: R3TemplateDependencyKind.Pipe,\n    name: pipe.name,\n    type: new WrappedNodeExpr(pipe.type),\n  };\n}\n\nfunction parseJitTemplate(\n    template: string, typeName: string, sourceMapUrl: string, preserveWhitespaces: boolean,\n    interpolation: [string, string]|undefined) {\n  const interpolationConfig =\n      interpolation ? InterpolationConfig.fromArray(interpolation) : DEFAULT_INTERPOLATION_CONFIG;\n  // Parse the template and check for errors.\n  const parsed = parseTemplate(template, sourceMapUrl, {preserveWhitespaces, interpolationConfig});\n  if (parsed.errors !== null) {\n    const errors = parsed.errors.map(err => err.toString()).join(', ');\n    throw new Error(`Errors during JIT compilation of template for ${typeName}: ${errors}`);\n  }\n  return {template: parsed, interpolation: interpolationConfig};\n}\n\n// This seems to be needed to placate TS v3.0 only\ntype R3DirectiveMetadataFacadeNoPropAndWhitespace =\n    Pick<R3DirectiveMetadataFacade, Exclude<keyof R3DirectiveMetadataFacade, 'propMetadata'>>;\n\n/**\n * Convert the expression, if present to an `R3ProviderExpression`.\n *\n * In JIT mode we do not want the compiler to wrap the expression in a `forwardRef()` call because,\n * if it is referencing a type that has not yet been defined, it will have already been wrapped in\n * a `forwardRef()` - either by the application developer or during partial-compilation. Thus we can\n * use `ForwardRefHandling.None`.\n */\nfunction convertToProviderExpression(obj: any, property: string): MaybeForwardRefExpression|\n    undefined {\n  if (obj.hasOwnProperty(property)) {\n    return createMayBeForwardRefExpression(\n        new WrappedNodeExpr(obj[property]), ForwardRefHandling.None);\n  } else {\n    return undefined;\n  }\n}\n\nfunction wrapExpression(obj: any, property: string): WrappedNodeExpr<any>|undefined {\n  if (obj.hasOwnProperty(property)) {\n    return new WrappedNodeExpr(obj[property]);\n  } else {\n    return undefined;\n  }\n}\n\nfunction computeProvidedIn(providedIn: Function|string|null|undefined): MaybeForwardRefExpression {\n  const expression = typeof providedIn === 'function' ? new WrappedNodeExpr(providedIn) :\n                                                        new LiteralExpr(providedIn ?? null);\n  // See `convertToProviderExpression()` for why this uses `ForwardRefHandling.None`.\n  return createMayBeForwardRefExpression(expression, ForwardRefHandling.None);\n}\n\nfunction convertR3DependencyMetadataArray(facades: R3DependencyMetadataFacade[]|null|\n                                          undefined): R3DependencyMetadata[]|null {\n  return facades == null ? null : facades.map(convertR3DependencyMetadata);\n}\n\nfunction convertR3DependencyMetadata(facade: R3DependencyMetadataFacade): R3DependencyMetadata {\n  const isAttributeDep = facade.attribute != null;  // both `null` and `undefined`\n  const rawToken = facade.token === null ? null : new WrappedNodeExpr(facade.token);\n  // In JIT mode, if the dep is an `@Attribute()` then we use the attribute name given in\n  // `attribute` rather than the `token`.\n  const token = isAttributeDep ? new WrappedNodeExpr(facade.attribute) : rawToken;\n  return createR3DependencyMetadata(\n      token, isAttributeDep, facade.host, facade.optional, facade.self, facade.skipSelf);\n}\n\nfunction convertR3DeclareDependencyMetadata(facade: R3DeclareDependencyMetadataFacade):\n    R3DependencyMetadata {\n  const isAttributeDep = facade.attribute ?? false;\n  const token = facade.token === null ? null : new WrappedNodeExpr(facade.token);\n  return createR3DependencyMetadata(\n      token, isAttributeDep, facade.host ?? false, facade.optional ?? false, facade.self ?? false,\n      facade.skipSelf ?? false);\n}\n\nfunction createR3DependencyMetadata(\n    token: WrappedNodeExpr<unknown>|null, isAttributeDep: boolean, host: boolean, optional: boolean,\n    self: boolean, skipSelf: boolean): R3DependencyMetadata {\n  // If the dep is an `@Attribute()` the `attributeNameType` ought to be the `unknown` type.\n  // But types are not available at runtime so we just use a literal `\"<unknown>\"` string as a dummy\n  // marker.\n  const attributeNameType = isAttributeDep ? literal('unknown') : null;\n  return {token, attributeNameType, host, optional, self, skipSelf};\n}\n\nfunction extractHostBindings(\n    propMetadata: {[key: string]: any[]}, sourceSpan: ParseSourceSpan,\n    host?: {[key: string]: string}): ParsedHostBindings {\n  // First parse the declarations from the metadata.\n  const bindings = parseHostBindings(host || {});\n\n  // After that check host bindings for errors\n  const errors = verifyHostBindings(bindings, sourceSpan);\n  if (errors.length) {\n    throw new Error(errors.map((error: ParseError) => error.msg).join('\\n'));\n  }\n\n  // Next, loop over the properties of the object, looking for @HostBinding and @HostListener.\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      propMetadata[field].forEach(ann => {\n        if (isHostBinding(ann)) {\n          // Since this is a decorator, we know that the value is a class member. Always access it\n          // through `this` so that further down the line it can't be confused for a literal value\n          // (e.g. if there's a property called `true`).\n          bindings.properties[ann.hostPropertyName || field] =\n              getSafePropertyAccessString('this', field);\n        } else if (isHostListener(ann)) {\n          bindings.listeners[ann.eventName || field] = `${field}(${(ann.args || []).join(',')})`;\n        }\n      });\n    }\n  }\n\n  return bindings;\n}\n\nfunction isHostBinding(value: any): value is HostBinding {\n  return value.ngMetadataName === 'HostBinding';\n}\n\nfunction isHostListener(value: any): value is HostListener {\n  return value.ngMetadataName === 'HostListener';\n}\n\n\nfunction isInput(value: any): value is Input {\n  return value.ngMetadataName === 'Input';\n}\n\nfunction isOutput(value: any): value is Output {\n  return value.ngMetadataName === 'Output';\n}\n\nfunction parseInputOutputs(values: string[]): StringMap {\n  return values.reduce((results, value) => {\n    const [field, property] = value.split(':', 2).map(str => str.trim());\n    results[field] = property || field;\n    return results;\n  }, {} as StringMap);\n}\n\nfunction convertDeclarePipeFacadeToMetadata(declaration: R3DeclarePipeFacade): R3PipeMetadata {\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    internalType: new WrappedNodeExpr(declaration.type),\n    typeArgumentCount: 0,\n    pipeName: declaration.name,\n    deps: null,\n    pure: declaration.pure ?? true,\n    isStandalone: declaration.isStandalone ?? false,\n  };\n}\n\nfunction convertDeclareInjectorFacadeToMetadata(declaration: R3DeclareInjectorFacade):\n    R3InjectorMetadata {\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    internalType: new WrappedNodeExpr(declaration.type),\n    providers: declaration.providers !== undefined && declaration.providers.length > 0 ?\n        new WrappedNodeExpr(declaration.providers) :\n        null,\n    imports: declaration.imports !== undefined ?\n        declaration.imports.map(i => new WrappedNodeExpr(i)) :\n        [],\n  };\n}\n\nexport function publishFacade(global: any) {\n  const ng: ExportedCompilerFacade = global.ng || (global.ng = {});\n  ng.\u0275compilerFacade = new CompilerFacadeImpl();\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the compiler package.\n */\n\nimport {Version} from './util';\n\nexport const VERSION = new Version('15.0.0');\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {MissingTranslationStrategy, ViewEncapsulation} from './core';\nimport {noUndefined} from './util';\n\nexport class CompilerConfig {\n  public defaultEncapsulation: ViewEncapsulation|null;\n  public useJit: boolean;\n  public missingTranslation: MissingTranslationStrategy|null;\n  public preserveWhitespaces: boolean;\n  public strictInjectionParameters: boolean;\n\n  constructor({\n    defaultEncapsulation = ViewEncapsulation.Emulated,\n    useJit = true,\n    missingTranslation = null,\n    preserveWhitespaces,\n    strictInjectionParameters\n  }: {\n    defaultEncapsulation?: ViewEncapsulation,\n    useJit?: boolean,\n    missingTranslation?: MissingTranslationStrategy|null,\n    preserveWhitespaces?: boolean,\n    strictInjectionParameters?: boolean,\n  } = {}) {\n    this.defaultEncapsulation = defaultEncapsulation;\n    this.useJit = !!useJit;\n    this.missingTranslation = missingTranslation;\n    this.preserveWhitespaces = preserveWhitespacesDefault(noUndefined(preserveWhitespaces));\n    this.strictInjectionParameters = strictInjectionParameters === true;\n  }\n}\n\nexport function preserveWhitespacesDefault(\n    preserveWhitespacesOption: boolean|null, defaultSetting = false): boolean {\n  return preserveWhitespacesOption === null ? defaultSetting : preserveWhitespacesOption;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as html from '../ml_parser/ast';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {ParseTreeResult} from '../ml_parser/parser';\n\nimport * as i18n from './i18n_ast';\nimport {createI18nMessageFactory, I18nMessageFactory} from './i18n_parser';\nimport {I18nError} from './parse_util';\nimport {TranslationBundle} from './translation_bundle';\n\nconst _I18N_ATTR = 'i18n';\nconst _I18N_ATTR_PREFIX = 'i18n-';\nconst _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\nconst MEANING_SEPARATOR = '|';\nconst ID_SEPARATOR = '@@';\nlet i18nCommentsWarned = false;\n\n/**\n * Extract translatable messages from an html AST\n */\nexport function extractMessages(\n    nodes: html.Node[], interpolationConfig: InterpolationConfig, implicitTags: string[],\n    implicitAttrs: {[k: string]: string[]}): ExtractionResult {\n  const visitor = new _Visitor(implicitTags, implicitAttrs);\n  return visitor.extract(nodes, interpolationConfig);\n}\n\nexport function mergeTranslations(\n    nodes: html.Node[], translations: TranslationBundle, interpolationConfig: InterpolationConfig,\n    implicitTags: string[], implicitAttrs: {[k: string]: string[]}): ParseTreeResult {\n  const visitor = new _Visitor(implicitTags, implicitAttrs);\n  return visitor.merge(nodes, translations, interpolationConfig);\n}\n\nexport class ExtractionResult {\n  constructor(public messages: i18n.Message[], public errors: I18nError[]) {}\n}\n\nenum _VisitorMode {\n  Extract,\n  Merge\n}\n\n/**\n * This Visitor is used:\n * 1. to extract all the translatable strings from an html AST (see `extract()`),\n * 2. to replace the translatable strings with the actual translations (see `merge()`)\n *\n * @internal\n */\nclass _Visitor implements html.Visitor {\n  // TODO(issue/24571): remove '!'.\n  private _depth!: number;\n\n  // <el i18n>...</el>\n  // TODO(issue/24571): remove '!'.\n  private _inI18nNode!: boolean;\n  // TODO(issue/24571): remove '!'.\n  private _inImplicitNode!: boolean;\n\n  // <!--i18n-->...<!--/i18n-->\n  // TODO(issue/24571): remove '!'.\n  private _inI18nBlock!: boolean;\n  // TODO(issue/24571): remove '!'.\n  private _blockMeaningAndDesc!: string;\n  // TODO(issue/24571): remove '!'.\n  private _blockChildren!: html.Node[];\n  // TODO(issue/24571): remove '!'.\n  private _blockStartDepth!: number;\n\n  // {<icu message>}\n  // TODO(issue/24571): remove '!'.\n  private _inIcu!: boolean;\n\n  // set to void 0 when not in a section\n  private _msgCountAtSectionStart: number|undefined;\n  // TODO(issue/24571): remove '!'.\n  private _errors!: I18nError[];\n  // TODO(issue/24571): remove '!'.\n  private _mode!: _VisitorMode;\n\n  // _VisitorMode.Extract only\n  // TODO(issue/24571): remove '!'.\n  private _messages!: i18n.Message[];\n\n  // _VisitorMode.Merge only\n  // TODO(issue/24571): remove '!'.\n  private _translations!: TranslationBundle;\n  // TODO(issue/24571): remove '!'.\n  private _createI18nMessage!: I18nMessageFactory;\n\n\n  constructor(private _implicitTags: string[], private _implicitAttrs: {[k: string]: string[]}) {}\n\n  /**\n   * Extracts the messages from the tree\n   */\n  extract(nodes: html.Node[], interpolationConfig: InterpolationConfig): ExtractionResult {\n    this._init(_VisitorMode.Extract, interpolationConfig);\n\n    nodes.forEach(node => node.visit(this, null));\n\n    if (this._inI18nBlock) {\n      this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n    }\n\n    return new ExtractionResult(this._messages, this._errors);\n  }\n\n  /**\n   * Returns a tree where all translatable nodes are translated\n   */\n  merge(\n      nodes: html.Node[], translations: TranslationBundle,\n      interpolationConfig: InterpolationConfig): ParseTreeResult {\n    this._init(_VisitorMode.Merge, interpolationConfig);\n    this._translations = translations;\n\n    // Construct a single fake root element\n    const wrapper = new html.Element('wrapper', [], nodes, undefined!, undefined!, undefined);\n\n    const translatedNode = wrapper.visit(this, null);\n\n    if (this._inI18nBlock) {\n      this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n    }\n\n    return new ParseTreeResult(translatedNode.children, this._errors);\n  }\n\n  visitExpansionCase(icuCase: html.ExpansionCase, context: any): any {\n    // Parse cases for translatable html attributes\n    const expression = html.visitAll(this, icuCase.expression, context);\n\n    if (this._mode === _VisitorMode.Merge) {\n      return new html.ExpansionCase(\n          icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan,\n          icuCase.expSourceSpan);\n    }\n  }\n\n  visitExpansion(icu: html.Expansion, context: any): html.Expansion {\n    this._mayBeAddBlockChildren(icu);\n\n    const wasInIcu = this._inIcu;\n\n    if (!this._inIcu) {\n      // nested ICU messages should not be extracted but top-level translated as a whole\n      if (this._isInTranslatableSection) {\n        this._addMessage([icu]);\n      }\n      this._inIcu = true;\n    }\n\n    const cases = html.visitAll(this, icu.cases, context);\n\n    if (this._mode === _VisitorMode.Merge) {\n      icu = new html.Expansion(\n          icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n    }\n\n    this._inIcu = wasInIcu;\n\n    return icu;\n  }\n\n  visitComment(comment: html.Comment, context: any): any {\n    const isOpening = _isOpeningComment(comment);\n\n    if (isOpening && this._isInTranslatableSection) {\n      this._reportError(comment, 'Could not start a block inside a translatable section');\n      return;\n    }\n\n    const isClosing = _isClosingComment(comment);\n\n    if (isClosing && !this._inI18nBlock) {\n      this._reportError(comment, 'Trying to close an unopened block');\n      return;\n    }\n\n    if (!this._inI18nNode && !this._inIcu) {\n      if (!this._inI18nBlock) {\n        if (isOpening) {\n          // deprecated from v5 you should use <ng-container i18n> instead of i18n comments\n          if (!i18nCommentsWarned && <any>console && <any>console.warn) {\n            i18nCommentsWarned = true;\n            const details = comment.sourceSpan.details ? `, ${comment.sourceSpan.details}` : '';\n            // TODO(ocombe): use a log service once there is a public one available\n            console.warn(`I18n comments are deprecated, use an <ng-container> element instead (${\n                comment.sourceSpan.start}${details})`);\n          }\n          this._inI18nBlock = true;\n          this._blockStartDepth = this._depth;\n          this._blockChildren = [];\n          this._blockMeaningAndDesc =\n              comment.value!.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();\n          this._openTranslatableSection(comment);\n        }\n      } else {\n        if (isClosing) {\n          if (this._depth == this._blockStartDepth) {\n            this._closeTranslatableSection(comment, this._blockChildren);\n            this._inI18nBlock = false;\n            const message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc)!;\n            // merge attributes in sections\n            const nodes = this._translateMessage(comment, message);\n            return html.visitAll(this, nodes);\n          } else {\n            this._reportError(comment, 'I18N blocks should not cross element boundaries');\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  visitText(text: html.Text, context: any): html.Text {\n    if (this._isInTranslatableSection) {\n      this._mayBeAddBlockChildren(text);\n    }\n    return text;\n  }\n\n  visitElement(el: html.Element, context: any): html.Element|null {\n    this._mayBeAddBlockChildren(el);\n    this._depth++;\n    const wasInI18nNode = this._inI18nNode;\n    const wasInImplicitNode = this._inImplicitNode;\n    let childNodes: html.Node[] = [];\n    let translatedChildNodes: html.Node[] = undefined!;\n\n    // Extract:\n    // - top level nodes with the (implicit) \"i18n\" attribute if not already in a section\n    // - ICU messages\n    const i18nAttr = _getI18nAttr(el);\n    const i18nMeta = i18nAttr ? i18nAttr.value : '';\n    const isImplicit = this._implicitTags.some(tag => el.name === tag) && !this._inIcu &&\n        !this._isInTranslatableSection;\n    const isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n    this._inImplicitNode = wasInImplicitNode || isImplicit;\n\n    if (!this._isInTranslatableSection && !this._inIcu) {\n      if (i18nAttr || isTopLevelImplicit) {\n        this._inI18nNode = true;\n        const message = this._addMessage(el.children, i18nMeta)!;\n        translatedChildNodes = this._translateMessage(el, message);\n      }\n\n      if (this._mode == _VisitorMode.Extract) {\n        const isTranslatable = i18nAttr || isTopLevelImplicit;\n        if (isTranslatable) this._openTranslatableSection(el);\n        html.visitAll(this, el.children);\n        if (isTranslatable) this._closeTranslatableSection(el, el.children);\n      }\n    } else {\n      if (i18nAttr || isTopLevelImplicit) {\n        this._reportError(\n            el, 'Could not mark an element as translatable inside a translatable section');\n      }\n\n      if (this._mode == _VisitorMode.Extract) {\n        // Descend into child nodes for extraction\n        html.visitAll(this, el.children);\n      }\n    }\n\n    if (this._mode === _VisitorMode.Merge) {\n      const visitNodes = translatedChildNodes || el.children;\n      visitNodes.forEach(child => {\n        const visited = child.visit(this, context);\n        if (visited && !this._isInTranslatableSection) {\n          // Do not add the children from translatable sections (= i18n blocks here)\n          // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)\n          childNodes = childNodes.concat(visited);\n        }\n      });\n    }\n\n    this._visitAttributesOf(el);\n\n    this._depth--;\n    this._inI18nNode = wasInI18nNode;\n    this._inImplicitNode = wasInImplicitNode;\n\n    if (this._mode === _VisitorMode.Merge) {\n      const translatedAttrs = this._translateAttributes(el);\n      return new html.Element(\n          el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan,\n          el.endSourceSpan);\n    }\n    return null;\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): any {\n    throw new Error('unreachable code');\n  }\n\n  private _init(mode: _VisitorMode, interpolationConfig: InterpolationConfig): void {\n    this._mode = mode;\n    this._inI18nBlock = false;\n    this._inI18nNode = false;\n    this._depth = 0;\n    this._inIcu = false;\n    this._msgCountAtSectionStart = undefined;\n    this._errors = [];\n    this._messages = [];\n    this._inImplicitNode = false;\n    this._createI18nMessage = createI18nMessageFactory(interpolationConfig);\n  }\n\n  // looks for translatable attributes\n  private _visitAttributesOf(el: html.Element): void {\n    const explicitAttrNameToValue: {[k: string]: string} = {};\n    const implicitAttrNames: string[] = this._implicitAttrs[el.name] || [];\n\n    el.attrs.filter(attr => attr.name.startsWith(_I18N_ATTR_PREFIX))\n        .forEach(\n            attr => explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n                attr.value);\n\n    el.attrs.forEach(attr => {\n      if (attr.name in explicitAttrNameToValue) {\n        this._addMessage([attr], explicitAttrNameToValue[attr.name]);\n      } else if (implicitAttrNames.some(name => attr.name === name)) {\n        this._addMessage([attr]);\n      }\n    });\n  }\n\n  // add a translatable message\n  private _addMessage(ast: html.Node[], msgMeta?: string): i18n.Message|null {\n    if (ast.length == 0 ||\n        ast.length == 1 && ast[0] instanceof html.Attribute && !(<html.Attribute>ast[0]).value) {\n      // Do not create empty messages\n      return null;\n    }\n\n    const {meaning, description, id} = _parseMessageMeta(msgMeta);\n    const message = this._createI18nMessage(ast, meaning, description, id);\n    this._messages.push(message);\n    return message;\n  }\n\n  // Translates the given message given the `TranslationBundle`\n  // This is used for translating elements / blocks - see `_translateAttributes` for attributes\n  // no-op when called in extraction mode (returns [])\n  private _translateMessage(el: html.Node, message: i18n.Message): html.Node[] {\n    if (message && this._mode === _VisitorMode.Merge) {\n      const nodes = this._translations.get(message);\n\n      if (nodes) {\n        return nodes;\n      }\n\n      this._reportError(\n          el, `Translation unavailable for message id=\"${this._translations.digest(message)}\"`);\n    }\n\n    return [];\n  }\n\n  // translate the attributes of an element and remove i18n specific attributes\n  private _translateAttributes(el: html.Element): html.Attribute[] {\n    const attributes = el.attrs;\n    const i18nParsedMessageMeta:\n        {[name: string]: {meaning: string, description: string, id: string}} = {};\n\n    attributes.forEach(attr => {\n      if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n        i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n            _parseMessageMeta(attr.value);\n      }\n    });\n\n    const translatedAttributes: html.Attribute[] = [];\n\n    attributes.forEach((attr) => {\n      if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n        // strip i18n specific attributes\n        return;\n      }\n\n      if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {\n        const {meaning, description, id} = i18nParsedMessageMeta[attr.name];\n        const message: i18n.Message = this._createI18nMessage([attr], meaning, description, id);\n        const nodes = this._translations.get(message);\n        if (nodes) {\n          if (nodes.length == 0) {\n            translatedAttributes.push(new html.Attribute(\n                attr.name, '', attr.sourceSpan, undefined /* keySpan */, undefined /* valueSpan */,\n                undefined /* valueTokens */, undefined /* i18n */));\n          } else if (nodes[0] instanceof html.Text) {\n            const value = (nodes[0] as html.Text).value;\n            translatedAttributes.push(new html.Attribute(\n                attr.name, value, attr.sourceSpan, undefined /* keySpan */,\n                undefined /* valueSpan */, undefined /* valueTokens */, undefined /* i18n */));\n          } else {\n            this._reportError(\n                el,\n                `Unexpected translation for attribute \"${attr.name}\" (id=\"${\n                    id || this._translations.digest(message)}\")`);\n          }\n        } else {\n          this._reportError(\n              el,\n              `Translation unavailable for attribute \"${attr.name}\" (id=\"${\n                  id || this._translations.digest(message)}\")`);\n        }\n      } else {\n        translatedAttributes.push(attr);\n      }\n    });\n\n    return translatedAttributes;\n  }\n\n\n  /**\n   * Add the node as a child of the block when:\n   * - we are in a block,\n   * - we are not inside a ICU message (those are handled separately),\n   * - the node is a \"direct child\" of the block\n   */\n  private _mayBeAddBlockChildren(node: html.Node): void {\n    if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\n      this._blockChildren.push(node);\n    }\n  }\n\n  /**\n   * Marks the start of a section, see `_closeTranslatableSection`\n   */\n  private _openTranslatableSection(node: html.Node): void {\n    if (this._isInTranslatableSection) {\n      this._reportError(node, 'Unexpected section start');\n    } else {\n      this._msgCountAtSectionStart = this._messages.length;\n    }\n  }\n\n  /**\n   * A translatable section could be:\n   * - the content of translatable element,\n   * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\n   */\n  private get _isInTranslatableSection(): boolean {\n    return this._msgCountAtSectionStart !== void 0;\n  }\n\n  /**\n   * Terminates a section.\n   *\n   * If a section has only one significant children (comments not significant) then we should not\n   * keep the message from this children:\n   *\n   * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\n   * - one for the <p> content with meaning and description,\n   * - another one for the ICU message.\n   *\n   * In this case the last message is discarded as it contains less information (the AST is\n   * otherwise identical).\n   *\n   * Note that we should still keep messages extracted from attributes inside the section (ie in the\n   * ICU message here)\n   */\n  private _closeTranslatableSection(node: html.Node, directChildren: html.Node[]): void {\n    if (!this._isInTranslatableSection) {\n      this._reportError(node, 'Unexpected section end');\n      return;\n    }\n\n    const startIndex = this._msgCountAtSectionStart;\n    const significantChildren: number = directChildren.reduce(\n        (count: number, node: html.Node): number => count + (node instanceof html.Comment ? 0 : 1),\n        0);\n\n    if (significantChildren == 1) {\n      for (let i = this._messages.length - 1; i >= startIndex!; i--) {\n        const ast = this._messages[i].nodes;\n        if (!(ast.length == 1 && ast[0] instanceof i18n.Text)) {\n          this._messages.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    this._msgCountAtSectionStart = undefined;\n  }\n\n  private _reportError(node: html.Node, msg: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, msg));\n  }\n}\n\nfunction _isOpeningComment(n: html.Node): boolean {\n  return !!(n instanceof html.Comment && n.value && n.value.startsWith('i18n'));\n}\n\nfunction _isClosingComment(n: html.Node): boolean {\n  return !!(n instanceof html.Comment && n.value && n.value === '/i18n');\n}\n\nfunction _getI18nAttr(p: html.Element): html.Attribute|null {\n  return p.attrs.find(attr => attr.name === _I18N_ATTR) || null;\n}\n\nfunction _parseMessageMeta(i18n?: string): {meaning: string, description: string, id: string} {\n  if (!i18n) return {meaning: '', description: '', id: ''};\n\n  const idIndex = i18n.indexOf(ID_SEPARATOR);\n  const descIndex = i18n.indexOf(MEANING_SEPARATOR);\n  const [meaningAndDesc, id] =\n      (idIndex > -1) ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''];\n  const [meaning, description] = (descIndex > -1) ?\n      [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n      ['', meaningAndDesc];\n\n  return {meaning, description, id: id.trim()};\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TagContentType, TagDefinition} from './tags';\n\nexport class XmlTagDefinition implements TagDefinition {\n  closedByParent: boolean = false;\n  // TODO(issue/24571): remove '!'.\n  requiredParents!: {[key: string]: boolean};\n  // TODO(issue/24571): remove '!'.\n  parentToAdd!: string;\n  // TODO(issue/24571): remove '!'.\n  implicitNamespacePrefix!: string;\n  isVoid: boolean = false;\n  ignoreFirstLf: boolean = false;\n  canSelfClose: boolean = true;\n  preventNamespaceInheritance: boolean = false;\n\n  requireExtraParent(currentParent: string): boolean {\n    return false;\n  }\n\n  isClosedByChild(name: string): boolean {\n    return false;\n  }\n\n  getContentType(): TagContentType {\n    return TagContentType.PARSABLE_DATA;\n  }\n}\n\nconst _TAG_DEFINITION = new XmlTagDefinition();\n\nexport function getXmlTagDefinition(tagName: string): XmlTagDefinition {\n  return _TAG_DEFINITION;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TokenizeOptions} from './lexer';\nimport {Parser, ParseTreeResult} from './parser';\nimport {getXmlTagDefinition} from './xml_tags';\n\nexport class XmlParser extends Parser {\n  constructor() {\n    super(getXmlTagDefinition);\n  }\n\n  override parse(source: string, url: string, options?: TokenizeOptions): ParseTreeResult {\n    return super.parse(source, url, options);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ml from '../../ml_parser/ast';\nimport {XmlParser} from '../../ml_parser/xml_parser';\nimport {digest} from '../digest';\nimport * as i18n from '../i18n_ast';\nimport {I18nError} from '../parse_util';\n\nimport {Serializer} from './serializer';\nimport * as xml from './xml_helper';\n\nconst _VERSION = '1.2';\nconst _XMLNS = 'urn:oasis:names:tc:xliff:document:1.2';\n// TODO(vicb): make this a param (s/_/-/)\nconst _DEFAULT_SOURCE_LANG = 'en';\nconst _PLACEHOLDER_TAG = 'x';\nconst _MARKER_TAG = 'mrk';\n\nconst _FILE_TAG = 'file';\nconst _SOURCE_TAG = 'source';\nconst _SEGMENT_SOURCE_TAG = 'seg-source';\nconst _ALT_TRANS_TAG = 'alt-trans';\nconst _TARGET_TAG = 'target';\nconst _UNIT_TAG = 'trans-unit';\nconst _CONTEXT_GROUP_TAG = 'context-group';\nconst _CONTEXT_TAG = 'context';\n\n// https://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html\n// https://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html\nexport class Xliff extends Serializer {\n  override write(messages: i18n.Message[], locale: string|null): string {\n    const visitor = new _WriteVisitor();\n    const transUnits: xml.Node[] = [];\n\n    messages.forEach(message => {\n      let contextTags: xml.Node[] = [];\n      message.sources.forEach((source: i18n.MessageSpan) => {\n        let contextGroupTag = new xml.Tag(_CONTEXT_GROUP_TAG, {purpose: 'location'});\n        contextGroupTag.children.push(\n            new xml.CR(10),\n            new xml.Tag(\n                _CONTEXT_TAG, {'context-type': 'sourcefile'}, [new xml.Text(source.filePath)]),\n            new xml.CR(10),\n            new xml.Tag(_CONTEXT_TAG, {'context-type': 'linenumber'}, [new xml.Text(\n                                                                          `${source.startLine}`)]),\n            new xml.CR(8));\n        contextTags.push(new xml.CR(8), contextGroupTag);\n      });\n\n      const transUnit = new xml.Tag(_UNIT_TAG, {id: message.id, datatype: 'html'});\n      transUnit.children.push(\n          new xml.CR(8), new xml.Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)),\n          ...contextTags);\n\n      if (message.description) {\n        transUnit.children.push(\n            new xml.CR(8),\n            new xml.Tag(\n                'note', {priority: '1', from: 'description'}, [new xml.Text(message.description)]));\n      }\n\n      if (message.meaning) {\n        transUnit.children.push(\n            new xml.CR(8),\n            new xml.Tag('note', {priority: '1', from: 'meaning'}, [new xml.Text(message.meaning)]));\n      }\n\n      transUnit.children.push(new xml.CR(6));\n\n      transUnits.push(new xml.CR(6), transUnit);\n    });\n\n    const body = new xml.Tag('body', {}, [...transUnits, new xml.CR(4)]);\n    const file = new xml.Tag(\n        'file', {\n          'source-language': locale || _DEFAULT_SOURCE_LANG,\n          datatype: 'plaintext',\n          original: 'ng2.template',\n        },\n        [new xml.CR(4), body, new xml.CR(2)]);\n    const xliff = new xml.Tag(\n        'xliff', {version: _VERSION, xmlns: _XMLNS}, [new xml.CR(2), file, new xml.CR()]);\n\n    return xml.serialize([\n      new xml.Declaration({version: '1.0', encoding: 'UTF-8'}), new xml.CR(), xliff, new xml.CR()\n    ]);\n  }\n\n  override load(content: string, url: string):\n      {locale: string, i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}} {\n    // xliff to xml nodes\n    const xliffParser = new XliffParser();\n    const {locale, msgIdToHtml, errors} = xliffParser.parse(content, url);\n\n    // xml nodes to i18n nodes\n    const i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {};\n    const converter = new XmlToI18n();\n\n    Object.keys(msgIdToHtml).forEach(msgId => {\n      const {i18nNodes, errors: e} = converter.convert(msgIdToHtml[msgId], url);\n      errors.push(...e);\n      i18nNodesByMsgId[msgId] = i18nNodes;\n    });\n\n    if (errors.length) {\n      throw new Error(`xliff parse errors:\\n${errors.join('\\n')}`);\n    }\n\n    return {locale: locale!, i18nNodesByMsgId};\n  }\n\n  override digest(message: i18n.Message): string {\n    return digest(message);\n  }\n}\n\nclass _WriteVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context?: any): xml.Node[] {\n    return [new xml.Text(text.value)];\n  }\n\n  visitContainer(container: i18n.Container, context?: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const ctype = getCtypeForTag(ph.tag);\n\n    if (ph.isVoid) {\n      // void tags have no children nor closing tags\n      return [new xml.Tag(\n          _PLACEHOLDER_TAG, {id: ph.startName, ctype, 'equiv-text': `<${ph.tag}/>`})];\n    }\n\n    const startTagPh =\n        new xml.Tag(_PLACEHOLDER_TAG, {id: ph.startName, ctype, 'equiv-text': `<${ph.tag}>`});\n    const closeTagPh =\n        new xml.Tag(_PLACEHOLDER_TAG, {id: ph.closeName, ctype, 'equiv-text': `</${ph.tag}>`});\n\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    return [new xml.Tag(_PLACEHOLDER_TAG, {id: ph.name, 'equiv-text': `{{${ph.value}}}`})];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const equivText = `{${ph.value.expression}, ${ph.value.type}, ${\n        Object.keys(ph.value.cases).map((value: string) => value + ' {...}').join(' ')}}`;\n    return [new xml.Tag(_PLACEHOLDER_TAG, {id: ph.name, 'equiv-text': equivText})];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\n\n// TODO(vicb): add error management (structure)\n// Extract messages as xml nodes from the xliff file\nclass XliffParser implements ml.Visitor {\n  // TODO(issue/24571): remove '!'.\n  private _unitMlString!: string|null;\n  // TODO(issue/24571): remove '!'.\n  private _errors!: I18nError[];\n  // TODO(issue/24571): remove '!'.\n  private _msgIdToHtml!: {[msgId: string]: string};\n  private _locale: string|null = null;\n\n  parse(xliff: string, url: string) {\n    this._unitMlString = null;\n    this._msgIdToHtml = {};\n\n    const xml = new XmlParser().parse(xliff, url);\n\n    this._errors = xml.errors;\n    ml.visitAll(this, xml.rootNodes, null);\n\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors,\n      locale: this._locale,\n    };\n  }\n\n  visitElement(element: ml.Element, context: any): any {\n    switch (element.name) {\n      case _UNIT_TAG:\n        this._unitMlString = null!;\n        const idAttr = element.attrs.find((attr) => attr.name === 'id');\n        if (!idAttr) {\n          this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            ml.visitAll(this, element.children, null);\n            if (typeof this._unitMlString === 'string') {\n              this._msgIdToHtml[id] = this._unitMlString;\n            } else {\n              this._addError(element, `Message ${id} misses a translation`);\n            }\n          }\n        }\n        break;\n\n      // ignore those tags\n      case _SOURCE_TAG:\n      case _SEGMENT_SOURCE_TAG:\n      case _ALT_TRANS_TAG:\n        break;\n\n      case _TARGET_TAG:\n        const innerTextStart = element.startSourceSpan.end.offset;\n        const innerTextEnd = element.endSourceSpan!.start.offset;\n        const content = element.startSourceSpan.start.file.content;\n        const innerText = content.slice(innerTextStart, innerTextEnd);\n        this._unitMlString = innerText;\n        break;\n\n      case _FILE_TAG:\n        const localeAttr = element.attrs.find((attr) => attr.name === 'target-language');\n        if (localeAttr) {\n          this._locale = localeAttr.value;\n        }\n        ml.visitAll(this, element.children, null);\n        break;\n\n      default:\n        // TODO(vicb): assert file structure, xliff version\n        // For now only recurse on unhandled nodes\n        ml.visitAll(this, element.children, null);\n    }\n  }\n\n  visitAttribute(attribute: ml.Attribute, context: any): any {}\n\n  visitText(text: ml.Text, context: any): any {}\n\n  visitComment(comment: ml.Comment, context: any): any {}\n\n  visitExpansion(expansion: ml.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: ml.ExpansionCase, context: any): any {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, message));\n  }\n}\n\n// Convert ml nodes (xliff syntax) to i18n nodes\nclass XmlToI18n implements ml.Visitor {\n  // TODO(issue/24571): remove '!'.\n  private _errors!: I18nError[];\n\n  convert(message: string, url: string) {\n    const xmlIcu = new XmlParser().parse(message, url, {tokenizeExpansionForms: true});\n    this._errors = xmlIcu.errors;\n\n    const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n        [] :\n        [].concat(...ml.visitAll(this, xmlIcu.rootNodes));\n\n    return {\n      i18nNodes: i18nNodes,\n      errors: this._errors,\n    };\n  }\n\n  visitText(text: ml.Text, context: any) {\n    return new i18n.Text(text.value, text.sourceSpan);\n  }\n\n  visitElement(el: ml.Element, context: any): i18n.Placeholder|ml.Node[]|null {\n    if (el.name === _PLACEHOLDER_TAG) {\n      const nameAttr = el.attrs.find((attr) => attr.name === 'id');\n      if (nameAttr) {\n        return new i18n.Placeholder('', nameAttr.value, el.sourceSpan);\n      }\n\n      this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"id\" attribute`);\n      return null;\n    }\n\n    if (el.name === _MARKER_TAG) {\n      return [].concat(...ml.visitAll(this, el.children));\n    }\n\n    this._addError(el, `Unexpected tag`);\n    return null;\n  }\n\n  visitExpansion(icu: ml.Expansion, context: any) {\n    const caseMap: {[value: string]: i18n.Node} = {};\n\n    ml.visitAll(this, icu.cases).forEach((c: any) => {\n      caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n    });\n\n    return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: ml.ExpansionCase, context: any): any {\n    return {\n      value: icuCase.value,\n      nodes: ml.visitAll(this, icuCase.expression),\n    };\n  }\n\n  visitComment(comment: ml.Comment, context: any) {}\n\n  visitAttribute(attribute: ml.Attribute, context: any) {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, message));\n  }\n}\n\nfunction getCtypeForTag(tag: string): string {\n  switch (tag.toLowerCase()) {\n    case 'br':\n      return 'lb';\n    case 'img':\n      return 'image';\n    default:\n      return `x-${tag}`;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ml from '../../ml_parser/ast';\nimport {XmlParser} from '../../ml_parser/xml_parser';\nimport {decimalDigest} from '../digest';\nimport * as i18n from '../i18n_ast';\nimport {I18nError} from '../parse_util';\n\nimport {Serializer} from './serializer';\nimport * as xml from './xml_helper';\n\nconst _VERSION = '2.0';\nconst _XMLNS = 'urn:oasis:names:tc:xliff:document:2.0';\n// TODO(vicb): make this a param (s/_/-/)\nconst _DEFAULT_SOURCE_LANG = 'en';\nconst _PLACEHOLDER_TAG = 'ph';\nconst _PLACEHOLDER_SPANNING_TAG = 'pc';\nconst _MARKER_TAG = 'mrk';\n\nconst _XLIFF_TAG = 'xliff';\nconst _SOURCE_TAG = 'source';\nconst _TARGET_TAG = 'target';\nconst _UNIT_TAG = 'unit';\n\n// https://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\nexport class Xliff2 extends Serializer {\n  override write(messages: i18n.Message[], locale: string|null): string {\n    const visitor = new _WriteVisitor();\n    const units: xml.Node[] = [];\n\n    messages.forEach(message => {\n      const unit = new xml.Tag(_UNIT_TAG, {id: message.id});\n      const notes = new xml.Tag('notes');\n\n      if (message.description || message.meaning) {\n        if (message.description) {\n          notes.children.push(\n              new xml.CR(8),\n              new xml.Tag('note', {category: 'description'}, [new xml.Text(message.description)]));\n        }\n\n        if (message.meaning) {\n          notes.children.push(\n              new xml.CR(8),\n              new xml.Tag('note', {category: 'meaning'}, [new xml.Text(message.meaning)]));\n        }\n      }\n\n      message.sources.forEach((source: i18n.MessageSpan) => {\n        notes.children.push(new xml.CR(8), new xml.Tag('note', {category: 'location'}, [\n          new xml.Text(`${source.filePath}:${source.startLine}${\n              source.endLine !== source.startLine ? ',' + source.endLine : ''}`)\n        ]));\n      });\n\n      notes.children.push(new xml.CR(6));\n      unit.children.push(new xml.CR(6), notes);\n\n      const segment = new xml.Tag('segment');\n\n      segment.children.push(\n          new xml.CR(8), new xml.Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)),\n          new xml.CR(6));\n\n      unit.children.push(new xml.CR(6), segment, new xml.CR(4));\n\n      units.push(new xml.CR(4), unit);\n    });\n\n    const file =\n        new xml.Tag('file', {'original': 'ng.template', id: 'ngi18n'}, [...units, new xml.CR(2)]);\n\n    const xliff = new xml.Tag(\n        _XLIFF_TAG, {version: _VERSION, xmlns: _XMLNS, srcLang: locale || _DEFAULT_SOURCE_LANG},\n        [new xml.CR(2), file, new xml.CR()]);\n\n    return xml.serialize([\n      new xml.Declaration({version: '1.0', encoding: 'UTF-8'}), new xml.CR(), xliff, new xml.CR()\n    ]);\n  }\n\n  override load(content: string, url: string):\n      {locale: string, i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}} {\n    // xliff to xml nodes\n    const xliff2Parser = new Xliff2Parser();\n    const {locale, msgIdToHtml, errors} = xliff2Parser.parse(content, url);\n\n    // xml nodes to i18n nodes\n    const i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {};\n    const converter = new XmlToI18n();\n\n    Object.keys(msgIdToHtml).forEach(msgId => {\n      const {i18nNodes, errors: e} = converter.convert(msgIdToHtml[msgId], url);\n      errors.push(...e);\n      i18nNodesByMsgId[msgId] = i18nNodes;\n    });\n\n    if (errors.length) {\n      throw new Error(`xliff2 parse errors:\\n${errors.join('\\n')}`);\n    }\n\n    return {locale: locale!, i18nNodesByMsgId};\n  }\n\n  override digest(message: i18n.Message): string {\n    return decimalDigest(message);\n  }\n}\n\nclass _WriteVisitor implements i18n.Visitor {\n  // TODO(issue/24571): remove '!'.\n  private _nextPlaceholderId!: number;\n\n  visitText(text: i18n.Text, context?: any): xml.Node[] {\n    return [new xml.Text(text.value)];\n  }\n\n  visitContainer(container: i18n.Container, context?: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const type = getTypeForTag(ph.tag);\n\n    if (ph.isVoid) {\n      const tagPh = new xml.Tag(_PLACEHOLDER_TAG, {\n        id: (this._nextPlaceholderId++).toString(),\n        equiv: ph.startName,\n        type: type,\n        disp: `<${ph.tag}/>`,\n      });\n      return [tagPh];\n    }\n\n    const tagPc = new xml.Tag(_PLACEHOLDER_SPANNING_TAG, {\n      id: (this._nextPlaceholderId++).toString(),\n      equivStart: ph.startName,\n      equivEnd: ph.closeName,\n      type: type,\n      dispStart: `<${ph.tag}>`,\n      dispEnd: `</${ph.tag}>`,\n    });\n    const nodes: xml.Node[] = [].concat(...ph.children.map(node => node.visit(this)));\n    if (nodes.length) {\n      nodes.forEach((node: xml.Node) => tagPc.children.push(node));\n    } else {\n      tagPc.children.push(new xml.Text(''));\n    }\n\n    return [tagPc];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    const idStr = (this._nextPlaceholderId++).toString();\n    return [new xml.Tag(_PLACEHOLDER_TAG, {\n      id: idStr,\n      equiv: ph.name,\n      disp: `{{${ph.value}}}`,\n    })];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const cases = Object.keys(ph.value.cases).map((value: string) => value + ' {...}').join(' ');\n    const idStr = (this._nextPlaceholderId++).toString();\n    return [new xml.Tag(\n        _PLACEHOLDER_TAG,\n        {id: idStr, equiv: ph.name, disp: `{${ph.value.expression}, ${ph.value.type}, ${cases}}`})];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    this._nextPlaceholderId = 0;\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\n\n// Extract messages as xml nodes from the xliff file\nclass Xliff2Parser implements ml.Visitor {\n  // TODO(issue/24571): remove '!'.\n  private _unitMlString!: string|null;\n  // TODO(issue/24571): remove '!'.\n  private _errors!: I18nError[];\n  // TODO(issue/24571): remove '!'.\n  private _msgIdToHtml!: {[msgId: string]: string};\n  private _locale: string|null = null;\n\n  parse(xliff: string, url: string) {\n    this._unitMlString = null;\n    this._msgIdToHtml = {};\n\n    const xml = new XmlParser().parse(xliff, url);\n\n    this._errors = xml.errors;\n    ml.visitAll(this, xml.rootNodes, null);\n\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors,\n      locale: this._locale,\n    };\n  }\n\n  visitElement(element: ml.Element, context: any): any {\n    switch (element.name) {\n      case _UNIT_TAG:\n        this._unitMlString = null;\n        const idAttr = element.attrs.find((attr) => attr.name === 'id');\n        if (!idAttr) {\n          this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            ml.visitAll(this, element.children, null);\n            if (typeof this._unitMlString === 'string') {\n              this._msgIdToHtml[id] = this._unitMlString;\n            } else {\n              this._addError(element, `Message ${id} misses a translation`);\n            }\n          }\n        }\n        break;\n\n      case _SOURCE_TAG:\n        // ignore source message\n        break;\n\n      case _TARGET_TAG:\n        const innerTextStart = element.startSourceSpan.end.offset;\n        const innerTextEnd = element.endSourceSpan!.start.offset;\n        const content = element.startSourceSpan.start.file.content;\n        const innerText = content.slice(innerTextStart, innerTextEnd);\n        this._unitMlString = innerText;\n        break;\n\n      case _XLIFF_TAG:\n        const localeAttr = element.attrs.find((attr) => attr.name === 'trgLang');\n        if (localeAttr) {\n          this._locale = localeAttr.value;\n        }\n\n        const versionAttr = element.attrs.find((attr) => attr.name === 'version');\n        if (versionAttr) {\n          const version = versionAttr.value;\n          if (version !== '2.0') {\n            this._addError(\n                element,\n                `The XLIFF file version ${version} is not compatible with XLIFF 2.0 serializer`);\n          } else {\n            ml.visitAll(this, element.children, null);\n          }\n        }\n        break;\n      default:\n        ml.visitAll(this, element.children, null);\n    }\n  }\n\n  visitAttribute(attribute: ml.Attribute, context: any): any {}\n\n  visitText(text: ml.Text, context: any): any {}\n\n  visitComment(comment: ml.Comment, context: any): any {}\n\n  visitExpansion(expansion: ml.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: ml.ExpansionCase, context: any): any {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, message));\n  }\n}\n\n// Convert ml nodes (xliff syntax) to i18n nodes\nclass XmlToI18n implements ml.Visitor {\n  // TODO(issue/24571): remove '!'.\n  private _errors!: I18nError[];\n\n  convert(message: string, url: string) {\n    const xmlIcu = new XmlParser().parse(message, url, {tokenizeExpansionForms: true});\n    this._errors = xmlIcu.errors;\n\n    const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n        [] :\n        [].concat(...ml.visitAll(this, xmlIcu.rootNodes));\n\n    return {\n      i18nNodes,\n      errors: this._errors,\n    };\n  }\n\n  visitText(text: ml.Text, context: any) {\n    return new i18n.Text(text.value, text.sourceSpan);\n  }\n\n  visitElement(el: ml.Element, context: any): i18n.Node[]|null {\n    switch (el.name) {\n      case _PLACEHOLDER_TAG:\n        const nameAttr = el.attrs.find((attr) => attr.name === 'equiv');\n        if (nameAttr) {\n          return [new i18n.Placeholder('', nameAttr.value, el.sourceSpan)];\n        }\n\n        this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equiv\" attribute`);\n        break;\n      case _PLACEHOLDER_SPANNING_TAG:\n        const startAttr = el.attrs.find((attr) => attr.name === 'equivStart');\n        const endAttr = el.attrs.find((attr) => attr.name === 'equivEnd');\n\n        if (!startAttr) {\n          this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equivStart\" attribute`);\n        } else if (!endAttr) {\n          this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"equivEnd\" attribute`);\n        } else {\n          const startId = startAttr.value;\n          const endId = endAttr.value;\n\n          const nodes: i18n.Node[] = [];\n\n          return nodes.concat(\n              new i18n.Placeholder('', startId, el.sourceSpan),\n              ...el.children.map(node => node.visit(this, null)),\n              new i18n.Placeholder('', endId, el.sourceSpan));\n        }\n        break;\n      case _MARKER_TAG:\n        return [].concat(...ml.visitAll(this, el.children));\n      default:\n        this._addError(el, `Unexpected tag`);\n    }\n\n    return null;\n  }\n\n  visitExpansion(icu: ml.Expansion, context: any) {\n    const caseMap: {[value: string]: i18n.Node} = {};\n\n    ml.visitAll(this, icu.cases).forEach((c: any) => {\n      caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n    });\n\n    return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: ml.ExpansionCase, context: any): any {\n    return {\n      value: icuCase.value,\n      nodes: [].concat(...ml.visitAll(this, icuCase.expression)),\n    };\n  }\n\n  visitComment(comment: ml.Comment, context: any) {}\n\n  visitAttribute(attribute: ml.Attribute, context: any) {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, message));\n  }\n}\n\nfunction getTypeForTag(tag: string): string {\n  switch (tag.toLowerCase()) {\n    case 'br':\n    case 'b':\n    case 'i':\n    case 'u':\n      return 'fmt';\n    case 'img':\n      return 'image';\n    case 'a':\n      return 'link';\n    default:\n      return 'other';\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ml from '../../ml_parser/ast';\nimport {XmlParser} from '../../ml_parser/xml_parser';\nimport * as i18n from '../i18n_ast';\nimport {I18nError} from '../parse_util';\n\nimport {PlaceholderMapper, Serializer, SimplePlaceholderMapper} from './serializer';\nimport {digest, toPublicName} from './xmb';\n\nconst _TRANSLATIONS_TAG = 'translationbundle';\nconst _TRANSLATION_TAG = 'translation';\nconst _PLACEHOLDER_TAG = 'ph';\n\nexport class Xtb extends Serializer {\n  override write(messages: i18n.Message[], locale: string|null): string {\n    throw new Error('Unsupported');\n  }\n\n  override load(content: string, url: string):\n      {locale: string, i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}} {\n    // xtb to xml nodes\n    const xtbParser = new XtbParser();\n    const {locale, msgIdToHtml, errors} = xtbParser.parse(content, url);\n\n    // xml nodes to i18n nodes\n    const i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {};\n    const converter = new XmlToI18n();\n\n    // Because we should be able to load xtb files that rely on features not supported by angular,\n    // we need to delay the conversion of html to i18n nodes so that non angular messages are not\n    // converted\n    Object.keys(msgIdToHtml).forEach(msgId => {\n      const valueFn = function() {\n        const {i18nNodes, errors} = converter.convert(msgIdToHtml[msgId], url);\n        if (errors.length) {\n          throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\n        }\n        return i18nNodes;\n      };\n      createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n    });\n\n    if (errors.length) {\n      throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\n    }\n\n    return {locale: locale!, i18nNodesByMsgId};\n  }\n\n  override digest(message: i18n.Message): string {\n    return digest(message);\n  }\n\n  override createNameMapper(message: i18n.Message): PlaceholderMapper {\n    return new SimplePlaceholderMapper(message, toPublicName);\n  }\n}\n\nfunction createLazyProperty(messages: any, id: string, valueFn: () => any) {\n  Object.defineProperty(messages, id, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      const value = valueFn();\n      Object.defineProperty(messages, id, {enumerable: true, value});\n      return value;\n    },\n    set: _ => {\n      throw new Error('Could not overwrite an XTB translation');\n    },\n  });\n}\n\n// Extract messages as xml nodes from the xtb file\nclass XtbParser implements ml.Visitor {\n  // TODO(issue/24571): remove '!'.\n  private _bundleDepth!: number;\n  // TODO(issue/24571): remove '!'.\n  private _errors!: I18nError[];\n  // TODO(issue/24571): remove '!'.\n  private _msgIdToHtml!: {[msgId: string]: string};\n  private _locale: string|null = null;\n\n  parse(xtb: string, url: string) {\n    this._bundleDepth = 0;\n    this._msgIdToHtml = {};\n\n    // We can not parse the ICU messages at this point as some messages might not originate\n    // from Angular that could not be lex'd.\n    const xml = new XmlParser().parse(xtb, url);\n\n    this._errors = xml.errors;\n    ml.visitAll(this, xml.rootNodes);\n\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors,\n      locale: this._locale,\n    };\n  }\n\n  visitElement(element: ml.Element, context: any): any {\n    switch (element.name) {\n      case _TRANSLATIONS_TAG:\n        this._bundleDepth++;\n        if (this._bundleDepth > 1) {\n          this._addError(element, `<${_TRANSLATIONS_TAG}> elements can not be nested`);\n        }\n        const langAttr = element.attrs.find((attr) => attr.name === 'lang');\n        if (langAttr) {\n          this._locale = langAttr.value;\n        }\n        ml.visitAll(this, element.children, null);\n        this._bundleDepth--;\n        break;\n\n      case _TRANSLATION_TAG:\n        const idAttr = element.attrs.find((attr) => attr.name === 'id');\n        if (!idAttr) {\n          this._addError(element, `<${_TRANSLATION_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            const innerTextStart = element.startSourceSpan.end.offset;\n            const innerTextEnd = element.endSourceSpan!.start.offset;\n            const content = element.startSourceSpan.start.file.content;\n            const innerText = content.slice(innerTextStart!, innerTextEnd!);\n            this._msgIdToHtml[id] = innerText;\n          }\n        }\n        break;\n\n      default:\n        this._addError(element, 'Unexpected tag');\n    }\n  }\n\n  visitAttribute(attribute: ml.Attribute, context: any): any {}\n\n  visitText(text: ml.Text, context: any): any {}\n\n  visitComment(comment: ml.Comment, context: any): any {}\n\n  visitExpansion(expansion: ml.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: ml.ExpansionCase, context: any): any {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, message));\n  }\n}\n\n// Convert ml nodes (xtb syntax) to i18n nodes\nclass XmlToI18n implements ml.Visitor {\n  // TODO(issue/24571): remove '!'.\n  private _errors!: I18nError[];\n\n  convert(message: string, url: string) {\n    const xmlIcu = new XmlParser().parse(message, url, {tokenizeExpansionForms: true});\n    this._errors = xmlIcu.errors;\n\n    const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n        [] :\n        ml.visitAll(this, xmlIcu.rootNodes);\n\n    return {\n      i18nNodes,\n      errors: this._errors,\n    };\n  }\n\n  visitText(text: ml.Text, context: any) {\n    return new i18n.Text(text.value, text.sourceSpan);\n  }\n\n  visitExpansion(icu: ml.Expansion, context: any) {\n    const caseMap: {[value: string]: i18n.Node} = {};\n\n    ml.visitAll(this, icu.cases).forEach(c => {\n      caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n    });\n\n    return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: ml.ExpansionCase, context: any): any {\n    return {\n      value: icuCase.value,\n      nodes: ml.visitAll(this, icuCase.expression),\n    };\n  }\n\n  visitElement(el: ml.Element, context: any): i18n.Placeholder|null {\n    if (el.name === _PLACEHOLDER_TAG) {\n      const nameAttr = el.attrs.find((attr) => attr.name === 'name');\n      if (nameAttr) {\n        return new i18n.Placeholder('', nameAttr.value, el.sourceSpan);\n      }\n\n      this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"name\" attribute`);\n    } else {\n      this._addError(el, `Unexpected tag`);\n    }\n    return null;\n  }\n\n  visitComment(comment: ml.Comment, context: any) {}\n\n  visitAttribute(attribute: ml.Attribute, context: any) {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, message));\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {MissingTranslationStrategy} from '../core';\nimport * as html from '../ml_parser/ast';\nimport {HtmlParser} from '../ml_parser/html_parser';\nimport {Console} from '../util';\n\nimport * as i18n from './i18n_ast';\nimport {I18nError} from './parse_util';\nimport {PlaceholderMapper, Serializer} from './serializers/serializer';\nimport {escapeXml} from './serializers/xml_helper';\n\n\n/**\n * A container for translated messages\n */\nexport class TranslationBundle {\n  private _i18nToHtml: I18nToHtmlVisitor;\n\n  constructor(\n      private _i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {}, locale: string|null,\n      public digest: (m: i18n.Message) => string,\n      public mapperFactory?: (m: i18n.Message) => PlaceholderMapper,\n      missingTranslationStrategy: MissingTranslationStrategy = MissingTranslationStrategy.Warning,\n      console?: Console) {\n    this._i18nToHtml = new I18nToHtmlVisitor(\n        _i18nNodesByMsgId, locale, digest, mapperFactory!, missingTranslationStrategy, console);\n  }\n\n  // Creates a `TranslationBundle` by parsing the given `content` with the `serializer`.\n  static load(\n      content: string, url: string, serializer: Serializer,\n      missingTranslationStrategy: MissingTranslationStrategy,\n      console?: Console): TranslationBundle {\n    const {locale, i18nNodesByMsgId} = serializer.load(content, url);\n    const digestFn = (m: i18n.Message) => serializer.digest(m);\n    const mapperFactory = (m: i18n.Message) => serializer.createNameMapper(m)!;\n    return new TranslationBundle(\n        i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);\n  }\n\n  // Returns the translation as HTML nodes from the given source message.\n  get(srcMsg: i18n.Message): html.Node[] {\n    const html = this._i18nToHtml.convert(srcMsg);\n\n    if (html.errors.length) {\n      throw new Error(html.errors.join('\\n'));\n    }\n\n    return html.nodes;\n  }\n\n  has(srcMsg: i18n.Message): boolean {\n    return this.digest(srcMsg) in this._i18nNodesByMsgId;\n  }\n}\n\nclass I18nToHtmlVisitor implements i18n.Visitor {\n  // TODO(issue/24571): remove '!'.\n  private _srcMsg!: i18n.Message;\n  private _contextStack: {msg: i18n.Message, mapper: (name: string) => string}[] = [];\n  private _errors: I18nError[] = [];\n  // TODO(issue/24571): remove '!'.\n  private _mapper!: (name: string) => string;\n\n  constructor(\n      private _i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {}, private _locale: string|null,\n      private _digest: (m: i18n.Message) => string,\n      private _mapperFactory: (m: i18n.Message) => PlaceholderMapper,\n      private _missingTranslationStrategy: MissingTranslationStrategy, private _console?: Console) {\n  }\n\n  convert(srcMsg: i18n.Message): {nodes: html.Node[], errors: I18nError[]} {\n    this._contextStack.length = 0;\n    this._errors.length = 0;\n\n    // i18n to text\n    const text = this._convertToText(srcMsg);\n\n    // text to html\n    const url = srcMsg.nodes[0].sourceSpan.start.file.url;\n    const html = new HtmlParser().parse(text, url, {tokenizeExpansionForms: true});\n\n    return {\n      nodes: html.rootNodes,\n      errors: [...this._errors, ...html.errors],\n    };\n  }\n\n  visitText(text: i18n.Text, context?: any): string {\n    // `convert()` uses an `HtmlParser` to return `html.Node`s\n    // we should then make sure that any special characters are escaped\n    return escapeXml(text.value);\n  }\n\n  visitContainer(container: i18n.Container, context?: any): any {\n    return container.children.map(n => n.visit(this)).join('');\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): any {\n    const cases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n\n    // TODO(vicb): Once all format switch to using expression placeholders\n    // we should throw when the placeholder is not in the source message\n    const exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ?\n        this._srcMsg.placeholders[icu.expression].text :\n        icu.expression;\n\n    return `{${exp}, ${icu.type}, ${cases.join(' ')}}`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): string {\n    const phName = this._mapper(ph.name);\n    if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n      return this._srcMsg.placeholders[phName].text;\n    }\n\n    if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n      return this._convertToText(this._srcMsg.placeholderToMessage[phName]);\n    }\n\n    this._addError(ph, `Unknown placeholder \"${ph.name}\"`);\n    return '';\n  }\n\n  // Loaded message contains only placeholders (vs tag and icu placeholders).\n  // However when a translation can not be found, we need to serialize the source message\n  // which can contain tag placeholders\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): string {\n    const tag = `${ph.tag}`;\n    const attrs = Object.keys(ph.attrs).map(name => `${name}=\"${ph.attrs[name]}\"`).join(' ');\n    if (ph.isVoid) {\n      return `<${tag} ${attrs}/>`;\n    }\n    const children = ph.children.map((c: i18n.Node) => c.visit(this)).join('');\n    return `<${tag} ${attrs}>${children}</${tag}>`;\n  }\n\n  // Loaded message contains only placeholders (vs tag and icu placeholders).\n  // However when a translation can not be found, we need to serialize the source message\n  // which can contain tag placeholders\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): string {\n    // An ICU placeholder references the source message to be serialized\n    return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n  }\n\n  /**\n   * Convert a source message to a translated text string:\n   * - text nodes are replaced with their translation,\n   * - placeholders are replaced with their content,\n   * - ICU nodes are converted to ICU expressions.\n   */\n  private _convertToText(srcMsg: i18n.Message): string {\n    const id = this._digest(srcMsg);\n    const mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n    let nodes: i18n.Node[];\n\n    this._contextStack.push({msg: this._srcMsg, mapper: this._mapper});\n    this._srcMsg = srcMsg;\n\n    if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n      // When there is a translation use its nodes as the source\n      // And create a mapper to convert serialized placeholder names to internal names\n      nodes = this._i18nNodesByMsgId[id];\n      this._mapper = (name: string) => mapper ? mapper.toInternalName(name)! : name;\n    } else {\n      // When no translation has been found\n      // - report an error / a warning / nothing,\n      // - use the nodes from the original message\n      // - placeholders are already internal and need no mapper\n      if (this._missingTranslationStrategy === MissingTranslationStrategy.Error) {\n        const ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\n        this._addError(srcMsg.nodes[0], `Missing translation for message \"${id}\"${ctx}`);\n      } else if (\n          this._console &&\n          this._missingTranslationStrategy === MissingTranslationStrategy.Warning) {\n        const ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\n        this._console.warn(`Missing translation for message \"${id}\"${ctx}`);\n      }\n      nodes = srcMsg.nodes;\n      this._mapper = (name: string) => name;\n    }\n    const text = nodes.map(node => node.visit(this)).join('');\n    const context = this._contextStack.pop()!;\n    this._srcMsg = context.msg;\n    this._mapper = context.mapper;\n    return text;\n  }\n\n  private _addError(el: i18n.Node, msg: string) {\n    this._errors.push(new I18nError(el.sourceSpan, msg));\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {MissingTranslationStrategy} from '../core';\nimport {HtmlParser} from '../ml_parser/html_parser';\nimport {DEFAULT_INTERPOLATION_CONFIG} from '../ml_parser/interpolation_config';\nimport {TokenizeOptions} from '../ml_parser/lexer';\nimport {ParseTreeResult} from '../ml_parser/parser';\nimport {Console} from '../util';\n\nimport {digest} from './digest';\nimport {mergeTranslations} from './extractor_merger';\nimport {Serializer} from './serializers/serializer';\nimport {Xliff} from './serializers/xliff';\nimport {Xliff2} from './serializers/xliff2';\nimport {Xmb} from './serializers/xmb';\nimport {Xtb} from './serializers/xtb';\nimport {TranslationBundle} from './translation_bundle';\n\nexport class I18NHtmlParser implements HtmlParser {\n  // @override\n  getTagDefinition: any;\n\n  private _translationBundle: TranslationBundle;\n\n  constructor(\n      private _htmlParser: HtmlParser, translations?: string, translationsFormat?: string,\n      missingTranslation: MissingTranslationStrategy = MissingTranslationStrategy.Warning,\n      console?: Console) {\n    if (translations) {\n      const serializer = createSerializer(translationsFormat);\n      this._translationBundle =\n          TranslationBundle.load(translations, 'i18n', serializer, missingTranslation, console);\n    } else {\n      this._translationBundle =\n          new TranslationBundle({}, null, digest, undefined, missingTranslation, console);\n    }\n  }\n\n  parse(source: string, url: string, options: TokenizeOptions = {}): ParseTreeResult {\n    const interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n    const parseResult = this._htmlParser.parse(source, url, {interpolationConfig, ...options});\n\n    if (parseResult.errors.length) {\n      return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);\n    }\n\n    return mergeTranslations(\n        parseResult.rootNodes, this._translationBundle, interpolationConfig, [], {});\n  }\n}\n\nfunction createSerializer(format?: string): Serializer {\n  format = (format || 'xlf').toLowerCase();\n\n  switch (format) {\n    case 'xmb':\n      return new Xmb();\n    case 'xtb':\n      return new Xtb();\n    case 'xliff2':\n    case 'xlf2':\n      return new Xliff2();\n    case 'xliff':\n    case 'xlf':\n    default:\n      return new Xliff();\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {HtmlParser} from '../ml_parser/html_parser';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {ParseError} from '../parse_util';\n\nimport {extractMessages} from './extractor_merger';\nimport * as i18n from './i18n_ast';\nimport {PlaceholderMapper, Serializer} from './serializers/serializer';\n\n\n/**\n * A container for message extracted from the templates.\n */\nexport class MessageBundle {\n  private _messages: i18n.Message[] = [];\n\n  constructor(\n      private _htmlParser: HtmlParser, private _implicitTags: string[],\n      private _implicitAttrs: {[k: string]: string[]}, private _locale: string|null = null) {}\n\n  updateFromTemplate(html: string, url: string, interpolationConfig: InterpolationConfig):\n      ParseError[] {\n    const htmlParserResult =\n        this._htmlParser.parse(html, url, {tokenizeExpansionForms: true, interpolationConfig});\n\n    if (htmlParserResult.errors.length) {\n      return htmlParserResult.errors;\n    }\n\n    const i18nParserResult = extractMessages(\n        htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);\n\n    if (i18nParserResult.errors.length) {\n      return i18nParserResult.errors;\n    }\n\n    this._messages.push(...i18nParserResult.messages);\n    return [];\n  }\n\n  // Return the message in the internal format\n  // The public (serialized) format might be different, see the `write` method.\n  getMessages(): i18n.Message[] {\n    return this._messages;\n  }\n\n  write(serializer: Serializer, filterSources?: (path: string) => string): string {\n    const messages: {[id: string]: i18n.Message} = {};\n    const mapperVisitor = new MapPlaceholderNames();\n\n    // Deduplicate messages based on their ID\n    this._messages.forEach(message => {\n      const id = serializer.digest(message);\n      if (!messages.hasOwnProperty(id)) {\n        messages[id] = message;\n      } else {\n        messages[id].sources.push(...message.sources);\n      }\n    });\n\n    // Transform placeholder names using the serializer mapping\n    const msgList = Object.keys(messages).map(id => {\n      const mapper = serializer.createNameMapper(messages[id]);\n      const src = messages[id];\n      const nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;\n      let transformedMessage = new i18n.Message(nodes, {}, {}, src.meaning, src.description, id);\n      transformedMessage.sources = src.sources;\n      if (filterSources) {\n        transformedMessage.sources.forEach(\n            (source: i18n.MessageSpan) => source.filePath = filterSources(source.filePath));\n      }\n      return transformedMessage;\n    });\n\n    return serializer.write(msgList, this._locale);\n  }\n}\n\n// Transform an i18n AST by renaming the placeholder nodes with the given mapper\nclass MapPlaceholderNames extends i18n.CloneVisitor {\n  convert(nodes: i18n.Node[], mapper: PlaceholderMapper): i18n.Node[] {\n    return mapper ? nodes.map(n => n.visit(this, mapper)) : nodes;\n  }\n\n  override visitTagPlaceholder(ph: i18n.TagPlaceholder, mapper: PlaceholderMapper):\n      i18n.TagPlaceholder {\n    const startName = mapper.toPublicName(ph.startName)!;\n    const closeName = ph.closeName ? mapper.toPublicName(ph.closeName)! : ph.closeName;\n    const children = ph.children.map(n => n.visit(this, mapper));\n    return new i18n.TagPlaceholder(\n        ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan,\n        ph.startSourceSpan, ph.endSourceSpan);\n  }\n\n  override visitPlaceholder(ph: i18n.Placeholder, mapper: PlaceholderMapper): i18n.Placeholder {\n    return new i18n.Placeholder(ph.value, mapper.toPublicName(ph.name)!, ph.sourceSpan);\n  }\n\n  override visitIcuPlaceholder(ph: i18n.IcuPlaceholder, mapper: PlaceholderMapper):\n      i18n.IcuPlaceholder {\n    return new i18n.IcuPlaceholder(ph.value, mapper.toPublicName(ph.name)!, ph.sourceSpan);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport {computeMsgId} from './digest';\nexport {I18NHtmlParser} from './i18n_html_parser';\nexport {MessageBundle} from './message_bundle';\nexport {Serializer} from './serializers/serializer';\nexport {Xliff} from './serializers/xliff';\nexport {Xliff2} from './serializers/xliff2';\nexport {Xmb} from './serializers/xmb';\nexport {Xtb} from './serializers/xtb';\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {ChangeDetectionStrategy, ViewEncapsulation} from '../../core';\nimport * as o from '../../output/output_ast';\n\nexport interface R3PartialDeclaration {\n  /**\n   * The minimum version of the compiler that can process this partial declaration.\n   */\n  minVersion: string;\n\n  /**\n   * Version number of the Angular compiler that was used to compile this declaration. The linker\n   * will be able to detect which version a library is using and interpret its metadata accordingly.\n   */\n  version: string;\n\n  /**\n   * A reference to the `@angular/core` ES module, which allows access\n   * to all Angular exports, including Ivy instructions.\n   */\n  ngImport: o.Expression;\n\n  /**\n   * Reference to the decorated class, which is subject to this partial declaration.\n   */\n  type: o.Expression;\n}\n\n/**\n * Describes the shape of the object that the `\u0275\u0275ngDeclareDirective()` function accepts.\n */\nexport interface R3DeclareDirectiveMetadata extends R3PartialDeclaration {\n  /**\n   * Unparsed selector of the directive.\n   */\n  selector?: string;\n\n  /**\n   * A mapping of inputs from class property names to binding property names, or to a tuple of\n   * binding property name and class property name if the names are different.\n   */\n  inputs?: {[classPropertyName: string]: string|[string, string]};\n\n  /**\n   * A mapping of outputs from class property names to binding property names.\n   */\n  outputs?: {[classPropertyName: string]: string};\n\n  /**\n   * Information about host bindings present on the component.\n   */\n  host?: {\n    /**\n     * A mapping of attribute names to their value expression.\n     */\n    attributes?: {[key: string]: o.Expression};\n\n    /**\n     * A mapping of event names to their unparsed event handler expression.\n     */\n    listeners: {[key: string]: string};\n\n    /**\n     * A mapping of bound properties to their unparsed binding expression.\n     */\n    properties?: {[key: string]: string};\n\n    /**\n     * The value of the class attribute, if present. This is stored outside of `attributes` as its\n     * string value must be known statically.\n     */\n    classAttribute?: string;\n\n    /**\n     * The value of the style attribute, if present. This is stored outside of `attributes` as its\n     * string value must be known statically.\n     */\n    styleAttribute?: string;\n  };\n\n  /**\n   * Information about the content queries made by the directive.\n   */\n  queries?: R3DeclareQueryMetadata[];\n\n  /**\n   * Information about the view queries made by the directive.\n   */\n  viewQueries?: R3DeclareQueryMetadata[];\n\n  /**\n   * The list of providers provided by the directive.\n   */\n  providers?: o.Expression;\n\n  /**\n   * The names by which the directive is exported.\n   */\n  exportAs?: string[];\n\n  /**\n   * Whether the directive has an inheritance clause. Defaults to false.\n   */\n  usesInheritance?: boolean;\n\n  /**\n   * Whether the directive implements the `ngOnChanges` hook. Defaults to false.\n   */\n  usesOnChanges?: boolean;\n\n  /**\n   * Whether the directive is standalone. Defaults to false.\n   */\n  isStandalone?: boolean;\n\n  /**\n   * Additional directives applied to the directive host.\n   */\n  hostDirectives?: R3DeclareHostDirectiveMetadata[];\n}\n\n/**\n * Describes the shape of the object that the `\u0275\u0275ngDeclareComponent()` function accepts.\n */\nexport interface R3DeclareComponentMetadata extends R3DeclareDirectiveMetadata {\n  /**\n   * The component's unparsed template string as opaque expression. The template is represented\n   * using either a string literal or template literal without substitutions, but its value is\n   * not read directly. Instead, the template parser is given the full source file's text and\n   * the range of this expression to parse directly from source.\n   */\n  template: o.Expression;\n\n  /**\n   * Whether the template was inline (using `template`) or external (using `templateUrl`).\n   * Defaults to false.\n   */\n  isInline?: boolean;\n\n  /**\n   * CSS from inline styles and included styleUrls.\n   */\n  styles?: string[];\n\n  /**\n   * List of components which matched in the template, including sufficient\n   * metadata for each directive to attribute bindings and references within\n   * the template to each directive specifically, if the runtime instructions\n   * support this.\n   */\n  components?: R3DeclareDirectiveDependencyMetadata[];\n\n  /**\n   * List of directives which matched in the template, including sufficient\n   * metadata for each directive to attribute bindings and references within\n   * the template to each directive specifically, if the runtime instructions\n   * support this.\n   */\n  directives?: R3DeclareDirectiveDependencyMetadata[];\n\n  /**\n   * List of dependencies which matched in the template, including sufficient\n   * metadata for each directive/pipe to attribute bindings and references within\n   * the template to each directive specifically, if the runtime instructions\n   * support this.\n   */\n  dependencies?: R3DeclareTemplateDependencyMetadata[];\n\n  /**\n   * A map of pipe names to an expression referencing the pipe type (possibly a forward reference\n   * wrapped in a `forwardRef` invocation) which are used in the template.\n   */\n  pipes?: {[pipeName: string]: o.Expression|(() => o.Expression)};\n\n  /**\n   * The list of view providers defined in the component.\n   */\n  viewProviders?: o.Expression;\n\n  /**\n   * A collection of animation triggers that will be used in the component template.\n   */\n  animations?: o.Expression;\n\n  /**\n   * Strategy used for detecting changes in the component.\n   * Defaults to `ChangeDetectionStrategy.Default`.\n   */\n  changeDetection?: ChangeDetectionStrategy;\n\n  /**\n   * An encapsulation policy for the component's styling.\n   * Defaults to `ViewEncapsulation.Emulated`.\n   */\n  encapsulation?: ViewEncapsulation;\n\n  /**\n   * Overrides the default interpolation start and end delimiters. Defaults to {{ and }}.\n   */\n  interpolation?: [string, string];\n\n  /**\n   * Whether whitespace in the template should be preserved. Defaults to false.\n   */\n  preserveWhitespaces?: boolean;\n}\n\nexport type R3DeclareTemplateDependencyMetadata = R3DeclareDirectiveDependencyMetadata|\n    R3DeclarePipeDependencyMetadata|R3DeclareNgModuleDependencyMetadata;\n\nexport interface R3DeclareDirectiveDependencyMetadata {\n  kind: 'directive'|'component';\n\n  /**\n   * Selector of the directive.\n   */\n  selector: string;\n\n  /**\n   * Reference to the directive class (possibly a forward reference wrapped in a `forwardRef`\n   * invocation).\n   */\n  type: o.Expression|(() => o.Expression);\n\n  /**\n   * Property names of the directive's inputs.\n   */\n  inputs?: string[];\n\n  /**\n   * Event names of the directive's outputs.\n   */\n  outputs?: string[];\n\n  /**\n   * Names by which this directive exports itself for references.\n   */\n  exportAs?: string[];\n}\n\nexport interface R3DeclarePipeDependencyMetadata {\n  kind: 'pipe';\n\n  name: string;\n\n  /**\n   * Reference to the pipe class (possibly a forward reference wrapped in a `forwardRef`\n   * invocation).\n   */\n  type: o.Expression|(() => o.Expression);\n}\n\nexport interface R3DeclareNgModuleDependencyMetadata {\n  kind: 'ngmodule';\n\n  type: o.Expression|(() => o.Expression);\n}\n\nexport interface R3DeclareQueryMetadata {\n  /**\n   * Name of the property on the class to update with query results.\n   */\n  propertyName: string;\n\n  /**\n   * Whether to read only the first matching result, or an array of results. Defaults to false.\n   */\n  first?: boolean;\n\n  /**\n   * Either an expression representing a type (possibly wrapped in a `forwardRef()`) or\n   * `InjectionToken` for the query predicate, or a set of string selectors.\n   */\n  predicate: o.Expression|string[];\n\n  /**\n   * Whether to include only direct children or all descendants. Defaults to false.\n   */\n  descendants?: boolean;\n\n  /**\n   * True to only fire changes if there are underlying changes to the query.\n   */\n  emitDistinctChangesOnly?: boolean;\n\n  /**\n   * An expression representing a type to read from each matched node, or null if the default value\n   * for a given node is to be returned.\n   */\n  read?: o.Expression;\n\n  /**\n   * Whether or not this query should collect only static results. Defaults to false.\n   *\n   * If static is true, the query's results will be set on the component after nodes are created,\n   * but before change detection runs. This means that any results that relied upon change detection\n   * to run (e.g. results inside *ngIf or *ngFor views) will not be collected. Query results are\n   * available in the ngOnInit hook.\n   *\n   * If static is false, the query's results will be set on the component after change detection\n   * runs. This means that the query results can contain nodes inside *ngIf or *ngFor views, but\n   * the results will not be available in the ngOnInit hook (only in the ngAfterContentInit for\n   * content hooks and ngAfterViewInit for view hooks).\n   */\n  static?: boolean;\n}\n\n/**\n * Describes the shape of the objects that the `\u0275\u0275ngDeclareNgModule()` accepts.\n */\nexport interface R3DeclareNgModuleMetadata extends R3PartialDeclaration {\n  /**\n   * An array of expressions representing the bootstrap components specified by the module.\n   */\n  bootstrap?: o.Expression[];\n\n  /**\n   * An array of expressions representing the directives and pipes declared by the module.\n   */\n  declarations?: o.Expression[];\n\n  /**\n   * An array of expressions representing the imports of the module.\n   */\n  imports?: o.Expression[];\n\n  /**\n   * An array of expressions representing the exports of the module.\n   */\n  exports?: o.Expression[];\n\n  /**\n   * The set of schemas that declare elements to be allowed in the NgModule.\n   */\n  schemas?: o.Expression[];\n\n  /** Unique ID or expression representing the unique ID of an NgModule. */\n  id?: o.Expression;\n}\n\n/**\n * Describes the shape of the objects that the `\u0275\u0275ngDeclareInjector()` accepts.\n */\nexport interface R3DeclareInjectorMetadata extends R3PartialDeclaration {\n  /**\n   * The list of providers provided by the injector.\n   */\n  providers?: o.Expression;\n  /**\n   * The list of imports into the injector.\n   */\n  imports?: o.Expression[];\n}\n\n/**\n * Describes the shape of the object that the `\u0275\u0275ngDeclarePipe()` function accepts.\n *\n * This interface serves primarily as documentation, as conformance to this interface is not\n * enforced during linking.\n */\nexport interface R3DeclarePipeMetadata extends R3PartialDeclaration {\n  /**\n   * The name to use in templates to refer to this pipe.\n   */\n  name: string;\n\n  /**\n   * Whether this pipe is \"pure\".\n   *\n   * A pure pipe's `transform()` method is only invoked when its input arguments change.\n   *\n   * Default: true.\n   */\n  pure?: boolean;\n\n  /**\n   * Whether the pipe is standalone.\n   *\n   * Default: false.\n   */\n  isStandalone?: boolean;\n}\n\n\n/**\n * Describes the shape of the object that the `\u0275\u0275ngDeclareFactory()` function accepts.\n *\n * This interface serves primarily as documentation, as conformance to this interface is not\n * enforced during linking.\n */\nexport interface R3DeclareFactoryMetadata extends R3PartialDeclaration {\n  /**\n   * A collection of dependencies that this factory relies upon.\n   *\n   * If this is `null`, then the type's constructor is nonexistent and will be inherited from an\n   * ancestor of the type.\n   *\n   * If this is `'invalid'`, then one or more of the parameters wasn't resolvable and any attempt to\n   * use these deps will result in a runtime error.\n   */\n  deps: R3DeclareDependencyMetadata[]|'invalid'|null;\n\n  /**\n   * Type of the target being created by the factory.\n   */\n  target: FactoryTarget;\n}\n\nexport enum FactoryTarget {\n  Directive = 0,\n  Component = 1,\n  Injectable = 2,\n  Pipe = 3,\n  NgModule = 4,\n}\n\n/**\n * Describes the shape of the object that the `\u0275\u0275ngDeclareInjectable()` function accepts.\n *\n * This interface serves primarily as documentation, as conformance to this interface is not\n * enforced during linking.\n */\nexport interface R3DeclareInjectableMetadata extends R3PartialDeclaration {\n  /**\n   * If provided, specifies that the declared injectable belongs to a particular injector:\n   * - `InjectorType` such as `NgModule`,\n   * - `'root'` the root injector\n   * - `'any'` all injectors.\n   * If not provided, then it does not belong to any injector. Must be explicitly listed in the\n   * providers of an injector.\n   */\n  providedIn?: o.Expression;\n\n  /**\n   * If provided, an expression that evaluates to a class to use when creating an instance of this\n   * injectable.\n   */\n  useClass?: o.Expression;\n\n  /**\n   * If provided, an expression that evaluates to a function to use when creating an instance of\n   * this injectable.\n   */\n  useFactory?: o.Expression;\n\n  /**\n   * If provided, an expression that evaluates to a token of another injectable that this injectable\n   * aliases.\n   */\n  useExisting?: o.Expression;\n\n  /**\n   * If provided, an expression that evaluates to the value of the instance of this injectable.\n   */\n  useValue?: o.Expression;\n\n  /**\n   * An array of dependencies to support instantiating this injectable via `useClass` or\n   * `useFactory`.\n   */\n  deps?: R3DeclareDependencyMetadata[];\n}\n\n/**\n * Metadata indicating how a dependency should be injected into a factory.\n */\nexport interface R3DeclareDependencyMetadata {\n  /**\n   * An expression representing the token or value to be injected, or `null` if the dependency is\n   * not valid.\n   *\n   * If this dependency is due to the `@Attribute()` decorator, then this is an expression\n   * evaluating to the name of the attribute.\n   */\n  token: o.Expression|null;\n\n  /**\n   * Whether the dependency is injecting an attribute value.\n   * Default: false.\n   */\n  attribute?: boolean;\n\n  /**\n   * Whether the dependency has an @Host qualifier.\n   * Default: false,\n   */\n  host?: boolean;\n\n  /**\n   * Whether the dependency has an @Optional qualifier.\n   * Default: false,\n   */\n  optional?: boolean;\n\n  /**\n   * Whether the dependency has an @Self qualifier.\n   * Default: false,\n   */\n  self?: boolean;\n\n  /**\n   * Whether the dependency has an @SkipSelf qualifier.\n   * Default: false,\n   */\n  skipSelf?: boolean;\n}\n\n/**\n * Describes the shape of the object that the `\u0275\u0275ngDeclareClassMetadata()` function accepts.\n *\n * This interface serves primarily as documentation, as conformance to this interface is not\n * enforced during linking.\n */\nexport interface R3DeclareClassMetadata extends R3PartialDeclaration {\n  /**\n   * The Angular decorators of the class.\n   */\n  decorators: o.Expression;\n\n  /**\n   * Optionally specifies the constructor parameters, their types and the Angular decorators of each\n   * parameter. This property is omitted if the class does not have a constructor.\n   */\n  ctorParameters?: o.Expression;\n\n  /**\n   * Optionally specifies the Angular decorators applied to the class properties. This property is\n   * omitted if no properties have any decorators.\n   */\n  propDecorators?: o.Expression;\n}\n\n/**\n * Describes the shape of the object literal that can be\n * passed in as a part of the `hostDirectives` array.\n */\nexport interface R3DeclareHostDirectiveMetadata {\n  directive: o.Expression;\n  inputs?: string[];\n  outputs?: string[];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, BindingPipe, ImplicitReceiver, PropertyRead, PropertyWrite, RecursiveAstVisitor, SafePropertyRead} from '../../expression_parser/ast';\nimport {SelectorMatcher} from '../../selector';\nimport {BoundAttribute, BoundEvent, BoundText, Content, Element, Icu, Node, Reference, Template, Text, TextAttribute, Variable, Visitor} from '../r3_ast';\n\nimport {BoundTarget, DirectiveMeta, Target, TargetBinder} from './t2_api';\nimport {createCssSelector} from './template';\nimport {getAttrsForDirectiveMatching} from './util';\n\n\n/**\n * Processes `Target`s with a given set of directives and performs a binding operation, which\n * returns an object similar to TypeScript's `ts.TypeChecker` that contains knowledge about the\n * target.\n */\nexport class R3TargetBinder<DirectiveT extends DirectiveMeta> implements TargetBinder<DirectiveT> {\n  constructor(private directiveMatcher: SelectorMatcher<DirectiveT[]>) {}\n\n  /**\n   * Perform a binding operation on the given `Target` and return a `BoundTarget` which contains\n   * metadata about the types referenced in the template.\n   */\n  bind(target: Target): BoundTarget<DirectiveT> {\n    if (!target.template) {\n      // TODO(alxhub): handle targets which contain things like HostBindings, etc.\n      throw new Error('Binding without a template not yet supported');\n    }\n\n    // First, parse the template into a `Scope` structure. This operation captures the syntactic\n    // scopes in the template and makes them available for later use.\n    const scope = Scope.apply(target.template);\n\n\n    // Use the `Scope` to extract the entities present at every level of the template.\n    const templateEntities = extractTemplateEntities(scope);\n\n    // Next, perform directive matching on the template using the `DirectiveBinder`. This returns:\n    //   - directives: Map of nodes (elements & ng-templates) to the directives on them.\n    //   - bindings: Map of inputs, outputs, and attributes to the directive/element that claims\n    //     them. TODO(alxhub): handle multiple directives claiming an input/output/etc.\n    //   - references: Map of #references to their targets.\n    const {directives, bindings, references} =\n        DirectiveBinder.apply(target.template, this.directiveMatcher);\n    // Finally, run the TemplateBinder to bind references, variables, and other entities within the\n    // template. This extracts all the metadata that doesn't depend on directive matching.\n    const {expressions, symbols, nestingLevel, usedPipes} =\n        TemplateBinder.applyWithScope(target.template, scope);\n    return new R3BoundTarget(\n        target, directives, bindings, references, expressions, symbols, nestingLevel,\n        templateEntities, usedPipes);\n  }\n}\n\n/**\n * Represents a binding scope within a template.\n *\n * Any variables, references, or other named entities declared within the template will\n * be captured and available by name in `namedEntities`. Additionally, child templates will\n * be analyzed and have their child `Scope`s available in `childScopes`.\n */\nclass Scope implements Visitor {\n  /**\n   * Named members of the `Scope`, such as `Reference`s or `Variable`s.\n   */\n  readonly namedEntities = new Map<string, Reference|Variable>();\n\n  /**\n   * Child `Scope`s for immediately nested `Template`s.\n   */\n  readonly childScopes = new Map<Template, Scope>();\n\n  private constructor(readonly parentScope: Scope|null, readonly template: Template|null) {}\n\n  static newRootScope(): Scope {\n    return new Scope(null, null);\n  }\n\n  /**\n   * Process a template (either as a `Template` sub-template with variables, or a plain array of\n   * template `Node`s) and construct its `Scope`.\n   */\n  static apply(template: Node[]): Scope {\n    const scope = Scope.newRootScope();\n    scope.ingest(template);\n    return scope;\n  }\n\n  /**\n   * Internal method to process the template and populate the `Scope`.\n   */\n  private ingest(template: Template|Node[]): void {\n    if (template instanceof Template) {\n      // Variables on an <ng-template> are defined in the inner scope.\n      template.variables.forEach(node => this.visitVariable(node));\n\n      // Process the nodes of the template.\n      template.children.forEach(node => node.visit(this));\n    } else {\n      // No overarching `Template` instance, so process the nodes directly.\n      template.forEach(node => node.visit(this));\n    }\n  }\n\n  visitElement(element: Element) {\n    // `Element`s in the template may have `Reference`s which are captured in the scope.\n    element.references.forEach(node => this.visitReference(node));\n\n    // Recurse into the `Element`'s children.\n    element.children.forEach(node => node.visit(this));\n  }\n\n  visitTemplate(template: Template) {\n    // References on a <ng-template> are defined in the outer scope, so capture them before\n    // processing the template's child scope.\n    template.references.forEach(node => this.visitReference(node));\n\n    // Next, create an inner scope and process the template within it.\n    const scope = new Scope(this, template);\n    scope.ingest(template);\n    this.childScopes.set(template, scope);\n  }\n\n  visitVariable(variable: Variable) {\n    // Declare the variable if it's not already.\n    this.maybeDeclare(variable);\n  }\n\n  visitReference(reference: Reference) {\n    // Declare the variable if it's not already.\n    this.maybeDeclare(reference);\n  }\n\n  // Unused visitors.\n  visitContent(content: Content) {}\n  visitBoundAttribute(attr: BoundAttribute) {}\n  visitBoundEvent(event: BoundEvent) {}\n  visitBoundText(text: BoundText) {}\n  visitText(text: Text) {}\n  visitTextAttribute(attr: TextAttribute) {}\n  visitIcu(icu: Icu) {}\n\n  private maybeDeclare(thing: Reference|Variable) {\n    // Declare something with a name, as long as that name isn't taken.\n    if (!this.namedEntities.has(thing.name)) {\n      this.namedEntities.set(thing.name, thing);\n    }\n  }\n\n  /**\n   * Look up a variable within this `Scope`.\n   *\n   * This can recurse into a parent `Scope` if it's available.\n   */\n  lookup(name: string): Reference|Variable|null {\n    if (this.namedEntities.has(name)) {\n      // Found in the local scope.\n      return this.namedEntities.get(name)!;\n    } else if (this.parentScope !== null) {\n      // Not in the local scope, but there's a parent scope so check there.\n      return this.parentScope.lookup(name);\n    } else {\n      // At the top level and it wasn't found.\n      return null;\n    }\n  }\n\n  /**\n   * Get the child scope for a `Template`.\n   *\n   * This should always be defined.\n   */\n  getChildScope(template: Template): Scope {\n    const res = this.childScopes.get(template);\n    if (res === undefined) {\n      throw new Error(`Assertion error: child scope for ${template} not found`);\n    }\n    return res;\n  }\n}\n\n/**\n * Processes a template and matches directives on nodes (elements and templates).\n *\n * Usually used via the static `apply()` method.\n */\nclass DirectiveBinder<DirectiveT extends DirectiveMeta> implements Visitor {\n  constructor(\n      private matcher: SelectorMatcher<DirectiveT[]>,\n      private directives: Map<Element|Template, DirectiveT[]>,\n      private bindings: Map<BoundAttribute|BoundEvent|TextAttribute, DirectiveT|Element|Template>,\n      private references:\n          Map<Reference, {directive: DirectiveT, node: Element|Template}|Element|Template>) {}\n\n  /**\n   * Process a template (list of `Node`s) and perform directive matching against each node.\n   *\n   * @param template the list of template `Node`s to match (recursively).\n   * @param selectorMatcher a `SelectorMatcher` containing the directives that are in scope for\n   * this template.\n   * @returns three maps which contain information about directives in the template: the\n   * `directives` map which lists directives matched on each node, the `bindings` map which\n   * indicates which directives claimed which bindings (inputs, outputs, etc), and the `references`\n   * map which resolves #references (`Reference`s) within the template to the named directive or\n   * template node.\n   */\n  static apply<DirectiveT extends DirectiveMeta>(\n      template: Node[], selectorMatcher: SelectorMatcher<DirectiveT[]>): {\n    directives: Map<Element|Template, DirectiveT[]>,\n    bindings: Map<BoundAttribute|BoundEvent|TextAttribute, DirectiveT|Element|Template>,\n    references: Map<Reference, {directive: DirectiveT, node: Element|Template}|Element|Template>,\n  } {\n    const directives = new Map<Element|Template, DirectiveT[]>();\n    const bindings =\n        new Map<BoundAttribute|BoundEvent|TextAttribute, DirectiveT|Element|Template>();\n    const references =\n        new Map<Reference, {directive: DirectiveT, node: Element | Template}|Element|Template>();\n    const matcher = new DirectiveBinder(selectorMatcher, directives, bindings, references);\n    matcher.ingest(template);\n    return {directives, bindings, references};\n  }\n\n  private ingest(template: Node[]): void {\n    template.forEach(node => node.visit(this));\n  }\n\n  visitElement(element: Element): void {\n    this.visitElementOrTemplate(element.name, element);\n  }\n\n  visitTemplate(template: Template): void {\n    this.visitElementOrTemplate('ng-template', template);\n  }\n\n  visitElementOrTemplate(elementName: string, node: Element|Template): void {\n    // First, determine the HTML shape of the node for the purpose of directive matching.\n    // Do this by building up a `CssSelector` for the node.\n    const cssSelector = createCssSelector(elementName, getAttrsForDirectiveMatching(node));\n\n    // Next, use the `SelectorMatcher` to get the list of directives on the node.\n    const directives: DirectiveT[] = [];\n    this.matcher.match(cssSelector, (_selector, results) => directives.push(...results));\n    if (directives.length > 0) {\n      this.directives.set(node, directives);\n    }\n\n    // Resolve any references that are created on this node.\n    node.references.forEach(ref => {\n      let dirTarget: DirectiveT|null = null;\n\n      // If the reference expression is empty, then it matches the \"primary\" directive on the node\n      // (if there is one). Otherwise it matches the host node itself (either an element or\n      // <ng-template> node).\n      if (ref.value.trim() === '') {\n        // This could be a reference to a component if there is one.\n        dirTarget = directives.find(dir => dir.isComponent) || null;\n      } else {\n        // This should be a reference to a directive exported via exportAs.\n        dirTarget =\n            directives.find(\n                dir => dir.exportAs !== null && dir.exportAs.some(value => value === ref.value)) ||\n            null;\n        // Check if a matching directive was found.\n        if (dirTarget === null) {\n          // No matching directive was found - this reference points to an unknown target. Leave it\n          // unmapped.\n          return;\n        }\n      }\n\n      if (dirTarget !== null) {\n        // This reference points to a directive.\n        this.references.set(ref, {directive: dirTarget, node});\n      } else {\n        // This reference points to the node itself.\n        this.references.set(ref, node);\n      }\n    });\n\n    // Associate attributes/bindings on the node with directives or with the node itself.\n    type BoundNode = BoundAttribute|BoundEvent|TextAttribute;\n    const setAttributeBinding =\n        (attribute: BoundNode, ioType: keyof Pick<DirectiveMeta, 'inputs'|'outputs'>) => {\n          const dir = directives.find(dir => dir[ioType].hasBindingPropertyName(attribute.name));\n          const binding = dir !== undefined ? dir : node;\n          this.bindings.set(attribute, binding);\n        };\n\n    // Node inputs (bound attributes) and text attributes can be bound to an\n    // input on a directive.\n    node.inputs.forEach(input => setAttributeBinding(input, 'inputs'));\n    node.attributes.forEach(attr => setAttributeBinding(attr, 'inputs'));\n    if (node instanceof Template) {\n      node.templateAttrs.forEach(attr => setAttributeBinding(attr, 'inputs'));\n    }\n    // Node outputs (bound events) can be bound to an output on a directive.\n    node.outputs.forEach(output => setAttributeBinding(output, 'outputs'));\n\n    // Recurse into the node's children.\n    node.children.forEach(child => child.visit(this));\n  }\n\n  // Unused visitors.\n  visitContent(content: Content): void {}\n  visitVariable(variable: Variable): void {}\n  visitReference(reference: Reference): void {}\n  visitTextAttribute(attribute: TextAttribute): void {}\n  visitBoundAttribute(attribute: BoundAttribute): void {}\n  visitBoundEvent(attribute: BoundEvent): void {}\n  visitBoundAttributeOrEvent(node: BoundAttribute|BoundEvent) {}\n  visitText(text: Text): void {}\n  visitBoundText(text: BoundText): void {}\n  visitIcu(icu: Icu): void {}\n}\n\n/**\n * Processes a template and extract metadata about expressions and symbols within.\n *\n * This is a companion to the `DirectiveBinder` that doesn't require knowledge of directives matched\n * within the template in order to operate.\n *\n * Expressions are visited by the superclass `RecursiveAstVisitor`, with custom logic provided\n * by overridden methods from that visitor.\n */\nclass TemplateBinder extends RecursiveAstVisitor implements Visitor {\n  private visitNode: (node: Node) => void;\n\n  private pipesUsed: string[] = [];\n\n  private constructor(\n      private bindings: Map<AST, Reference|Variable>,\n      private symbols: Map<Reference|Variable, Template>, private usedPipes: Set<string>,\n      private nestingLevel: Map<Template, number>, private scope: Scope,\n      private template: Template|null, private level: number) {\n    super();\n\n    // Save a bit of processing time by constructing this closure in advance.\n    this.visitNode = (node: Node) => node.visit(this);\n  }\n\n  // This method is defined to reconcile the type of TemplateBinder since both\n  // RecursiveAstVisitor and Visitor define the visit() method in their\n  // interfaces.\n  override visit(node: AST|Node, context?: any) {\n    if (node instanceof AST) {\n      node.visit(this, context);\n    } else {\n      node.visit(this);\n    }\n  }\n\n  /**\n   * Process a template and extract metadata about expressions and symbols within.\n   *\n   * @param template the nodes of the template to process\n   * @param scope the `Scope` of the template being processed.\n   * @returns three maps which contain metadata about the template: `expressions` which interprets\n   * special `AST` nodes in expressions as pointing to references or variables declared within the\n   * template, `symbols` which maps those variables and references to the nested `Template` which\n   * declares them, if any, and `nestingLevel` which associates each `Template` with a integer\n   * nesting level (how many levels deep within the template structure the `Template` is), starting\n   * at 1.\n   */\n  static applyWithScope(template: Node[], scope: Scope): {\n    expressions: Map<AST, Reference|Variable>,\n    symbols: Map<Variable|Reference, Template>,\n    nestingLevel: Map<Template, number>,\n    usedPipes: Set<string>,\n  } {\n    const expressions = new Map<AST, Reference|Variable>();\n    const symbols = new Map<Variable|Reference, Template>();\n    const nestingLevel = new Map<Template, number>();\n    const usedPipes = new Set<string>();\n    // The top-level template has nesting level 0.\n    const binder = new TemplateBinder(\n        expressions, symbols, usedPipes, nestingLevel, scope,\n        template instanceof Template ? template : null, 0);\n    binder.ingest(template);\n    return {expressions, symbols, nestingLevel, usedPipes};\n  }\n\n  private ingest(template: Template|Node[]): void {\n    if (template instanceof Template) {\n      // For <ng-template>s, process only variables and child nodes. Inputs, outputs, templateAttrs,\n      // and references were all processed in the scope of the containing template.\n      template.variables.forEach(this.visitNode);\n      template.children.forEach(this.visitNode);\n\n      // Set the nesting level.\n      this.nestingLevel.set(template, this.level);\n    } else {\n      // Visit each node from the top-level template.\n      template.forEach(this.visitNode);\n    }\n  }\n\n  visitElement(element: Element) {\n    // Visit the inputs, outputs, and children of the element.\n    element.inputs.forEach(this.visitNode);\n    element.outputs.forEach(this.visitNode);\n    element.children.forEach(this.visitNode);\n  }\n\n  visitTemplate(template: Template) {\n    // First, visit inputs, outputs and template attributes of the template node.\n    template.inputs.forEach(this.visitNode);\n    template.outputs.forEach(this.visitNode);\n    template.templateAttrs.forEach(this.visitNode);\n\n    // References are also evaluated in the outer context.\n    template.references.forEach(this.visitNode);\n\n    // Next, recurse into the template using its scope, and bumping the nesting level up by one.\n    const childScope = this.scope.getChildScope(template);\n    const binder = new TemplateBinder(\n        this.bindings, this.symbols, this.usedPipes, this.nestingLevel, childScope, template,\n        this.level + 1);\n    binder.ingest(template);\n  }\n\n  visitVariable(variable: Variable) {\n    // Register the `Variable` as a symbol in the current `Template`.\n    if (this.template !== null) {\n      this.symbols.set(variable, this.template);\n    }\n  }\n\n  visitReference(reference: Reference) {\n    // Register the `Reference` as a symbol in the current `Template`.\n    if (this.template !== null) {\n      this.symbols.set(reference, this.template);\n    }\n  }\n\n  // Unused template visitors\n\n  visitText(text: Text) {}\n  visitContent(content: Content) {}\n  visitTextAttribute(attribute: TextAttribute) {}\n  visitIcu(icu: Icu): void {\n    Object.keys(icu.vars).forEach(key => icu.vars[key].visit(this));\n    Object.keys(icu.placeholders).forEach(key => icu.placeholders[key].visit(this));\n  }\n\n  // The remaining visitors are concerned with processing AST expressions within template bindings\n\n  visitBoundAttribute(attribute: BoundAttribute) {\n    attribute.value.visit(this);\n  }\n\n  visitBoundEvent(event: BoundEvent) {\n    event.handler.visit(this);\n  }\n\n  visitBoundText(text: BoundText) {\n    text.value.visit(this);\n  }\n  override visitPipe(ast: BindingPipe, context: any): any {\n    this.usedPipes.add(ast.name);\n    return super.visitPipe(ast, context);\n  }\n\n  // These five types of AST expressions can refer to expression roots, which could be variables\n  // or references in the current scope.\n\n  override visitPropertyRead(ast: PropertyRead, context: any): any {\n    this.maybeMap(context, ast, ast.name);\n    return super.visitPropertyRead(ast, context);\n  }\n\n  override visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n    this.maybeMap(context, ast, ast.name);\n    return super.visitSafePropertyRead(ast, context);\n  }\n\n  override visitPropertyWrite(ast: PropertyWrite, context: any): any {\n    this.maybeMap(context, ast, ast.name);\n    return super.visitPropertyWrite(ast, context);\n  }\n\n  private maybeMap(scope: Scope, ast: PropertyRead|SafePropertyRead|PropertyWrite, name: string):\n      void {\n    // If the receiver of the expression isn't the `ImplicitReceiver`, this isn't the root of an\n    // `AST` expression that maps to a `Variable` or `Reference`.\n    if (!(ast.receiver instanceof ImplicitReceiver)) {\n      return;\n    }\n\n    // Check whether the name exists in the current scope. If so, map it. Otherwise, the name is\n    // probably a property on the top-level component context.\n    let target = this.scope.lookup(name);\n    if (target !== null) {\n      this.bindings.set(ast, target);\n    }\n  }\n}\n\n/**\n * Metadata container for a `Target` that allows queries for specific bits of metadata.\n *\n * See `BoundTarget` for documentation on the individual methods.\n */\nexport class R3BoundTarget<DirectiveT extends DirectiveMeta> implements BoundTarget<DirectiveT> {\n  constructor(\n      readonly target: Target, private directives: Map<Element|Template, DirectiveT[]>,\n      private bindings: Map<BoundAttribute|BoundEvent|TextAttribute, DirectiveT|Element|Template>,\n      private references:\n          Map<BoundAttribute|BoundEvent|Reference|TextAttribute,\n              {directive: DirectiveT, node: Element|Template}|Element|Template>,\n      private exprTargets: Map<AST, Reference|Variable>,\n      private symbols: Map<Reference|Variable, Template>,\n      private nestingLevel: Map<Template, number>,\n      private templateEntities: Map<Template|null, ReadonlySet<Reference|Variable>>,\n      private usedPipes: Set<string>) {}\n\n  getEntitiesInTemplateScope(template: Template|null): ReadonlySet<Reference|Variable> {\n    return this.templateEntities.get(template) ?? new Set();\n  }\n\n  getDirectivesOfNode(node: Element|Template): DirectiveT[]|null {\n    return this.directives.get(node) || null;\n  }\n\n  getReferenceTarget(ref: Reference): {directive: DirectiveT, node: Element|Template}|Element\n      |Template|null {\n    return this.references.get(ref) || null;\n  }\n\n  getConsumerOfBinding(binding: BoundAttribute|BoundEvent|TextAttribute): DirectiveT|Element\n      |Template|null {\n    return this.bindings.get(binding) || null;\n  }\n\n  getExpressionTarget(expr: AST): Reference|Variable|null {\n    return this.exprTargets.get(expr) || null;\n  }\n\n  getTemplateOfSymbol(symbol: Reference|Variable): Template|null {\n    return this.symbols.get(symbol) || null;\n  }\n\n  getNestingLevel(template: Template): number {\n    return this.nestingLevel.get(template) || 0;\n  }\n\n  getUsedDirectives(): DirectiveT[] {\n    const set = new Set<DirectiveT>();\n    this.directives.forEach(dirs => dirs.forEach(dir => set.add(dir)));\n    return Array.from(set.values());\n  }\n\n  getUsedPipes(): string[] {\n    return Array.from(this.usedPipes);\n  }\n}\n\nfunction extractTemplateEntities(rootScope: Scope): Map<Template|null, Set<Reference|Variable>> {\n  const entityMap = new Map<Template|null, Map<string, Reference|Variable>>();\n\n  function extractScopeEntities(scope: Scope): Map<string, Reference|Variable> {\n    if (entityMap.has(scope.template)) {\n      return entityMap.get(scope.template)!;\n    }\n\n    const currentEntities = scope.namedEntities;\n\n    let templateEntities: Map<string, Reference|Variable>;\n    if (scope.parentScope !== null) {\n      templateEntities = new Map([...extractScopeEntities(scope.parentScope), ...currentEntities]);\n    } else {\n      templateEntities = new Map(currentEntities);\n    }\n\n    entityMap.set(scope.template, templateEntities);\n    return templateEntities;\n  }\n\n  const scopesToProcess: Scope[] = [rootScope];\n  while (scopesToProcess.length > 0) {\n    const scope = scopesToProcess.pop()!;\n    for (const childScope of scope.childScopes.values()) {\n      scopesToProcess.push(childScope);\n    }\n    extractScopeEntities(scope);\n  }\n\n  const templateEntities = new Map<Template|null, Set<Reference|Variable>>();\n  for (const [template, entities] of entityMap) {\n    templateEntities.set(template, new Set(entities.values()));\n  }\n  return templateEntities;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../output/output_ast';\n\nimport {Identifiers as R3} from './r3_identifiers';\nimport {devOnlyGuardedExpression} from './util';\n\nexport type CompileClassMetadataFn = (metadata: R3ClassMetadata) => o.Expression;\n\n/**\n * Metadata of a class which captures the original Angular decorators of a class. The original\n * decorators are preserved in the generated code to allow TestBed APIs to recompile the class\n * using the original decorator with a set of overrides applied.\n */\nexport interface R3ClassMetadata {\n  /**\n   * The class type for which the metadata is captured.\n   */\n  type: o.Expression;\n\n  /**\n   * An expression representing the Angular decorators that were applied on the class.\n   */\n  decorators: o.Expression;\n\n  /**\n   * An expression representing the Angular decorators applied to constructor parameters, or `null`\n   * if there is no constructor.\n   */\n  ctorParameters: o.Expression|null;\n\n  /**\n   * An expression representing the Angular decorators that were applied on the properties of the\n   * class, or `null` if no properties have decorators.\n   */\n  propDecorators: o.Expression|null;\n}\n\nexport function compileClassMetadata(metadata: R3ClassMetadata): o.Expression {\n  // Generate an ngDevMode guarded call to setClassMetadata with the class identifier and its\n  // metadata.\n  const fnCall = o.importExpr(R3.setClassMetadata).callFn([\n    metadata.type,\n    metadata.decorators,\n    metadata.ctorParameters ?? o.literal(null),\n    metadata.propDecorators ?? o.literal(null),\n  ]);\n  const iife = o.fn([], [devOnlyGuardedExpression(fnCall).toStmt()]);\n  return iife.callFn([]);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {R3ClassMetadata} from '../r3_class_metadata_compiler';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareClassMetadata} from './api';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';\n\nexport function compileDeclareClassMetadata(metadata: R3ClassMetadata): o.Expression {\n  const definitionMap = new DefinitionMap<R3DeclareClassMetadata>();\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('15.0.0'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n  definitionMap.set('type', metadata.type);\n  definitionMap.set('decorators', metadata.decorators);\n  definitionMap.set('ctorParameters', metadata.ctorParameters);\n  definitionMap.set('propDecorators', metadata.propDecorators);\n\n  return o.importExpr(R3.declareClassMetadata).callFn([definitionMap.toLiteralMap()]);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {R3DependencyMetadata} from '../r3_factory';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareDependencyMetadata} from './api';\n\n/**\n * Creates an array literal expression from the given array, mapping all values to an expression\n * using the provided mapping function. If the array is empty or null, then null is returned.\n *\n * @param values The array to transfer into literal array expression.\n * @param mapper The logic to use for creating an expression for the array's values.\n * @returns An array literal expression representing `values`, or null if `values` is empty or\n * is itself null.\n */\nexport function toOptionalLiteralArray<T>(\n    values: T[]|null, mapper: (value: T) => o.Expression): o.LiteralArrayExpr|null {\n  if (values === null || values.length === 0) {\n    return null;\n  }\n  return o.literalArr(values.map(value => mapper(value)));\n}\n\n/**\n * Creates an object literal expression from the given object, mapping all values to an expression\n * using the provided mapping function. If the object has no keys, then null is returned.\n *\n * @param object The object to transfer into an object literal expression.\n * @param mapper The logic to use for creating an expression for the object's values.\n * @returns An object literal expression representing `object`, or null if `object` does not have\n * any keys.\n */\nexport function toOptionalLiteralMap<T>(\n    object: {[key: string]: T}, mapper: (value: T) => o.Expression): o.LiteralMapExpr|null {\n  const entries = Object.keys(object).map(key => {\n    const value = object[key];\n    return {key, value: mapper(value), quoted: true};\n  });\n\n  if (entries.length > 0) {\n    return o.literalMap(entries);\n  } else {\n    return null;\n  }\n}\n\nexport function compileDependencies(deps: R3DependencyMetadata[]|'invalid'|null): o.LiteralExpr|\n    o.LiteralArrayExpr {\n  if (deps === 'invalid') {\n    // The `deps` can be set to the string \"invalid\"  by the `unwrapConstructorDependencies()`\n    // function, which tries to convert `ConstructorDeps` into `R3DependencyMetadata[]`.\n    return o.literal('invalid');\n  } else if (deps === null) {\n    return o.literal(null);\n  } else {\n    return o.literalArr(deps.map(compileDependency));\n  }\n}\n\nexport function compileDependency(dep: R3DependencyMetadata): o.LiteralMapExpr {\n  const depMeta = new DefinitionMap<R3DeclareDependencyMetadata>();\n  depMeta.set('token', dep.token);\n  if (dep.attributeNameType !== null) {\n    depMeta.set('attribute', o.literal(true));\n  }\n  if (dep.host) {\n    depMeta.set('host', o.literal(true));\n  }\n  if (dep.optional) {\n    depMeta.set('optional', o.literal(true));\n  }\n  if (dep.self) {\n    depMeta.set('self', o.literal(true));\n  }\n  if (dep.skipSelf) {\n    depMeta.set('skipSelf', o.literal(true));\n  }\n  return depMeta.toLiteralMap();\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {convertFromMaybeForwardRefExpression, generateForwardRef, R3CompiledExpression} from '../util';\nimport {R3DirectiveMetadata, R3HostMetadata, R3QueryMetadata} from '../view/api';\nimport {createDirectiveType, createHostDirectivesMappingArray} from '../view/compiler';\nimport {asLiteral, conditionallyCreateMapObjectLiteral, DefinitionMap} from '../view/util';\n\nimport {R3DeclareDirectiveMetadata, R3DeclareQueryMetadata} from './api';\nimport {toOptionalLiteralMap} from './util';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '14.0.0';\n\n/**\n * Compile a directive declaration defined by the `R3DirectiveMetadata`.\n */\nexport function compileDeclareDirectiveFromMetadata(meta: R3DirectiveMetadata):\n    R3CompiledExpression {\n  const definitionMap = createDirectiveDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declareDirective).callFn([definitionMap.toLiteralMap()]);\n  const type = createDirectiveType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for a directive into a `DefinitionMap`. This allows for reusing\n * this logic for components, as they extend the directive metadata.\n */\nexport function createDirectiveDefinitionMap(meta: R3DirectiveMetadata):\n    DefinitionMap<R3DeclareDirectiveMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclareDirectiveMetadata>();\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('15.0.0'));\n\n  // e.g. `type: MyDirective`\n  definitionMap.set('type', meta.internalType);\n\n  if (meta.isStandalone) {\n    definitionMap.set('isStandalone', o.literal(meta.isStandalone));\n  }\n\n  // e.g. `selector: 'some-dir'`\n  if (meta.selector !== null) {\n    definitionMap.set('selector', o.literal(meta.selector));\n  }\n\n  definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));\n  definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));\n\n  definitionMap.set('host', compileHostMetadata(meta.host));\n\n  definitionMap.set('providers', meta.providers);\n\n  if (meta.queries.length > 0) {\n    definitionMap.set('queries', o.literalArr(meta.queries.map(compileQuery)));\n  }\n\n  if (meta.viewQueries.length > 0) {\n    definitionMap.set('viewQueries', o.literalArr(meta.viewQueries.map(compileQuery)));\n  }\n\n  if (meta.exportAs !== null) {\n    definitionMap.set('exportAs', asLiteral(meta.exportAs));\n  }\n\n  if (meta.usesInheritance) {\n    definitionMap.set('usesInheritance', o.literal(true));\n  }\n\n  if (meta.lifecycle.usesOnChanges) {\n    definitionMap.set('usesOnChanges', o.literal(true));\n  }\n\n  if (meta.hostDirectives?.length) {\n    definitionMap.set('hostDirectives', createHostDirectives(meta.hostDirectives));\n  }\n\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n\n  return definitionMap;\n}\n\n/**\n * Compiles the metadata of a single query into its partial declaration form as declared\n * by `R3DeclareQueryMetadata`.\n */\nfunction compileQuery(query: R3QueryMetadata): o.LiteralMapExpr {\n  const meta = new DefinitionMap<R3DeclareQueryMetadata>();\n  meta.set('propertyName', o.literal(query.propertyName));\n  if (query.first) {\n    meta.set('first', o.literal(true));\n  }\n  meta.set(\n      'predicate',\n      Array.isArray(query.predicate) ? asLiteral(query.predicate) :\n                                       convertFromMaybeForwardRefExpression(query.predicate));\n  if (!query.emitDistinctChangesOnly) {\n    // `emitDistinctChangesOnly` is special because we expect it to be `true`.\n    // Therefore we explicitly emit the field, and explicitly place it only when it's `false`.\n    meta.set('emitDistinctChangesOnly', o.literal(false));\n  } else {\n    // The linker will assume that an absent `emitDistinctChangesOnly` flag is by default `true`.\n  }\n  if (query.descendants) {\n    meta.set('descendants', o.literal(true));\n  }\n  meta.set('read', query.read);\n  if (query.static) {\n    meta.set('static', o.literal(true));\n  }\n  return meta.toLiteralMap();\n}\n\n/**\n * Compiles the host metadata into its partial declaration form as declared\n * in `R3DeclareDirectiveMetadata['host']`\n */\nfunction compileHostMetadata(meta: R3HostMetadata): o.LiteralMapExpr|null {\n  const hostMetadata = new DefinitionMap<NonNullable<R3DeclareDirectiveMetadata['host']>>();\n  hostMetadata.set('attributes', toOptionalLiteralMap(meta.attributes, expression => expression));\n  hostMetadata.set('listeners', toOptionalLiteralMap(meta.listeners, o.literal));\n  hostMetadata.set('properties', toOptionalLiteralMap(meta.properties, o.literal));\n\n  if (meta.specialAttributes.styleAttr) {\n    hostMetadata.set('styleAttribute', o.literal(meta.specialAttributes.styleAttr));\n  }\n  if (meta.specialAttributes.classAttr) {\n    hostMetadata.set('classAttribute', o.literal(meta.specialAttributes.classAttr));\n  }\n\n  if (hostMetadata.values.length > 0) {\n    return hostMetadata.toLiteralMap();\n  } else {\n    return null;\n  }\n}\n\nfunction createHostDirectives(hostDirectives: NonNullable<R3DirectiveMetadata['hostDirectives']>):\n    o.LiteralArrayExpr {\n  const expressions = hostDirectives.map(current => {\n    const keys = [{\n      key: 'directive',\n      value: current.isForwardReference ? generateForwardRef(current.directive.type) :\n                                          current.directive.type,\n      quoted: false\n    }];\n    const inputsLiteral = current.inputs ? createHostDirectivesMappingArray(current.inputs) : null;\n    const outputsLiteral =\n        current.outputs ? createHostDirectivesMappingArray(current.outputs) : null;\n\n    if (inputsLiteral) {\n      keys.push({key: 'inputs', value: inputsLiteral, quoted: false});\n    }\n\n    if (outputsLiteral) {\n      keys.push({key: 'outputs', value: outputsLiteral, quoted: false});\n    }\n\n    return o.literalMap(keys);\n  });\n\n  // If there's a forward reference, we generate a `function() { return [{directive: HostDir}] }`,\n  // otherwise we can save some bytes by using a plain array, e.g. `[{directive: HostDir}]`.\n  return o.literalArr(expressions);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as core from '../../core';\nimport {DEFAULT_INTERPOLATION_CONFIG} from '../../ml_parser/interpolation_config';\nimport * as o from '../../output/output_ast';\nimport {ParseLocation, ParseSourceFile, ParseSourceSpan} from '../../parse_util';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {generateForwardRef, R3CompiledExpression} from '../util';\nimport {DeclarationListEmitMode, R3ComponentMetadata, R3TemplateDependencyKind, R3TemplateDependencyMetadata} from '../view/api';\nimport {createComponentType} from '../view/compiler';\nimport {ParsedTemplate} from '../view/template';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareComponentMetadata, R3DeclareDirectiveDependencyMetadata, R3DeclareNgModuleDependencyMetadata, R3DeclarePipeDependencyMetadata} from './api';\nimport {createDirectiveDefinitionMap} from './directive';\nimport {toOptionalLiteralArray} from './util';\n\nexport interface DeclareComponentTemplateInfo {\n  /**\n   * The string contents of the template.\n   *\n   * This is the \"logical\" template string, after expansion of any escaped characters (for inline\n   * templates). This may differ from the actual template bytes as they appear in the .ts file.\n   */\n  content: string;\n\n  /**\n   * A full path to the file which contains the template.\n   *\n   * This can be either the original .ts file if the template is inline, or the .html file if an\n   * external file was used.\n   */\n  sourceUrl: string;\n\n  /**\n   * Whether the template was inline (using `template`) or external (using `templateUrl`).\n   */\n  isInline: boolean;\n\n  /**\n   * If the template was defined inline by a direct string literal, then this is that literal\n   * expression. Otherwise `null`, if the template was not defined inline or was not a literal.\n   */\n  inlineTemplateLiteralExpression: o.Expression|null;\n}\n\n/**\n * Compile a component declaration defined by the `R3ComponentMetadata`.\n */\nexport function compileDeclareComponentFromMetadata(\n    meta: R3ComponentMetadata<R3TemplateDependencyMetadata>, template: ParsedTemplate,\n    additionalTemplateInfo: DeclareComponentTemplateInfo): R3CompiledExpression {\n  const definitionMap = createComponentDefinitionMap(meta, template, additionalTemplateInfo);\n\n  const expression = o.importExpr(R3.declareComponent).callFn([definitionMap.toLiteralMap()]);\n  const type = createComponentType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for a component into a `DefinitionMap`.\n */\nexport function createComponentDefinitionMap(\n    meta: R3ComponentMetadata<R3TemplateDependencyMetadata>, template: ParsedTemplate,\n    templateInfo: DeclareComponentTemplateInfo): DefinitionMap<R3DeclareComponentMetadata> {\n  const definitionMap: DefinitionMap<R3DeclareComponentMetadata> =\n      createDirectiveDefinitionMap(meta);\n\n  definitionMap.set('template', getTemplateExpression(template, templateInfo));\n  if (templateInfo.isInline) {\n    definitionMap.set('isInline', o.literal(true));\n  }\n\n  definitionMap.set('styles', toOptionalLiteralArray(meta.styles, o.literal));\n  definitionMap.set('dependencies', compileUsedDependenciesMetadata(meta));\n  definitionMap.set('viewProviders', meta.viewProviders);\n  definitionMap.set('animations', meta.animations);\n\n  if (meta.changeDetection !== undefined) {\n    definitionMap.set(\n        'changeDetection',\n        o.importExpr(R3.ChangeDetectionStrategy)\n            .prop(core.ChangeDetectionStrategy[meta.changeDetection]));\n  }\n  if (meta.encapsulation !== core.ViewEncapsulation.Emulated) {\n    definitionMap.set(\n        'encapsulation',\n        o.importExpr(R3.ViewEncapsulation).prop(core.ViewEncapsulation[meta.encapsulation]));\n  }\n  if (meta.interpolation !== DEFAULT_INTERPOLATION_CONFIG) {\n    definitionMap.set(\n        'interpolation',\n        o.literalArr([o.literal(meta.interpolation.start), o.literal(meta.interpolation.end)]));\n  }\n\n  if (template.preserveWhitespaces === true) {\n    definitionMap.set('preserveWhitespaces', o.literal(true));\n  }\n\n  return definitionMap;\n}\n\nfunction getTemplateExpression(\n    template: ParsedTemplate, templateInfo: DeclareComponentTemplateInfo): o.Expression {\n  // If the template has been defined using a direct literal, we use that expression directly\n  // without any modifications. This is ensures proper source mapping from the partially\n  // compiled code to the source file declaring the template. Note that this does not capture\n  // template literals referenced indirectly through an identifier.\n  if (templateInfo.inlineTemplateLiteralExpression !== null) {\n    return templateInfo.inlineTemplateLiteralExpression;\n  }\n\n  // If the template is defined inline but not through a literal, the template has been resolved\n  // through static interpretation. We create a literal but cannot provide any source span. Note\n  // that we cannot use the expression defining the template because the linker expects the template\n  // to be defined as a literal in the declaration.\n  if (templateInfo.isInline) {\n    return o.literal(templateInfo.content, null, null);\n  }\n\n  // The template is external so we must synthesize an expression node with\n  // the appropriate source-span.\n  const contents = templateInfo.content;\n  const file = new ParseSourceFile(contents, templateInfo.sourceUrl);\n  const start = new ParseLocation(file, 0, 0, 0);\n  const end = computeEndLocation(file, contents);\n  const span = new ParseSourceSpan(start, end);\n  return o.literal(contents, null, span);\n}\n\nfunction computeEndLocation(file: ParseSourceFile, contents: string): ParseLocation {\n  const length = contents.length;\n  let lineStart = 0;\n  let lastLineStart = 0;\n  let line = 0;\n  do {\n    lineStart = contents.indexOf('\\n', lastLineStart);\n    if (lineStart !== -1) {\n      lastLineStart = lineStart + 1;\n      line++;\n    }\n  } while (lineStart !== -1);\n\n  return new ParseLocation(file, length, line, length - lastLineStart);\n}\n\nfunction compileUsedDependenciesMetadata(meta: R3ComponentMetadata<R3TemplateDependencyMetadata>):\n    o.LiteralArrayExpr|null {\n  const wrapType = meta.declarationListEmitMode !== DeclarationListEmitMode.Direct ?\n      generateForwardRef :\n      (expr: o.Expression) => expr;\n\n  return toOptionalLiteralArray(meta.declarations, decl => {\n    switch (decl.kind) {\n      case R3TemplateDependencyKind.Directive:\n        const dirMeta = new DefinitionMap<R3DeclareDirectiveDependencyMetadata>();\n        dirMeta.set('kind', o.literal(decl.isComponent ? 'component' : 'directive'));\n        dirMeta.set('type', wrapType(decl.type));\n        dirMeta.set('selector', o.literal(decl.selector));\n        dirMeta.set('inputs', toOptionalLiteralArray(decl.inputs, o.literal));\n        dirMeta.set('outputs', toOptionalLiteralArray(decl.outputs, o.literal));\n        dirMeta.set('exportAs', toOptionalLiteralArray(decl.exportAs, o.literal));\n        return dirMeta.toLiteralMap();\n      case R3TemplateDependencyKind.Pipe:\n        const pipeMeta = new DefinitionMap<R3DeclarePipeDependencyMetadata>();\n        pipeMeta.set('kind', o.literal('pipe'));\n        pipeMeta.set('type', wrapType(decl.type));\n        pipeMeta.set('name', o.literal(decl.name));\n        return pipeMeta.toLiteralMap();\n      case R3TemplateDependencyKind.NgModule:\n        const ngModuleMeta = new DefinitionMap<R3DeclareNgModuleDependencyMetadata>();\n        ngModuleMeta.set('kind', o.literal('ngmodule'));\n        ngModuleMeta.set('type', wrapType(decl.type));\n        return ngModuleMeta.toLiteralMap();\n    }\n  });\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {createFactoryType, FactoryTarget, R3FactoryMetadata} from '../r3_factory';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {R3CompiledExpression} from '../util';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareFactoryMetadata} from './api';\nimport {compileDependencies} from './util';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';\n\nexport function compileDeclareFactoryFunction(meta: R3FactoryMetadata): R3CompiledExpression {\n  const definitionMap = new DefinitionMap<R3DeclareFactoryMetadata>();\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('15.0.0'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n  definitionMap.set('type', meta.internalType);\n  definitionMap.set('deps', compileDependencies(meta.deps));\n  definitionMap.set('target', o.importExpr(R3.FactoryTarget).prop(FactoryTarget[meta.target]));\n\n  return {\n    expression: o.importExpr(R3.declareFactory).callFn([definitionMap.toLiteralMap()]),\n    statements: [],\n    type: createFactoryType(meta),\n  };\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {createInjectableType, R3InjectableMetadata} from '../../injectable_compiler_2';\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {convertFromMaybeForwardRefExpression, R3CompiledExpression} from '../util';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareInjectableMetadata} from './api';\nimport {compileDependency} from './util';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';\n\n/**\n * Compile a Injectable declaration defined by the `R3InjectableMetadata`.\n */\nexport function compileDeclareInjectableFromMetadata(meta: R3InjectableMetadata):\n    R3CompiledExpression {\n  const definitionMap = createInjectableDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declareInjectable).callFn([definitionMap.toLiteralMap()]);\n  const type = createInjectableType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for a Injectable into a `DefinitionMap`.\n */\nexport function createInjectableDefinitionMap(meta: R3InjectableMetadata):\n    DefinitionMap<R3DeclareInjectableMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclareInjectableMetadata>();\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('15.0.0'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n  definitionMap.set('type', meta.internalType);\n\n  // Only generate providedIn property if it has a non-null value\n  if (meta.providedIn !== undefined) {\n    const providedIn = convertFromMaybeForwardRefExpression(meta.providedIn);\n    if ((providedIn as o.LiteralExpr).value !== null) {\n      definitionMap.set('providedIn', providedIn);\n    }\n  }\n\n  if (meta.useClass !== undefined) {\n    definitionMap.set('useClass', convertFromMaybeForwardRefExpression(meta.useClass));\n  }\n  if (meta.useExisting !== undefined) {\n    definitionMap.set('useExisting', convertFromMaybeForwardRefExpression(meta.useExisting));\n  }\n  if (meta.useValue !== undefined) {\n    definitionMap.set('useValue', convertFromMaybeForwardRefExpression(meta.useValue));\n  }\n  // Factories do not contain `ForwardRef`s since any types are already wrapped in a function call\n  // so the types will not be eagerly evaluated. Therefore we do not need to process this expression\n  // with `convertFromProviderExpression()`.\n  if (meta.useFactory !== undefined) {\n    definitionMap.set('useFactory', meta.useFactory);\n  }\n\n  if (meta.deps !== undefined) {\n    definitionMap.set('deps', o.literalArr(meta.deps.map(compileDependency)));\n  }\n\n  return definitionMap;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {createInjectorType, R3InjectorMetadata} from '../r3_injector_compiler';\nimport {R3CompiledExpression} from '../util';\nimport {DefinitionMap} from '../view/util';\nimport {R3DeclareInjectorMetadata} from './api';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';\n\nexport function compileDeclareInjectorFromMetadata(meta: R3InjectorMetadata): R3CompiledExpression {\n  const definitionMap = createInjectorDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declareInjector).callFn([definitionMap.toLiteralMap()]);\n  const type = createInjectorType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for an Injector into a `DefinitionMap`.\n */\nfunction createInjectorDefinitionMap(meta: R3InjectorMetadata):\n    DefinitionMap<R3DeclareInjectorMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclareInjectorMetadata>();\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('15.0.0'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n\n  definitionMap.set('type', meta.internalType);\n  definitionMap.set('providers', meta.providers);\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', o.literalArr(meta.imports));\n  }\n\n  return definitionMap;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {createNgModuleType, R3NgModuleMetadata} from '../r3_module_compiler';\nimport {R3CompiledExpression, refsToArray} from '../util';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareNgModuleMetadata} from './api';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '14.0.0';\n\nexport function compileDeclareNgModuleFromMetadata(meta: R3NgModuleMetadata): R3CompiledExpression {\n  const definitionMap = createNgModuleDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declareNgModule).callFn([definitionMap.toLiteralMap()]);\n  const type = createNgModuleType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for an NgModule into a `DefinitionMap`.\n */\nfunction createNgModuleDefinitionMap(meta: R3NgModuleMetadata):\n    DefinitionMap<R3DeclareNgModuleMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclareNgModuleMetadata>();\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('15.0.0'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n  definitionMap.set('type', meta.internalType);\n\n  // We only generate the keys in the metadata if the arrays contain values.\n\n  // We must wrap the arrays inside a function if any of the values are a forward reference to a\n  // not-yet-declared class. This is to support JIT execution of the `\u0275\u0275ngDeclareNgModule()` call.\n  // In the linker these wrappers are stripped and then reapplied for the `\u0275\u0275defineNgModule()` call.\n\n  if (meta.bootstrap.length > 0) {\n    definitionMap.set('bootstrap', refsToArray(meta.bootstrap, meta.containsForwardDecls));\n  }\n\n  if (meta.declarations.length > 0) {\n    definitionMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n  }\n\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n  }\n\n  if (meta.exports.length > 0) {\n    definitionMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n  }\n\n  if (meta.schemas !== null && meta.schemas.length > 0) {\n    definitionMap.set('schemas', o.literalArr(meta.schemas.map(ref => ref.value)));\n  }\n\n  if (meta.id !== null) {\n    definitionMap.set('id', meta.id);\n  }\n\n  return definitionMap;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {createPipeType, R3PipeMetadata} from '../r3_pipe_compiler';\nimport {R3CompiledExpression} from '../util';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclarePipeMetadata} from './api';\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '14.0.0';\n\n/**\n * Compile a Pipe declaration defined by the `R3PipeMetadata`.\n */\nexport function compileDeclarePipeFromMetadata(meta: R3PipeMetadata): R3CompiledExpression {\n  const definitionMap = createPipeDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declarePipe).callFn([definitionMap.toLiteralMap()]);\n  const type = createPipeType(meta);\n\n  return {expression, type, statements: []};\n}\n\n/**\n * Gathers the declaration fields for a Pipe into a `DefinitionMap`.\n */\nexport function createPipeDefinitionMap(meta: R3PipeMetadata):\n    DefinitionMap<R3DeclarePipeMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclarePipeMetadata>();\n\n  definitionMap.set('minVersion', o.literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', o.literal('15.0.0'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n\n  // e.g. `type: MyPipe`\n  definitionMap.set('type', meta.internalType);\n\n  if (meta.isStandalone) {\n    definitionMap.set('isStandalone', o.literal(meta.isStandalone));\n  }\n\n  // e.g. `name: \"myPipe\"`\n  definitionMap.set('name', o.literal(meta.pipeName));\n\n  if (meta.pure === false) {\n    // e.g. `pure: false`\n    definitionMap.set('pure', o.literal(meta.pure));\n  }\n\n  return definitionMap;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n//////////////////////////////////////\n// THIS FILE HAS GLOBAL SIDE EFFECT //\n//       (see bottom of file)       //\n//////////////////////////////////////\n\n/**\n * @module\n * @description\n * Entry point for all APIs of the compiler package.\n *\n * <div class=\"callout is-critical\">\n *   <header>Unstable APIs</header>\n *   <p>\n *     All compiler apis are currently considered experimental and private!\n *   </p>\n *   <p>\n *     We expect the APIs in this package to keep on changing. Do not rely on them.\n *   </p>\n * </div>\n */\n\nimport * as core from './core';\nimport {publishFacade} from './jit_compiler_facade';\nimport {global} from './util';\n\nexport {CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, SchemaMetadata} from './core';\nexport {core};\n\nexport * from './version';\nexport {CompilerConfig, preserveWhitespacesDefault} from './config';\nexport * from './resource_loader';\nexport {ConstantPool} from './constant_pool';\nexport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './ml_parser/interpolation_config';\nexport * from './schema/element_schema_registry';\nexport * from './i18n/index';\nexport * from './expression_parser/ast';\nexport * from './expression_parser/lexer';\nexport * from './expression_parser/parser';\nexport * from './ml_parser/ast';\nexport * from './ml_parser/html_parser';\nexport * from './ml_parser/html_tags';\nexport * from './ml_parser/interpolation_config';\nexport * from './ml_parser/tags';\nexport {ParseTreeResult, TreeError} from './ml_parser/parser';\nexport {LexerRange} from './ml_parser/lexer';\nexport * from './ml_parser/xml_parser';\nexport {ArrayType, DYNAMIC_TYPE, BinaryOperator, BinaryOperatorExpr, BuiltinType, BuiltinTypeName, CommaExpr, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionType, ExpressionVisitor, ExternalExpr, ExternalReference, literalMap, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, MapType, NotExpr, NONE_TYPE, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, StatementVisitor, TaggedTemplateExpr, TemplateLiteral, TemplateLiteralElement, Type, TypeModifier, TypeVisitor, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr, StmtModifier, Statement, STRING_TYPE, TypeofExpr, jsDocComment, leadingComment, LeadingComment, JSDocComment, UnaryOperator, UnaryOperatorExpr, LocalizedString} from './output/output_ast';\nexport {EmitterVisitorContext} from './output/abstract_emitter';\nexport {JitEvaluator} from './output/output_jit';\nexport * from './parse_util';\nexport * from './schema/dom_element_schema_registry';\nexport * from './selector';\nexport {Version} from './util';\nexport {SourceMap} from './output/source_map';\nexport * from './injectable_compiler_2';\nexport * from './render3/partial/api';\nexport * from './render3/view/api';\nexport {BoundAttribute as TmplAstBoundAttribute, BoundEvent as TmplAstBoundEvent, BoundText as TmplAstBoundText, Content as TmplAstContent, Element as TmplAstElement, Icu as TmplAstIcu, Node as TmplAstNode, RecursiveVisitor as TmplAstRecursiveVisitor, Reference as TmplAstReference, Template as TmplAstTemplate, Text as TmplAstText, TextAttribute as TmplAstTextAttribute, Variable as TmplAstVariable} from './render3/r3_ast';\nexport * from './render3/view/t2_api';\nexport * from './render3/view/t2_binder';\nexport {Identifiers as R3Identifiers} from './render3/r3_identifiers';\nexport {R3ClassMetadata, CompileClassMetadataFn, compileClassMetadata} from './render3/r3_class_metadata_compiler';\nexport {compileFactoryFunction, R3DependencyMetadata, R3FactoryMetadata, FactoryTarget} from './render3/r3_factory';\nexport {compileNgModule, R3NgModuleMetadata, R3SelectorScopeMode} from './render3/r3_module_compiler';\nexport {compileInjector, R3InjectorMetadata} from './render3/r3_injector_compiler';\nexport {compilePipeFromMetadata, R3PipeMetadata} from './render3/r3_pipe_compiler';\nexport {makeBindingParser, ParsedTemplate, parseTemplate, ParseTemplateOptions} from './render3/view/template';\nexport {ForwardRefHandling, MaybeForwardRefExpression, R3CompiledExpression, R3Reference, createMayBeForwardRefExpression, devOnlyGuardedExpression, getSafePropertyAccessString} from './render3/util';\nexport {compileComponentFromMetadata, compileDirectiveFromMetadata, parseHostBindings, ParsedHostBindings, verifyHostBindings} from './render3/view/compiler';\nexport {compileDeclareClassMetadata} from './render3/partial/class_metadata';\nexport {compileDeclareComponentFromMetadata, DeclareComponentTemplateInfo} from './render3/partial/component';\nexport {compileDeclareDirectiveFromMetadata} from './render3/partial/directive';\nexport {compileDeclareFactoryFunction} from './render3/partial/factory';\nexport {compileDeclareInjectableFromMetadata} from './render3/partial/injectable';\nexport {compileDeclareInjectorFromMetadata} from './render3/partial/injector';\nexport {compileDeclareNgModuleFromMetadata} from './render3/partial/ng_module';\nexport {compileDeclarePipeFromMetadata} from './render3/partial/pipe';\nexport {publishFacade} from './jit_compiler_facade';\nexport {emitDistinctChangesOnlyDefaultValue, ChangeDetectionStrategy, ViewEncapsulation} from './core';\nimport * as outputAst from './output/output_ast';\nexport {outputAst};\n// This file only reexports content of the `src` folder. Keep it that way.\n\n// This function call has a global side effects and publishes the compiler into global namespace for\n// the late binding of the Compiler to the @angular/core for jit compilation.\npublishFacade(global);\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\nexport * from './src/compiler';\n\n// This file only reexports content of the `src` folder. Keep it that way.\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// This file is not used to build this module. It is only used during editing\n// by the TypeScript language service and during build for verification. `ngc`\n// replaces this file with production index.ts when it rewrites private symbol\n// names.\n\nexport * from './public_api';\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// This file is not used to build this module. It is only used during editing\n// by the TypeScript language service and during build for verification. `ngc`\n// replaces this file with production index.ts when it rewrites private symbol\n// names.\n\nexport * from './compiler';\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ParsedTemplate,\n  TmplAstElement,\n  TmplAstNode,\n  TmplAstTemplate,\n  parseTemplate as parseTemplateUsingCompiler,\n} from '@angular/compiler';\n\n/**\n * Traverses the given tree of nodes and runs the given callbacks for each Element node encountered.\n *\n * Note that updates to the start tags of html element should be done in the postorder callback,\n * and updates to the end tags of html elements should be done in the preorder callback to avoid\n * issues with line collisions.\n *\n * @param nodes The nodes of the ast from a parsed template.\n * @param preorderCallback A function that gets run for each Element node in a preorder traversal.\n * @param postorderCallback A function that gets run for each Element node in a postorder traversal.\n */\nexport function visitElements(\n  nodes: TmplAstNode[],\n  preorderCallback: (node: TmplAstElement) => void = () => {},\n  postorderCallback: (node: TmplAstElement) => void = () => {},\n): void {\n  for (let i = nodes.length - 1; i > -1; i--) {\n    const node = nodes[i];\n    const isElement = node instanceof TmplAstElement;\n\n    if (isElement) {\n      preorderCallback(node);\n    }\n\n    // Descend both into elements and templates in order to cover cases like `*ngIf` and `*ngFor`.\n    if (isElement || node instanceof TmplAstTemplate) {\n      visitElements(node.children, preorderCallback, postorderCallback);\n    }\n\n    if (isElement) {\n      postorderCallback(node);\n    }\n  }\n}\n\n/**\n * A wrapper for the Angular compilers parseTemplate, which passes the correct options to ensure\n * the parsed template is accurate.\n *\n * For more details, see https://github.com/angular/angular/blob/4332897baa2226ef246ee054fdd5254e3c129109/packages/compiler-cli/src/ngtsc/annotations/component/src/resources.ts#L230.\n *\n * @param template text of the template to parse\n * @param templateUrl URL to use for source mapping of the parsed template\n * @returns the updated template html.\n */\nexport function parseTemplate(template: string, templateUrl: string = ''): ParsedTemplate {\n  return parseTemplateUsingCompiler(template, templateUrl, {\n    preserveWhitespaces: true,\n    preserveLineEndings: true,\n    leadingTriviaChars: [],\n  });\n}\n\n/**\n * Replaces the start tag of the given Element node inside of the html document with a new tag name.\n *\n * @param html The full html document.\n * @param node The Element node to be updated.\n * @param tag A new tag name.\n * @returns an updated html document.\n */\nexport function replaceStartTag(html: string, node: TmplAstElement, tag: string): string {\n  return replaceAt(html, node.startSourceSpan.start.offset + 1, node.name, tag);\n}\n\n/**\n * Replaces the end tag of the given Element node inside of the html document with a new tag name.\n *\n * @param html The full html document.\n * @param node The Element node to be updated.\n * @param tag A new tag name.\n * @returns an updated html document.\n */\nexport function replaceEndTag(html: string, node: TmplAstElement, tag: string): string {\n  if (!node.endSourceSpan) {\n    return html;\n  }\n  return replaceAt(html, node.endSourceSpan.start.offset + 2, node.name, tag);\n}\n\n/**\n * Appends an attribute to the given node of the template html.\n *\n * @param html The template html to be updated.\n * @param node The node to be updated.\n * @param name The name of the attribute.\n * @param update The function that determines how to update the value.\n * @returns The updated template html.\n */\nexport function updateAttribute(\n  html: string,\n  node: TmplAstElement,\n  name: string,\n  update: (old: string | null) => string | null,\n): string {\n  const existingAttr = node.attributes.find(currentAttr => currentAttr.name === name);\n\n  // If the attribute has a value already, replace it.\n  if (existingAttr && existingAttr.keySpan) {\n    const updatedValue = update(existingAttr.valueSpan?.toString() || '');\n    if (updatedValue == null) {\n      // Delete attribute\n      return (\n        html.slice(0, existingAttr.sourceSpan.start.offset).trimEnd() +\n        html.slice(existingAttr.sourceSpan.end.offset)\n      );\n    } else if (updatedValue == '') {\n      // Delete value from attribute\n      return (\n        html.slice(0, existingAttr.keySpan.end.offset) +\n        html.slice(existingAttr.sourceSpan.end.offset)\n      );\n    } else {\n      // Set attribute value\n      if (existingAttr.valueSpan) {\n        // Replace attribute value\n        return (\n          html.slice(0, existingAttr.valueSpan.start.offset) +\n          updatedValue +\n          html.slice(existingAttr.valueSpan.end.offset)\n        );\n      } else {\n        // Add value to attribute\n        return (\n          html.slice(0, existingAttr.keySpan.end.offset) +\n          `=\"${updatedValue}\"` +\n          html.slice(existingAttr.keySpan.end.offset)\n        );\n      }\n    }\n  }\n\n  const newValue = update(null);\n\n  // No change needed if attribute should be deleted and is already not present.\n  if (newValue == null) {\n    return html;\n  }\n\n  // Otherwise insert a new attribute.\n  const index = node.startSourceSpan.start.offset + node.name.length + 1;\n  const prefix = html.slice(0, index);\n  const suffix = html.slice(index);\n  const attrText = newValue ? `${name}=\"${newValue}\"` : `${name}`;\n\n  if (node.startSourceSpan.start.line === node.startSourceSpan.end.line) {\n    return `${prefix} ${attrText}${suffix}`;\n  }\n\n  const attr = node.attributes[0];\n  if (attr) {\n    const ctx = attr.sourceSpan.start.getContext(attr.sourceSpan.start.col + 1, 1)!;\n    const indentation = ctx.before;\n    return prefix + indentation + attrText + suffix;\n  }\n\n  return prefix + attrText + suffix;\n}\n\n/**\n * Replaces a substring of a given string starting at some offset index.\n *\n * @param str A string to be updated.\n * @param offset An offset index to start at.\n * @param oldSubstr The old substring to be replaced.\n * @param newSubstr A new substring.\n * @returns the updated string.\n */\nfunction replaceAt(str: string, offset: number, oldSubstr: string, newSubstr: string): string {\n  const index = offset;\n  const prefix = str.slice(0, index);\n  const suffix = str.slice(index + oldSubstr.length);\n  return prefix + newSubstr + suffix;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as compiler from '@angular/compiler';\nimport {TemplateMigrator} from '../../template-migrator';\nimport {updateAttribute, visitElements} from '../../tree-traversal';\nimport {Update} from '../../../../../migration-utilities';\n\nexport class CardTemplateMigrator extends TemplateMigrator {\n  getUpdates(ast: compiler.ParsedTemplate): Update[] {\n    const updates: Update[] = [];\n\n    visitElements(ast.nodes, (node: compiler.TmplAstElement) => {\n      if (node.name !== 'mat-card') {\n        return;\n      }\n\n      updates.push({\n        offset: node.startSourceSpan.start.offset,\n        updateFn: html => updateAttribute(html, node, 'appearance', () => 'outlined'),\n      });\n    });\n\n    return updates;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class CheckboxStylesMigrator extends StyleMigrator {\n  component = 'checkbox';\n\n  deprecatedPrefixes = ['mat-checkbox'];\n\n  mixinChanges = [\n    {\n      old: 'legacy-checkbox-theme',\n      new: ['checkbox-theme'],\n    },\n    {\n      old: 'legacy-checkbox-color',\n      new: ['checkbox-color'],\n    },\n    {\n      old: 'legacy-checkbox-typography',\n      new: ['checkbox-typography'],\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [{old: '.mat-checkbox', new: '.mat-mdc-checkbox'}];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class ChipsStylesMigrator extends StyleMigrator {\n  component = 'chips';\n\n  deprecatedPrefixes = ['mat-chip'];\n\n  mixinChanges = [\n    {\n      old: 'legacy-chips-theme',\n      new: ['chips-theme'],\n    },\n    {\n      old: 'legacy-chips-color',\n      new: ['chips-color'],\n    },\n    {\n      old: 'legacy-chips-typography',\n      new: ['chips-typography'],\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [\n    {old: '.mat-chip-set', new: '.mat-mdc-chip-set'},\n    {old: '.mat-chip-grid', new: '.mat-mdc-chip-grid'},\n    {old: '.mat-chip', new: '.mat-mdc-chip'},\n    {old: '.mat-basic-chip', new: '.mat-mdc-basic-chip'},\n    {old: '.mat-standard-chip', new: '.mat-mdc-standard-chip'},\n    {old: '.mat-chip-input', new: '.mat-mdc-chip-input'},\n  ];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as compiler from '@angular/compiler';\nimport {TemplateMigrator} from '../../template-migrator';\nimport {replaceStartTag, replaceEndTag, visitElements} from '../../tree-traversal';\nimport {Update} from '../../../../../migration-utilities';\n\n/** Stores a mat-chip-list with the mat-chip elements nested within it. */\ninterface ChipMap {\n  chipList: compiler.TmplAstElement;\n  chips: compiler.TmplAstElement[];\n}\n\nexport class ChipsTemplateMigrator extends TemplateMigrator {\n  /** Stores the mat-chip-list elements with their nested mat-chip elements. */\n  chipMap?: ChipMap;\n\n  /** All of the ChipMaps found while parsing a template AST. */\n  chipMaps: ChipMap[] = [];\n\n  /** Chips that are not nested within mat-chip elements. */\n  standaloneChips: compiler.TmplAstElement[] = [];\n\n  /** Input elements that have matChipInputFor attributes. */\n  chipInputs: compiler.TmplAstBoundAttribute[] = [];\n\n  getUpdates(ast: compiler.ParsedTemplate): Update[] {\n    this._gatherDomData(ast);\n    const updates: Update[] = [];\n    this.chipMaps.forEach(chipMap => {\n      if (this._isChipGrid(chipMap.chipList)) {\n        updates.push(...this._buildUpdatesForChipMap(chipMap, 'mat-chip-grid', 'mat-chip-row'));\n        return;\n      }\n      updates.push(...this._buildUpdatesForChipMap(chipMap, 'mat-chip-listbox', 'mat-chip-option'));\n    });\n    this.standaloneChips.forEach(chip => {\n      updates.push(...this._buildTagUpdates(chip, 'mat-chip-option'));\n    });\n    return updates;\n  }\n\n  /** Traverses the AST and stores all relevant DOM data needed for building updates. */\n  private _gatherDomData(ast: compiler.ParsedTemplate): void {\n    this.chipMap = undefined;\n    this.chipMaps = [];\n    this.standaloneChips = [];\n    this.chipInputs = [];\n\n    visitElements(\n      ast.nodes,\n      (node: compiler.TmplAstElement) => {\n        switch (node.name) {\n          case 'input':\n            this._handleInputNode(node);\n            break;\n          case 'mat-chip-list':\n            this.chipMap = {chipList: node, chips: []};\n            break;\n          case 'mat-chip':\n            this.chipMap ? this.chipMap.chips.push(node) : this.standaloneChips.push(node);\n        }\n      },\n      (node: compiler.TmplAstElement) => {\n        if (node.name === 'mat-chip-list') {\n          this.chipMaps.push(this.chipMap!);\n          this.chipMap = undefined;\n        }\n      },\n    );\n  }\n\n  /** Returns the mat-chip-list and mat-chip updates for the given ChipMap. */\n  private _buildUpdatesForChipMap(\n    chipMap: ChipMap,\n    chipListTagName: string,\n    chipTagName: string,\n  ): Update[] {\n    const updates: Update[] = [];\n    updates.push(...this._buildTagUpdates(chipMap.chipList, chipListTagName));\n    chipMap.chips.forEach(chip => updates.push(...this._buildTagUpdates(chip, chipTagName)));\n    return updates;\n  }\n\n  /** Creates and returns the start and end tag updates for the given node. */\n  private _buildTagUpdates(node: compiler.TmplAstElement, tagName: string): Update[] {\n    return [\n      {\n        offset: node.startSourceSpan.start.offset,\n        updateFn: html => replaceStartTag(html, node, tagName),\n      },\n      {\n        offset: node.endSourceSpan!.start.offset,\n        updateFn: html => replaceEndTag(html, node, tagName),\n      },\n    ];\n  }\n\n  /** Stores the given input node if it has a matChipInputFor attribute. */\n  private _handleInputNode(node: compiler.TmplAstElement): void {\n    node.inputs.forEach(attr => {\n      if (attr.name === 'matChipInputFor') {\n        this.chipInputs.push(attr);\n      }\n    });\n  }\n\n  /** Returns true if the given mat-chip-list is referenced by any inputs. */\n  private _isChipGrid(node: compiler.TmplAstElement): boolean {\n    return node.references.some(ref => {\n      return this.chipInputs.some(attr => {\n        return ref.name === (attr.value as compiler.ASTWithSource).source;\n      });\n    });\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class DialogStylesMigrator extends StyleMigrator {\n  component = 'dialog';\n\n  deprecatedPrefixes = ['mat-dialog'];\n\n  mixinChanges = [\n    {\n      old: 'legacy-dialog-theme',\n      new: ['dialog-theme'],\n    },\n    {\n      old: 'legacy-dialog-color',\n      new: ['dialog-color'],\n    },\n    {\n      old: 'legacy-dialog-typography',\n      new: ['dialog-typography'],\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [\n    {old: '.mat-dialog', new: '.mat-mdc-dialog'},\n    {old: '.mat-dialog-title', new: '.mat-mdc-dialog-title'},\n    {old: '.mat-dialog-container', new: '.mat-mdc-dialog-container'},\n    {old: '.mat-dialog-content', new: '.mat-mdc-dialog-content'},\n    {old: '.mat-dialog-actions', new: '.mat-mdc-dialog-actions'},\n  ];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class FormFieldStylesMigrator extends StyleMigrator {\n  component = 'form-field';\n\n  deprecatedPrefixes = [\n    '.mat-form-field-can-float',\n    '.mat-form-field-should-float',\n    '.mat-form-field-has-label',\n    '.mat-form-field-wrapper',\n    '.mat-form-field-flex',\n    '.mat-form-field-outline',\n    '.mat-form-field-prefix',\n    '.mat-form-field-infix',\n    '.mat-form-field-suffix',\n    '.mat-form-field-label',\n    '.mat-form-field-required-marker',\n    '.mat-form-field-underline',\n    '.mat-form-field-ripple',\n    '.mat-form-field-subscript-wrapper',\n    '.mat-form-field-hint-wrapper',\n    '.mat-form-field-hint-hint-spacer',\n  ];\n\n  mixinChanges = [\n    {\n      old: 'legacy-form-field-theme',\n      new: ['form-field-theme'],\n      checkForDuplicates: true,\n    },\n    {\n      old: 'legacy-form-field-color',\n      new: ['form-field-color'],\n      checkForDuplicates: true,\n    },\n    {\n      old: 'legacy-form-field-typography',\n      new: ['form-field-typography'],\n      checkForDuplicates: true,\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [\n    {\n      old: '.mat-form-field',\n      new: '.mat-mdc-form-field',\n    },\n    {\n      old: '.mat-hint',\n      new: '.mat-mdc-form-field-hint',\n    },\n    {\n      old: '.mat-error',\n      new: '.mat-mdc-form-field-error',\n    },\n  ];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class InputStylesMigrator extends StyleMigrator {\n  component = 'input';\n\n  deprecatedPrefixes = ['mat-input'];\n\n  mixinChanges = [\n    {\n      old: 'legacy-input-theme',\n      new: ['input-theme'],\n    },\n    {\n      old: 'legacy-input-color',\n      new: ['input-color'],\n    },\n    {\n      old: 'legacy-input-typography',\n      new: ['input-typography'],\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [{old: '.mat-input-element', new: '.mat-mdc-input-element'}];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class ListStylesMigrator extends StyleMigrator {\n  component = 'list';\n\n  deprecatedPrefixes = ['mat-list'];\n\n  mixinChanges = [\n    {\n      old: 'legacy-list-theme',\n      new: ['list-theme'],\n    },\n    {\n      old: 'legacy-list-color',\n      new: ['list-color'],\n    },\n    {\n      old: 'legacy-list-typography',\n      new: ['list-typography'],\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [\n    {old: `.mat-list-base`, new: `.mat-mdc-list-base`},\n    {old: `.mat-list`, new: `.mat-mdc-list`},\n    {old: `.mat-list-avatar`, new: `.mat-mdc-list-item-avatar`},\n    {old: `.mat-list-icon`, new: `.mat-mdc-list-item-icon`},\n    {old: `.mat-subheader`, new: `.mat-mdc-subheader`},\n    {old: `.mat-list-item`, new: `.mat-mdc-list-item`},\n  ];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class MenuStylesMigrator extends StyleMigrator {\n  component = 'menu';\n\n  deprecatedPrefixes = ['mat-menu'];\n\n  mixinChanges = [\n    {\n      old: 'legacy-menu-theme',\n      new: ['menu-theme'],\n    },\n    {\n      old: 'legacy-menu-color',\n      new: ['menu-color'],\n    },\n    {\n      old: 'legacy-menu-typography',\n      new: ['menu-typography'],\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [\n    {old: '.mat-menu-item', new: '.mat-mdc-menu-item'},\n    {old: '.mat-menu-trigger', new: '.mat-mdc-menu-trigger'},\n    {old: '.mat-menu-panel', new: '.mat-mdc-menu-panel'},\n    {old: '.mat-menu-content', new: '.mat-mdc-menu-content'},\n    {\n      old: '.mat-menu-item-submenu-trigger',\n      new: '.mat-mdc-menu-item-submenu-trigger',\n    },\n  ];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class PaginatorStylesMigrator extends StyleMigrator {\n  component = 'paginator';\n\n  deprecatedPrefixes = ['mat-paginator'];\n\n  mixinChanges = [\n    {\n      old: 'legacy-paginator-theme',\n      new: ['paginator-theme', 'icon-button-theme', 'form-field-theme', 'select-theme'],\n      checkForDuplicates: true,\n    },\n    {\n      old: 'legacy-paginator-color',\n      new: ['paginator-color', 'icon-button-color', 'form-field-color', 'select-color'],\n      checkForDuplicates: true,\n    },\n    {\n      old: 'legacy-paginator-typography',\n      new: [\n        'paginator-typography',\n        'icon-button-typography',\n        'form-field-typography',\n        'select-typography',\n      ],\n      checkForDuplicates: true,\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [\n    {old: '.mat-paginator', new: '.mat-mdc-paginator'},\n    {old: '.mat-paginator-outer-container', new: '.mat-mdc-paginator-outer-container'},\n    {old: '.mat-paginator-container', new: '.mat-mdc-paginator-container'},\n    {old: '.mat-paginator-page-size', new: '.mat-mdc-paginator-page-size'},\n    {old: '.mat-paginator-page-size-label', new: '.mat-mdc-paginator-page-size-label'},\n    {old: '.mat-paginator-page-size-value', new: '.mat-mdc-paginator-page-size-value'},\n    {old: '.mat-paginator-range-actions', new: '.mat-mdc-paginator-range-actions'},\n    {old: '.mat-paginator-range-label', new: '.mat-mdc-paginator-range-label'},\n    {old: '.mat-paginator-navigation-first', new: '.mat-mdc-paginator-navigation-first'},\n    {old: '.mat-paginator-navigation-previous', new: '.mat-mdc-paginator-navigation-previous'},\n    {old: '.mat-paginator-navigation-next', new: '.mat-mdc-paginator-navigation-next'},\n    {old: '.mat-paginator-navigation-last', new: '.mat-mdc-paginator-navigation-last'},\n    {old: '.mat-paginator-icon', new: '.mat-mdc-paginator-icon'},\n  ];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class ProgressBarStylesMigrator extends StyleMigrator {\n  component = 'progress-bar';\n\n  deprecatedPrefixes = ['mat-progress-bar'];\n\n  mixinChanges = [\n    {\n      old: 'legacy-progress-bar-theme',\n      new: ['progress-bar-theme'],\n    },\n    {\n      old: 'legacy-progress-bar-color',\n      new: ['progress-bar-color'],\n    },\n    {\n      old: 'legacy-progress-bar-typography',\n      new: ['progress-bar-typography'],\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [{old: '.mat-progress-bar', new: '.mat-mdc-progress-bar'}];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class ProgressSpinnerStylesMigrator extends StyleMigrator {\n  component = 'progress-spinner';\n\n  // There are no other progress spinner selectors available aside from the\n  // specified changes below\n  deprecatedPrefixes = [];\n\n  mixinChanges = [\n    {\n      old: 'legacy-progress-spinner-theme',\n      new: ['progress-spinner-theme'],\n    },\n    {\n      old: 'legacy-progress-spinner-color',\n      new: ['progress-spinner-color'],\n    },\n    {\n      old: 'legacy-progress-spinner-typography',\n      new: ['progress-spinner-typography'],\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [\n    {old: '.mat-progress-spinner', new: '.mat-mdc-progress-spinner'},\n    {old: '.mat-spinner', new: '.mat-mdc-progress-spinner'},\n  ];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class RadioStylesMigrator extends StyleMigrator {\n  component = 'radio';\n\n  deprecatedPrefixes = ['mat-radio'];\n\n  mixinChanges = [\n    {\n      old: 'legacy-radio-theme',\n      new: ['radio-theme'],\n    },\n    {\n      old: 'legacy-radio-color',\n      new: ['radio-color'],\n    },\n    {\n      old: 'legacy-radio-typography',\n      new: ['radio-typography'],\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [\n    {old: '.mat-radio-group', new: '.mat-mdc-radio-group'},\n    {old: '.mat-radio-button', new: '.mat-mdc-radio-button'},\n  ];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class SelectStylesMigrator extends StyleMigrator {\n  component = 'select';\n\n  deprecatedPrefixes = ['mat-select', 'mat-option'];\n\n  mixinChanges = [\n    {\n      old: 'legacy-select-theme',\n      new: ['select-theme'],\n      checkForDuplicates: true,\n    },\n    {\n      old: 'legacy-select-color',\n      new: ['select-color'],\n      checkForDuplicates: true,\n    },\n    {\n      old: 'legacy-select-typography',\n      new: ['select-typography'],\n      checkForDuplicates: true,\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [\n    {old: '.mat-select', new: '.mat-mdc-select'},\n    {old: '.mat-select-panel', new: '.mat-mdc-select-panel'},\n    {old: '.mat-option', new: '.mat-mdc-option'},\n  ];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class SlideToggleStylesMigrator extends StyleMigrator {\n  component = 'slide-toggle';\n\n  deprecatedPrefixes = ['mat-slide-toggle'];\n\n  mixinChanges = [\n    {\n      old: 'legacy-slide-toggle-theme',\n      new: ['slide-toggle-theme'],\n    },\n    {\n      old: 'legacy-slide-toggle-color',\n      new: ['slide-toggle-color'],\n    },\n    {\n      old: 'legacy-slide-toggle-typography',\n      new: ['slide-toggle-typography'],\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [{old: '.mat-slide-toggle', new: '.mat-mdc-slide-toggle'}];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class SliderStylesMigrator extends StyleMigrator {\n  component = 'slider';\n\n  deprecatedPrefixes = ['mat-slider'];\n\n  mixinChanges = [\n    {\n      old: 'legacy-slider-theme',\n      new: ['slider-theme'],\n    },\n    {\n      old: 'legacy-slider-color',\n      new: ['slider-color'],\n    },\n    {\n      old: 'legacy-slider-typography',\n      new: ['slider-typography'],\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [{old: '.mat-slider', new: '.mat-mdc-slider'}];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class SnackBarMigrator extends StyleMigrator {\n  component = 'snack-bar';\n\n  // There are no other selectors with the 'mat-snack-bar' prefix available\n  // aside from the specified changes below\n  deprecatedPrefixes = [];\n\n  mixinChanges = [\n    {\n      old: 'legacy-snack-bar-theme',\n      new: ['snack-bar-theme', 'button-theme'],\n      checkForDuplicates: true,\n    },\n    {\n      old: 'legacy-snack-bar-color',\n      new: ['snack-bar-color', 'button-color'],\n      checkForDuplicates: true,\n    },\n    {\n      old: 'legacy-snack-bar-typography',\n      new: ['snack-bar-typography', 'button-typography'],\n      checkForDuplicates: true,\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [\n    {old: '.mat-snack-bar-container', new: '.mat-mdc-snack-bar-container'},\n    {old: '.mat-snack-bar-handset', new: '.mat-mdc-snack-bar-handset'},\n    {old: '.mat-simple-snackbar', new: '.mat-mdc-simple-snack-bar'},\n  ];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class TableStylesMigrator extends StyleMigrator {\n  component = 'table';\n\n  // There are no other table selectors available aside from the specified\n  // changes below\n  deprecatedPrefixes = [];\n\n  mixinChanges = [\n    {\n      old: 'legacy-table-theme',\n      new: ['table-theme'],\n    },\n    {\n      old: 'legacy-table-color',\n      new: ['table-color'],\n    },\n    {\n      old: 'legacy-table-typography',\n      new: ['table-typography'],\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [\n    {old: '.mat-table', new: '.mat-mdc-table'},\n    {old: '.mat-table-sticky', new: '.mat-mdc-table-sticky'},\n    {old: '.mat-header-cell', new: '.mat-mdc-header-cell'},\n    {old: '.mat-footer-cell', new: '.mat-mdc-footer-cell'},\n    {old: '.mat-cell', new: '.mat-mdc-cell'},\n    {old: '.mat-header-row', new: '.mat-mdc-header-row'},\n    {old: '.mat-footer-row', new: '.mat-mdc-footer-row'},\n    {old: '.mat-row', new: '.mat-mdc-row'},\n    {\n      old: '.mat-table-sticky-border-elem-left',\n      new: '.mat-mdc-table-sticky-border-elem-left',\n    },\n    {\n      old: '.mat-table-sticky-border-elem-right',\n      new: '.mat-mdc-table-sticky-border-elem-right',\n    },\n  ];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class TabsStylesMigrator extends StyleMigrator {\n  component = 'tabs';\n\n  deprecatedPrefixes = ['mat-tabs', 'mat-tab'];\n\n  mixinChanges = [\n    {\n      old: 'legacy-tabs-theme',\n      new: ['tabs-theme'],\n    },\n    {\n      old: 'legacy-tabs-color',\n      new: ['tabs-color'],\n    },\n    {\n      old: 'legacy-tabs-typography',\n      new: ['tabs-typography'],\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [\n    {old: '.mat-tab', new: '.mat-mdc-tab'},\n    {old: '.mat-tab-body', new: '.mat-mdc-tab-body'},\n    {old: '.mat-tab-group', new: '.mat-mdc-tab-group'},\n    {old: '.mat-tab-header', new: '.mat-mdc-tab-header'},\n    {old: '.mat-tab-nav-bar', new: '.mat-mdc-tab-nav-bar'},\n    {old: '.mat-tab-link', new: '.mat-mdc-tab-link'},\n  ];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class TooltipStylesMigrator extends StyleMigrator {\n  component = 'tooltip';\n\n  deprecatedPrefixes = ['mat-tooltip'];\n\n  mixinChanges = [\n    {\n      old: 'legacy-tooltip-theme',\n      new: ['tooltip-theme'],\n    },\n    {\n      old: 'legacy-tooltip-color',\n      new: ['tooltip-color'],\n    },\n    {\n      old: 'legacy-tooltip-typography',\n      new: ['tooltip-typography'],\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [\n    {old: '.mat-tooltip', new: '.mat-mdc-tooltip'},\n    {old: '.mat-tooltip-trigger', new: '.mat-mdc-tooltip-trigger'},\n    {old: '.mat-tooltip-panel', new: '.mat-mdc-tooltip-panel'},\n    {old: '.mat-tooltip-panel-above', new: '.mat-mdc-tooltip-panel-above'},\n    {old: '.mat-tooltip-panel-below', new: '.mat-mdc-tooltip-panel-below'},\n    {old: '.mat-tooltip-panel-left', new: '.mat-mdc-tooltip-panel-left'},\n    {old: '.mat-tooltip-panel-right', new: '.mat-mdc-tooltip-panel-right'},\n    {old: '.mat-tooltip-panel-before', new: '.mat-mdc-tooltip-panel-before'},\n    {old: '.mat-tooltip-panel-after', new: '.mat-mdc-tooltip-panel-after'},\n  ];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class OptgroupStylesMigrator extends StyleMigrator {\n  component = 'optgroup';\n\n  deprecatedPrefixes = ['mat-optgroup'];\n\n  mixinChanges = [\n    {\n      old: 'legacy-optgroup-theme',\n      new: ['optgroup-theme'],\n    },\n    {\n      old: 'legacy-optgroup-color',\n      new: ['optgroup-color'],\n    },\n    {\n      old: 'legacy-optgroup-typography',\n      new: ['optgroup-typography'],\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [\n    {\n      old: '.mat-optgroup',\n      new: '.mat-mdc-optgroup',\n    },\n    {\n      old: '.mat-optgroup-label',\n      new: '.mat-mdc-optgroup-label',\n    },\n  ];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\n\nexport class OptionStylesMigrator extends StyleMigrator {\n  component = 'option';\n\n  deprecatedPrefixes = ['mat-option'];\n\n  mixinChanges = [\n    {\n      old: 'legacy-option-theme',\n      new: ['option-theme'],\n    },\n    {\n      old: 'legacy-option-color',\n      new: ['option-color'],\n    },\n    {\n      old: 'legacy-option-typography',\n      new: ['option-typography'],\n    },\n    {\n      old: 'legacy-core-theme',\n      new: ['core-theme'],\n    },\n    {\n      old: 'legacy-core-color',\n      new: ['core-color'],\n    },\n    {\n      old: 'legacy-core-typography',\n      new: ['core-typography'],\n    },\n  ];\n\n  classChanges: ClassNameChange[] = [\n    {\n      old: '.mat-option',\n      new: '.mat-mdc-option',\n    },\n    {\n      old: '.mat-option-multiple',\n      new: '.mat-mdc-option-multiple',\n    },\n    {\n      old: '.mat-option-pseudo-checkbox',\n      new: '.mat-mdc-option-pseudo-checkbox',\n    },\n    {\n      old: '.mat-option-ripple',\n      new: '.mat-mdc-option-ripple',\n    },\n  ];\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as compiler from '@angular/compiler';\nimport {TemplateMigrator} from '../../template-migrator';\nimport {updateAttribute, visitElements} from '../../tree-traversal';\nimport {Update} from '../../../../../migration-utilities';\n\nexport class FormFieldTemplateMigrator extends TemplateMigrator {\n  getUpdates(ast: compiler.ParsedTemplate): Update[] {\n    const updates: Update[] = [];\n\n    visitElements(ast.nodes, (node: compiler.TmplAstElement) => {\n      if (node.name !== 'mat-form-field') {\n        return;\n      }\n\n      updates.push({\n        offset: node.startSourceSpan.start.offset,\n        updateFn: html =>\n          updateAttribute(html, node, 'appearance', old =>\n            ['legacy', 'standard'].includes(old || '') ? null : old,\n          ),\n      });\n    });\n\n    return updates;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as compiler from '@angular/compiler';\nimport {TemplateMigrator} from '../../template-migrator';\nimport {visitElements} from '../../tree-traversal';\nimport {Update} from '../../../../../migration-utilities';\n\n/** Contains a parsed binding node's standardized data. */\ninterface Binding {\n  /** The actual compiler ast binding node. */\n  node: compiler.TmplAstNode;\n  /** The type of binding this node is. */\n  type: BindingType;\n  /** The name of the property, attribute, or event. */\n  name: string;\n  /** The event handler or property/attribute value. */\n  value: string;\n}\n\n/** Describes the different types of bindings we care about. */\nconst enum BindingType {\n  INPUT,\n  OUTPUT,\n  ATTRIBUTE,\n  TWO_WAY_BINDING,\n}\n\nexport class SliderTemplateMigrator extends TemplateMigrator {\n  getUpdates(ast: compiler.ParsedTemplate): Update[] {\n    const updates: Update[] = [];\n\n    visitElements(ast.nodes, (node: compiler.TmplAstElement) => {\n      if (node.name === 'mat-slider') {\n        const originalHtml = node.sourceSpan.start.file.content;\n        const bindings = this._getBindings(node);\n        const inputBindings: string[] = [];\n        const comments: string[] = [];\n\n        let alreadyAppendedTemplateVars = false;\n\n        for (let i = 0; i < bindings.length; i++) {\n          const binding = bindings[i];\n\n          if (binding.name === 'value') {\n            // Move the binding to the <input>.\n            const sourceSpan = binding.node.sourceSpan;\n            inputBindings.push(originalHtml.slice(sourceSpan.start.offset, sourceSpan.end.offset));\n            updates.push(this._removeBinding(originalHtml, binding.node));\n          }\n\n          if (\n            binding.name === 'invert' ||\n            binding.name === 'vertical' ||\n            binding.name === 'tickInterval' ||\n            binding.name === 'valueText'\n          ) {\n            // Remove the binding and leave a comment.\n            comments.push(`<!-- TODO: The '${binding.name}' property no longer exists -->`);\n            updates.push(this._removeBinding(originalHtml, binding.node));\n          }\n\n          if (binding.name === 'displayValue') {\n            // Remove the binding and leave a comment.\n            comments.push(\n              `<!-- TODO: The '${binding.name}' property no longer exists. Use 'displayWith' instead. -->`,\n            );\n            updates.push(this._removeBinding(originalHtml, binding.node));\n          }\n\n          if (binding.name === 'input' || binding.name === 'change') {\n            // Replace $event with a MatSliderChange object.\n            const sourceSpan = binding.node.sourceSpan;\n            const oldBindingStr = originalHtml.slice(\n              sourceSpan.start.offset,\n              sourceSpan.end.offset,\n            );\n            const newBindingStr = oldBindingStr.replace(\n              '$event',\n              '{source: ngSliderThumb, parent: ngSlider, value: ngSliderThumb.value}',\n            );\n\n            // Remove the old binding and add the new binding to the <input>.\n            inputBindings.push(newBindingStr);\n            updates.push(this._removeBinding(originalHtml, binding.node));\n\n            if (!alreadyAppendedTemplateVars) {\n              // Add the necessary template vars used in the MatSliderChange object.\n              inputBindings.push('#ngSliderThumb=\"matSliderThumb\"');\n              updates.push(this._insertTemplateVar(node, 'ngSlider'));\n              alreadyAppendedTemplateVars = true;\n            }\n          }\n        }\n\n        if (comments.length) {\n          updates.push(this._addComments(node, comments));\n        }\n\n        const matSliderThumb = inputBindings.length\n          ? `<input matSliderThumb ${inputBindings.join(' ')} />`\n          : '<input matSliderThumb />';\n\n        updates.push({\n          offset: node.startSourceSpan.end.offset,\n          updateFn: (html: string) =>\n            html.slice(0, node.startSourceSpan.end.offset) +\n            matSliderThumb +\n            html.slice(node.startSourceSpan.end.offset),\n        });\n      }\n    });\n    return updates;\n  }\n\n  /** Returns an update that inserts a template var at the end of the given node. */\n  private _insertTemplateVar(node: compiler.TmplAstElement, varName: string): Update {\n    return {\n      offset: node.startSourceSpan.end.offset - 1,\n      updateFn: html =>\n        html.slice(0, node.startSourceSpan.end.offset - 1) + // -1 to stop before the closing '>'\n        ` #${varName}` +\n        html.slice(node.startSourceSpan.end.offset - 1),\n    };\n  }\n\n  /** Returns an update that adds the given comments before the given template ast element. */\n  private _addComments(node: compiler.TmplAstElement, comments: string[]): Update {\n    const whitespace = this._parseIndentation(node);\n    const indentation = '\\n' + this._parseIndentation(node);\n\n    // If everything leading up to the mat-slider start tag\n    // was whitespace, we don't need to start on a new line.\n    const commentStr =\n      whitespace.length === node.sourceSpan.start.col\n        ? comments.join(indentation)\n        : indentation + comments.join(indentation);\n\n    return {\n      offset: node.sourceSpan.start.offset,\n      updateFn: (html: string) =>\n        html.slice(0, node.sourceSpan.start.offset) +\n        commentStr +\n        `${indentation}${html.slice(node.sourceSpan.start.offset)}`,\n    };\n  }\n\n  /** Returns the whitespace at the start of the given node's line. */\n  private _parseIndentation(node: compiler.TmplAstElement): string {\n    const html = node.sourceSpan.start.file.content;\n    const before = html.slice(\n      node.sourceSpan.start.offset - node.sourceSpan.start.col,\n      node.sourceSpan.start.offset,\n    );\n    return before.slice(0, before.length - before.trimStart().length);\n  }\n\n  /** Returns an update that removes the given binding from the given template ast element. */\n  private _removeBinding(originalHtml: string, binding: compiler.TmplAstNode): Update {\n    let charIndex = binding.sourceSpan.start.offset - 1;\n\n    // Find the first char before the binding that is not whitespace.\n    while (/\\s/.test(originalHtml.charAt(charIndex)) && charIndex > -1) {\n      charIndex--;\n    }\n\n    return {\n      offset: charIndex + 1,\n      updateFn: (html: string) =>\n        html.slice(0, charIndex + 1) + html.slice(binding.sourceSpan.end.offset),\n    };\n  }\n\n  /** Returns all of the property, attribute, event, or two-way bindings on the given node. */\n  private _getBindings(node: compiler.TmplAstElement): Binding[] {\n    const allInputs = this._getInputs(node);\n    const allOutputs = this._getOutputs(node);\n    const attributes = this._getAttributes(node);\n    const twoWayBindings = this._getTwoWayBindings(allInputs, allOutputs);\n\n    // Remove the inputs & outputs that are two-way bindings.\n\n    const inputs = allInputs.filter(\n      input => !twoWayBindings.some(binding => binding.name === input.name),\n    );\n    const outputs = allOutputs.filter(\n      output => !twoWayBindings.some(binding => binding.name === output.name),\n    );\n\n    return inputs.concat(outputs).concat(attributes).concat(twoWayBindings);\n  }\n\n  /** Returns the two-way bindings based on the given input & output bindings. */\n  private _getTwoWayBindings(inputs: Binding[], outputs: Binding[]): Binding[] {\n    return inputs\n      .filter(input => outputs.some(output => output.name === input.name))\n      .map(input => ({...input, type: BindingType.TWO_WAY_BINDING}));\n  }\n\n  /** Returns the output bindings on the given node. */\n  private _getOutputs(node: compiler.TmplAstElement): Binding[] {\n    return node.outputs.map(output => ({\n      node: output,\n      type: BindingType.OUTPUT,\n      name: node.sourceSpan.start.file.content.slice(\n        output.keySpan.start.offset,\n        output.keySpan.end.offset,\n      ),\n      value: node.sourceSpan.start.file.content.slice(\n        output.handlerSpan.start.offset,\n        output.handlerSpan.end.offset,\n      ),\n    }));\n  }\n\n  /** Returns the input bindings on the given node. */\n  private _getInputs(node: compiler.TmplAstElement): Binding[] {\n    return node.inputs.map(input => ({\n      node: input,\n      type: BindingType.INPUT,\n      name: node.sourceSpan.start.file.content.slice(\n        input.keySpan.start.offset,\n        input.keySpan.end.offset,\n      ),\n      value: node.sourceSpan.start.file.content.slice(\n        input.value.sourceSpan.start,\n        input.value.sourceSpan.end,\n      ),\n    }));\n  }\n\n  /** Returns the attributes on the given node. */\n  private _getAttributes(node: compiler.TmplAstElement): Binding[] {\n    return node.attributes.map(attribute => ({\n      node: attribute,\n      type: BindingType.ATTRIBUTE,\n      name: attribute.name,\n      value: attribute.value,\n    }));\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst mappings: [string, string][] = [\n  ['display-4', 'headline-1'],\n  ['display-3', 'headline-2'],\n  ['display-2', 'headline-3'],\n  ['display-1', 'headline-4'],\n  ['headline', 'headline-5'],\n  ['title', 'headline-6'],\n  ['subheading-2', 'subtitle-1'],\n  ['body-2', 'subtitle-2'],\n  ['subheading-1', 'body-1'],\n  ['body-1', 'body-2'],\n];\n\n/**\n * Mapping between the renamed legacy typography levels and their new non-legacy names. Based on\n * the mappings in `private-typography-to-2018-config` from `core/typography/_typography.scss`.\n */\nexport const RENAMED_TYPOGRAPHY_LEVELS = new Map(mappings);\n\n/** Mapping between the renamed typography CSS classes and their non-legacy equivalents. */\nexport const RENAMED_TYPOGRAPHY_CLASSES = new Map(\n  mappings.map(m => ['mat-' + m[0], 'mat-' + m[1]]),\n);\n\n/** Typography levels that have been combined into other levels with no replacement. */\nexport const COMBINED_TYPOGRAPHY_LEVELS = new Map([['input', 'body-1']]);\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as compiler from '@angular/compiler';\nimport {TemplateMigrator} from '../../template-migrator';\nimport {visitElements} from '../../tree-traversal';\nimport {Update} from '../../../../../migration-utilities';\nimport {RENAMED_TYPOGRAPHY_CLASSES} from './constants';\n\nexport class TypographyHierarchyTemplateMigrator extends TemplateMigrator {\n  getUpdates(ast: compiler.ParsedTemplate): Update[] {\n    const updates: Update[] = [];\n\n    visitElements(ast.nodes, node => {\n      this._addStaticClassUpdates(node, updates);\n      this._addClassBindingUpdates(node, updates);\n    });\n\n    return updates;\n  }\n\n  /** Migrates the legacy typography classes in a static `class` attribute. */\n  private _addStaticClassUpdates(node: compiler.TmplAstElement, updates: Update[]): void {\n    const classAttr = node.attributes.find(attr => attr.name === 'class');\n\n    if (classAttr && classAttr.keySpan && classAttr.valueSpan && classAttr.value.includes('mat-')) {\n      const classes = classAttr.value.split(' ');\n      let hasChanged = false;\n\n      classes.forEach((current, index) => {\n        if (RENAMED_TYPOGRAPHY_CLASSES.has(current)) {\n          hasChanged = true;\n          classes[index] = RENAMED_TYPOGRAPHY_CLASSES.get(current)!;\n        }\n      });\n\n      if (hasChanged) {\n        updates.push({\n          offset: classAttr.keySpan.start.offset,\n          updateFn: html =>\n            html.slice(0, classAttr.valueSpan!.start.offset) +\n            classes.join(' ') +\n            html.slice(classAttr.valueSpan!.end.offset),\n        });\n      }\n    }\n  }\n\n  /** Migrates the legacy typography classes in `[class.x]` bindings. */\n  private _addClassBindingUpdates(node: compiler.TmplAstElement, updates: Update[]): void {\n    node.inputs.forEach(input => {\n      if (input.type === compiler.BindingType.Class && RENAMED_TYPOGRAPHY_CLASSES.has(input.name)) {\n        updates.push({\n          offset: input.keySpan.start.offset,\n          updateFn: html => {\n            return (\n              html.slice(0, input.keySpan.start.offset) +\n              'class.' +\n              RENAMED_TYPOGRAPHY_CLASSES.get(input.name)! +\n              html.slice(input.keySpan.end.offset)\n            );\n          },\n        });\n      }\n    });\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassNameChange, StyleMigrator} from '../../style-migrator';\nimport {RENAMED_TYPOGRAPHY_CLASSES} from './constants';\n\nexport class TypographyHierarchyStylesMigrator extends StyleMigrator {\n  component = 'typography-hierarchy';\n  deprecatedPrefixes = [];\n  classChanges: ClassNameChange[] = [];\n  mixinChanges = [\n    {\n      old: 'legacy-typography-hierarchy',\n      new: ['typography-hierarchy'],\n      checkForDuplicates: false,\n    },\n  ];\n\n  constructor() {\n    super();\n\n    RENAMED_TYPOGRAPHY_CLASSES.forEach((newClass, oldClass) => {\n      // Some classes get renamed to each other. E.g. `subheading-1` -> `body-1` -> `body-2`.\n      // PostCSS will re-run its processors whenever an AST is mutated which means that we'll\n      // either end up with an incorrect result or potentially fall into an infinite loop. Wrap\n      // the risky classes in a special string that will be stripped out later to avoid the issue.\n      const wrappedNewClass = RENAMED_TYPOGRAPHY_CLASSES.has(newClass)\n        ? `.${StyleMigrator.wrapValue(newClass)}`\n        : `.${newClass}`;\n\n      this.classChanges.push({new: wrappedNewClass, old: '.' + oldClass});\n    });\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StyleMigrator} from './style-migrator';\nimport {TemplateMigrator} from './template-migrator';\n\nimport {AutocompleteStylesMigrator} from './components/autocomplete/autocomplete-styles';\nimport {ButtonStylesMigrator} from './components/button/button-styles';\nimport {CardStylesMigrator} from './components/card/card-styles';\nimport {CardTemplateMigrator} from './components/card/card-template';\nimport {CheckboxStylesMigrator} from './components/checkbox/checkbox-styles';\nimport {ChipsStylesMigrator} from './components/chips/chips-styles';\nimport {ChipsTemplateMigrator} from './components/chips/chips-template';\nimport {DialogStylesMigrator} from './components/dialog/dialog-styles';\nimport {FormFieldStylesMigrator} from './components/form-field/form-field-styles';\nimport {InputStylesMigrator} from './components/input/input-styles';\nimport {ListStylesMigrator} from './components/list/list-styles';\nimport {MenuStylesMigrator} from './components/menu/menu-styles';\nimport {PaginatorStylesMigrator} from './components/paginator/paginator-styles';\nimport {ProgressBarStylesMigrator} from './components/progress-bar/progress-bar-styles';\nimport {ProgressSpinnerStylesMigrator} from './components/progress-spinner/progress-spinner-styles';\nimport {RadioStylesMigrator} from './components/radio/radio-styles';\nimport {SelectStylesMigrator} from './components/select/select-styles';\nimport {SlideToggleStylesMigrator} from './components/slide-toggle/slide-toggle-styles';\nimport {SliderStylesMigrator} from './components/slider/slider-styles';\nimport {SnackBarMigrator} from './components/snack-bar/snack-bar-styles';\nimport {TableStylesMigrator} from './components/table/table-styles';\nimport {TabsStylesMigrator} from './components/tabs/tabs-styles';\nimport {TooltipStylesMigrator} from './components/tooltip/tooltip-styles';\nimport {OptgroupStylesMigrator} from './components/optgroup/optgroup-styles';\nimport {OptionStylesMigrator} from './components/option/option-styles';\nimport {FormFieldTemplateMigrator} from './components/form-field/form-field-template';\nimport {SliderTemplateMigrator} from './components/slider/slider-template';\nimport {TypographyHierarchyTemplateMigrator} from './components/typography-hierarchy/typography-hierarchy-template';\nimport {TypographyHierarchyStylesMigrator} from './components/typography-hierarchy/typography-hierarchy-styles';\n\n/** Contains the migrators to migrate a single component. */\nexport interface ComponentMigrator {\n  component: string;\n  styles: StyleMigrator;\n  template?: TemplateMigrator;\n}\n\nexport const LEGACY_MODULES = new Set(\n  [\n    'legacy-autocomplete',\n    'legacy-autocomplete/testing',\n    'legacy-button',\n    'legacy-button/testing',\n    'legacy-card',\n    'legacy-card/testing',\n    'legacy-checkbox',\n    'legacy-checkbox/testing',\n    'legacy-chips',\n    'legacy-chips/testing',\n    'legacy-core',\n    'legacy-core/testing',\n    'legacy-dialog',\n    'legacy-dialog/testing',\n    'legacy-form-field',\n    'legacy-form-field/testing',\n    'legacy-input',\n    'legacy-input/testing',\n    'legacy-list',\n    'legacy-list/testing',\n    'legacy-menu',\n    'legacy-menu/testing',\n    'legacy-paginator',\n    'legacy-paginator/testing',\n    'legacy-progress-bar',\n    'legacy-progress-bar/testing',\n    'legacy-progress-spinner',\n    'legacy-progress-spinner/testing',\n    'legacy-radio',\n    'legacy-radio/testing',\n    'legacy-select',\n    'legacy-select/testing',\n    'legacy-slide-toggle',\n    'legacy-slide-toggle/testing',\n    'legacy-slider',\n    'legacy-slider/testing',\n    'legacy-snack-bar',\n    'legacy-snack-bar/testing',\n    'legacy-table',\n    'legacy-table/testing',\n    'legacy-tabs',\n    'legacy-tabs/testing',\n    'legacy-tooltip',\n    'legacy-tooltip/testing',\n  ].map(name => `@angular/material/${name}`),\n);\n\nexport const MIGRATORS: ComponentMigrator[] = [\n  {\n    component: 'autocomplete',\n    styles: new AutocompleteStylesMigrator(),\n  },\n  {\n    component: 'button',\n    styles: new ButtonStylesMigrator(),\n  },\n  {\n    component: 'card',\n    styles: new CardStylesMigrator(),\n    template: new CardTemplateMigrator(),\n  },\n  {\n    component: 'checkbox',\n    styles: new CheckboxStylesMigrator(),\n  },\n  {\n    component: 'chips',\n    styles: new ChipsStylesMigrator(),\n    template: new ChipsTemplateMigrator(),\n  },\n  {\n    component: 'dialog',\n    styles: new DialogStylesMigrator(),\n  },\n  {\n    component: 'form-field',\n    styles: new FormFieldStylesMigrator(),\n    template: new FormFieldTemplateMigrator(),\n  },\n  {\n    component: 'input',\n    styles: new InputStylesMigrator(),\n  },\n  {\n    component: 'list',\n    styles: new ListStylesMigrator(),\n  },\n  {\n    component: 'menu',\n    styles: new MenuStylesMigrator(),\n  },\n  {\n    component: 'optgroup',\n    styles: new OptgroupStylesMigrator(),\n  },\n  {\n    component: 'option',\n    styles: new OptionStylesMigrator(),\n  },\n  {\n    component: 'paginator',\n    styles: new PaginatorStylesMigrator(),\n  },\n  {\n    component: 'progress-bar',\n    styles: new ProgressBarStylesMigrator(),\n  },\n  {\n    component: 'progress-spinner',\n    styles: new ProgressSpinnerStylesMigrator(),\n  },\n  {\n    component: 'radio',\n    styles: new RadioStylesMigrator(),\n  },\n  {\n    component: 'select',\n    styles: new SelectStylesMigrator(),\n  },\n  {\n    component: 'slide-toggle',\n    styles: new SlideToggleStylesMigrator(),\n  },\n  {\n    component: 'slider',\n    styles: new SliderStylesMigrator(),\n    template: new SliderTemplateMigrator(),\n  },\n  {\n    component: 'snack-bar',\n    styles: new SnackBarMigrator(),\n  },\n  {\n    component: 'table',\n    styles: new TableStylesMigrator(),\n  },\n  {\n    component: 'tabs',\n    styles: new TabsStylesMigrator(),\n  },\n  {\n    component: 'tooltip',\n    styles: new TooltipStylesMigrator(),\n  },\n];\n\nexport const PERMANENT_MIGRATORS: ComponentMigrator[] = [\n  {\n    // The typography hierarchy used to always be included\n    // with `mat.core` so it always has to be migrated.\n    component: 'typography-hierarchy',\n    template: new TypographyHierarchyTemplateMigrator(),\n    styles: new TypographyHierarchyStylesMigrator(),\n  },\n];\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Migration, getPropertyNameText} from '@angular/cdk/schematics';\nimport {SchematicContext} from '@angular-devkit/schematics';\nimport {ComponentMigrator, LEGACY_MODULES} from '../index';\nimport * as ts from 'typescript';\nimport {ThemingStylesMigration} from '../theming-styles';\nimport {TemplateMigration} from '../template-migration';\n\ntype Replacement = [node: ts.Node, newText: string];\n\nexport class RuntimeCodeMigration extends Migration<ComponentMigrator[], SchematicContext> {\n  enabled = true;\n\n  private _printer = ts.createPrinter({newLine: ts.NewLineKind.LineFeed});\n  private _stylesMigration: ThemingStylesMigration;\n  private _templateMigration: TemplateMigration;\n  private _hasPossibleTemplateMigrations = true;\n\n  override visitNode(node: ts.Node): void {\n    if (ts.isSourceFile(node)) {\n      this._migrateSourceFileReferences(node);\n    } else if (this._isComponentDecorator(node)) {\n      this._migrateComponentDecorator(node as ts.Decorator);\n    } else if (this._isImportExpression(node)) {\n      this._migrateModuleSpecifier(node.arguments[0]);\n    } else if (this._isTypeImportExpression(node)) {\n      this._migrateModuleSpecifier(node.argument.literal);\n    }\n  }\n\n  /** Runs the SourceFile-level migrations, including renaming imports and references. */\n  private _migrateSourceFileReferences(sourceFile: ts.SourceFile) {\n    const {importSpecifiersToNewNames, identifiersToImportSpecifiers, moduleSpecifiers} =\n      this._findImportsToMigrate(sourceFile);\n\n    [\n      ...this._renameModuleSpecifiers(moduleSpecifiers),\n      ...this._renameReferences(\n        sourceFile,\n        identifiersToImportSpecifiers,\n        importSpecifiersToNewNames,\n      ),\n    ]\n      .sort(([a], [b]) => b.getStart() - a.getStart())\n      .forEach(([currentNode, newName]) => {\n        this._printAndUpdateNode(sourceFile, currentNode, newName);\n      });\n  }\n\n  /** Finds the imported symbols in a file that need to be migrated. */\n  private _findImportsToMigrate(sourceFile: ts.SourceFile) {\n    const importSpecifiersToNewNames = new Map<ts.ImportSpecifier, string>();\n    const moduleSpecifiers = new Map<ts.StringLiteral, string>();\n    const identifiersToImportSpecifiers = new Map<string, ts.ImportSpecifier>();\n\n    for (const statement of sourceFile.statements) {\n      if (\n        ts.isImportDeclaration(statement) &&\n        ts.isStringLiteral(statement.moduleSpecifier) &&\n        statement.importClause?.namedBindings &&\n        ts.isNamedImports(statement.importClause.namedBindings) &&\n        LEGACY_MODULES.has(statement.moduleSpecifier.text)\n      ) {\n        statement.importClause.namedBindings.elements.forEach(element => {\n          const oldName = (element.propertyName || element.name).text;\n          const newName = this._removeLegacy(oldName);\n\n          if (newName) {\n            importSpecifiersToNewNames.set(element, newName);\n\n            // Skip aliased imports since they only need to be renamed in the import declaration.\n            if (!element.propertyName) {\n              identifiersToImportSpecifiers.set(oldName, element);\n            }\n          }\n        });\n\n        const newModuleSpecifier = this._removeLegacy(statement.moduleSpecifier.text);\n\n        if (newModuleSpecifier) {\n          moduleSpecifiers.set(statement.moduleSpecifier, newModuleSpecifier);\n        }\n      }\n    }\n\n    return {importSpecifiersToNewNames, identifiersToImportSpecifiers, moduleSpecifiers};\n  }\n\n  /** Renames all of the references to imported legacy symbols. */\n  private _renameReferences(\n    sourceFile: ts.SourceFile,\n    identifiersToImportSpecifiers: Map<string, ts.ImportSpecifier>,\n    importSpecifiersToNewNames: Map<ts.ImportSpecifier, string>,\n  ): Replacement[] {\n    if (importSpecifiersToNewNames.size === 0) {\n      return [];\n    }\n\n    const replacements: Replacement[] = [];\n    const walk = (node: ts.Node) => {\n      // Imports are handled separately.\n      if (ts.isImportDeclaration(node)) {\n        return;\n      }\n\n      if (ts.isIdentifier(node)) {\n        const specifier = identifiersToImportSpecifiers.get(node.text);\n\n        if (specifier && this._isReferenceToImport(node, specifier)) {\n          replacements.push([node, importSpecifiersToNewNames.get(specifier)!]);\n        }\n      }\n\n      node.forEachChild(walk);\n    };\n\n    sourceFile.forEachChild(walk);\n\n    importSpecifiersToNewNames.forEach((newName, specifier) => {\n      if (specifier.propertyName) {\n        replacements.push([\n          // If the import looks like `import {OldName as NewName} from ...;`,\n          // we drop the alias and simplify the import to `import {NewName} from ...`.\n          specifier.name.text === newName ? specifier : specifier.propertyName,\n          newName,\n        ]);\n      } else {\n        replacements.push([specifier.name, newName]);\n      }\n    });\n\n    return replacements;\n  }\n\n  /** Renames all of the legacy module import specifiers. */\n  private _renameModuleSpecifiers(moduleSpecifiers: Map<ts.StringLiteral, string>): Replacement[] {\n    const replacements: Replacement[] = [];\n\n    for (const [specifier, newName] of moduleSpecifiers.entries()) {\n      const quoteStyle = specifier.getText()[0];\n      replacements.push([specifier, quoteStyle + newName + quoteStyle]);\n    }\n\n    return replacements;\n  }\n\n  /** Migrates the `@Component` metadata. */\n  private _migrateComponentDecorator(node: ts.Decorator) {\n    if (!ts.isCallExpression(node.expression)) {\n      return;\n    }\n    const metadata = node.expression.arguments[0];\n\n    if (!ts.isObjectLiteralExpression(metadata)) {\n      return;\n    }\n\n    for (const prop of metadata.properties) {\n      if (prop.name) {\n        switch (getPropertyNameText(prop.name)) {\n          case 'styles':\n            this._migrateStyles(prop as ts.PropertyAssignment);\n            break;\n          case 'template':\n            if (this._hasPossibleTemplateMigrations) {\n              this._migrateTemplate(prop as ts.PropertyAssignment);\n            }\n            break;\n        }\n      }\n    }\n  }\n\n  private _migrateStyles(node: ts.PropertyAssignment) {\n    // Create styles migration if no styles have been migrated yet. Needs to be\n    // additionally created because the migrations run in isolation.\n    if (!this._stylesMigration) {\n      this._stylesMigration = new ThemingStylesMigration(\n        this.program,\n        this.typeChecker,\n        this.targetVersion,\n        this.context,\n        this.upgradeData,\n        this.fileSystem,\n        this.logger,\n      );\n    }\n\n    node.initializer.forEachChild(stringLiteralNode => {\n      this._migratePropertyAssignment(stringLiteralNode as ts.StringLiteral, this._stylesMigration);\n    });\n  }\n\n  private _migrateTemplate(node: ts.PropertyAssignment) {\n    // Create template migration if no template has been migrated yet. Needs to\n    // be additionally created because the migrations run in isolation.\n    if (!this._templateMigration) {\n      const templateUpgradeData = this.upgradeData.filter(component => component.template);\n      // If no component in the upgrade data has a a template migrator, stop\n      // trying to migrate any templates from now on\n      if (templateUpgradeData.length === 0) {\n        this._hasPossibleTemplateMigrations = false;\n        return;\n      } else {\n        this._templateMigration = new TemplateMigration(\n          this.program,\n          this.typeChecker,\n          this.targetVersion,\n          this.context,\n          templateUpgradeData,\n          this.fileSystem,\n          this.logger,\n        );\n      }\n    }\n\n    this._migratePropertyAssignment(node.initializer as ts.StringLiteral, this._templateMigration);\n  }\n\n  private _migratePropertyAssignment(\n    node: ts.StringLiteralLike | ts.Identifier,\n    migration: TemplateMigration | ThemingStylesMigration,\n  ) {\n    let migratedText = migration.migrate(node.text, node.getSourceFile().fileName);\n    let migratedTextLines = migratedText.split('\\n');\n\n    // Update quotes based on if its multiline or not to avoid compilation errors\n    if (migratedTextLines.length > 1) {\n      // Add correct identation for new lines before replacing\n      migratedText = migratedTextLines\n        .map((line: string, index: number) => {\n          if (index !== 0 && line != '\\n') {\n            const leadingWidth = node.getLeadingTriviaWidth();\n            if (leadingWidth > 0) {\n              line = ' '.repeat(leadingWidth - 1) + line;\n            }\n          }\n          return line;\n        })\n        .join('\\n');\n\n      migratedText = '`' + migratedText + '`';\n    } else {\n      // Need to grab quotation because it is not included in node.text\n      const quotation = node.getText().trimStart()[0];\n      migratedText = quotation + migratedText + quotation;\n    }\n\n    this._printAndUpdateNode(\n      node.getSourceFile(),\n      node,\n      ts.factory.createRegularExpressionLiteral(migratedText),\n    );\n  }\n\n  private _migrateModuleSpecifier(specifier: ts.StringLiteralLike) {\n    const newName = this._removeLegacy(specifier.text);\n\n    if (newName) {\n      const quoteStyle = specifier.getText()[0];\n      this._printAndUpdateNode(\n        specifier.getSourceFile(),\n        specifier,\n        quoteStyle + newName + quoteStyle,\n      );\n    }\n  }\n\n  /** Gets whether the specified decorator node is for a Component declaration */\n  private _isComponentDecorator(node: ts.Node): node is ts.Decorator {\n    if (!ts.isDecorator(node)) {\n      return false;\n    }\n\n    const call = node.expression;\n    if (!ts.isCallExpression(call) || !ts.isIdentifier(call.expression)) {\n      return false;\n    }\n\n    return call.expression.text === 'Component';\n  }\n\n  /** Gets whether the specified node is an import expression. */\n  private _isImportExpression(\n    node: ts.Node,\n  ): node is ts.CallExpression & {arguments: [ts.StringLiteralLike]} {\n    return (\n      ts.isCallExpression(node) &&\n      node.expression.kind === ts.SyntaxKind.ImportKeyword &&\n      node.arguments.length === 1 &&\n      ts.isStringLiteralLike(node.arguments[0])\n    );\n  }\n\n  /** Gets whether the specified node is a type import expression. */\n  private _isTypeImportExpression(\n    node: ts.Node,\n  ): node is ts.ImportTypeNode & {argument: {literal: ts.StringLiteralLike}} {\n    return (\n      ts.isImportTypeNode(node) &&\n      ts.isLiteralTypeNode(node.argument) &&\n      ts.isStringLiteralLike(node.argument.literal)\n    );\n  }\n\n  private _printAndUpdateNode(\n    sourceFile: ts.SourceFile,\n    oldNode: ts.Node,\n    newNode: ts.Node | string,\n  ) {\n    const filePath = this.fileSystem.resolve(sourceFile.fileName);\n    const newNodeText =\n      typeof newNode === 'string'\n        ? newNode\n        : this._printer.printNode(ts.EmitHint.Unspecified, newNode, sourceFile);\n    const start = oldNode.getStart();\n    const width = oldNode.getWidth();\n\n    this.fileSystem.edit(filePath).remove(start, width).insertRight(start, newNodeText);\n  }\n\n  /** Checks whether a specifier identifier is referring to an imported symbol. */\n  private _isReferenceToImport(node: ts.Identifier, importSpecifier: ts.ImportSpecifier): boolean {\n    if ((importSpecifier.propertyName || importSpecifier.name).text !== node.text) {\n      return false;\n    }\n\n    const nodeSymbol = this.typeChecker.getTypeAtLocation(node).getSymbol();\n    const importSymbol = this.typeChecker.getTypeAtLocation(importSpecifier).getSymbol();\n\n    // This can happen for type references.\n    if (!nodeSymbol && !importSymbol) {\n      return this.typeChecker.getSymbolAtLocation(node)?.declarations?.[0] === importSpecifier;\n    }\n\n    return (\n      !!(nodeSymbol?.declarations?.[0] && importSymbol?.declarations?.[0]) &&\n      nodeSymbol.declarations[0] === importSymbol.declarations[0]\n    );\n  }\n\n  /**\n   * Strips \"legacy\" from the name of a symbol or an import.\n   * Returns null if it doesn't have a legacy name.\n   */\n  private _removeLegacy(name: string): string | null {\n    const legacyRegex = /legacy[_-]?/i;\n    return legacyRegex.test(name) ? name.replace(legacyRegex, '') : null;\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Migration, ResolvedResource} from '@angular/cdk/schematics';\nimport {SchematicContext} from '@angular-devkit/schematics';\nimport * as postcss from 'postcss';\nimport * as scss from 'postcss-scss';\nimport {ComponentMigrator, MIGRATORS, PERMANENT_MIGRATORS} from '.';\nimport {\n  COMBINED_TYPOGRAPHY_LEVELS,\n  RENAMED_TYPOGRAPHY_LEVELS,\n} from './components/typography-hierarchy/constants';\nimport {StyleMigrator} from './style-migrator';\n\nconst COMPONENTS_MIXIN_NAME = /\\.([^(;]*)/;\n\nexport class ThemingStylesMigration extends Migration<ComponentMigrator[], SchematicContext> {\n  enabled = true;\n  private _namespace: string;\n\n  override visitStylesheet(stylesheet: ResolvedResource) {\n    let migratedContent = this.migrate(stylesheet.content, stylesheet.filePath);\n\n    // Note: needs to run after `migrate` so that the `namespace` has been resolved.\n    if (this._namespace) {\n      migratedContent = migrateTypographyConfigs(migratedContent, this._namespace);\n    }\n\n    this.fileSystem\n      .edit(stylesheet.filePath)\n      .remove(stylesheet.start, stylesheet.content.length)\n      .insertRight(stylesheet.start, migratedContent);\n  }\n\n  migrate(styles: string, filename: string): string {\n    const processor = new postcss.Processor([\n      {\n        postcssPlugin: 'theming-styles-migration-plugin',\n        AtRule: {\n          use: this._atUseHandler.bind(this),\n          include: atRule => this._atIncludeHandler(atRule),\n        },\n        Rule: rule => this._ruleHandler(rule),\n      },\n    ]);\n\n    try {\n      const result = processor.process(styles, {syntax: scss}).toString();\n      // PostCSS will re-run the processors if it detects that an AST has been mutated. We want to\n      // avoid this when removing the unwrapped values, because it may cause them to be re-migrated\n      // incorrectly. This is achieved by unwrapping after the AST has been converted to a string.\n      return result === styles ? styles : StyleMigrator.unwrapAllValues(result);\n    } catch (e) {\n      this.context.logger.error(`${e}`);\n      this.context.logger.warn(`Failed to process stylesheet: ${filename} (see error above).`);\n      return styles;\n    }\n  }\n\n  private _atUseHandler(atRule: postcss.AtRule) {\n    if (isAngularMaterialImport(atRule)) {\n      this._namespace = parseNamespace(atRule);\n    }\n  }\n\n  private _atIncludeHandler(atRule: postcss.AtRule) {\n    const migrator = this.upgradeData.find(m => {\n      return m.styles.isLegacyMixin(this._namespace, atRule);\n    });\n    if (migrator) {\n      const mixinChange = migrator.styles.getMixinChange(this._namespace, atRule);\n      if (mixinChange) {\n        if (mixinChange.new) {\n          replaceAtRuleWithMultiple(atRule, mixinChange.old, mixinChange.new);\n        } else {\n          atRule.remove();\n        }\n      }\n    } else if (atRule.parent && this.isCrossCuttingMixin(atRule.params)) {\n      if (this.isPartialMigration()) {\n        // the second element of the result from match is the matching text\n        const mixinName = atRule.params.match(COMPONENTS_MIXIN_NAME)![1];\n        const comment = `TODO(mdc-migration): Remove ${mixinName} once all legacy components are migrated`;\n        if (!addLegacyCommentForPartialMigrations(atRule, comment)) {\n          // same mixin already replaced, nothing to do here\n          return;\n        }\n      }\n      replaceCrossCuttingMixin(atRule, this._namespace);\n    }\n  }\n\n  isCrossCuttingMixin(mixinText: string) {\n    return [\n      `${this._namespace}\\\\.all-legacy-component-`,\n      `${this._namespace}\\\\.legacy-core([^-]|$)`,\n    ].some(r => new RegExp(r).test(mixinText));\n  }\n\n  isPartialMigration() {\n    return this.upgradeData.length !== MIGRATORS.length + PERMANENT_MIGRATORS.length;\n  }\n\n  private _ruleHandler(rule: postcss.Rule) {\n    let isLegacySelector = false;\n    let isDeprecatedSelector = false;\n\n    const migrator = this.upgradeData.find(m => {\n      isLegacySelector = m.styles.isLegacySelector(rule);\n      isDeprecatedSelector = m.styles.isDeprecatedSelector(rule);\n      return isLegacySelector || isDeprecatedSelector;\n    });\n\n    if (!migrator) {\n      return;\n    }\n\n    if (isLegacySelector) {\n      migrator.styles.replaceLegacySelector(rule);\n    } else if (isDeprecatedSelector) {\n      addCommentBeforeNode(\n        rule,\n        `TODO(mdc-migration): The following rule targets internal classes of ${migrator.component} ` +\n          `that may no longer apply for the MDC version.`,\n      );\n    }\n  }\n}\n\n/**\n * Returns whether the given AtRule is an import for @angular/material styles.\n *\n * @param atRule a postcss AtRule node.\n * @returns true if the given AtRule is an import for @angular/material styles.\n */\nfunction isAngularMaterialImport(atRule: postcss.AtRule): boolean {\n  const params = postcss.list.space(atRule.params);\n  return params[0] === \"'@angular/material'\";\n}\n\n/**\n * Parses the given @use AtRule and returns the namespace being used.\n *\n * @param atRule a postcss @use AtRule.\n * @returns the namespace being used.\n */\nfunction parseNamespace(atRule: postcss.AtRule): string {\n  const params = postcss.list.space(atRule.params);\n  return params[params.length - 1];\n}\n\n/**\n *\n * @param atRule a postcss @use AtRule.\n * @param legacyComment comment that will be added to legacy mixin\n * @returns true if comment added, false if comment already exists\n */\nfunction addLegacyCommentForPartialMigrations(\n  atRule: postcss.AtRule,\n  legacyComment: string,\n): boolean {\n  let hasAddedComment = false;\n  // Check if comment has been added before, we don't want to add multiple\n  // comments. We need to check since replacing the original node causes\n  // this function to be called again.\n  atRule.parent?.walkComments(comment => {\n    if (comment.text.includes(legacyComment)) {\n      hasAddedComment = true;\n    }\n  });\n\n  if (hasAddedComment) {\n    // If comment has been added, no action to do anymore.\n    return false;\n  }\n\n  addCommentBeforeNode(atRule.cloneBefore(), legacyComment);\n  return true;\n}\n\n/**\n * Adds comment before postcss rule or at rule node\n *\n * @param node a postcss rule.\n * @param comment the text content for the comment\n */\nfunction addCommentBeforeNode(node: postcss.Rule | postcss.AtRule, comment: string): void {\n  let commentNode = postcss.comment({\n    text: comment,\n  });\n  // We need to manually adjust the indentation and add new lines between the\n  // comment and node\n  const indentation = node.raws.before?.split('\\n').pop();\n  commentNode.raws.before = '\\n' + indentation;\n  // Since node is parsed and not a copy, will always have a parent node\n  node.parent!.insertBefore(node, commentNode);\n  node.raws.before = '\\n' + indentation;\n}\n\n/**\n * Replaces a cross-cutting mixin that affects multiple components with the MDC equivalent.\n *\n * @param atRule A mixin inclusion node\n * @param namespace The @angular/material namespace\n */\nfunction replaceCrossCuttingMixin(atRule: postcss.AtRule, namespace: string) {\n  atRule.cloneBefore({\n    params: atRule.params\n      .replace(`${namespace}.all-legacy-component`, `${namespace}.all-component`)\n      .replace(`${namespace}.legacy-core`, `${namespace}.core`),\n  });\n  atRule.remove();\n}\n\n/**\n * Replaces the text in an atRule with multiple replacements on new lines\n *\n * @param atRule a postcss @use AtRule.\n * @param textToReplace text to replace in the at rule node's params attributes\n * @param replacements an array of strings to replace the specified text. Each\n * entry appears on a new line.\n */\nfunction replaceAtRuleWithMultiple(\n  atRule: postcss.AtRule,\n  textToReplace: string,\n  replacements: string[],\n) {\n  // Cloning & inserting the first node before changing the\n  // indentation preserves the indentation of the first node (e.g. 3 newlines).\n  atRule.cloneBefore({\n    params: atRule.params.replace(textToReplace, replacements[0]),\n  });\n\n  // We change the indentation before inserting all of the other nodes\n  // because the additional @includes should only be separated by a single newline.\n  const indentation = atRule.raws.before?.split('\\n').pop();\n  atRule.raws.before = '\\n' + indentation;\n\n  // Note: It may be more efficient to create an array of clones and then insert\n  // them all at once. If we are having performance issues, we should revisit this.\n  for (let i = 1; i < replacements.length; i++) {\n    atRule.cloneBefore({\n      params: atRule.params.replace(textToReplace, replacements[i]),\n    });\n  }\n  atRule.remove();\n}\n\n/**\n * Migrates all of the `define-legacy-typography-config` calls within a file.\n * @param content Content of the file to be migrated.\n * @param namespace Namespace under which `define-legacy-typography-config` is being used.\n */\nfunction migrateTypographyConfigs(content: string, namespace: string): string {\n  const calls = extractFunctionCalls(`${namespace}.define-legacy-typography-config`, content);\n  const newFunctionName = `${namespace}.define-typography-config`;\n  const replacements: {start: number; end: number; text: string}[] = [];\n\n  calls.forEach(({name, args}) => {\n    const parameters = extractNamedParameters(content, args);\n    const addedParameters = new Set<string>();\n\n    RENAMED_TYPOGRAPHY_LEVELS.forEach((newName, oldName) => {\n      const correspondingParam = parameters.get(oldName);\n\n      if (correspondingParam) {\n        addedParameters.add(newName);\n        replacements.push({\n          start: correspondingParam.key.start + 1, // + 1 to skip over the $ in the parameter name.\n          end: correspondingParam.key.end,\n          text: newName,\n        });\n      }\n    });\n\n    COMBINED_TYPOGRAPHY_LEVELS.forEach((newName, oldName) => {\n      const correspondingParam = parameters.get(oldName);\n\n      if (correspondingParam) {\n        if (addedParameters.has(newName)) {\n          const fullContent = content.slice(\n            correspondingParam.key.start,\n            correspondingParam.value.fullEnd,\n          );\n          replacements.push({\n            start: correspondingParam.key.start,\n            end: correspondingParam.value.fullEnd,\n            text: `/* TODO(mdc-migration): No longer supported. Use \\`${newName}\\` instead. ${fullContent} */`,\n          });\n        } else {\n          addedParameters.add(newName);\n          replacements.push({\n            start: correspondingParam.key.start + 1, // + 1 to skip over the $ in the parameter name.\n            end: correspondingParam.key.end,\n            text: newName,\n          });\n        }\n      }\n    });\n\n    replacements.push({start: name.start, end: name.end, text: newFunctionName});\n  });\n\n  replacements\n    .sort((a, b) => b.start - a.start)\n    .forEach(\n      ({start, end, text}) => (content = content.slice(0, start) + text + content.slice(end)),\n    );\n\n  return content;\n}\n\n/**\n * Extracts the spans of all calls of a specific Sass function within a file.\n * @param name Name of the function to look for.\n * @param content Content of the file being searched.\n */\nfunction extractFunctionCalls(name: string, content: string) {\n  const results: {name: {start: number; end: number}; args: {start: number; end: number}}[] = [];\n  const callString = name + '(';\n  let index = content.indexOf(callString);\n\n  // This would be much simpler with a regex, but it can be fragile when it comes to nested\n  // parentheses. We use this manual parsing which should be more reliable.\n  while (index > -1) {\n    let openParens = 0;\n    let endIndex = -1;\n    let nameEnd = index + callString.length - 1; // -1 to exclude the opening paren.\n\n    for (let i = nameEnd; i < content.length; i++) {\n      const char = content[i];\n\n      if (char === '(') {\n        openParens++;\n      } else if (char === ')') {\n        openParens--;\n\n        if (openParens === 0) {\n          endIndex = i;\n          break;\n        }\n      }\n    }\n\n    // Invalid call, skip over it.\n    if (endIndex === -1) {\n      index = content.indexOf(callString, nameEnd + 1);\n    } else {\n      results.push({name: {start: index, end: nameEnd}, args: {start: nameEnd + 1, end: endIndex}});\n      index = content.indexOf(callString, endIndex);\n    }\n  }\n\n  return results;\n}\n\n/** Extracts all of the named parameters and their values from a string. */\nfunction extractNamedParameters(content: string, argsRange: {start: number; end: number}) {\n  let escapeCount = 0;\n\n  const args = content\n    .slice(argsRange.start, argsRange.end)\n    // The top-level function parameters can contain function calls with named parameters of their\n    // own (e.g. `$display-4: mat.define-typography-level($font-family: $foo))` which we don't want to\n    // extract. Escape everything between parentheses to make it easier to parse out the value later\n    // on. Note that we escape with an equal-length string so that the string indexes remain the same.\n    .replace(/\\(.*\\)/g, current => ++escapeCount + '\u25EC'.repeat(current.length - 1));\n\n  let colonIndex = args.indexOf(':');\n\n  const params = new Map<\n    string,\n    {key: {start: number; end: number}; value: {start: number; end: number; fullEnd: number}}\n  >();\n\n  while (colonIndex > -1) {\n    const keyRange = extractKeyRange(args, colonIndex);\n    const valueRange = extractValueRange(args, colonIndex);\n\n    if (keyRange && valueRange) {\n      // + 1 to exclude the $ in the key name.\n      params.set(args.slice(keyRange.start + 1, keyRange.end), {\n        // Add the argument start offset since the indexes are relative to the argument string.\n        key: {start: keyRange.start + argsRange.start, end: keyRange.end + argsRange.start},\n        value: {\n          start: valueRange.start + argsRange.start,\n          end: valueRange.end + argsRange.start,\n          fullEnd: valueRange.fullEnd + argsRange.start,\n        },\n      });\n    }\n\n    colonIndex = args.indexOf(':', colonIndex + 1);\n  }\n\n  return params;\n}\n\n/**\n * Extracts the text range that contains the key of a named Sass parameter, including the leading $.\n * @param content Text content in which to search.\n * @param colonIndex Index of the colon between the key and value.\n * Used as a starting point for the search.\n */\nfunction extractKeyRange(content: string, colonIndex: number) {\n  let index = colonIndex - 1;\n  let start = -1;\n  let end = -1;\n\n  while (index > -1) {\n    const char = content[index];\n    if (char !== ' ' && char !== '\\n') {\n      if (end === -1) {\n        end = index + 1;\n      } else if (char === '$') {\n        start = index;\n        break;\n      }\n    }\n    index--;\n  }\n\n  return start > -1 && end > -1 ? {start, end} : null;\n}\n\n/**\n * Extracts the text range that contains the value of a named Sass parameter.\n * @param content Text content in which to search.\n * @param colonIndex Index of the colon between the key and value.\n * Used as a starting point for the search.\n */\nfunction extractValueRange(content: string, colonIndex: number) {\n  let index = colonIndex + 1;\n  let start = -1;\n  let end = -1;\n  let fullEnd = -1; // This is the end including any separators (e.g. commas).\n\n  while (index < content.length) {\n    const char = content[index];\n    const isWhitespace = char === ' ' || char === '\\n';\n\n    if (!isWhitespace && start === -1) {\n      start = index;\n    } else if (start > -1 && (isWhitespace || char === ',')) {\n      end = index;\n      fullEnd = index + 1;\n      break;\n    }\n\n    if (start > -1 && index === content.length - 1) {\n      fullEnd = end = content.length;\n      break;\n    }\n\n    index++;\n  }\n\n  return start > -1 && end > -1 ? {start, end, fullEnd} : null;\n}\n", "import postcss from './postcss.js'\n\nexport default postcss\n\nexport const stringify = postcss.stringify\nexport const fromJSON = postcss.fromJSON\nexport const plugin = postcss.plugin\nexport const parse = postcss.parse\nexport const list = postcss.list\n\nexport const document = postcss.document\nexport const comment = postcss.comment\nexport const atRule = postcss.atRule\nexport const rule = postcss.rule\nexport const decl = postcss.decl\nexport const root = postcss.root\n\nexport const CssSyntaxError = postcss.CssSyntaxError\nexport const Declaration = postcss.Declaration\nexport const Container = postcss.Container\nexport const Processor = postcss.Processor\nexport const Document = postcss.Document\nexport const Comment = postcss.Comment\nexport const Warning = postcss.Warning\nexport const AtRule = postcss.AtRule\nexport const Result = postcss.Result\nexport const Input = postcss.Input\nexport const Rule = postcss.Rule\nexport const Root = postcss.Root\nexport const Node = postcss.Node\n", "import index from \"./scss-syntax.js\"\n\nexport default index\n\nexport const stringify = index.stringify\nexport const parse = index.parse\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Migration, ResolvedResource} from '@angular/cdk/schematics';\nimport {SchematicContext} from '@angular-devkit/schematics';\nimport {parseTemplate} from './tree-traversal';\nimport {ComponentMigrator} from '.';\nimport {Update, writeUpdates} from '../../../migration-utilities';\n\nexport class TemplateMigration extends Migration<ComponentMigrator[], SchematicContext> {\n  enabled = true;\n\n  override visitTemplate(template: ResolvedResource) {\n    this.fileSystem\n      .edit(template.filePath)\n      .remove(template.start, template.content.length)\n      .insertRight(template.start, this.migrate(template.content, template.filePath));\n  }\n\n  migrate(template: string, templateUrl?: string): string {\n    const ast = parseTemplate(template, templateUrl);\n    const migrators = this.upgradeData.filter(m => m.template).map(m => m.template!);\n    const updates: Update[] = [];\n    migrators.forEach(m => {\n      try {\n        updates.push(...m.getUpdates(ast));\n      } catch (error: any) {\n        this.logger.error(`${error}`);\n        if (error instanceof Error) {\n          this.logger.error(`${error.stack}`);\n        }\n        this.logger.warn(`Failed to process template: ${templateUrl} (see error above).`);\n      }\n    });\n\n    return writeUpdates(template, updates);\n  }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Update} from '../update';\nimport * as ts from 'typescript';\n\n/** Returns an Update that renames the module specifier of the given import declaration node. */\nexport function updateModuleSpecifier(\n  node: ts.ImportDeclaration,\n  opts: {\n    moduleSpecifier: string;\n  },\n): Update {\n  const moduleSpecifier = node.moduleSpecifier as ts.StringLiteral;\n  return {\n    offset: moduleSpecifier.pos,\n    updateFn: (text: string) => {\n      const index = text.indexOf(moduleSpecifier.text, moduleSpecifier.pos);\n      return replaceAt(text, index, {\n        old: moduleSpecifier.text,\n        new: opts.moduleSpecifier,\n      });\n    },\n  };\n}\n\n/** Returns an Update that renames an export of the given named import node. */\nexport function updateNamedImport(\n  node: ts.NamedImports,\n  opts: {\n    oldExport: string;\n    newExport: string;\n  },\n): Update | undefined {\n  for (let i = 0; i < node.elements.length; i++) {\n    const n = node.elements[i];\n    const name = n.propertyName ? n.propertyName : n.name;\n    if (name.escapedText === opts.oldExport) {\n      return {\n        offset: name.pos,\n        updateFn: (text: string) => {\n          const index = text.indexOf(opts.oldExport, name.pos);\n          return replaceAt(text, index, {\n            old: opts.oldExport,\n            new: opts.newExport,\n          });\n        },\n      };\n    }\n  }\n  return;\n}\n\n/** Replaces the first instance of substring.old after the given index. */\nfunction replaceAt(str: string, index: number, substring: {old: string; new: string}): string {\n  return str.slice(0, index) + substring.new + str.slice(index + substring.old.length);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Stores the data needed to make a single update to a file. */\nexport interface Update {\n  /** The start index of the location of the update. */\n  offset: number;\n\n  /** A function to be used to update the file content. */\n  updateFn: (text: string) => string;\n}\n\n/** Applies the updates to the given file content in reverse offset order. */\nexport function writeUpdates(content: string, updates: Update[]): string {\n  updates.sort((a, b) => b.offset - a.offset);\n  updates.forEach(update => (content = update.updateFn(content)));\n  return content;\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport {updateModuleSpecifier} from './typescript/import-operations';\nexport {Update, writeUpdates} from './update';\n"],
  "mappings": "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;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;AAGF,IAAM,gBAAgB,IAAI,IAAI,OAAO,QAAQ;EAC3C,SAAS;EACT,OAAO;EACP,cAAc;EACd,aAAa;EACb,YAAY;EACZ,YAAY;AACb,CAAA,CAAC;AAGF,IAAM,gBACF,MAAM,KAAK,aAAa,EAAE,OAAO,CAAC,UAAU,CAAC,cAAc,mBAAkB;AAC3E,WAAS,IAAI,cAAc,aAAa;AACxC,SAAO;AACT,GAAG,oBAAI,IAAG,CAAkB;AAE1B,6CAAwC,sBAAqB;EAMjE,cAAA;AACE,UAAK;AANC,SAAA,UAAU,oBAAI,IAAG;AAGjB,SAAY,eAAG,oBAAI;AAIzB,WAAO,QAAQ,iBAAc;AAC3B,YAAM,OAAO,oBAAI,IAAG;AACpB,YAAM,SAAsB,oBAAI,IAAG;AACnC,YAAM,CAAC,SAAS,iBAAiB,YAAY,MAAM,GAAG;AACtD,YAAM,aAAa,cAAc,MAAM,GAAG;AAC1C,YAAM,CAAC,WAAW,aAAa,QAAQ,MAAM,GAAG;AAChD,gBAAU,MAAM,GAAG,EAAE,QAAQ,SAAM;AACjC,aAAK,QAAQ,IAAI,IAAI,YAAW,GAAI,IAAI;AACxC,aAAK,aAA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",
  "names": []
}
